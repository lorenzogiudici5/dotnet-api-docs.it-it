<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b90a20583f24b5370819a5d643b5b26bb93210ac" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37643731" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce le rappresentazioni dei campi delle istruzioni MSIL (Microsoft Intermediate Language) per la creazione da parte dei membri della classe <see cref="T:System.Reflection.Emit.ILGenerator" />, ad esempio il metodo <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per una descrizione dettagliata di codici operativi il membro, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition III: CIL Instruction Set" e "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata la costruzione di un metodo dinamico usando <xref:System.Reflection.Emit.ILGenerator> per generare `OpCodes` in un <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Somma due valori e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|58|aggiunta|Aggiunge due valori numerici, restituendo un nuovo valore numerico.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value1` viene aggiunto a `value2`.  
  
4.  Il risultato viene inserito nello stack.  
  
 Overflow non viene rilevato per operazioni con numeri interi (per gestire l'overflow appropriate, vedere <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Aggiunta di integer esegue il wrapping, anziché una saturazione. Ad esempio, supponendo che valori integer a 8 bit in cui `value1` è impostata su 255 e `value2` è impostato su 1, il risultato è 0 anziché a 256.  
  
 Restituisce overflow a virgola mobile `+inf` (`PositiveInfinity`) o `-inf` (`NegativeInfinity`).  
  
 Nella tabella seguente sono elencati i tipi di operando accettabili e i tipi di dati corrispondenti. Se non è presente alcuna voce per una particolare combinazione di tipi (ad esempio, `int32` e `float`; `int32` e `int64`), è un valido linguaggio MSIL (Microsoft Intermediate) e genera un errore.  
  
|operando|tipo di value1|tipo value2|tipo di risultato|  
|-------------|-----------------|-----------------|-----------------|  
|aggiunta|`int32`|`int32`|`int32`|  
|aggiunta|`int32`|`native int`|`native int`|  
|aggiunta|`int32`|`&`|`&`|  
|aggiunta|`int32`|`*`|`*`|  
|aggiunta|`int64`|`int64`|`int64`|  
|aggiunta|`native int`|`int32`|`native int`|  
|aggiunta|`native int`|`native int`|`native int`|  
|aggiunta|`native int`|`&`|`&`|  
|aggiunta|`native int`|`*`|`*`|  
|aggiunta|`F`|`F`|`F`|  
|aggiunta|`&`|`int32`|`&`|  
|aggiunta|`&`|`native int`|`&`|  
|aggiunta|`*`|`int32`|`*`|  
|aggiunta|`*`|`native int`|`*`|  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `add` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Somma due valori interi, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D6|add.ovf|Somma due interi con segno con un controllo dell'overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value1` viene aggiunto a `value2` con un controllo dell'overflow.  
  
4.  Il risultato viene inserito nello stack.  
  
 <xref:System.OverflowException> viene generata se il risultato non è rappresentato nel tipo di risultato.  
  
 È possibile eseguire questa operazione su integer con segno. Per i valori a virgola mobile, usare <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Nella tabella seguente sono elencati i tipi di operando accettabili e i tipi di dati corrispondenti. Se non è presente alcuna voce per una particolare combinazione di tipi (ad esempio, `int32` e `float`; `int32` e `int64`), è un'istruzione di Microsoft Intermediate Language (MSIL) non valida e genera un errore.  
  
|operando|tipo di value1|tipo value2|tipo di risultato|  
|-------------|-----------------|-----------------|-----------------|  
|aggiunta|`int32`|`int32`|`int32`|  
|aggiunta|`int32`|`native int`|`native int`|  
|aggiunta|`int32`|`&`|`&`|  
|aggiunta|`int32`|`*`|`*`|  
|aggiunta|`int64`|`int64`|`int64`|  
|aggiunta|`native int`|`int32`|`native int`|  
|aggiunta|`native int`|`native int`|`native int`|  
|aggiunta|`native int`|`&`|`&`|  
|aggiunta|`native int`|`*`|`*`|  
|aggiunta|`F`|`F`|`F`|  
|aggiunta|`&`|`int32`|`&`|  
|aggiunta|`&`|`native int`|`&`|  
|aggiunta|`*`|`int32`|`*`|  
|aggiunta|`*`|`native int`|`*`|  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `add.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Somma due valori interi senza segno, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|Aggiunge due valori interi senza segno con un controllo dell'overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value1` viene aggiunto a `value2` con un controllo dell'overflow.  
  
4.  Il risultato viene inserito nello stack.  
  
 <xref:System.OverflowException> viene generata se il risultato non è rappresentato nel tipo di risultato.  
  
 È possibile eseguire questa operazione su integer con segno. Per i valori a virgola mobile, usare <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Nella tabella seguente sono elencati i tipi di operando accettabili e i tipi di dati corrispondenti. Se non è presente alcuna voce per una particolare combinazione di tipi (ad esempio, `int32` e `float`; `int32` e `int64`), è un'istruzione di Microsoft Intermediate Language (MSIL) non valida e genera un errore.  
  
|operando|tipo di value1|tipo value2|tipo di risultato|  
|-------------|-----------------|-----------------|-----------------|  
|aggiunta|`int32`|`int32`|`int32`|  
|aggiunta|`int32`|`native int`|`native int`|  
|aggiunta|`int32`|`&`|`&`|  
|aggiunta|`int32`|`*`|`*`|  
|aggiunta|`int64`|`int64`|`int64`|  
|aggiunta|`native int`|`int32`|`native int`|  
|aggiunta|`native int`|`native int`|`native int`|  
|aggiunta|`native int`|`&`|`&`|  
|aggiunta|`native int`|`*`|`*`|  
|aggiunta|`F`|`F`|`F`|  
|aggiunta|`&`|`int32`|`&`|  
|aggiunta|`&`|`native int`|`&`|  
|aggiunta|`*`|`int32`|`*`|  
|aggiunta|`*`|`native int`|`*`|  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `add.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcola l'operatore AND bit per bit di due valori e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Istruzione|Descrizione|  
|------------|-----------------|-----------------|  
|5F|e|Determina l'operatore AND bit per bit su due valori integer.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value1` e `value2` vengono estratti dallo stack; viene calcolato l'operatore AND bit per bit dei due valori.  
  
4.  Il risultato viene inserito nello stack.  
  
 Il `and` calcola l'operatore AND bit per bit dei primi due valori nello stack di istruzioni e lascia il risultato nello stack.  
  
 `And` è un'operazione specifica del numero intero.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `and` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce un puntatore non gestito all'elenco di argomenti del metodo corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Restituisce un handle di elenco di argomenti per il metodo corrente.|  
  
 Sullo stack di valutazione viene eseguito da questa operazione.  
  
 Il `arglist` istruzione restituisce un handle opaco (un puntatore non gestito, di tipo `native int`) che rappresenta l'elenco di argomenti del metodo corrente. Questo handle è valido solo durante il ciclo di vita del metodo corrente. È possibile, tuttavia, passare l'handle ad altri metodi fino a quando il metodo corrente è sul thread del controllo. È possibile eseguire solo il `arglist` istruzione all'interno di un metodo che accetta un numero variabile di argomenti.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `arglist` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se due valori sono uguali.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset `target` se i due valori sono uguali.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `beq` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è uguale a `value2`. L'effetto è equivale all'esecuzione di un `ceq` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 I tipi di operando accettabili sono indicati di seguito:  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi.  
  
 Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione (tali trasferimenti sono particolari restrizioni e devono utilizzare il <xref:System.Reflection.Emit.OpCodes.Leave> istruzione invece).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `beq` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) se due valori sono uguali.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|2E &LT; `int8` >|beq. s `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset `target` se uguale, forma breve|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `beq.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è uguale a `value2`. L'effetto è equivale all'esecuzione di un `ceq` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 I tipi di operando accettabili sono indicati di seguito:  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi.  
  
 Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione (tali trasferimenti sono particolari restrizioni e devono utilizzare il <xref:System.Reflection.Emit.OpCodes.Leave> istruzione invece).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `beq.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore o uguale al secondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è maggiore o uguale al secondo.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore o uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bge` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è maggiore o uguale a `value2`. L'effetto è identico all'esecuzione di un `clt.un` istruzione seguita da un `brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bge` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore o uguale al secondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge. s `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è maggiore o uguale al secondo, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore o uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bge.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è maggiore o uguale a `value2`. L'effetto è identico all'esecuzione di un `clt.un` istruzione seguita da un `brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bge.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge. un `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è maggiore o uguale al secondo valore (valori senza segno).|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore o uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bge.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è maggiore o uguale a `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `clt` istruzione seguita da un `brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bge.un` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è maggiore o uguale al secondo valore (valori senza segno), forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore o uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bge.un.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è maggiore o uguale a `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `clt` istruzione seguita da un `brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bge.un.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore del secondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|3D < `int32` >|bgt `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è maggiore del secondo valore.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore di quella `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bgt` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è maggiore di quella `value2`. L'effetto è identico all'esecuzione di un `cgt` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bgt` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore del secondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt. s `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è maggiore del secondo valore, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore di quella `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bgt.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è maggiore di quella `value2`. L'effetto è identico all'esecuzione di un `cgt` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bgt.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è maggiore del secondo valore (valori senza segno).|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore di quella `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bgt.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è maggiore di quella `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `cgt.un` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bgt.un` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è maggiore del secondo valore (valori senza segno), forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore di quella `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bgt.un.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è maggiore di quella `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `cgt.un` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bgt.un.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore o uguale al secondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|3E `<int32>`|bLe `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è minore o uguale al secondo.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è minore o uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `ble` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è minore o uguale a `value2`. L'effetto è identico all'esecuzione di un `cgt` istruzioni (`cgt.un` per valori a virgola mobile) seguito da un `brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ble` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore o uguale al secondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble. s `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è minore o uguale al secondo, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è minore o uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `ble.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è minore o uguale a `value2`. L'effetto è identico all'esecuzione di un `cgt` istruzioni (`cgt.un` per valori a virgola mobile) istruzione seguita da un`brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ble.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore o uguale al secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble. un `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è minore o uguale al secondo valore (valori senza segno).|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è minore o uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `ble.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è minore o uguale a `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `cgt.un` istruzioni (`cgt` per valori a virgola mobile) seguito da un `brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ble.un` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore o uguale al secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato, se il primo valore è minore o uguale al secondo valore (valori senza segno), forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è minore o uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `ble.un.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è minore o uguale a `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `cgt.un` istruzioni (`cgt` per valori a virgola mobile) seguito da un `brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ble.un.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore del secondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|3F &LT; `int32` >|blt `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo valore.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è minore di `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `blt` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è minore o uguale a `value2`. L'effetto è identico all'esecuzione di un `clt` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `blt` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore del secondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt. s `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è minore di `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `blt.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è minore di `value2`. L'effetto è identico all'esecuzione di un `clt` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `blt.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo valore (valori senza segno).|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è minore di `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `blt.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è minore di `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `clt.un` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `blt.un` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo valore (valori senza segno), forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` è minore di `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `blt.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` è minore di `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `clt.un` istruzione seguita da un `brtrue` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `blt.un.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione quando due valori interi senza segno o valori float non ordinati non sono uguali.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne. un `target`|Ramo di destinazione istruzione in corrispondenza dell'offset specificato, se due valori unsigned integer non sono uguali (i valori senza segno).|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` non è uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bne.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` non è uguale a `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `ceq` istruzione seguita da un `brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bne.un` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve) quando due valori interi senza segno o valori float non ordinati non sono uguali.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s `target`|Ramo di destinazione (istruzione) in corrispondenza dell'offset specificato, se due valori unsigned integer non sono uguali (i valori senza segno), forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; se `value1` non è uguale a `value2`, viene eseguita l'operazione di diramazione.  
  
 Il `bne.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value1` non è uguale a `value2`, quando vengono confrontati tramite l'intero senza segno o valori float non ordinati. L'effetto è identico all'esecuzione di un `ceq` istruzione seguita da un `brfalse` ramo per l'istruzione di destinazione specifico. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `bne.un.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte un tipo di valore in un riferimento a un oggetto di tipo <see langword="O" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|8C &LT; `T` >|finestra `valTypeToken`|Convertire un tipo di valore (del tipo specificato `valTypeToken`) a un riferimento all'oggetto true.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un tipo di valore viene inserito nello stack.  
  
2.  Il tipo di valore viene estratto dallo stack; il `box` operazione viene eseguita.  
  
3.  Un riferimento all'oggetto al tipo di valore "sottoposto a conversione boxing" risultante viene inserito nello stack.  
  
 Un tipo di valore ha due rappresentazioni separate all'interno di Common Language Infrastructure (CLI):  
  
-   'Raw' modulo quando un tipo di valore viene incorporato all'interno di un altro oggetto o nello stack.  
  
-   Un modulo 'boxed', in cui i dati nel tipo di valore viene eseguito il wrapping (boxed) in un oggetto in modo che possano esistere come entità indipendenti.  
  
 Il `box` istruzione converte il tipo 'raw' valore unboxed in un riferimento all'oggetto (tipo `O`). Questa operazione viene eseguita creando un nuovo oggetto e copiando i dati dal tipo di valore nell'oggetto appena allocato. `valTypeToken` è un token di metadati che indica il tipo del tipo di valore nello stack.  
  
 <xref:System.OutOfMemoryException> viene generata se la memoria è insufficiente per soddisfare la richiesta.  
  
 <xref:System.TypeLoadException> viene generata se la classe non viene trovata. Questo in genere viene rilevato quando Microsoft Intermediate Language (MSIL) viene convertito in codice nativo, anziché in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `box` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione in modo incondizionato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|Rami di un'istruzione di destinazione in corrispondenza dell'offset specificato.|  
  
 Sullo stack di valutazione viene eseguito da questa operazione.  
  
 Il `br` istruzione trasferisce il controllo a un'istruzione di destinazione. L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `br` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione in modo incondizionato (forma breve).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br. s `target`|Rami di un'istruzione di destinazione in corrispondenza dell'offset specificato, forma breve.|  
  
 Sullo stack di valutazione viene eseguito da questa operazione.  
  
 Il `br.s` istruzione trasferisce il controllo a un'istruzione di destinazione. L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `br.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Segnala a Common Language Infrastructure (CLI) di indicare al debugger che è stato raggiunto un punto di interruzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|01|break|indica al debugger che è stato raggiunto un punto di interruzione.|  
  
 Sullo stack di valutazione viene eseguito da questa operazione.  
  
 Il `break` istruzione è per il supporto del debug. Segnala l'interfaccia della riga di comando di indicare al debugger che è stato raggiunto un punto di interruzione. Non ha alcun altro effetto sullo stato dell'interprete.  
  
 Il `break` (istruzione) è il più piccolo possibile un'istruzione dimensioni dell'applicazione di patch con un punto di interruzione e la generazione di interferire con il codice circostante.  
  
 Il `break` istruzione può intercettare a un debugger, non fare nulla o generare un'eccezione di sicurezza. L'esatto comportamento viene definito dall'implementazione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `break` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se <paramref name="value" /> è <see langword="false" />, un riferimento null (<see langword="Nothing" /> in Visual Basic) oppure zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> rispettivi brnull `target`<br /><br /> brzero `target`|Rami di un'istruzione di destinazione in corrispondenza dell'offset specificato se `false`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene eseguito il push nello stack da un'operazione precedente.  
  
2.  `value` viene estratto dallo stack; Se `value` viene `false`, creare rami `target`.  
  
 Il `brfalse` istruzione (e i relativi alias `brnull` e `brzero`) trasferisce il controllo all'istruzione di destinazione specificato se `value` (di tipo `int32`, `int64`, il riferimento all'oggetto `O`gestiti, puntatore `&`, puntatore transitorio `*`, `native int`) è uguale a zero (`false`). Se `value` è diverso da zero (`true`) l'esecuzione continua con l'istruzione successiva.  
  
 L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `brfalse` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se <paramref name="value" /> è <see langword="false" />, un riferimento null oppure zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse. s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|Rami di un'istruzione di destinazione in corrispondenza dell'offset specificato se `false`, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene eseguito il push nello stack da un'operazione precedente.  
  
2.  `value` viene estratto dallo stack; Se `value` viene `false`, creare rami `target`.  
  
 Il `brfalse.s` istruzione (e i relativi alias `brnull` e `brzero`) trasferisce il controllo all'istruzione di destinazione specificato se `value` (di tipo `int32`, `int64`, il riferimento all'oggetto `O`gestiti, puntatore `&`, puntatore transitorio `*`, `native int`) è uguale a zero (`false`). Se `value` è diverso da zero (`true`) l'esecuzione continua con l'istruzione successiva.  
  
 L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `brfalse.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione se <paramref name="value" /> è <see langword="true" />, diverso da null o da zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|3A &LT; `int32` >|brtrue `target`<br /><br /> brinst, che rappresenta `target`|Creare un ramo a un'istruzione di destinazione in corrispondenza dell'offset specificato, se diverso da zero (`true`).|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene eseguito il push nello stack da un'operazione precedente.  
  
2.  `value` viene estratto dallo stack; Se `value` viene `true`, creare rami `target`.  
  
 Il `brtrue` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value` (tipo `native int`) è diverso da zero (`true`). Se `value` è uguale a zero (`false`) l'esecuzione continua con l'istruzione successiva.  
  
 Se `value` è un riferimento all'oggetto (tipo `O`) quindi `brinst` (un alias per `brtrue`) trasferisce il controllo se rappresenta un'istanza di un oggetto (ad esempio, se non è il riferimento all'oggetto null; vedere <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 L'istruzione di destinazione è rappresentato da un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `brtrue` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo a un'istruzione di destinazione (forma breve), se <paramref name="value" /> è <see langword="true" />, diverso da null oppure diverso da zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue. s `target`<br /><br /> brinst.s `target`|Creare un ramo a un'istruzione di destinazione in corrispondenza dell'offset specificato, se diverso da zero (`true`), forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene eseguito il push nello stack da un'operazione precedente.  
  
2.  `value` viene estratto dallo stack; Se `value` viene `true`, creare rami `target`.  
  
 Il `brtrue.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato, se `value` (tipo `native int`) è diverso da zero (`true`). Se `value` è uguale a zero (`false`) l'esecuzione continua con l'istruzione successiva.  
  
 Se `value` è un riferimento all'oggetto (tipo `O`) quindi `brinst` (un alias per `brtrue`) trasferisce il controllo se rappresenta un'istanza di un oggetto (ad esempio, se non è il riferimento all'oggetto null; vedere <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 L'istruzione di destinazione è rappresentato da un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi. Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `brtrue.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Chiama il metodo indicato dal descrittore di metodo passato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|28 < `T` >|chiamata `methodDesc`|Chiamare il metodo descritto dal `methodDesc`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Gli argomenti del metodo `arg1` tramite `argN` vengono inseriti nello stack.  
  
2.  Gli argomenti del metodo `arg1` tramite `argN` vengono estratti dallo stack; la chiamata al metodo viene eseguita con questi argomenti e il controllo viene trasferito al metodo a cui fa riferimento il descrittore del metodo. Al termine dell'esercitazione, un valore restituito è generato dal metodo chiamato e inviato al chiamante.  
  
3.  Il valore restituito viene inserito nello stack.  
  
 Il `call` istruzione chiama il metodo indicato dal descrittore del metodo passato con l'istruzione. Descrittore del metodo è un token di metadati che indica il metodo di chiamata e il numero, tipo e ordine degli argomenti che sono stati inseriti nello stack deve essere passato a tale metodo, nonché la convenzione di denominazione da utilizzare. Il `call` istruzione può essere immediatamente preceduta da un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) immediatamente precedente per specificare che lo stato corrente del metodo deve essere rilasciato prima di trasferire il controllo. Se la chiamata trasferisce il controllo a un metodo di attendibilità superiore rispetto al metodo di origine, il frame dello stack non viene rilasciato. Al contrario, l'esecuzione continua automaticamente come se il `tail` non fosse stata fornita. Il token di metadati contiene informazioni sufficienti per determinare se la chiamata è per un metodo statico, un metodo di istanza, un metodo virtuale o una funzione globale. In tutti questi casi l'indirizzo di destinazione è determinata interamente dal descrittore del metodo (confrontare questa operazione con il <xref:System.Reflection.Emit.OpCodes.Callvirt> per chiamare metodi virtuali, in cui l'indirizzo di destinazione dipende anche dalla fase il tipo di runtime dell'istanza (istruzione) riferimento inserito prima il <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Gli argomenti vengono inseriti nello stack in ordine da sinistra a destra. Vale a dire, il primo argomento è calcolato e inserito in stack, quindi il secondo argomento e il terzo, fino a quando tutti gli argomenti necessari sono all'inizio dello stack in ordine decrescente. Esistono tre casi speciali importanti:  
  
 1. Le chiamate a un'istanza (o virtuale) metodo deve inserire il riferimento all'istanza prima di qualsiasi argomento visibile all'utente. Il riferimento all'istanza non deve essere un riferimento null. La firma contenuta nei metadati non contiene una voce nell'elenco dei parametri per il `this` puntatore; Usa invece un bit per indicare se il metodo richiede il passaggio di `this` puntatore.  
  
 2. È possibile chiamare un metodo virtuale utilizzando `call` (anziché `callvirt`); ciò indica che il metodo deve essere risolto con la classe specificata dal metodo anziché come specificato in modo dinamico dall'oggetto a cui viene richiamato.  
  
 3. Si noti che un delegato `Invoke` metodo può essere chiamato con il `call` o `callvirt` (istruzione).  
  
 <xref:System.Security.SecurityException> può essere generata se la protezione del sistema non concede al chiamante di accedere al metodo chiamato. Il controllo di sicurezza può verificarsi quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.  
  
> [!NOTE]
>  Quando si chiamano metodi System. Object sui tipi di valore, è consigliabile usare la `constrained` prefisso con il `callvirt` istruzione invece di generare un `call` (istruzione). Ciò elimina la necessità di generare IL diverso a seconda se il tipo di valore esegue l'override del metodo, evitando un potenziale problema di controllo delle versioni. È consigliabile usare la `constrained` prefisso quando si richiama i metodi di interfaccia sui tipi di valore, poiché il metodo con tipo di valore che implementa il metodo di interfaccia può essere modificato utilizzando un `MethodImpl`. Questi problemi sono descritti più dettagliatamente il <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possono usare overload del metodo di `call` opcode:  
  
-   ILGenerator (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
> [!NOTE]
>  Il <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> viene fornito il metodo `varargs` chiamate. Usare il <xref:System.Reflection.Emit.ILGenerator.Emit%2A> metodo per le chiamate normali.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Chiama il metodo indicato nello stack di valutazione, come un puntatore a un punto di ingresso, con gli argomenti descritti da una convenzione di chiamata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|Chiama il metodo a cui si fa riferimento con gli argomenti descritti dalla convenzione di chiamata.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Gli argomenti del metodo `arg1` tramite `argN` vengono inseriti nello stack.  
  
2.  Il puntatore di ingresso del metodo viene effettuato il push nello stack.  
  
3.  Gli argomenti del metodo `arg1` tramite `argN` e il puntatore di ingresso del metodo vengono estratti dallo stack; viene eseguita la chiamata al metodo. Al termine dell'esercitazione, un valore restituito è generato dal metodo chiamato e inviato al chiamante.  
  
4.  Il valore restituito viene inserito nello stack.  
  
 Il `calli` istruzione chiama il puntatore di ingresso del metodo con gli argomenti `arg1` tramite `argN`. I tipi di questi argomenti vengono descritti dalla convenzione di chiamata specifica (`callSiteDesc`). Il `calli` istruzione può essere immediatamente preceduta da un `tail` prefisso (<xref:System.Reflection.Emit.OpCodes.Tailcall>) per specificare che lo stato corrente del metodo deve essere rilasciato prima di trasferire il controllo. Se la chiamata trasferisce il controllo a un metodo di attendibilità superiore rispetto al metodo di origine dello stack frame non essere rilasciato. al contrario, l'esecuzione continua automaticamente come se il `tail` non fosse stata fornita.  
  
 Si presuppone che il puntatore di ingresso del metodo specifico puntatore a codice nativo (nel computer di destinazione) che può essere chiamato legittimamente con gli argomenti descritti dalla convenzione di chiamata (un token di metadati per una firma autonoma). Tale puntatore può essere creati usando il <xref:System.Reflection.Emit.OpCodes.Ldftn> o <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> istruzioni, oppure è passato da codice nativo.  
  
 La convenzione di chiamata non è selezionata in modo dinamico, pertanto, il codice che utilizza un `calli` (istruzione) non funziona correttamente se la destinazione non usa in realtà la convenzione di chiamata specificata.  
  
 Gli argomenti vengono inseriti nello stack in ordine da sinistra a destra. Vale a dire, il primo argomento è calcolato e inserito in stack, quindi il secondo argomento e il terzo, fino a quando tutti gli argomenti necessari sono all'inizio dello stack in ordine decrescente. La sequenza di codice di compilazione di argomento per un'istanza o un metodo virtuale deve inserire il riferimento all'istanza (che non deve essere un riferimento null) prima di qualsiasi argomento visibile all'utente.  
  
 <xref:System.Security.SecurityException> può essere generata se la protezione del sistema non concede al chiamante di accedere al metodo chiamato. Il controllo di sicurezza può verificarsi quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> metodi possono essere utilizzati per eseguire un `calli` (istruzione) nello stack. Si noti che `calli` deve essere chiamato tramite il seguito metodi anziché il <xref:System.Reflection.Emit.ILGenerator.Emit%2A> classe per posizionare l'istruzione direttamente nello stack.  
  
-   ILGenerator. EmitCalli (codice operativo, CallingConventions, Type, Type [], Type[]) per chiamate tramite una convenzione di chiamata gestita.  
  
-   ILGenerator. EmitCalli (Opcode, Type[]) CallingConvention, tipo, per chiamate tramite una convenzione di chiamata non gestita.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Chiama un metodo ad associazione tardiva su un oggetto, inserendo il valore restituito nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|Chiama un metodo specifico associato `obj`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `obj` viene inserito nello stack.  
  
2.  Gli argomenti del metodo `arg1` tramite `argN` vengono inseriti nello stack.  
  
3.  Gli argomenti del metodo `arg1` attraverso `argN` e il riferimento all'oggetto `obj` vengono estratti dallo stack; la chiamata al metodo viene eseguita con questi argomenti e il controllo viene trasferito al metodo nel `obj` a cui fa riferimento il metodo token di metadati. Al termine dell'esercitazione, un valore restituito è generato dal metodo chiamato e inviato al chiamante.  
  
4.  Il valore restituito viene inserito nello stack.  
  
 Il `callvirt` istruzione chiama un metodo di associazione tardiva su un oggetto. Vale a dire, viene scelto il metodo di base al tipo di runtime di `obj` anziché la classe in fase di compilazione visibile nel puntatore al metodo. `Callvirt` Consente di chiamare sia virtuale e metodi di istanza. Il `callvirt` istruzione può essere immediatamente preceduta da un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) per specificare che lo stack frame corrente deve essere rilasciato prima di trasferire il controllo. Se la chiamata trasferisce il controllo a un metodo di attendibilità superiore rispetto al metodo originale il frame dello stack verrà rilasciato non.  
  
 Il token di metadati del metodo contiene il nome, classe e firma del metodo da chiamare. La classe associata `obj` è la classe di cui è un'istanza. Se la classe definisce un metodo non statico che corrisponde al nome del metodo indicato e firma, questo metodo viene chiamato. In caso contrario, tutte le classi nella catena di classe di base di questa classe vengono controllate in ordine. È un errore se non viene trovato alcun metodo.  
  
 `Callvirt` estrae l'oggetto e gli argomenti dallo stack di valutazione associati prima di chiamare il metodo. Se il metodo ha un valore restituito, viene eseguito il push nello stack al completamento del metodo. Sul lato computer chiamato, il `obj` parametro viene eseguito come argomento 0, `arg1` come argomento 1 e così via.  
  
 Gli argomenti vengono inseriti nello stack in ordine da sinistra a destra. Vale a dire, il primo argomento è calcolato e inserito in stack, quindi il secondo argomento e il terzo, fino a quando tutti gli argomenti necessari sono all'inizio dello stack in ordine decrescente. Il riferimento all'istanza `obj` (sempre necessario per `callvirt`) deve essere inserito prima di qualsiasi argomento visibile all'utente. La firma (contenuta nel token di metadati) non debba contenere una voce nell'elenco dei parametri per questo puntatore.  
  
 Si noti che un metodo virtuale può essere chiamato anche usando il <xref:System.Reflection.Emit.OpCodes.Call> (istruzione).  
  
 <xref:System.MissingMethodException> viene generata se un metodo non statico con il nome indicato e la firma non è stato trovato nella classe associata `obj` o una delle relative classi base. Ciò in genere viene rilevata quando istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, anziché in fase di esecuzione.  
  
 <xref:System.NullReferenceException> viene generata se l'oggetto è null.  
  
 <xref:System.Security.SecurityException> viene generata se la protezione del sistema non concede al chiamante di accedere al metodo chiamato. Il controllo di sicurezza può verificarsi quando l'elenco CIL viene convertito in codice nativo piuttosto che in fase di esecuzione.  
  
> [!NOTE]
>  Quando si chiamano metodi System. Object sui tipi di valore, è consigliabile usare la `constrained` Anteponi il prefisso di `callvirt` (istruzione). Ciò elimina la necessità di generare IL diverso a seconda se il tipo di valore esegue l'override del metodo, evitando un potenziale problema di controllo delle versioni. È consigliabile usare la `constrained` prefisso quando si richiama i metodi di interfaccia sui tipi di valore, poiché il metodo con tipo di valore che implementa il metodo di interfaccia può essere modificato utilizzando un `MethodImpl`. Questi problemi sono descritti più dettagliatamente il <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `callvirt` opcode:  
  
-   ILGenerator (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (OpCode, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tenta di eseguire il cast di un oggetto passato per riferimento alla classe specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|Esegue il cast di un oggetto a un nuovo oggetto di tipo `class`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto viene inserito nello stack.  
  
2.  Il riferimento all'oggetto viene estratto dallo stack; l'oggetto di riferimento viene eseguito il cast specificato `class`.  
  
3.  Se ha esito positivo, un nuovo riferimento all'oggetto viene inserito nello stack.  
  
 Il `castclass` istruzione tenta di eseguire il cast di riferimento all'oggetto (tipo `O`) all'inizio dello stack per una classe specificata. La nuova classe è specificata da un token di metadati che indica la classe desiderata. Se la classe dell'oggetto all'inizio dello stack non implementa la nuova classe (presupponendo che la nuova classe è un'interfaccia) e non è una classe derivata della nuova classe un' <xref:System.InvalidCastException> viene generata un'eccezione. Se il riferimento all'oggetto è un riferimento null, `castclass` ha esito positivo e restituisce il nuovo oggetto come un riferimento null.  
  
 <xref:System.InvalidCastException> viene generata se obj non è possibile eseguire il cast alla classe.  
  
 <xref:System.TypeLoadException> viene generata se non è stata trovata classe. Questo in genere viene rilevato quando un'istruzione di Microsoft Intermediate Language (MSIL) viene convertita in codice nativo piuttosto che in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `castclass` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Confronta due valori. Se tali valori sono uguali, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Effettua il push di 1 se `value1` è uguale a `value2`; in caso contrario inserisce 0.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value1` viene confrontato con `value2`.  
  
4.  Se `value1` è uguale a `value2`, 1 viene inserito nello stack; in caso contrario, 0 viene inserito nello stack.  
  
 Il `ceq` istruzione confronta `value1` e `value2`. Se `value1` è uguale a `value2`, quindi 1 (di tipo `int32`) viene eseguito il push nello stack. In caso contrario, 0 (di tipo `int32`) viene eseguito il push nello stack.  
  
 Per un numero a virgola mobile, `ceq` restituirà 0 se i numeri non sono ordinati (uno o entrambi sono NaN). I valori infiniti sono uguali a se stessi.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ceq` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Confronta due valori. Se il primo valore è maggiore del secondo, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 02|cgt|Effettua il push di 1 se `value1` è maggiore di quella `value2`; in caso contrario inserisce 0.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `cgt` verifica se `value1` è maggiore di quella `value2`.  
  
4.  Se `value1` è maggiore di quella `value2`, 1 viene inserito nello stack; in caso contrario, 0 viene inserito nello stack.  
  
 Il `cgt` istruzione confronta `value1` e `value2`. Se `value1` è rigorosamente maggiore `value2`, quindi un `int32` valore 1 viene eseguito il push nello stack. In caso contrario, un `int32` il valore 0 viene eseguito il push nello stack.  
  
-   Per i numeri a virgola mobile, `cgt` restituisce 0 se i numeri non sono ordinati (vale a dire, se uno o entrambi gli argomenti sono NaN).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `cgt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Confronta due valori senza segno o non ordinati. Se il primo valore è maggiore del secondo, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|Effettua il push di 1 se `value1` è maggiore di quella `value2`; in caso contrario inserisce 0 (valori senza segno).|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `cgt.un` verifica se `value1` è maggiore di quella `value2`.  
  
4.  Se `value1` è maggiore di quella `value2`, 1 viene inserito nello stack; in caso contrario, 0 viene inserito nello stack.  
  
 Un' `int32` il valore 1 viene eseguito il push nello stack, se si verifica una delle opzioni seguenti `true` :  
  
 Per i numeri a virgola mobile `value1` non viene ordinato in base al `value2`.  
  
 Per i valori integer `value1` è rigorosamente maggiore `value2` se considerati come numeri senza segno.  
  
 In caso contrario un `int32` il valore 0 viene eseguito il push nello stack.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `cgt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Genera un'eccezione <see cref="T:System.ArithmeticException" /> se il valore non è un numero finito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|C3|ckfinite|generare <xref:System.ArithmeticException> Se valore non è un numero finito.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene eseguito il push nello stack...  
  
2.  `value` viene estratto dallo stack e `ckfinite` istruzione viene eseguita su di esso.  
  
3.  `value` viene nuovamente inserito nello stack se viene generata alcuna eccezione.  
  
 Il `ckfinite instruction` genera un'eccezione <xref:System.ArithmeticException> se `value` (un numero a virgola mobile) è un "not a number" valore (NaN) o un `+-` valore infinito. `Ckfinite` lascia il valore dello stack se viene generata alcuna eccezione. Esecuzione non è specificata se `value` non è un numero a virgola mobile.  
  
 <xref:System.ArithmeticException> Se viene generata `value` non è un numero 'normal'.  
  
 Si noti che una particolare eccezione o una classe derivata di <xref:System.ArithmeticException> potrebbe essere più appropriato, passando il valore non corretto per il gestore di eccezioni.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ckfinite` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Confronta due valori. Se il primo valore è inferiore al secondo, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 04|clt|Effettua il push di 1 se `value1` è minore di `value2`; in caso contrario inserisce 0.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è: `value1` viene inserito nello stack.  
  
1.  `value2` viene inserito nello stack.  
  
2.  `value2` e `value1` vengono estratti dallo stack; `clt` verifica se `value1` è minore di `value2`.  
  
3.  Se `value1` è minore di `value2`, 1 viene inserito nello stack; in caso contrario, 0 viene inserito nello stack.  
  
 Il `clt` istruzione confronta `value1` e `value2`. Se `value1` è rigorosamente minore `value2`, quindi un `int32` valore 1 viene eseguito il push nello stack. In caso contrario, un `int32` il valore 0 viene eseguito il push nello stack.  
  
-   Per i numeri a virgola mobile, `clt` restituisce 0 se i numeri non sono ordinati (vale a dire, se uno o entrambi gli argomenti sono NaN).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `clt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Confronta i due valori senza segno o non ordinati <paramref name="value1" /> e <paramref name="value2" />. Se <paramref name="value1" /> è minore di <paramref name="value2" />, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|Effettua il push di 1 se `value1` è minore di `value2`; in caso contrario inserisce 0 (valori senza segno).|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `clt.un` verifica se `value1` è minore di `value2`.  
  
4.  Se `value1` è minore di `value2`, 1 viene inserito nello stack; in caso contrario, 0 viene inserito nello stack.  
  
 Il `clt.un` istruzione confronta `value1` e `value2`. Un `int32` valore 1 viene eseguito il push nello stack, se una delle operazioni seguenti è vera:  
  
-   `value1` è rigorosamente minore `value2` (ad esempio `clt`).  
  
-   Per i numeri a virgola mobile `value1` non viene ordinato in base al `value2`.  
  
-   Per i valori integer `value1` è rigorosamente minore `value2` se considerati come numeri senza segno.  
  
 In caso contrario, un `int32` il valore 0 viene eseguito il push nello stack.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `clt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Vincola il tipo su cui viene eseguita una chiamata al metodo virtuale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft intermediate language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 16 &LT; `T` >|vincolato. `thisType`|Chiamata di un metodo virtuale in un tipo vincolato a essere di tipo `T`.|  
  
 Il `constrained` prefisso è consentito solo in un `callvirt` (istruzione).  
  
 Lo stato dello stack a questo punto di codice MSIL deve essere come segue:  
  
1.  Un puntatore gestito, `ptr`, viene eseguito il push nello stack. Il tipo della `ptr` deve essere un puntatore gestito (`&`) a `thisType`. Si noti che questo è diverso da quello di senza un prefisso `callvirt` istruzione, che prevede un riferimento a `thisType`.  
  
2.  Gli argomenti del metodo `arg1` attraverso `argN` vengono inseriti nello stack, proprio come con un senza prefisso `callvirt` (istruzione).  
  
 Il `constrained` prefisso è progettato per consentire `callvirt` istruzioni da eseguire in un valore uniforme modo indipendentemente dal fatto che `thisType` è un tipo di valore o un tipo di riferimento.  
  
 Quando un `callvirt` `method` istruzione è stata preceduta dal prefisso `constrained` `thisType`, l'istruzione viene eseguita come indicato di seguito:  
  
-   Se `thisType` è un tipo di riferimento (anziché un tipo di valore), quindi `ptr` dereferenziato, passata come il puntatore 'this' per il `callvirt` di `method`.  
  
-   Se `thisType` è un tipo valore e `thisType` implementa `method` quindi `ptr` viene passato senza modifiche mentre il puntatore 'this' per una `call` `method` istruzione per l'implementazione di `method` dal `thisType`.  
  
-   Se `thisType` è un tipo valore e `thisType` non implementa `method` quindi `ptr` è dereferenziato, sottoposto a boxing e passato come il puntatore 'this' per il `callvirt` `method` (istruzione).  
  
 Quest'ultimo caso può verificarsi solo quando `method` era definita nello <xref:System.Object>, <xref:System.ValueType>, o <xref:System.Enum> e non esegue l'override `thisType`. In questo caso, la conversione boxing, una copia dell'oggetto originale da apportare. Tuttavia, poiché nessuno dei metodi della <xref:System.Object>, <xref:System.ValueType>, e <xref:System.Enum> modificano lo stato dell'oggetto, non è possibile rilevare questo fatto.  
  
 Il `constrained` prefisso supporta i generatori di linguaggio intermedio che creano codice generico. In genere il `callvirt` istruzione non è valida per i tipi di valore. In alternativa è necessario che i compilatori di linguaggio intermedio svolgere in modo efficace la trasformazione 'this' descritta in precedenza in fase di compilazione, a seconda del tipo di `ptr` e il metodo chiamato. Tuttavia, quando `ptr` è un tipo generico è noto in fase di compilazione non è possibile eseguire questa trasformazione in fase di compilazione.  
  
 Il `constrained` opcode consente ai compilatori di linguaggio intermedio effettuare una chiamata a una funzione virtuale in un valore uniforme modo indipendentemente dal fatto che `ptr` è un tipo di valore o un tipo di riferimento. Sebbene sia progettato per il caso in cui `thisType` è una variabile di tipo generico, la `constrained` prefisso anche adatto a tipi non generici e possono ridurre la complessità della generazione di chiamate virtuale nei linguaggi che la differenza tra i tipi di valore e tipi di riferimento.  
  
 Uso di `constrained` prefisso consente anche di evitare potenziali problemi di controllo delle versioni con i tipi di valore. Se il `constrained` prefisso non viene utilizzato, deve essere inviato IL diverso a seconda se un tipo di valore esegue l'override di un metodo System. Object. Ad esempio, se un tipo di valore `V` esegue l'override del metodo ToString (), una `call` `V.ToString()` viene generata un'istruzione; in caso contrario, una `box` (istruzione) e un `callvirt` `Object.ToString()` istruzione vengono generati. Un problema durante il controllo delle versioni può verificarsi nel caso precedente se l'override in un secondo momento viene rimosso e nel secondo caso se successivamente viene aggiunta una sostituzione.  
  
 Il `constrained` prefisso può essere utilizzato anche per la chiamata dei metodi di interfaccia sui tipi di valore, perché il metodo con tipo di valore che implementa il metodo di interfaccia può essere modificato utilizzando un `MethodImpl`. Se il `constrained` prefisso non viene utilizzato, il compilatore viene imposto di scegliere quali il valore di metodi del tipo da associare alla fase di compilazione. Uso di `constrained` prefisso consente il codice MSIL da associare al metodo che implementa il metodo di interfaccia in fase di esecuzione, anziché in fase di compilazione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `constrained` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D3|conv.i|Convertire `native int`, inserendo `native int` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.i` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="int8" />, quindi lo estende, aggiungendo spazi, a <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|67|conv.i1|Convertire `int8`, inserendo `int32` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.i1` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="int16" />, quindi lo estende, aggiungendo spazi, a <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|68|conv.i2|Convertire `int16`, inserendo `int32` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.i2` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|69|conv.i4|Convertire `int32`, inserendo `int32` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.i4` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|6A|conv.i8|Convertire `int64`, inserendo `int64` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.i8` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="native int" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|Convertire in un `native int` (nello stack come `native int`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="native int" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|Converte un valore senza segno in un `native int` (nello stack come `native int`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="int8" /> con segno e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|Convertire in un `int8` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i1` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="int8" /> con segno e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|Converte un valore senza segno in un `int8` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i1.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="int16" /> con segno e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|Convertire in un `int16` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i2` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="int16" /> con segno e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|Converte un valore senza segno in un `int16` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i2.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="int32" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|Convertire in un `int32` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i4` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="int32" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|Converte un valore senza segno in un `int32` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i4.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="int64" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|Convertire in un `int64` (nello stack come `int64`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i8` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="int64" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|Converte un valore senza segno in un `int64` (nello stack come `int64`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.i8.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.i8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned native int" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|Convertire in un `unsigned native int` (nello stack come `native int`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned native int" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|Converte un valore senza segno in un `unsigned native int` (nello stack come `native int`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.uvf.u.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned int8" /> e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|Convertire in un `unsigned int8` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u1` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned int8" /> e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|Converte un valore senza segno in un `unsigned int8` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u1.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.u1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned int16" /> e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|Convertire in un `unsigned int16` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u2` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned int16" /> e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|Converte un valore senza segno in un `unsigned int16` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u2.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.u2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|Convertire in un `unsigned int32` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u4` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|Converte un valore senza segno in un `unsigned int32` (nello stack come `int32`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u4.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.u4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned int64" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|Convertire in un `unsigned int64` (nello stack come `int64`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u8` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned int64" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|Converte un valore senza segno in un `unsigned int64` (nello stack come `int64`) e genera un'eccezione in caso di overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione. Se si verifica un overflow, viene generata un'eccezione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.ovf.u8.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo delle posizioni in cui convertire valore all'inizio dello stack. Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.  
  
 Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero. Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` oppure `conv.ovf.u` vengono usati, nel qual caso il risultato è anche `native int`).  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.ovf.u8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore intero senza segno all'inizio dello stack di valutazione in <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|76|conv.r.un|Convert intero senza segno a virgola mobile, eseguire il push `F` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.r.un` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero di `result` restituito non è specificato. Il `conv.r.un` operazione accetta un numero intero dallo stack, interpreta come senza segno e lo sostituisce con un numero a virgola mobile per rappresentare il numero intero: entrambi un `float32`, se è sufficientemente ampio per rappresentare il numero intero senza perdita di precisione o else un `float64`.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.r.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|6B|conv.r4|Convertire `float32`, inserendo `F` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.r4` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|6C|conv.r8|Convertire `float64`, inserendo `F` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.r8` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned native int" /> e lo estende a <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|E0|conv.u|Convertire `unsigned native int`, inserendo `native int` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.u` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned int8" /> e lo estende a <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D2|conv.u1|Convertire `int8`, inserendo `int32` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.u1` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned int16" /> e lo estende a <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D1|conv.u2|Convertire `int16`, inserendo `int32` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.u2` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned int32" /> e lo estende a <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|6D|conv.u4|Convertire `unsigned int32`, inserendo `int32` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.u4` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned int64" /> e lo estende a <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|6E|conv.u8|Convertire `int64`, inserendo `int64` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e la conversione viene tentata l'operazione.  
  
3.  Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.  
  
 Il `conv.u8` opcode converte il `value` all'inizio dello stack nel tipo specificato nel codice operativo e lasciare il valore nella parte superiore dello stack convertito. Valori interi di meno di 4 byte vengono estesi ad `int32` quando vengono caricati nello stack di valutazione (a meno che `conv.i` oppure `conv.u` viene usato, nel qual caso il risultato è anche `native int`). Vengono convertiti in valori a virgola mobile il `F` tipo.  
  
 Conversione da numeri a virgola mobile a valori interi tronca il numero verso lo zero. Durante la conversione da un `float64` a un `float32`, precisione può essere persa. Se `value` è troppo grande per un `float32 (F)`, un numero infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito. Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati. Se il risultato è inferiore a un `int32`, il valore è segno esteso per riempire lo slot.  
  
 Se si verifica un overflow conversione di un tipo a virgola mobile a un numero intero il valore restituito è specificata.  
  
 Non vengono mai generate eccezioni quando si utilizza questo campo. Visualizzare <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `conv.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia un numero specificato di byte da un indirizzo di origine a un indirizzo di destinazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Copiare dati da un blocco di memoria a un altro.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  L'indirizzo di destinazione viene inserito nello stack.  
  
2.  L'indirizzo di origine viene eseguito il push nello stack.  
  
3.  Il numero di byte da copiare sia inserito nello stack.  
  
4.  Il numero di byte, l'indirizzo di origine e l'indirizzo di destinazione viene estratti dallo stack; il numero di byte specificato viene copiato dall'indirizzo di origine all'indirizzo di destinazione.  
  
 Il `cpblk` istruzione copia un numero (tipo `unsigned int32`) di byte da un indirizzo di origine (di tipo `*`, `native int`, o `&`) per un indirizzo di destinazione (di tipo `*`, `native int`, o `&`). Il comportamento di `cpblk` è specificato se le aree di origine e destinazione si sovrappongono.  
  
 `cpblk` si presuppone che sia l'origine e destinazione risolto sono allineati alla dimensione standard del computer. Il `cpblk` istruzione può essere immediatamente preceduta dal `unaligned.<prefix>` (istruzione) per indicare che l'origine o la destinazione è allineata.  
  
 L'operazione dei `cpblk` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `cpblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia il tipo di valore individuato in corrispondenza dell'indirizzo di un oggetto di tipo <see langword="&amp;" />, <see langword="*" /> o <see langword="native int" /> nell'indirizzo dell'oggetto di destinazione, di tipo <see langword="&amp;" />, <see langword="*" /> o <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|Copia un valore di tipo da un oggetto di origine a un oggetto di destinazione.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il riferimento all'oggetto di destinazione viene inserito nello stack.  
  
2.  Il riferimento all'oggetto di origine viene eseguito il push nello stack.  
  
3.  I riferimenti agli due oggetti vengono estratti dallo stack; il tipo di valore in corrispondenza dell'indirizzo dell'oggetto di origine viene copiato l'indirizzo dell'oggetto di destinazione.  
  
 Il comportamento di `cpobj` viene omesso se l'origine e destinazione dell'oggetto i riferimenti non sono puntatori alle istanze della classe rappresentata dal token di classe `classTok` (un `typeref` oppure `typedef`), oppure se `classTok` non rappresenta un tipo di valore.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `cpobj` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide due valori e inserisce il risultato come valore in virgola mobile (di tipo <see langword="F" />) o quoziente (di tipo <see langword="int32" />) nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|5B|div|Divide due valori per restituire un risultato a virgola mobile o il quoziente.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value1` diviso per `value2`.  
  
4.  Il risultato viene inserito nello stack.  
  
 `result` = `value1` value2 div soddisfa le condizioni seguenti:  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, e:  
  
 Sign (`result`) = +, se l'accesso (`value1`) = sign (`value2`), - o, se sign (`value1`) ~ = sign (`value2`)  
  
 Il `div` istruzione calcola il risultato e lo inserisce nello stack.  
  
 Divisione di interi tronca verso lo zero.  
  
 Divisione di un numero finito per zero produce il valore di infinito con il segno corretto.  
  
 Divisione zero da zero o infinito per infinito produce il valore NaN (Not-A-Number). Qualsiasi numero diviso per un numero infinito produce un valore pari a zero.  
  
 Operazioni integrale generano <xref:System.ArithmeticException> se il risultato non può essere rappresentato nel tipo di risultato. Questa situazione può verificarsi se `value1` è il massimo valore negativo, e `value2` è -1.  
  
 Operazioni integrale generano <xref:System.DivideByZeroException> se `value2` è uguale a zero.  
  
 Si noti che nelle piattaforme basate su Intel un <xref:System.OverflowException> viene generata un'eccezione durante il calcolo (div minint -1). Operazioni a virgola mobile non generano mai un'eccezione (producono valori infiniti o NaN invece).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `div` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide due valori interi senza segno e inserisce il risultato (<see langword="int32" />) nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|5C|div.un|Divide due valori senza segno, restituendo un quoziente.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value1` diviso per `value2`.  
  
4.  Il risultato viene inserito nello stack.  
  
 Il `div.un` istruzione calcola `value1` diviso per `value2`, entrambi come interi senza segno e inserisce il `result` nello stack.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `div.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia il valore corrente più in alto nello stack di valutazione e inserisce la copia nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|25|dup|Duplica il valore nella parte superiore dello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene rimosso dallo stack per la duplicazione.  
  
3.  `value` viene nuovamente inserito nello stack.  
  
4.  Un valore duplicato viene inserito nello stack.  
  
 Il `dup` istruzione consente di duplicare l'elemento superiore dello stack e rimane nella parte superiore, due valori identici.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `dup` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo dalla clausola <see langword="filter" /> di un'eccezione nuovamente al gestore di eccezioni di Common Language Infrastructure (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|Clausola di filtro al fine di gestione delle eccezioni SEH.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack; `endfilter` viene eseguita e il controllo viene trasferito al gestore di eccezioni.  
  
 `Value` (che deve essere di tipo `int32` e fa parte di un set specifico di valori) viene restituito dalla clausola di filtro. Deve essere uno di:  
  
-   `exception_continue_search` (`value` = 0) per continuare la ricerca di un gestore di eccezioni  
  
-   `exception_execute_handler` (`value` = 1) per avviare la seconda fase di gestione delle eccezioni in cui i blocchi vengono eseguiti fino a quando il gestore associato alla clausola di filtro si trova. Una volta individuato, il gestore viene eseguito.  
  
 Altri valori interi produrrà risultati non specificati.  
  
 Il punto di ingresso di un filtro, come illustrato nella tabella delle eccezioni del metodo, deve essere la prima istruzione nel blocco di codice del filtro. Il `endfilter` istruzione deve essere l'ultima istruzione nel blocco di codice del filtro (di conseguenza può essere presente solo un `endfilter` per ogni blocco di filtro). Dopo l'esecuzione di `endfilter` un'istruzione di controllo passa di nuovo al meccanismo di gestione delle eccezioni dell'interfaccia della riga.  
  
 Il controllo non può essere trasferito in un blocco di filtro solo tramite il meccanismo delle eccezioni. Controllo non può essere trasferito all'esterno di un blocco di filtro solo tramite l'uso di un `throw` (istruzione) o tramite l'esecuzione finale `endfilter` (istruzione). Non è possibile incorporare una `try` blocchi all'interno di un `filter` blocco. Se viene generata un'eccezione all'interno di `filter` blocco, questo viene intercettato e un valore pari a 0 (`exception_continue_search`) viene restituito.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `endfilter` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trasferisce il controllo dalla clausola <see langword="fault" /> o <see langword="finally" /> di un blocco di eccezioni al gestore di eccezioni di Common Language Infrastructure (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|Termina la `finally` o `fault` clausola di un blocco di eccezioni.|  
  
 Esistono nessuno stack di comportamenti di transizione per questa istruzione.  
  
 `Endfinally` e `endfault` segnalare la fine del `finally` o `fault` clausola in modo che la rimozione dello stack può continuare fino a quando non viene richiamato il gestore di eccezioni. Il `endfinally` o `endfault` istruzione trasferisce il controllo torna al meccanismo di eccezione della riga di comando. Il meccanismo quindi le ricerche per i prossimi `finally` clausola nella catena se il blocco protetto è stato terminato con un'istruzione di uscita. Se il blocco protetto è stato terminato con un'eccezione, l'interfaccia della riga di comando eseguirà la ricerca per i prossimi `finally` o `fault`, oppure immettere il gestore di eccezioni scelto durante la prima sessione di gestione delle eccezioni.  
  
 Un' `endfinally` istruzione potrebbe essere presente solo livello lessicale interno un `finally` blocco. A differenza di `endfilter` (istruzione), non è necessario che il blocco terminano con un `endfinally` istruzione e ci possono essere tante `endfinally` istruzioni all'interno del blocco in base alle esigenze. Queste stesse restrizioni si applicano per la `endfault` (istruzione) e il `fault` blocco.  
  
 Il controllo non può essere trasferito in un `finally` (o `fault`) Blocca tranne tramite il meccanismo delle eccezioni. Controllo non può essere trasferito all'esterno di un `finally` (o `fault`) Blocca tranne tramite l'uso di un `throw` istruzione o l'esecuzione di `endfinally` (o `endfault`) (istruzione). In particolare, è possibile "fallback" di una `finally` (o `fault`) blocco o l'esecuzione di un <xref:System.Reflection.Emit.OpCodes.Ret> o <xref:System.Reflection.Emit.OpCodes.Leave> istruzione all'interno di un `finally` (o `fault`) blocco.  
  
 Si noti che il `endfault` e `endfinally` sono alias, ovvero corrispondono allo stesso codice operativo.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile usare il `endfinally` (`endfault`) opcode, così come il `ILGenerator` metodo <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inizializza un blocco specificato di memoria in corrispondenza di un indirizzo specifico su una dimensione e un valore iniziale dati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Impostare ogni posizione in un blocco di memoria in un determinato valore.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Indirizzo iniziale viene inserito nello stack.  
  
2.  Un valore di inizializzazione viene inserito nello stack.  
  
3.  Il numero di byte da inizializzare viene inserito nello stack.  
  
4.  Numero di byte, il valore di inizializzazione e l'indirizzo iniziale venga estratti dallo stack e l'inizializzazione viene eseguita in base ai relativi valori.  
  
 Il `initblk` il numero di set di istruzioni (`unsigned int32`) di byte a partire dall'indirizzo specificato (di tipo `native int`, `&`, o `*`) per il valore di inizializzazione (di tipo `unsigned int8`). `initblk` si presuppone che l'indirizzo iniziale è allineato alle dimensioni fisiche del computer.  
  
 L'operazione dei `initblk` istruzioni possono essere modificate da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `initblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inizializza ciascun campo del tipo di valore in corrispondenza di un indirizzo specifico su un riferimento Null o uno 0 di tipo primitivo appropriato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 15 &LT; `T` >|`initobj` `typeTok`|Inizializza un tipo di valore.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  L'indirizzo del tipo di valore per l'inizializzazione viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; il tipo di valore in corrispondenza dell'indirizzo specificato viene inizializzato come tipo `typeTok`.  
  
 Il `initobj` istruzione Inizializza ogni campo del tipo di valore specificato dall'indirizzo inserito (typu `native int`, `&`, o `*`) a un riferimento null o uno 0 di tipo primitivo appropriato. Dopo che questo metodo viene chiamato, l'istanza è pronta per un metodo del costruttore da chiamare. Se `typeTok` è un tipo riferimento, questa istruzione ha lo stesso effetto `ldnull` seguita da `stind.ref`.  
  
 A differenza <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` non chiama il metodo del costruttore. `Initobj` è previsto per l'inizializzazione di tipi di valore, mentre `newobj` viene usato per allocare e inizializzare gli oggetti.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `initobj` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Verifica se un riferimento a un oggetto di tipo <see langword="O" /> è un'istanza di una classe particolare.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|Verifica se un riferimento all'oggetto è un'istanza di `class`, che restituisce un riferimento null oppure un'istanza di tale classe o interfaccia.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto viene inserito nello stack.  
  
2.  Il riferimento all'oggetto viene estratto dallo stack e testata per verificare se è un'istanza della classe passata `class`.  
  
3.  Il risultato (un riferimento all'oggetto o un riferimento null) viene inserito nello stack.  
  
 `Class` è un token di metadati che indica la classe desiderata. Se la classe dell'oggetto all'inizio dello stack implementa `class` (se `class` è un'interfaccia) oppure è una classe derivata di `class` (se `class` è una classe normale), quindi ne viene eseguito il cast al tipo `class` e il risultato viene inserito nello stack, esattamente come quando <xref:System.Reflection.Emit.OpCodes.Castclass> fosse stata chiamata. In caso contrario, nello stack viene inserito un riferimento null. Se il riferimento all'oggetto stesso è un riferimento null, quindi `isinst` allo stesso modo restituisce un riferimento null.  
  
 <xref:System.TypeLoadException> viene generata se non è stata trovata classe. Ciò in genere viene rilevata quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `isinst` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esce dal metodo corrente e passa a quello specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|Esce dal metodo corrente e passa al metodo specificato.|  
  
 Esistono nessuno stack di comportamenti di transizione per questa istruzione.  
  
 Il `jmp` istruzione (collegamento) trasferisce il controllo al metodo specificato da `method`, ovvero un token di metadati per un riferimento al metodo. Gli argomenti correnti vengono trasferiti al metodo di destinazione.  
  
 Stack di valutazione deve essere vuoto quando questa istruzione viene eseguita. La convenzione di chiamata, numero e tipo di argomenti in corrispondenza dell'indirizzo di destinazione deve corrispondere a quello del metodo corrente.  
  
 Il `jmp` istruzione non può essere utilizzata per trasferire il controllo di un `try`, `filter`, `catch`, o `finally` blocco.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `jmp` opcode:  
  
-   ILGenerator (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica un argomento (a cui fa riferimento un valore di indice specificato) nello stack.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 09 &LT; `unsigned int16` >|ldarg `index`|Carica l'argomento in `index` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Valore dell'argomento in `index` viene inserito nello stack.  
  
 Il `ldarg` istruzione inserisce l'argomento indicizzato in `index`, in cui gli argomenti sono indicizzati compreso tra 0 e versioni successive, nello stack di valutazione. Il `ldarg` istruzione può essere utilizzata per caricare un tipo valore o un valore primitivo nello stack di copiandoli da un argomento in ingresso. Il tipo del valore dell'argomento è quello utilizzato per il tipo dell'argomento, come specificato dalla firma del metodo corrente.  
  
 Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il `ldarg` istruzione può essere utilizzata solo per gli argomenti, non quelle nella variabile parte della firma iniziali fissato (vedere il <xref:System.Reflection.Emit.OpCodes.Arglist> istruzione per altri dettagli).  
  
 Gli argomenti che contengono un valore integer minore di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldarg` opcode:  
  
-   ILGenerator (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'argomento in corrispondenza dell'indice 0 nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|02|ldarg.0|Carica l'argomento 0 nello stack|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore dell'argomento in corrispondenza dell'indice 0 verrà inserito nello stack.  
  
 Il `ldarg.0` istruzione è una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 0.  
  
 Il `ldarg.0` istruzione inserisce l'argomento dell'indice 0 nello stack di valutazione. Il `ldarg.0` istruzione può essere utilizzata per caricare un tipo valore o un valore primitivo nello stack di copiandoli da un argomento in ingresso. Il tipo del valore dell'argomento è quello utilizzato per il tipo dell'argomento, come specificato dalla firma del metodo corrente.  
  
 Gli argomenti che contengono un valore integer minore di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldarg.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'argomento in corrispondenza dell'indice 1 nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|03|ldarg.1|Carica l'argomento 1 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore dell'argomento in corrispondenza dell'indice 1 viene inserito nello stack.  
  
 Il `ldarg.1` istruzione è una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 1.  
  
 Il `ldarg.1` istruzione inserisce l'argomento dell'indice 1 nello stack di valutazione. Il `ldarg.1` istruzione può essere utilizzata per caricare un tipo valore o un valore primitivo nello stack di copiandoli da un argomento in ingresso. Il tipo del valore dell'argomento è quello utilizzato per il tipo dell'argomento, come specificato dalla firma del metodo corrente.  
  
 Gli argomenti che contengono un valore integer minore di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldarg.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'argomento in corrispondenza dell'indice 2 nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|04|ldarg.2|Carica l'argomento 2 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore dell'argomento in corrispondenza dell'indice 2 viene inserito nello stack.  
  
 Il `ldarg.2` istruzione è una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 2.  
  
 Il `ldarg.2` istruzione inserisce l'argomento dell'indice 2 nello stack di valutazione. Il `ldarg.2` istruzione può essere utilizzata per caricare un tipo valore o un valore primitivo nello stack di copiandoli da un argomento in ingresso. Il tipo del valore dell'argomento è quello utilizzato per il tipo dell'argomento, come specificato dalla firma del metodo corrente.  
  
 Gli argomenti che contengono un valore integer minore di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldarg.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'argomento in corrispondenza dell'indice 3 nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|05|ldarg.3|Carica l'argomento 3 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Viene inserito il valore dell'argomento in corrispondenza dell'indice 3 nello stack.  
  
 Il `ldarg.3` istruzione è una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 3.  
  
 Il `ldarg.3` istruzione inserisce l'argomento dell'indice 3 nello stack di valutazione. Il `ldarg.3` istruzione può essere utilizzata per caricare un tipo valore o un valore primitivo nello stack di copiandoli da un argomento in ingresso. Il tipo del valore dell'argomento è quello utilizzato per il tipo dell'argomento, come specificato dalla firma del metodo corrente.  
  
 Gli argomenti che contengono un valore integer minore di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldarg.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'argomento (a cui fa riferimento un indice specificato in forma breve) nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|0E &LT; `unsigned int8` >|ldarg.s `index`|Carica l'argomento in `index` nello stack, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Valore dell'argomento in `index` viene inserito nello stack.  
  
 Il `ldarg.s` istruzione rappresenta una codifica efficiente per il caricamento degli argomenti indicizzati da 4 e 255.  
  
 Il `ldarg.s` istruzione inserisce l'argomento indicizzato in `index`, in cui gli argomenti sono indicizzati compreso tra 0 e versioni successive, nello stack di valutazione. Il `ldarg.s` istruzione può essere utilizzata per caricare un tipo valore o un valore primitivo nello stack di copiandoli da un argomento in ingresso. Il tipo del valore dell'argomento è quello utilizzato per il tipo dell'argomento, come specificato dalla firma del metodo corrente.  
  
 Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il `ldarg.s` istruzione può essere utilizzata solo per gli argomenti, non quelle nella variabile parte della firma iniziali fissato (vedere il <xref:System.Reflection.Emit.OpCodes.Arglist> istruzione per altri dettagli).  
  
 Gli argomenti che contengono un valore integer minore di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldarg.s` opcode:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'indirizzo di un argomento nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 0A &LT; `unsigned int16` >|ldarga `index`|Recupera l'indirizzo dell'argomento dell'indice da `index`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  L'indirizzo `addr` dell'argomento indicizzato da `index` viene inserito nello stack.  
  
 Il `ldarga` istruzione recupera l'indirizzo (di tipo `*`) dell'argomento indicizzato da `index`, in cui gli argomenti sono indicizzati compreso tra 0 e versioni successive. L'indirizzo `addr` è sempre allineato a un limite naturale nel computer di destinazione.  
  
 Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il `ldarga` istruzione può essere utilizzata solo per gli argomenti, non quelle nella variabile parte della firma iniziali fissato.  
  
 `ldarga` viene usato per passare parametri per riferimento. Per altri casi <xref:System.Reflection.Emit.OpCodes.Ldarg> e <xref:System.Reflection.Emit.OpCodes.Starg> deve essere utilizzato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldarga` opcode:  
  
-   ILGenerator (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'indirizzo di un argomento, in forma breve, nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|0F &LT; `unsigned int8` >|ldarga.s `index`|Recupera l'indirizzo dell'argomento dell'indice da `index`, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  L'indirizzo `addr` dell'argomento indicizzato da `index` viene inserito nello stack.  
  
 `ldarga.s` (la versione abbreviata di `ldarga`) deve essere utilizzato per i numeri di argomento 0 e 255 e un tipo di codifica più efficiente.  
  
 Il `ldarga.s` istruzione recupera l'indirizzo (di tipo`*`) dell'argomento indicizzato da `index`, in cui gli argomenti sono indicizzati compreso tra 0 e versioni successive. L'indirizzo `addr` è sempre allineato a un limite naturale nel computer di destinazione.  
  
 Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il `ldarga.s` istruzione può essere utilizzata solo per gli argomenti, non quelle nella variabile parte della firma iniziali fissato.  
  
 `ldarga.s` viene usato per passare parametri per riferimento. Per altri casi <xref:System.Reflection.Emit.OpCodes.Ldarg_S> e <xref:System.Reflection.Emit.OpCodes.Starg_S> deve essere utilizzato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldarga.s` opcode:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un valore fornito di tipo <see langword="int32" /> nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4 `num`|Inserisce il valore `num` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore `num` viene inserito nello stack.  
  
 Si noti che esistono speciali codifiche short (e pertanto più efficiente) per i valori integer da -128 a 127 e in particolare breve codifiche per -1 a 8. Tutte le codifiche short effettuare il push nello stack di interi a 4 byte. Codifiche più lunghi vengono usate per valori integer a 8 byte e 4 e 8 numeri a virgola mobile in byte, nonché i valori a 4 byte che non rientrano in forme brevi. Esistono tre modi per inserire una costante integer a 8 byte di stack  
  
 1. Usare il <xref:System.Reflection.Emit.OpCodes.Ldc_I8> istruzione per le costanti che devono essere espressi in più di 32 bit.  
  
 2. Usare la <xref:System.Reflection.Emit.OpCodes.Ldc_I4> istruzione seguita da un <xref:System.Reflection.Emit.OpCodes.Conv_I8> per le costanti che richiedono da 9 a 32 bit.  
  
 3. Usare un'istruzione abbreviata seguita da un <xref:System.Reflection.Emit.OpCodes.Conv_I8> per le costanti che possono essere espressi in un numero minore o uguale a 8 bit.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4` opcode:  
  
-   ILGenerator (OpCode, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero 0 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Inserisce 0 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore 0 viene inserito nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero 1 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Effettua il push di 1 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore 1 viene inserito nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero 2 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Effettua il push di 2 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore 2 viene inserito nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero 3 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Inserisce 3 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore 3 viene inserito nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero 4 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Effettua il push di 4 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore 4 viene inserito nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero 5 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Effettua il push di 5 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore 5 viene inserito nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.5` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero 6 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Effettua il push di 6 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore 6 viene inserito nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.6` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero 7 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|Effettua il push di 7 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore 7 viene eseguito il push nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.7` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero 8 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Effettua il push di 8 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore 8 viene inserito nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore intero -1 nello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|Inserisce -1 nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore -1 viene inserito nello stack.  
  
 Si tratta di una codifica brevi speciale per il push del valore intero 0. Tutte le codifiche short speciali effettuare il push nello stack di interi a 4 byte.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.m1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore fornito <see langword="int8" /> nello stack di valutazione come <see langword="int32" /> (forma breve).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|1F &LT; `int8` >|ldc.i4.s `num`|Effettua il push `num` nello stack di come `int32`, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore `num` viene inserito nello stack.  
  
 `ldc.i4.s` è una codifica più efficiente per l'inserimento di numeri interi compresi tra -128 a 127 nello stack di valutazione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i4.s` opcode:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un valore fornito di tipo <see langword="int64" /> nello stack di valutazione come <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.i8 `num`|Effettua il push `num` nello stack di come `int64`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore `num` viene inserito nello stack.  
  
 Questa codifica inserisce un `int64` valore nello stack.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.i8` opcode:  
  
-   ILGenerator (OpCode, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un valore fornito di tipo <see langword="float32" /> nello stack di valutazione come tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|Effettua il push `num` nello stack di come `F`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore `num` viene inserito nello stack.  
  
 Questa codifica inserisce un `float32` valore nello stack.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.r4` opcode:  
  
-   ILGenerator (OpCode, singola)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un valore fornito di tipo <see langword="float64" /> nello stack di valutazione come tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|Effettua il push `num` nello stack di come `F`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore `num` viene inserito nello stack.  
  
 Questa codifica inserisce un `float64` valore nello stack.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldc.r8` opcode:  
  
-   ILGenerator (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo specificato nell'istruzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft intermediate language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|A3 &LT; `T` >|ldelem `typeTok`|Carica l'elemento in corrispondenza `index` all'inizio dello stack come tipo `typeTok`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il tipo del valore restituito è specificato dal token `typeTok` all'interno dell'istruzione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite superiore di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="native int" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|97|ldelem.i|Carica l'elemento con tipo `native int` alla `index` all'inizio dello stack come un `native int`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.i` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.i` è `native int`.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="int8" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|Carica l'elemento con tipo `int8` alla `index` all'inizio dello stack come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.i1` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.i1` è `int8`.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="int16" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|Carica l'elemento con tipo `int16` alla `index` all'inizio dello stack come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.i2` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.i2` è `int16`.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="int32" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|Carica l'elemento con tipo `int32` alla `index` all'inizio dello stack come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.i4` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.i4` è `int32`.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="int64" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|96|ldelem. i8|Carica l'elemento con tipo `int64` alla `index` all'inizio dello stack come un `int64`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.i8` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.i8` è `int64`.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="float32" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|98|ldelem. r4|Carica l'elemento con tipo `float32` alla `index` all'inizio dello stack come tipo `F`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.r4` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.r4` è `float32`.  
  
 Valori a virgola mobile vengono convertiti nel tipo `F` quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="float64" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|99|ldelem. r8|Carica l'elemento con tipo `float64` alla `index` all'inizio dello stack come tipo `F`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.r8` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.r8` è `float64`.  
  
 Valori a virgola mobile vengono convertiti nel tipo `F` quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento contenente un riferimento a un oggetto in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo <see langword="O" /> (riferimento a un oggetto).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|Carica l'elemento con un riferimento all'oggetto a `index` all'inizio dello stack come tipo `O`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.ref` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.ref` è di tipo `O` (riferimento all'oggetto).  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="unsigned int8" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|Carica l'elemento con tipo `unsigned int8` alla `index` all'inizio dello stack come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.u1` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.u1` è `int8`.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="unsigned int16" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|93|ldelem. u2|Carica l'elemento con tipo `unsigned int16` in corrispondenza dell'indice all'inizio dello stack come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.u2` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.u2` è `int16`.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'elemento con tipo <see langword="unsigned int32" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|Carica l'elemento con tipo `unsigned int32` in corrispondenza dell'indice all'inizio dello stack come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  Il valore viene inserito nello stack.  
  
 Il `ldelem.u4` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`.  
  
 Il valore restituito per `ldelem.u4` è `int32`.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> viene generata se matrice non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelem.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'indirizzo dell'elemento di matrice in corrispondenza di un indice di matrice specificato all'inizio dello stack di valutazione come tipo <see langword="&amp;" /> (puntatore gestito).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|8F &LT; `T` >|ldelema `class`|Carica l'indirizzo dell'elemento della matrice alla `index` all'inizio dello stack di valutazione come tipo `&` (puntatore gestito).|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `array` viene inserito nello stack.  
  
2.  Un valore di indice `index` viene inserito nello stack.  
  
3.  `index` e `array` vengono estratti dallo stack; indirizzo archiviato nella posizione `index` in `array` viene eseguita una ricerca.  
  
4.  L'indirizzo viene inserito nello stack.  
  
 Il `ldelema` viene usato per recuperare l'indirizzo di un oggetto in corrispondenza dell'indice specifico in una matrice di oggetti (di tipo `class`). Il `ldelema` istruzione carica l'indirizzo del valore in corrispondenza dell'indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack. Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. Il valore deve essere di tipo `class` passato con l'istruzione.  
  
 Il valore restituito per `ldelema` è un puntatore gestito (tipo `&`).  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldelema` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trova il valore di un campo nell'oggetto il cui riferimento si trova attualmente nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|Inserisce il valore di un campo in un oggetto specificato nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto (o puntatore) viene inserito nello stack.  
  
2.  Il riferimento all'oggetto (o puntatore) viene estratto dallo stack; il valore del campo specificato nell'oggetto è stato trovato.  
  
3.  Il valore archiviato nel campo viene inserito nello stack.  
  
 Il `ldfld` istruzione inserisce il valore di un campo che si trova in un oggetto nello stack. L'oggetto deve essere nello stack come un riferimento all'oggetto (tipo `O`), un puntatore gestito (tipo `&`), un puntatore non gestito (tipo `native int`), un puntatore transitorio (tipo `*`), o un'istanza di un tipo di valore. L'uso di un puntatore non gestito non è consentita nel codice verificabile. Campo dell'oggetto è specificato da un token di metadati che deve fare riferimento a un membro del campo. Il tipo restituito è identico a quello associato al campo. Il campo può essere un campo di istanza (nel qual caso l'oggetto non deve essere un riferimento null) o un campo statico.  
  
 Il `ldfld` istruzione può essere preceduta da una o entrambe le <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefissi.  
  
 <xref:System.NullReferenceException> viene generata se l'oggetto è null e il campo non è statico.  
  
 <xref:System.MissingFieldException> viene generata se il campo specificato non viene trovato nei metadati. Ciò in genere viene verificata quando istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldfld` opcode:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trova l'indirizzo di un campo nell'oggetto il cui riferimento si trova attualmente nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|7C &LT; `T` >|ldflda `field`|Inserisce l'indirizzo di `field` in un oggetto specificato nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto (o puntatore) viene inserito nello stack.  
  
2.  Il riferimento all'oggetto (o puntatore) viene estratto dallo stack; l'indirizzo del campo specificato nell'oggetto è stato trovato.  
  
3.  L'indirizzo del campo specificato viene inserito nello stack.  
  
 Il `ldflda` istruzione inserisce l'indirizzo di un campo che si trova in un oggetto nello stack. L'oggetto deve essere nello stack come un riferimento all'oggetto (tipo `O`), un puntatore gestito (tipo `&`), un puntatore non gestito (tipo `native int`), un puntatore transitorio (tipo `*`), o un'istanza di un tipo di valore. L'uso di un puntatore non gestito non è consentita nel codice verificabile. Campo dell'oggetto è specificato da un token di metadati che deve fare riferimento a un membro del campo.  
  
 Il valore restituito da `ldflda` è un puntatore gestito (tipo `&`), a meno che l'oggetto sia inserito nello stack di come un puntatore non gestito, nel qual caso l'indirizzo del mittente è anche un puntatore non gestito (tipo `native int`).  
  
 Il `ldflda` istruzione può essere preceduta da una o entrambe le <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefissi.  
  
 <xref:System.InvalidOperationException> viene generata se l'oggetto non è presente all'interno del dominio applicazione da cui si accede. Impossibile caricare l'indirizzo di un campo che non si trova all'interno al dominio di accesso dell'applicazione.  
  
 <xref:System.NullReferenceException> viene generata se l'oggetto è null e il campo non è statico.  
  
 <xref:System.MissingFieldException> viene generata se il campo specificato non viene trovato nei metadati. Ciò in genere viene verificata quando istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldflda` opcode:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un puntatore non gestito di tipo <see langword="native int" /> al codice nativo che implementa un metodo specifico nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 06 &LT; `T` >|ldftn `method`|Inserisce un puntatore a un metodo a cui fanno riferimento `method` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il puntatore non gestito a un metodo specifico viene inserito nello stack.  
  
 Il metodo specifico (`method`) può essere chiamato usando la <xref:System.Reflection.Emit.OpCodes.Calli> istruzioni se fa riferimento a un metodo gestito (o uno stub che effettua la transizione da gestito a codice non gestito).  
  
 Il valore restituito punta in codice nativo usando il convenzione di chiamata di CLR. Puntatore this (metodo) non deve essere passato al codice nativo non gestito come una routine di callback.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldftn` opcode:  
  
-   ILGenerator (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="native int" /> come <see langword="native int" /> nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|4D|ldind.i|Carica il `native int` valore all'indirizzo `addr` nello stack di come un `native int`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene inserito nello stack.  
  
 Il `ldind.i` istruzione carica indirettamente un `native int` valore dall'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come un `native int`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="int8" /> come <see langword="int32" /> nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|46|ldind.i1|Carica il `int8` valore all'indirizzo `addr` nello stack di come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene eseguito il push nello stack...  
  
 Il `ldind.i1` istruzione carica indirettamente un `int8` valore dall'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come un `int32`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="int16" /> come <see langword="int32" /> nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|48|ldind.i2|Carica il `int16` valore all'indirizzo `addr` nello stack di come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene inserito nello stack.  
  
 Il `ldind.i2` istruzione carica indirettamente un `int16` valore dall'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come un `int32`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="int32" /> come <see langword="int32" /> nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|Carica il `int32` valore all'indirizzo `addr` nello stack di come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene inserito nello stack.  
  
 Il `ldind.i4` istruzione carica indirettamente un `int32` valore dall'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come un `int32`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="int64" /> come <see langword="int64" /> nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|4C|ldind. i8|Carica il `int64` valore all'indirizzo `addr` nello stack di come un `int64`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene inserito nello stack.  
  
 Il `ldind.i8` istruzione carica indirettamente un `int64` valore dall'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come un `int64`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="float32" /> come un tipo <see langword="F" /> (float) nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|Carica il `float32` valore all'indirizzo `addr` nello stack di come un tipo `F`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene inserito nello stack.  
  
 Il `ldind.r4` istruzione carica indirettamente un `float32` valore dall'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come un tipo `F`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="float64" /> come un tipo <see langword="F" /> (float) nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|4F|ldind. r8|Carica il `float64` valore all'indirizzo `addr` nello stack di come un tipo `F`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene inserito nello stack.  
  
 Il `ldind.r8` istruzione carica indirettamente un `float64` valore dall'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come un `float64`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un riferimento a un oggetto come un tipo <see langword="O" /> (riferimento a un oggetto) nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|50|ldind.ref|Carica il riferimento oggetto all'indirizzo `addr` nello stack di come un tipo `O`|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il riferimento all'oggetto che si trova in corrispondenza dell'indirizzo.  
  
3.  Il riferimento recuperato viene inserito nello stack.  
  
 Il `ldind.ref` istruzione carica indirettamente riferimento all'oggetto dell'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come tipo `O`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="unsigned int8" /> come <see langword="int32" /> nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|47|ldind. U1|Carica il `unsigned int8` valore all'indirizzo `addr` nello stack di come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene inserito nello stack.  
  
 Il `ldind.u1` istruzione carica indirettamente un `unsigned int8` valore dall'indirizzo specificato (di tipo`native int`, `&`, o *) nello stack di come un `int32`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="unsigned int16" /> come <see langword="int32" /> nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|49|ldind. u2|Carica il `unsigned int16` valore all'indirizzo `addr` nello stack di come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene inserito nello stack.  
  
 Il `ldind.u2` istruzione carica indirettamente un `unsigned int16` valore dall'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come un `int32`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica indirettamente un valore di tipo <see langword="unsigned int32" /> come <see langword="int32" /> nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|4B|ldind. u4|Carica il `unsigned int32` valore all'indirizzo `addr` nello stack di come un `int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.  
  
3.  Il valore recuperato viene inserito nello stack.  
  
 Il `ldind.u4` istruzione carica indirettamente un `unsigned int32` valore dall'indirizzo specificato (di tipo `native int`, `&`, o *) nello stack di come un `int32`.  
  
 Tutti i `ldind` le istruzioni sono rapide da tastiera per un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valori predefiniti corrispondenti.  
  
 Si noti che i valori interi di meno di 4 byte vengono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione. Vengono convertiti in valori a virgola mobile `F` digitare quando vengono caricati nello stack di valutazione.  
  
 Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` istruzioni vengono usate in modo coerente con il tipo del puntatore.  
  
 L'indirizzo iniziale inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso). I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro. Per tipi di dati maggiori di 1 byte, l'ordine dei byte è dipende da CPU di destinazione. Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.  
  
 <xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldind.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il numero di elementi di una matrice unidimensionale in base zero nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|8E|ldlen|Inserisce la lunghezza (di tipo `natural unsigned int`) di una matrice nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto a una matrice viene inserito nello stack.  
  
2.  Il riferimento alla matrice viene estratto dallo stack e la lunghezza viene calcolata.  
  
3.  La lunghezza viene inserita nello stack.  
  
 Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. La lunghezza viene restituita come un `natural unsigned int`.  
  
 <xref:System.NullReferenceException> viene generata se il riferimento della matrice è un riferimento null.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldlen` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica la variabile locale in corrispondenza di un indice specifico nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 0C &LT; `unsigned int16` >|ldloc `index`|Carica la variabile locale in corrispondenza dell'indice `index` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore della variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.  
  
 Il `ldloc` istruzione inserisce il contenuto del numero della variabile locale in corrispondenza dell'indice passato nello stack di valutazione, in cui le variabili locali vengono numerate a partire da 0. Le variabili locali vengono inizializzate su 0 prima di immettere il metodo solo se il flag di inizializzazione nel metodo è true. Esistono 65.535 (2 ^ 16 - 1) le variabili locali possibili (0-65.534). 65.535 indice non è valido perché probabilmente implementazioni utilizzerà un valore integer a 2 byte per tenere traccia sia un indice locale, insieme al numero totale di variabili locali per un determinato metodo. Se un indice di 65535 è stato reso valido, è comunque necessario un numero intero più ampio tenere traccia del numero di variabili locali in tale metodo.  
  
 Il `ldloc.0`, `ldloc.1`, `ldloc.2`, e `ldloc.3` istruzioni forniscono una codifica efficiente per l'accesso alle prime quattro variabili locali.  
  
 Il tipo del valore è uguale al tipo della variabile locale, che viene specificato nell'intestazione del metodo. Vedere le variabili locali I. di partizione che sono minori di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possono usare overload del metodo di `ldloc` opcode:  
  
-   ILGenerator (OpCode, LocalBuilder)  
  
-   ILGenerator (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica la variabile locale in corrispondenza dell'indice 0 nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|06|ldloc.0|Carica la variabile locale in corrispondenza dell'indice 0 nello stack di valutazione.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore della variabile locale in corrispondenza dell'indice 0 viene inserito nello stack.  
  
 `ldloc.0` è una codifica particolarmente efficace per <xref:System.Reflection.Emit.OpCodes.Ldloc>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 0.  
  
 Il tipo del valore è uguale al tipo della variabile locale, che viene specificato nell'intestazione del metodo. Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica la variabile locale in corrispondenza dell'indice 1 nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|07|ldloc.1|Carica la variabile locale in corrispondenza dell'indice 1 nello stack di valutazione.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore della variabile locale in corrispondenza dell'indice 1 viene inserito nello stack.  
  
 `ldloc.1` è una codifica particolarmente efficace per <xref:System.Reflection.Emit.OpCodes.Ldloc>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 1.  
  
 Il tipo del valore è uguale al tipo della variabile locale, che viene specificato nell'intestazione del metodo. Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica la variabile locale in corrispondenza dell'indice 2 nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|08|ldloc.2|Carica la variabile locale in corrispondenza dell'indice 2 nello stack di valutazione.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore della variabile locale in corrispondenza dell'indice 2 viene eseguito il push nello stack.  
  
 `ldloc.2` è una codifica particolarmente efficace per <xref:System.Reflection.Emit.OpCodes.Ldloc>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 2.  
  
 Il tipo del valore è uguale al tipo della variabile locale, che viene specificato nell'intestazione del metodo. Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica la variabile locale in corrispondenza dell'indice 3 nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|09|ldloc.3|Carica la variabile locale in corrispondenza dell'indice 3 nello stack di valutazione.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Viene inserito il valore della variabile locale in corrispondenza dell'indice 3 nello stack.  
  
 `ldloc.3` è una codifica particolarmente efficace per <xref:System.Reflection.Emit.OpCodes.Ldloc>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 3.  
  
 Il tipo del valore è uguale al tipo della variabile locale, che viene specificato nell'intestazione del metodo. Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica la variabile locale in corrispondenza di un indice specifico nello stack di valutazione, forma breve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|Carica la variabile locale in corrispondenza dell'indice `index` nello stack, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore della variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.  
  
 Il `ldloc.s` istruzione inserisce il contenuto del numero della variabile locale in corrispondenza dell'indice passato nello stack di valutazione, in cui le variabili locali vengono numerate a partire da 0. Le variabili locali vengono inizializzate su 0 prima dell'uso del metodo, se il flag di inizializzazione nel metodo è true. Sono presenti 256 (2 ^ 8) variabili locali (0-255) nel formato breve, ovvero una codifica più efficiente rispetto a `ldloc`.  
  
 Il tipo del valore è uguale al tipo della variabile locale, che viene specificato nell'intestazione del metodo. Vedere le variabili locali I. di partizione che sono minori di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack. I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possono usare overload del metodo di `ldloc.s` opcode:  
  
-   ILGenerator (OpCode, LocalBuilder)  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'indirizzo della variabile locale in corrispondenza di un indice specifico nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE OD &LT; `unsigned int16` >|ldloca `index`|Carica l'indirizzo della variabile locale in `index` nello stack di valutazione.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  L'indirizzo archiviato nella variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.  
  
 Il `ldloca` istruzione inserisce l'indirizzo del numero della variabile locale in corrispondenza dell'indice passato nello stack, in cui le variabili locali sono numerati da 0 e versioni successive. Il valore inserito nello stack è già allineato correttamente per l'uso con le istruzioni, ad esempio <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>. Il risultato è un puntatore transitorio (tipo `*`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldloca` opcode:  
  
-   ILGenerator (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carica l'indirizzo della variabile locale in corrispondenza di un indice specifico nello stack di valutazione, forma breve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|Carica l'indirizzo della variabile locale in `index` nello stack di valutazione, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  L'indirizzo archiviato nella variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.  
  
 Il `ldloca.s` istruzione inserisce l'indirizzo del numero della variabile locale in corrispondenza dell'indice passato nello stack, in cui le variabili locali sono numerati da 0 e versioni successive. Il valore inserito nello stack è già allineato correttamente per l'uso con le istruzioni, ad esempio <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>. Il risultato è un puntatore transitorio (tipo `*`).  
  
 Il `ldloca.s` istruzione fornisce una codifica efficiente per l'uso con le variabili locali, tra 0 e 255.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldloca.s` opcode:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un riferimento null di tipo <see langword="O" /> nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|14|ldnull|eseguire il push nello stack di riferimento null|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a un oggetto null viene inserito nello stack.  
  
 `ldnull` Inserisce un riferimento null (tipo `O`) nello stack. Ciò consente di inizializzare i percorsi prima che siano compilati con i dati o quando è diventano deprecati.  
  
 `ldnull` fornisce un riferimento null che è indipendente dalla dimensione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldnull` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia l'oggetto tipo di valore a cui punta un indirizzo all'inizio dello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|Copia un'istanza del tipo di valore `class` allo stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  L'indirizzo di un oggetto di tipo valore viene inserito nello stack.  
  
2.  L'indirizzo viene estratto dallo stack e l'istanza a quell'indirizzo particolare viene eseguita una ricerca.  
  
3.  Il valore dell'oggetto archiviato in tale indirizzo viene inserito nello stack.  
  
 Il `ldobj` (istruzione) viene usata per passare un tipo di valore come parametro.  
  
 Il `ldobj` istruzione copia il valore a cui punta `addrOfValObj` (di tipo `&`, `*`, o `native int`) nella parte superiore dello stack. Il numero di byte copiati dipende dalle dimensioni della classe (come specificato da di `class` parametro). Il `class` parametro è un token di metadati che rappresenta il tipo di valore.  
  
 L'operazione dei `ldobj` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.TypeLoadException> viene generata se non è stata trovata classe. Questo in genere viene rilevato quando l'istruzione di Microsoft Intermediate Language (MSIL) viene convertito in codice nativo piuttosto che in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldobj` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce il valore di un campo statico nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|7E &LT; `T` >|ldsfld `field`|Inserire il valore di `field` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore del campo specifico viene inserito nello stack.  
  
 Il `ldsfld` istruzione inserisce il valore di un valore statico (condiviso tra tutte le istanze di una classe) campo nello stack. Il tipo restituito è quello associato al token di metadati passato `field`.  
  
 Il `ldsfld` istruzione può essere un <xref:System.Reflection.Emit.OpCodes.Volatile> prefisso.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldsfld` opcode:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce l'indirizzo di un campo statico nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|7F &LT; `T` >|ldsflda `field`|Inserisce l'indirizzo di `field` nello stack|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  L'indirizzo di un campo specifico viene inserito nello stack.  
  
 Il `ldsflda` istruzione inserisce l'indirizzo di un valore statico (condiviso tra tutte le istanze di una classe) campo nello stack. L'indirizzo può essere rappresentato come un puntatore transitorio (tipo `*`) se il token di metadati `field` fa riferimento a un tipo la cui memoria viene gestita. In caso contrario, corrisponde a un puntatore non gestito (tipo `native int`). Si noti che `field` può essere un valore statico globale con un indirizzo virtuale relativo assegnato (l'offset del campo dall'indirizzo di base in corrispondenza del quale il file PE che lo contiene viene caricato in memoria) in cui la memoria è non gestita.  
  
 Il `ldsflda` istruzione può essere un <xref:System.Reflection.Emit.OpCodes.Volatile> prefisso.  
  
 <xref:System.MissingFieldException> viene generata se il campo non viene trovato nei metadati. Ciò in genere viene verificata quando istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldsflda` opcode:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un nuovo riferimento a un oggetto in un valore letterale stringa archiviato nei metadati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|Inserisce un oggetto stringa per il token di stringa dei metadati `mdToken`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Riferimento a una stringa di un oggetto viene inserito nello stack.  
  
 Il `ldstr` istruzione inserisce un riferimento all'oggetto (tipo `O`) a un nuovo oggetto stringa che rappresenta la stringa letterale archiviata nei metadati. Il `ldstr` istruzione consente di allocare la quantità di memoria necessaria ed esegue qualsiasi conversione del formato richiesto per convertire il valore letterale stringa dal formato utilizzato nel file per il formato di stringa necessario in fase di esecuzione.  
  
 Common Language Infrastructure (CLI) garantisce che il risultato di due `ldstr` istruzioni che fanno riferimento ai due token di metadati che hanno la stessa sequenza di caratteri restituiscano esattamente lo stesso oggetto di stringa (un processo noto come "centralizzazione delle stringhe").  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldstr` opcode:  
  
-   ILGenerator (OpCode, stringa)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte un token di metadati nella relativa rappresentazione di runtime, inserendolo nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|Converte un token di metadati nella relativa rappresentazione di runtime.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il token passato viene convertito in un `RuntimeHandle` e inserito nello stack.  
  
 Il `ldtoken` notifiche push (istruzione) un `RuntimeHandle` per il token di metadati specificato. Oggetto `RuntimeHandle` può essere un `fieldref/fielddef`, un `methodref/methoddef`, o un `typeref/typedef`.  
  
 Il valore inserito nello stack può essere utilizzato nelle chiamate a `Reflection` metodi nella libreria di classi di sistema.  
  
 Per informazioni sugli handle di runtime, vedere le seguenti classi: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, e <xref:System.RuntimeMethodHandle>.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possono usare overload del metodo di `ldtoken` opcode:  
  
-   ILGenerator (OpCode, MethodInfo)  
  
-   ILGenerator (OpCode, FieldInfo)  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un puntatore non gestito di tipo (<see langword="native int" />) al codice nativo che implementa un particolare metodo virtual con un oggetto specificato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 07 &LT; `T` >|ldvirtftn `method`|Inserisce il puntatore a un metodo dell'oggetto virtuale `method` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto viene inserito nello stack.  
  
2.  Il riferimento all'oggetto viene estratto dallo stack e l'indirizzo del punto di ingresso al metodo (come specificato dal token di metadati `method`) viene eseguita una ricerca.  
  
3.  Il puntatore alla `method` viene inserito nello stack.  
  
 Il puntatore non gestito risultante inseriti nello stack per il `ldvirtftn` istruzione può essere chiamata usando la <xref:System.Reflection.Emit.OpCodes.Calli> istruzioni se fa riferimento a un metodo gestito (o uno stub che effettua la transizione da gestito a codice non gestito).  
  
 Il puntatore non gestito punta a codice nativo usando il convenzione di chiamata di CLR. Puntatore this (metodo) non deve essere passato al codice nativo non gestito come una routine di callback.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ldvirtftn` opcode:  
  
-   ILGenerator (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esce da un'area protetta di codice, trasferendo il controllo in modo incondizionato a un'istruzione di destinazione specifica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|DD < `int32` >|lasciare `target`|Esce da un'area protetta di codice.|  
  
 Non è disponibile alcun comportamento di transizione dello stack specificato per questa istruzione.  
  
 Il `leave` istruzione trasferisce il controllo all'istruzione di destinazione specifico, rappresentato come un offset con segno a 4 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Il `leave` l'istruzione è simile al `br` (istruzione), ma può essere utilizzato per chiudere un `try`, `filter`, o `catch` block, mentre le normali istruzioni branch possono essere utilizzate solo in tale blocco per trasferire il controllo all'interno di si tratta. Il `leave` Svuota dello stack di valutazione di istruzioni e assicura che l'appropriato che circonda `finally` vengono eseguiti blocchi.  
  
 Non è possibile usare una `leave` per uscire dall'istruzione un `finally` blocco. Per facilitare la generazione di codice per i gestori di eccezioni è valida all'interno di un blocco catch per usare un `leave` istruzione per trasferire il controllo per qualsiasi istruzione all'interno associato `try` blocco.  
  
 Se un'istruzione include uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possono usare overload del metodo di `leave` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esce da un'area protetta di codice, trasferendo il controllo in modo incondizionato a un'istruzione di destinazione (forma breve).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|GERMANIA &LT; `int8` >|leave. s `target`|Uscire da un'area protetta di codice, forma breve.|  
  
 Non è disponibile alcun comportamento di transizione dello stack specificato per questa istruzione.  
  
 Il `leave.s` istruzione trasferisce il controllo all'istruzione di destinazione passata, rappresentato come un offset con segno a 1 byte dall'inizio dell'istruzione che segue l'istruzione corrente.  
  
 Il `leave.s` l'istruzione è simile al `br` (istruzione), ma può essere utilizzato per chiudere un `try`, `filter`, o `catch` block, mentre le normali istruzioni branch possono essere utilizzate solo in tale blocco per trasferire il controllo all'interno di si tratta. Il `leave.s` Svuota dello stack di valutazione di istruzioni e assicura che l'appropriato che circonda `finally` vengono eseguiti blocchi.  
  
 Non è possibile usare una `leave.s` per uscire dall'istruzione un `finally` blocco. Per facilitare la generazione di codice per i gestori di eccezioni è valida all'interno di un blocco catch per usare un `leave.s` istruzione per trasferire il controllo per qualsiasi istruzione all'interno associato `try` blocco.  
  
 Se un'istruzione include uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `leave.s` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esegue l'allocazione di un numero di byte dal pool di memoria dinamica locale e inserisce l'indirizzo (un puntatore transitorio di tipo <see langword="*" />) del primo byte allocato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Allocare lo spazio dell'heap locale.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il numero di byte da allocare viene inserito nello stack.  
  
2.  Il numero di byte viene estratto dallo stack; una quantità di memoria per ogni dimensione viene allocata dall'heap locale.  
  
3.  Un puntatore al primo byte della memoria allocata è inserito nello stack.  
  
 Il `localloc` istruzione alloca `size` (tipo `natural unsigned int`) pool di byte di memoria dinamica locale e restituisce l'indirizzo (un puntatore transitorio, tipo `*`) del primo byte allocato. Il blocco di memoria restituita viene inizializzata su 0 solo se il flag di inizializzazione nel metodo è `true`. Quando il metodo corrente viene eseguito un <xref:System.Reflection.Emit.OpCodes.Ret>, pool di memoria locale viene resa disponibile per il riutilizzo.  
  
 L'indirizzo risulta è allineato in modo che qualsiasi tipo di dati primitivi può essere memorizzato usando il `stind` istruzioni (, ad esempio <xref:System.Reflection.Emit.OpCodes.Stind_I4>) e caricati usando il `ldind` istruzioni (ad esempio <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 Il `localloc` istruzione non può verificarsi all'interno di un `filter`, `catch`, `finally`, o `fault` blocco.  
  
 <xref:System.StackOverflowException> viene generata se la memoria è insufficiente per soddisfare la richiesta.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `localloc` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un riferimento tipizzato a un'istanza di un tipo specifico nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|C6 &LT; `T` >|mkrefany `class`|Inserisce un riferimento tipizzato del tipo `class` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Puntatore alla porzione di dati viene eseguito il push nello stack.  
  
2.  Il puntatore viene estratto e convertito in un riferimento tipizzato del tipo `class`.  
  
3.  Il riferimento tipizzato viene inserito nello stack.  
  
 Il `mkrefany` istruzione supporta il passaggio dei riferimenti tipizzati in modo dinamico. Il puntatore deve essere di tipo `&`, `*`, o `native int`, tenere premuto l'indirizzo di una porzione di dati valido. `Class` è il token di classe che descrive il tipo di dati a cui fa riferimento il puntatore. `Mkrefany` Inserisce un riferimento tipizzato nello stack, fornendo un descrittore del puntatore e il tipo opaco `class`.  
  
 Operazione valida solo consentita su un riferimento tipizzato è passare a un metodo che richiede un riferimento tipizzato come parametro. Il chiamato può quindi usare il <xref:System.Reflection.Emit.OpCodes.Refanytype> e <xref:System.Reflection.Emit.OpCodes.Refanyval> istruzioni per recuperare rispettivamente il tipo (classe) e l'indirizzo.  
  
 <xref:System.TypeLoadException> Se viene generata `class` nebyla nalezena. Ciò in genere viene rilevata quando istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `mkrefany` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Moltiplica due valori e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|5A|mul|Moltiplica due valori nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value1` viene moltiplicato per `value2`.  
  
4.  Il risultato viene inserito nello stack.  
  
 Il `mul` istruzione moltiplica `value1` da `value2` e inserisce il risultato nello stack. Operazioni con numeri interi troncano automaticamente i bit superiori in caso di overflow.  
  
 Vedere <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> per un numero intero specifica operazione con la gestione dell'overflow di moltiplicazione.  
  
 Per i tipi a virgola mobile, 0 * infinity = NaN.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `mul` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Moltiplica due valori interi, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|Moltiplica due valori interi nello stack con un controllo dell'overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value1` viene moltiplicato per `value2`, con un controllo dell'overflow.  
  
4.  Il risultato viene inserito nello stack.  
  
 Il `mul.ovf` istruzione moltiplica l'intero `value1` dall'intero `value2` e inserisce il risultato nello stack. Se il risultato non rientrano nel tipo di risultato, viene generata un'eccezione.  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `mul.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Moltiplica due valori interi senza segno, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|Moltiplica due valori senza segno nello stack con un controllo dell'overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value1` viene moltiplicato per `value2`, con un controllo dell'overflow.  
  
4.  Il risultato viene inserito nello stack.  
  
 Il `mul.ovf.un` istruzione moltiplica l'intero senza segno `value1` dall'intero senza segno `value2` e inserisce il risultato nello stack. Se il risultato non rientrano nel tipo di risultato, viene generata un'eccezione.  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `mul.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nega un valore e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|65|neg|Nega il valore attualmente all'inizio dello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore viene inserito nello stack.  
  
2.  Un valore è estratto dallo stack e negato.  
  
3.  Il risultato viene inserito nello stack.  
  
 Il `neg` istruzione Nega il valore e inserisce il risultato all'inizio dello stack. Il tipo restituito è lo stesso tipo dell'operando.  
  
 Negazione di valori integrali è standard in complemento a due negazione. In particolare, la negazione del numero più negativo (che non ha una controparte di positiva) produce il numero più negativo. Per rilevare questo utilizzo di overflow di <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> istruzione invece (vale a dire, sottrarre da 0).  
  
 La negazione di un numero a virgola mobile non è possibile overflow e la negazione di NaN restituisce NaN.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `neg` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce un riferimento a un oggetto in una matrice unidimensionale in base zero i cui elementi sono di un tipo specifico nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|Crea una nuova matrice con elementi di tipo `etype`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il numero di elementi nella matrice viene inserito nello stack.  
  
2.  Il numero di elementi viene estratto dallo stack e la matrice viene creata.  
  
3.  Un riferimento all'oggetto per la nuova matrice viene inserito nello stack.  
  
 Il `newarr` istruzione inserisce un riferimento all'oggetto (tipo `O`) a una matrice unidimensionale in base zero i cui elementi sono di tipo `etype` (un token di metadati che descrive il tipo). Il numero di elementi nella nuova matrice deve essere specificato come un `native int`. Intervallo di indici di matrice valido compreso tra zero e il numero massimo di elementi meno uno.  
  
 Gli elementi della matrice possono essere qualsiasi tipo, inclusi i tipi di valore.  
  
 In base zero unidimensionale le matrici dei numeri vengono create tramite un token di metadati che fa riferimento il tipo di valore appropriato (<xref:System.Int32>e così via). Gli elementi della matrice vengono inizializzati su 0 del tipo appropriato.  
  
 Matrici unidimensionali a base e le matrici multidimensionali vengono create usando <xref:System.Reflection.Emit.OpCodes.Newobj> anziché `newarr`. Più comunemente, vengono creati utilizzando i metodi del <xref:System.Array> classe in .NET Framework.  
  
 <xref:System.OutOfMemoryException> viene generata se la memoria è insufficiente per soddisfare la richiesta.  
  
 <xref:System.OverflowException> Se viene generata `numElems` è minore di 0.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `newarr` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Crea un nuovo oggetto o una nuova istanza di un tipo di valore, inserendo un riferimento a un oggetto (di tipo <see langword="O" />) nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|Alloca un oggetto o valore di tipo non inizializzato e chiama il metodo costruttore `ctor`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Gli argomenti `arg1` tramite `argn` vengono inseriti nello stack in sequenza.  
  
2.  Gli argomenti `argn` attraverso `arg1` vengono estratti dallo stack e passati a `ctor` per la creazione di oggetti.  
  
3.  Un riferimento al nuovo oggetto viene inserito nello stack.  
  
 Il `newobj` istruzione crea un nuovo oggetto o una nuova istanza di un tipo valore. `Ctor` è un token di metadati (un `methodref` o `methoddef` che devono essere contrassegnati come un costruttore) che indica il nome, classe e la firma del costruttore da chiamare.  
  
 Il `newobj` istruzione consente di allocare una nuova istanza della classe associata `ctor` e inizializza tutti i campi nella nuova istanza su 0 (del tipo appropriato) o riferimenti null come appropriato. Viene quindi chiamato il costruttore `ctor` con gli argomenti specificati insieme all'istanza appena creata. Dopo aver chiamato il costruttore, l'ora inizializzati riferimento all'oggetto (tipo `O`) viene eseguito il push nello stack.  
  
 Dal punto di vista del costruttore, l'oggetto non inizializzato è l'argomento 0 e gli altri argomenti passati a newobj seguono in ordine.  
  
 Tutte le matrici unidimensionale in base zero vengono create usando <xref:System.Reflection.Emit.OpCodes.Newarr>, non `newobj`. D'altra parte, tutti gli altri array (più di una dimensione, o unidimensionale, ma non in base zero) vengono creati usando `newobj`.  
  
 I tipi di valore non vengono in genere creati usando `newobj`. In genere vengono allocate come argomenti o variabili locali, usando `newarr` (per matrici unidimensionale in base zero), o come campi di oggetti. Una volta allocata, vengono inizializzati usando <xref:System.Reflection.Emit.OpCodes.Initobj>. Tuttavia, il `newobj` istruzione può essere utilizzata per creare una nuova istanza di un tipo di valore nello stack, che può quindi essere passato come argomento, archiviato in locale e così via.  
  
 <xref:System.OutOfMemoryException> viene generata se la memoria è insufficiente per soddisfare la richiesta.  
  
 <xref:System.MissingMethodException> viene generata se un metodo del costruttore `ctor` con il nome indicato, classe e la firma non è stati trovati. Ciò in genere viene rilevata quando istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, anziché in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `newobj` opcode:  
  
-   ILGenerator (OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Riempie lo spazio se i codici operativi sono corretti. Non viene eseguita alcuna operazione significativa sebbene possa essere usato un ciclo di elaborazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|00|NOP|Esegue un'operazione senza il comportamento.|  
  
 Non è disponibile alcun comportamento di transizione dello stack definito per questa istruzione.  
  
 Il `nop` non esegue alcuna operazione. Consente di riempire lo spazio se i codici operativi sono corretti.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `nop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcola il complemento bit per bit del valore intero all'inizio dello stack e inserisce il risultato nello stack di valutazione come lo stesso tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|66|not|Calcola il complemento bit per bit di un valore.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value` viene inserito nello stack.  
  
2.  `value` viene estratto dallo stack e il bit per bit complemento calcolato.  
  
3.  Il risultato viene inserito nello stack.  
  
 Il `not` istruzione calcola il complemento bit per bit di un valore integer e inserisce il risultato nello stack. Il tipo restituito è lo stesso tipo dell'operando.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `not` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcola il complemento bit per bit dei due valori interi all'inizio dello stack e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|60|oppure|Calcola bit per bit oppure su due valori integer, restituisce un valore integer.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack e relativo OR calcolato.  
  
4.  Il risultato viene inserito nello stack.  
  
 Il `or` istruzione calcola l'operatore OR di due valori all'inizio dello stack, inserendo il risultato nello stack.  
  
 `Or` è un'operazione specifica del numero intero.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `or` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rimuove il valore attualmente all'inizio dello stack.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|26|pop|Estrae il valore dallo stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il primo valore viene estratto dallo stack.  
  
 Il `pop` istruzione rimuove il primo elemento dallo stack.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `pop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si tratta di un'istruzione riservata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si tratta di un'istruzione riservata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si tratta di un'istruzione riservata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si tratta di un'istruzione riservata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si tratta di un'istruzione riservata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si tratta di un'istruzione riservata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si tratta di un'istruzione riservata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si tratta di un'istruzione riservata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che la successiva operazione sull'indirizzo di matrice non comporta l'esecuzione di alcun controllo del tipo in fase di esecuzione e che viene restituito un puntatore gestito la cui modificabilità è limitata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft intermediate language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 1E|sola lettura.|Specificare che l'operazione di indirizzo della matrice successive viene eseguito alcun controllo di tipo in fase di esecuzione e che restituisce un puntatore gestito con modificabilità con restrizioni.|  
  
 Questo prefisso può trovarsi solo immediatamente precedente il `ldelema` (istruzione) e le chiamate a speciale `Address` metodo nelle matrici. Il relativo effetto sull'operazione successiva è duplice:  
  
1.  In fase di esecuzione, viene eseguita alcuna operazione di controllo di tipo. Si noti che è in genere un controllo di tipo implicito per il `ldelema` e `stelem` matrici di tipi di istruzioni quando viene usato in riferimento. Non è mai un controllo del tipo in fase di esecuzione per le classi di valore, pertanto `readonly` è no-op in questo caso.  
  
2.  Il sistema di verifica considera il risultato dell'operazione AddressOf come un puntatore gestito mutabilità è limitata.  
  
 Il puntatore si dice che mutabilità limitata poiché il tipo di definizione consente di controllare se il valore può essere modificato. Per le classi di valore che non espongono alcun campi pubblici o i metodi che aggiornano il valore nella posizione, il puntatore è di sola lettura (quindi il nome del prefisso). In particolare, le classi che rappresentano i tipi primitivi (ad esempio System.Int32) non espongono metodi mutatori e pertanto sono di sola lettura.  
  
 Un puntatore gestito con restrizioni in questo modo può essere utilizzato solo nei modi seguenti:  
  
-   Come le `object` parametro per il `ldfld`, `ldflda`, `stfld`, `call`, o`constrained callvirt` istruzioni.  
  
-   Come le `pointer` parametro per il `ldobj` (istruzione) o a uno del `ldind` istruzioni.  
  
-   Come le `source` parametro per il `cpobj` (istruzione).  
  
 Tutte le altre operazioni non consentite, incluse le `stobj`, `initobj`, o `mkrefany` operazioni o una qualsiasi del `stind` istruzioni.  
  
 Lo scopo del `readonly` prefisso consiste nell'evitare di un controllo del tipo durante il recupero di un elemento da una matrice in codice generico. Ad esempio, l'espressione `arr[i].m()`, in cui il tipo di elemento della matrice `arr` è un tipo generico è vincolato a un'interfaccia con metodo `m`, potrebbe essere compilate in MSIL seguenti.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Senza il `readonly` prefisso, il `ldelema` istruzione eseguirebbe un controllo del tipo nel caso in cui! 0 era un tipo di riferimento. Non solo questo controllo di tipo non è efficiente, ma non è semanticamente corretto. Il controllo dei tipi per `ldelema` è una corrispondenza esatta, che è troppo complessa. Se nella matrice sono presenti le sottoclassi di tipo! 0, il codice precedente avrà esito negativo il controllo dei tipi.  
  
 L'indirizzo dell'elemento della matrice verrà recuperato, invece dell'elemento stesso, per disporre di un handle per la `arr[i]` che utilizzi entrambi i tipi di valore e tipi di riferimento e pertanto può essere passati al `constrained callvirt` (istruzione).  
  
 In genere sarebbe unsafe ignora il controllo in fase di esecuzione se la matrice sono presenti elementi di un tipo riferimento. Per sicurezza, è necessario garantire che non vengano eseguiti modifiche all'array tramite puntatore ' this '. Verificare che le regole di sistema di verifica questo. Il puntatore gestito con restrizioni può essere passato come oggetto della chiamate ai metodi di istanza, in modo che non è in senso stretto sola lettura per i tipi di valore, ma non determina alcun problema di sicurezza di tipo per i tipi di valore.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `readonly` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera il token di tipo incorporato in un riferimento tipizzato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Inserisce il token di tipo archiviato in un riferimento tipizzato.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Riferimento a un tipo valore viene inserito nello stack.  
  
2.  Il riferimento tipizzato viene estratto dallo stack e recuperata il token di tipo corrispondente.  
  
3.  Il token di tipo viene inserito nello stack.  
  
 Un riferimento tipizzato contiene un token del tipo e un indirizzo per un'istanza dell'oggetto.  
  
 Il `refanytype` istruzione recupera il token di tipo incorporato in riferimento tipizzato. Vedere il <xref:System.Reflection.Emit.OpCodes.Mkrefany> (istruzione) per informazioni sulla creazione di riferimenti tipizzati.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `refanytype` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera l'indirizzo (di tipo <see langword="&amp;" />) incorporato in un riferimento tipizzato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|Inserisce l'indirizzo archiviato in un riferimento tipizzato.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Riferimento a un tipo valore viene inserito nello stack.  
  
2.  Il riferimento tipizzato viene estratto dallo stack e recuperare l'indirizzo del corrispondente.  
  
3.  L'indirizzo viene inserito nello stack.  
  
 Un riferimento tipizzato contiene un token del tipo e un indirizzo per un'istanza dell'oggetto.  
  
 Il `refanyval` istruzione recupera l'indirizzo incorporato in di un riferimento tipizzato. Il tipo incorporato nel riferimento tipizzato fornito nello stack deve corrispondere al tipo specificato da `type` (un token di metadati, ovvero un `typedef` o un `typeref`). Vedere il <xref:System.Reflection.Emit.OpCodes.Mkrefany> istruzione per il contenuto correlato.  
  
 <xref:System.InvalidCastException> Se viene generata `type` non è identico al tipo archiviato nel riferimento del tipo (in questo caso, `type` è la classe fornita per il <xref:System.Reflection.Emit.OpCodes.Mkrefany> istruzione di costruzione detto riferimento tipizzato).  
  
 <xref:System.TypeLoadException> Se viene generata `type` nebyla nalezena.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `refanyval` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide due valori e inserisce il resto nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|5D|REM|Inserisce il resto della divisione `value1` da `value2` nello stack.|  
  
> [!NOTE]
>  ReplaceThisText  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Oggetto `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack e il resto della `value1` `div` `value2` calcolato.  
  
4.  Il risultato viene inserito nello stack.  
  
 `result` = `value1` `rem` `value2` soddisfa le condizioni seguenti:  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`), e:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign (`result`) = sign (`value1`), dove `div` è l'istruzione di divisione che tronca verso lo zero.  
  
 Se `value2` è uguale a zero o `value1` è infinito, il risultato è NaN. Se `value2` è un valore infinito, il risultato è `value1` (negata per `-infinity`).  
  
 Operazioni integrale generano <xref:System.DivideByZeroException> se `value2` è uguale a zero.  
  
 Si noti che nelle piattaforme basate su Intel un' <xref:System.OverflowException> viene generata un'eccezione durante il calcolo (minint `rem` -1).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `rem` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide due valori senza segno e inserisce il resto nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|5E|rem.un|Inserisce il resto della divisione senza segno `value1` dall'unsigned `value2` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack e il resto della `value1` `div` `value2` calcolato.  
  
4.  Il risultato viene inserito nello stack.  
  
 `result` = `value1` `rem.un` `value2` soddisfa le condizioni seguenti:  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`), e:  
  
 0 = `result`  <  `value2`, dove `div.un` è l'istruzione di divisione senza segno.  
  
 Il `rem.un` istruzione calcola `result` e lo inserisce nello stack. `Rem.un` considera i propri argomenti come valori interi senza segno, mentre <xref:System.Reflection.Emit.OpCodes.Rem> li considera come interi con segno.  
  
 `Rem.un` non è specificato per i numeri a virgola mobile.  
  
 Operazioni integrale generano <xref:System.DivideByZeroException> se `value2` è uguale a zero.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `rem.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restituisce il risultato del metodo corrente, inserendo il valore restituito (se presente) dallo stack di valutazione del chiamato nello stack di valutazione del chiamante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|2A|RET|Restituisce dal metodo, possibilmente restituire un valore.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore restituito viene estratto dallo stack di valutazione del chiamato.  
  
2.  Il valore restituito ottenuto nel passaggio 1 viene eseguito il push nello stack di valutazione chiamante.  
  
 Se il valore restituito non è presente nello stack di valutazione chiamato, viene restituito alcun valore (senza alcun comportamento di transizione dello stack per il metodo chiamato o chiamante).  
  
 Il tipo del valore restituito, se presente, del metodo corrente determina il tipo del valore da recuperare dall'inizio dello stack e copiato nello stack del metodo che ha chiamato il metodo corrente. Lo stack di valutazione per il metodo corrente deve essere vuoto tranne per il valore da restituire.  
  
 Il `ret` istruzione non può essere utilizzata per trasferire il controllo di un`try`, `filter`, `catch`, o `finally` blocco. Dall'interno una `try` o `catch`, utilizzare il <xref:System.Reflection.Emit.OpCodes.Leave> istruzione con una destinazione di un `ret` istruzione che è all'esterno di tutti i blocchi di eccezioni. Poiché il `filter` e `finally` blocchi fanno logicamente parte di gestione delle eccezioni e non il metodo in cui è incorporato il proprio codice, istruzioni Microsoft Intermediate Language (MSIL) generato in modo corretto non eseguono un metodo viene restituito all'interno di un `filter` o `finally`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `ret` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Genera nuovamente l'eccezione corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 1A|rethrow|Genera nuovamente l'eccezione corrente|  
  
 Per questa istruzione non è definito alcun comportamento dello stack di transizione.  
  
 Il `rethrow` istruzione è consentita solo all'interno del corpo di un `catch` gestore. Genera la stessa eccezione che è stata intercettata da questo gestore.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `rethrow` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sposta un valore intero verso sinistra (spostando gli zeri) di un numero specificato di bit, inserendo il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|62|shl|Sposta a sinistra (spostando gli zeri) di un numero intero.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore viene inserito nello stack.  
  
2.  La quantità di bit da spostare sia inserita nello stack.  
  
3.  Il numero di bit da spostare e il valore vengono estratti dallo stack; il valore viene spostato a sinistra del numero specificato di bit.  
  
4.  Il risultato viene inserito nello stack.  
  
 Il `shl` istruzione sposta il valore (tipo `int32`, `int64` o `native int`) a sinistra del numero specificato di bit. Il numero di bit è un valore di tipo `int32` o `native int`. Se il numero di bit da spostare sia maggiore o uguale alla larghezza (espressa in bit) del valore fornito non è specificato il valore restituito.  
  
 `Shl` Inserisce un bit zero nella posizione più bassa su ogni turno.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `shl` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sposta un valore intero verso destra (spostando il segno) di un numero specificato di bit, inserendo il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|63|shr|Sposta a destra (spostando il segno) di un numero intero.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore viene inserito nello stack.  
  
2.  La quantità di bit da spostare sia inserita nello stack.  
  
3.  Il numero di bit da spostare e il valore vengono estratti dallo stack; il valore viene spostato a destra del numero specificato di bit.  
  
4.  Il risultato viene inserito nello stack.  
  
 Il `shr.un` istruzione sposta il valore (tipo `int32`, `int64` o `native int`) a destra del numero specificato di bit. Il numero di bit è un valore di tipo `int32` o `native int`. Se il numero di bit da spostare sia maggiore o uguale alla larghezza (espressa in bit) del valore fornito non è specificato il valore restituito.  
  
 `Shr` esegue la replica il bit più significativo per ogni turno, mantenendo il segno del valore originale di `result`.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `shr` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sposta un valore intero senza segno verso destra (spostando gli zeri) di un numero specificato di bit, inserendo il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|64|shr. un|Sposta a destra (spostando gli zeri) di un numero intero.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore viene inserito nello stack.  
  
2.  La quantità di bit da spostare sia inserita nello stack.  
  
3.  Il numero di bit da spostare e il valore vengono estratti dallo stack; il valore viene spostato a destra del numero specificato di bit.  
  
4.  Il risultato viene inserito nello stack.  
  
 Il `shr.un` istruzione sposta il valore (tipo `int32`, `int64` o `native int`) a destra del numero specificato di bit. Il numero di bit è un valore di tipo `int32`, `int64` o `native int`. Se il numero di bit da spostare sia maggiore o uguale alla larghezza (espressa in bit) del valore fornito non è specificato il valore restituito.  
  
 `Shr.un` Inserisce un bit zero nella posizione più alta in ogni turno.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `shr.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inserisce la dimensione in byte del tipo di valore fornito nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 1C &LT; `T` >|sizeof `valType`|Inserisce la dimensione in byte, di un tipo di valore come un `unsigned int32`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Le dimensioni (in byte) del tipo di valore fornito (`valType`) viene eseguito il push nello stack.  
  
 `valType` deve essere un token di metadati (un `typeref` o `typedef`) che specifica un tipo valore, un tipo riferimento o un parametro di tipo generico.  
  
 Per un tipo riferimento, le dimensioni restituite sono le dimensioni di un valore di riferimento dell'elemento corrispondente tipo (4 byte nei sistemi a 32 bit), non la dimensione dei dati archiviati in oggetti a cui fa riferimento il valore di riferimento. Un parametro di tipo generico può essere utilizzato solo nel corpo del tipo o metodo che lo definisce. Quando viene creata un'istanza quel tipo o metodo, il parametro di tipo generico viene sostituito da un tipo valore o tipo di riferimento.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `sizeof` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Archivia il valore all'inizio dello stack di valutazione nello slot di argomento in corrispondenza di un indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 0B &LT; `unsigned int16` >|starg `num`|Estrae il valore dallo stack e lo archivia in uno slot di argomento `num`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore attualmente all'inizio dello stack viene estratto e inserito in uno slot di argomento `num`.  
  
 Il `starg` estrae un valore dallo stack di istruzioni e lo inserisce nello slot di argomento `num`. Il tipo del valore deve corrispondere al tipo dell'argomento, come specificato nella firma del metodo corrente.  
  
 Per le procedure che accettano un elenco di argomenti variabili, il `starg` istruzione può essere utilizzata solo per gli argomenti, non quelle nella variabile parte della firma iniziali fissato.  
  
 Esecuzione di un archivio in argomenti che contengono un valore integer minore di 4 byte tronca il valore durante il passaggio dallo stack per l'argomento. I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata all'argomento.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `starg` opcode:  
  
-   ILGenerator (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Archivia il valore all'inizio dello stack di valutazione nello slot di argomento in corrispondenza di un indice specificato, forma breve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg. s `num`|Estrae il valore dallo stack e lo archivia in uno slot di argomento `num`, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Il valore attualmente all'inizio dello stack viene estratto e inserito in uno slot di argomento `num`.  
  
 Il `starg.s` estrae un valore dallo stack di istruzioni e lo inserisce nello slot di argomento `num`. Il tipo del valore deve corrispondere al tipo dell'argomento, come specificato nella firma del metodo corrente.  
  
 Il `starg.s` istruzione fornisce una codifica efficiente per l'uso con i primi 256 argomenti.  
  
 Per le procedure che accettano un elenco di argomenti variabili, il `starg.s` istruzione può essere utilizzata solo per gli argomenti, non quelle nella variabile parte della firma iniziali fissato.  
  
 Esecuzione di un archivio in argomenti che contengono un valore integer minore di 4 byte tronca il valore durante il passaggio dallo stack per l'argomento. I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata all'argomento.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `starg.s` opcode:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore presente nello stack di valutazione, il cui tipo è specificato nell'istruzione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft intermediate language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|A4 &LT; `T` >|stelem `typeTok`|Sostituisce l'elemento di matrice in corrispondenza dell'indice specificato con un valore di tipo `typeTok` nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a una matrice, oggetto `array`, viene eseguito il push nello stack.  
  
2.  Un valore di indice `index`, a un elemento in `array` viene inserito nello stack.  
  
3.  Un valore del tipo specificato nell'istruzione viene eseguito il push nello stack.  
  
4.  Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.  
  
 Il `stelem` istruzione sostituisce il valore dell'elemento in corrispondenza dell'indice specificato in base zero nella matrice unidimensionale `array` con il valore. Il valore è il tipo specificato dal token `typeTok` all'interno dell'istruzione.  
  
 Le matrici sono oggetti e quindi rappresentato da un valore di tipo `O`. L'indice è di tipo `native int`.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stelem` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="native int" /> sullo stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|9B|stelem.i|Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `native int` valore nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a una matrice, oggetto `array`, viene eseguito il push nello stack.  
  
2.  Un indice valido per un elemento in `array` viene inserito nello stack.  
  
3.  Un valore viene inserito nello stack.  
  
4.  Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.  
  
 Il `stelem.i` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `native int` valore inserito nello stack.  
  
 Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. L'indice è di tipo `native int`.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="int8" /> sullo stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|9C|stelem. i1|Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `int8` valore nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a una matrice, oggetto `array`, viene eseguito il push nello stack.  
  
2.  Un indice valido per un elemento in `array` viene inserito nello stack.  
  
3.  Un valore viene inserito nello stack.  
  
4.  Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.  
  
 Il `stelem.i1` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `int8` valore inserito nello stack.  
  
 Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. L'indice è di tipo `native int`.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="int16" /> sullo stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `int16` valore nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a una matrice, oggetto `array`, viene eseguito il push nello stack.  
  
2.  Un indice valido per un elemento in `array` viene inserito nello stack.  
  
3.  Un valore viene inserito nello stack.  
  
4.  Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.  
  
 Il `stelem.i2` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `int16` valore inserito nello stack.  
  
 Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. L'indice è di tipo `native int`.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="int32" /> sullo stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|9E|stelem. i4|Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `int32` valore nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a una matrice, oggetto `array`, viene eseguito il push nello stack.  
  
2.  Un indice valido per un elemento in `array` viene inserito nello stack.  
  
3.  Un valore viene inserito nello stack.  
  
4.  Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.  
  
 Il `stelem.i4` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `int32` valore inserito nello stack.  
  
 Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. L'indice è di tipo `native int`.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="int64" /> sullo stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|9F|stelem. i8|Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `int64` valore nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a una matrice, oggetto `array`, viene eseguito il push nello stack.  
  
2.  Un indice valido per un elemento in `array` viene inserito nello stack.  
  
3.  Un valore viene inserito nello stack.  
  
4.  Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.  
  
 Il `stelem.i8` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `int64` valore inserito nello stack.  
  
 Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. L'indice è di tipo `native int`.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="float32" /> sullo stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|A0|stelem. r4|Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `float32` valore nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a una matrice, oggetto `array`, viene eseguito il push nello stack.  
  
2.  Un indice valido per un elemento in `array` viene inserito nello stack.  
  
3.  Un valore viene inserito nello stack.  
  
4.  Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.  
  
 Il `stelem.r4` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `float32` valore inserito nello stack.  
  
 Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. L'indice è di tipo `native int`.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="float64" /> sullo stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|A1|stelem. r8|Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `float64` valore nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a una matrice, oggetto `array`, viene eseguito il push nello stack.  
  
2.  Un indice valido per un elemento in `array` viene inserito nello stack.  
  
3.  Un valore viene inserito nello stack.  
  
4.  Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.  
  
 Il `stelem.r8` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `float64` valore inserito nello stack.  
  
 Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. L'indice è di tipo `native int`.  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore di un riferimento a un oggetto (di tipo <see langword="O" />) sullo stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `ref` valore (tipo `O`) nello stack.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento a una matrice, oggetto `array`, viene eseguito il push nello stack.  
  
2.  Un indice valido per un elemento in `array` viene inserito nello stack.  
  
3.  Un valore viene inserito nello stack.  
  
4.  Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.  
  
 Il `stelem.ref` istruzione sostituisce il valore dell'elemento in corrispondenza dell'indice specificato nella matrice unidimensionale `array` con il `ref` (tipo `O`) valore inserito nello stack.  
  
 Le matrici sono gli oggetti e quindi rappresentato da un valore di tipo `O`. L'indice è di tipo `native int`.  
  
 Si noti che `stelem.ref` esegue il cast implicito del valore fornito al tipo di elemento di `array` prima di assegnare il valore all'elemento della matrice. Questa operazione può non riuscire, anche per il codice di verifica. In questo modo il `stelem.ref` possono generare istruzioni <xref:System.InvalidCastException>. Per le matrici unidimensionali che non sono in base zero e per le matrici multidimensionali, il <xref:System.Array> classe fornisce un <xref:System.Array.SetValue%2A> (metodo).  
  
 <xref:System.NullReferenceException> Se viene generata `array` è un riferimento null.  
  
 <xref:System.IndexOutOfRangeException> Se viene generata `index` è negativo o maggiore del limite di `array`.  
  
 <xref:System.ArrayTypeMismatchException> Se viene generata `array` non contiene elementi del tipo richiesto.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce il valore archiviato nel campo di un riferimento a un oggetto o puntatore con un nuovo valore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|Sostituisce il valore di `field` dell'oggetto con un nuovo valore.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto o un puntatore viene inserito nello stack.  
  
2.  Un valore viene inserito nello stack.  
  
3.  Il valore e il riferimento o puntatore all'oggetto vengono estratti dallo stack; il valore di `field` nell'oggetto viene sostituito con il valore fornito.  
  
 Il `stfld` istruzione sostituisce il valore di un campo di un oggetto (tipo `O`) o tramite un puntatore (tipo `native int`, `&`, o `*`) con un determinato valore. `Field` è un token di metadati che fa riferimento a un riferimento al membro di campo. Il `stfld` istruzione può essere un prefisso di uno o entrambi <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException> viene generata se il riferimento all'oggetto o puntatore è un riferimento null e il campo non statico.  
  
 <xref:System.MissingFieldException> Se viene generata `field` non viene trovato nei metadati. Questo in genere viene selezionato quando l'istruzione di Microsoft Intermediate Language (MSIL) viene convertito in codice nativo, non in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stfld` opcode:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Memorizza un valore di tipo <see langword="native int" /> in corrispondenza di un indirizzo fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|DF|stind.i|Archivia un `native int` valore in corrispondenza di un determinato indirizzo.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  Un valore viene inserito nello stack.  
  
3.  Il valore e l'indirizzo sono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.  
  
 Il `stind.i` istruzione archivia una `native int` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).  
  
 Tipo di operazione sicura richiede che il `stind.i` l'istruzione sia utilizzata in modo coerente con il tipo del puntatore. L'operazione dei `stind.i` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> Se viene generata `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Memorizza un valore di tipo <see langword="int8" /> in corrispondenza di un indirizzo fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|52|stind.i1|Archivia un `int8` valore in corrispondenza di un determinato indirizzo.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  Un valore viene inserito nello stack.  
  
3.  Il valore e l'indirizzo sono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.  
  
 Il `stind.i1` archivi istruzione un' `int8` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).  
  
 Tipo di operazione sicura richiede che il `stind.i1` l'istruzione sia utilizzata in modo coerente con il tipo del puntatore. L'operazione dei `stind.i1` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> Se viene generata `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Memorizza un valore di tipo <see langword="int16" /> in corrispondenza di un indirizzo fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|53|stind.i2|Archivia un `int16` valore in corrispondenza di un determinato indirizzo.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  Un valore viene inserito nello stack.  
  
3.  Il valore e l'indirizzo sono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.  
  
 Il `stind.i2` archivi istruzione un' `int16` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).  
  
 Tipo di operazione sicura richiede che il `stind.2i` l'istruzione sia utilizzata in modo coerente con il tipo del puntatore. L'operazione dei `stind.i2` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> Se viene generata `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Memorizza un valore di tipo <see langword="int32" /> in corrispondenza di un indirizzo fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|54|stind.i4|Archivia un `int32` valore in corrispondenza di un determinato indirizzo.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  Un valore viene inserito nello stack.  
  
3.  Il valore e l'indirizzo sono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.  
  
 Il `stind.i4` archivi istruzione un' `int32` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).  
  
 Tipo di operazione sicura richiede che il `stind.i4` l'istruzione sia utilizzata in modo coerente con il tipo del puntatore. L'operazione dei `stind.i4` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> Se viene generata `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Memorizza un valore di tipo <see langword="int64" /> in corrispondenza di un indirizzo fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|55|stind.i8|Archivia un `int64` valore in corrispondenza di un determinato indirizzo.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  Un valore viene inserito nello stack.  
  
3.  Il valore e l'indirizzo sono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.  
  
 Il `stind.i8` archivi istruzione un' `int64` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).  
  
 Tipo di operazione sicura richiede che il `stind.i8` l'istruzione sia utilizzata in modo coerente con il tipo del puntatore. L'operazione dei `stind.i` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> Se viene generata `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Memorizza un valore di tipo <see langword="float32" /> in corrispondenza di un indirizzo fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|56|stind.r4|Archivia un `float32` valore in corrispondenza di un determinato indirizzo.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  Un valore viene inserito nello stack.  
  
3.  Il valore e l'indirizzo sono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.  
  
 Il `stind.r4` istruzione archivia una `float32` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).  
  
 Tipo di operazione sicura richiede che il `stind.r4` l'istruzione sia utilizzata in modo coerente con il tipo del puntatore. L'operazione dei `stind.r4` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> Se viene generata `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Memorizza un valore di tipo <see langword="float64" /> in corrispondenza di un indirizzo fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|57|stind.r8|Archivia un `float64` valore in corrispondenza di un determinato indirizzo.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  Un valore viene inserito nello stack.  
  
3.  Il valore e l'indirizzo sono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.  
  
 Il `stind.r8` istruzione archivia una `float64` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).  
  
 Tipo di operazione sicura richiede che il `stind.r8` l'istruzione sia utilizzata in modo coerente con il tipo del puntatore. L'operazione dei `stind.r8` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> Se viene generata `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Archivia il valore di un riferimento a un oggetto in corrispondenza di un indirizzo fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|51|stind.ref|Archivia un riferimento all'oggetto (tipo `O`) valore di un indirizzo specificato.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  Un valore viene inserito nello stack.  
  
3.  Il valore e l'indirizzo sono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.  
  
 Il `stind.ref` istruzione archivia un valore dell'oggetto di riferimento all'indirizzo fornito (tipo `native int`, `*`, o `&`).  
  
 Tipo di operazione sicura richiede che il `stind.ref` l'istruzione sia utilizzata in modo coerente con il tipo del puntatore. L'operazione dei `stind.ref` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.NullReferenceException> Se viene generata `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza di un indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 0E &LT; `unsigned int16` >|stloc `index`|Estrae un valore dallo stack e lo archivia nella variabile locale `index`.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore è estratto dallo stack e inserito nella variabile locale `index`.  
  
 Il `stloc` istruzione estrae il valore dallo stack di valutazione e lo sposta in numero di variabile locale `index`, in cui le variabili locali sono numerati da 0 e versioni successive. Il tipo del valore deve corrispondere al tipo della variabile locale come specificato nella firma locale del metodo corrente.  
  
 L'archiviazione in variabili locali che contengono un valore integer minore di 4 byte tronca il valore durante il passaggio dallo stack alla variabile locale. I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata all'argomento.  
  
 Corrette istruzioni Microsoft Intermediate Language (MSIL) richiedono che `index` indice locale valido. Per il `stloc` un'istruzione di `index` deve essere compreso nell'intervallo tra 0 e 65.534 compreso (in particolare, 65535 non è valido). Il motivo di 65.535 è pragmatic: le implementazioni probabilmente utilizzeranno un integer a 2 byte per tenere traccia di un indice locale sia, nonché il numero totale di variabili locali per un determinato metodo. Se un indice di 65535 è stato reso valido, è comunque necessario un numero intero più ampio tenere traccia del numero di variabili locali in tale metodo.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possono usare overload del metodo di `stloc` opcode:  
  
-   ILGenerator (OpCode, LocalBuilder)  
  
-   ILGenerator (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|0A|stloc.0|Estrae dallo stack un valore nella variabile locale 0.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore è estratto dallo stack e inserito nella variabile locale indicizzata in base 0.  
  
 Il `stloc.0` istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata in base 0. Il tipo del valore deve corrispondere al tipo della variabile locale come specificato nella firma locale del metodo corrente.  
  
 `stloc.0` è una codifica particolarmente efficace per l'archiviazione dei valori nella variabile locale 0.  
  
 L'archiviazione in variabili locali che contengono un valore integer minore di 4 byte tronca il valore durante il passaggio dallo stack alla variabile locale. I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata all'argomento.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|0B|stloc.1|Estrae dallo stack un valore nella variabile locale 1.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore è estratto dallo stack e inserito nella variabile locale indicizzata in base 1.  
  
 Il `stloc.1` istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata in base 1. Il tipo del valore deve corrispondere al tipo della variabile locale come specificato nella firma locale del metodo corrente.  
  
 `stloc.1` è una codifica particolarmente efficace per l'archiviazione dei valori nella variabile locale 1.  
  
 L'archiviazione in variabili locali che contengono un valore integer minore di 4 byte tronca il valore durante il passaggio dallo stack alla variabile locale. I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata all'argomento.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|0C|stloc.2|Estrae dallo stack un valore nella variabile locale 2|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore è estratto dallo stack e inserito nella variabile locale indicizzata in base 2.  
  
 Il `stloc.2` istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata in base 2. Il tipo del valore deve corrispondere al tipo della variabile locale come specificato nella firma locale del metodo corrente.  
  
 `stloc.2` è una codifica particolarmente efficace per l'archiviazione dei valori nella variabile locale 2.  
  
 L'archiviazione in variabili locali che contengono un valore integer minore di 4 byte tronca il valore durante il passaggio dallo stack alla variabile locale. I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata all'argomento.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|0D|stloc.3|Estrae dallo stack un valore nella variabile locale 3|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore è estratto dallo stack e inserito nella variabile locale indicizzata da 3.  
  
 Il `stloc.3` istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata da 3. Il tipo del valore deve corrispondere al tipo della variabile locale come specificato nella firma locale del metodo corrente.  
  
 `stloc.3` è una codifica particolarmente efficace per l'archiviazione dei valori nella variabile locale 3.  
  
 L'archiviazione in variabili locali che contengono un valore integer minore di 4 byte tronca il valore durante il passaggio dallo stack alla variabile locale. I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata all'argomento.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Estrae il valore corrente dall'inizio dello stack di valutazione e lo memorizza nell'elenco delle variabili in corrispondenza di <paramref name="index" /> (forma breve).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc. s `index`|Estrae un valore dallo stack e lo archivia nella variabile locale `index`, forma breve.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore è estratto dallo stack e inserito nella variabile locale `index`.  
  
 Il `stloc.s` istruzione estrae il valore dallo stack di valutazione e lo sposta in numero di variabile locale `index`, in cui le variabili locali sono numerati da 0 e versioni successive. Il tipo del valore deve corrispondere al tipo della variabile locale come specificato nella firma locale del metodo corrente.  
  
 Il `stloc.s` istruzione fornisce una codifica efficiente per le variabili locali 0 e 255.  
  
 L'archiviazione in variabili locali che contengono un valore integer minore di 4 byte tronca il valore durante il passaggio dallo stack alla variabile locale. I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata all'argomento.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possono usare overload del metodo di `stloc.s` opcode:  
  
-   ILGenerator (OpCode, LocalBuilder)  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia un valore di un tipo specificato dallo stack di valutazione in un indirizzo di memoria fornito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|Archivia un valore di tipo `class` dallo stack nella memoria.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
2.  Un oggetto tipo di valore di tipo `class` viene inserito nello stack.  
  
3.  L'oggetto e l'indirizzo sono estratti dallo stack; l'oggetto di tipo valore viene archiviato in corrispondenza dell'indirizzo.  
  
 Il `stobj` istruzione copia l'oggetto di tipo di valore nell'indirizzo specificato dall'indirizzo (un puntatore di tipo `native int`, `*`, o `&`). Il numero di byte copiati dipende dalle dimensioni della classe rappresentata da `class`, un token di metadati che rappresenta un tipo di valore.  
  
 L'operazione dei `stobj` istruzione può essere modificata da un precede <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.  
  
 <xref:System.TypeLoadException> viene generata se non è stata trovata classe. Ciò in genere viene rilevata quando istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stobj` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sostituisce il valore di un campo statico con un valore dallo stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|Sostituisce il valore in `field` con un valore fornito.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore viene inserito nello stack.  
  
2.  Un valore è estratto dallo stack e archiviato in `field`.  
  
 Il `stsfld` istruzione sostituisce il valore di un campo statico con un valore dallo stack. `field` è un token di metadati che deve fare riferimento a un membro del campo statico.  
  
 Il `stsfld` istruzione può essere preceduta da <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException> viene generata se il campo non viene trovato nei metadati. Ciò in genere viene verificata quando istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `stsfld` opcode:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sottrae un valore da un altro e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|59|sub|Sottrae un valore da un altro, ottenendo un nuovo valore numerico.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value2` viene sottratto da `value1`.  
  
4.  Il risultato viene inserito nello stack.  
  
 Overflow non viene rilevato per operazioni con numeri interi (per gestire l'overflow appropriate, vedere <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Sottrazione di integer esegue il wrapping, anziché una saturazione. Ad esempio: interi a 8 bit, dove `value1` è impostato su 0 e `value2` è impostato su 1, il risultato "wrapping" è 255.  
  
 Restituisce overflow a virgola mobile `+inf` (`PositiveInfinity`) o `-inf` (`NegativeInfinity`).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `sub` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sottrae un valore intero da un altro, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|Sottrae un valore intero da un altro con un controllo dell'overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value2` viene sottratto da `value1` con un controllo dell'overflow.  
  
4.  Il risultato viene inserito nello stack.  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Questa operazione viene eseguita sui valori signed integer; per i valori a virgola mobile, usare <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `sub.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sottrae un valore intero senza segno da un altro, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|Sottrae un valore intero senza segno da un altro con un controllo dell'overflow.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack; `value2` viene sottratto da `value1` con un controllo dell'overflow.  
  
4.  Il risultato viene inserito nello stack.  
  
 <xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.  
  
 Questa operazione viene eseguita sui valori signed integer; per i valori a virgola mobile, usare <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `sub.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementa una tabella di collegamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` >< `int32` >... < `int32` >|switch (`N`, `t1`, `t2`... `tN`)|Passa a uno dei `N` valori.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un valore viene inserito nello stack.  
  
2.  Il valore è estratto dallo stack e l'esecuzione viene trasferita all'istruzione in corrispondenza dell'offset indicizzata con il valore, dove il valore è minore di `N`.  
  
 Il `switch` istruzione implementa una tabella di collegamento. Il formato dell'istruzione è un' `unsigned int32` che rappresenta il numero di destinazioni `N`, seguito da `N` int32 valori che specificano gli obiettivi di passaggio. Queste destinazioni vengono rappresentate come offset (positivo o negativo) dall'inizio dell'istruzione che segue tale `switch` (istruzione).  
  
 Il `switch` estrae un valore dallo stack di istruzioni e messi a confronto, come valore intero senza segno, a `N`. Se il valore è minore di `N`, l'esecuzione viene trasferita nella destinazione indicizzato per valore, in cui le destinazioni sono numerate da 0 (ad esempio, un valore pari a 0 corrisponde alla prima destinazione, un valore pari a 1 ha la seconda destinazione e così via). Se il valore è maggiore o uguale a `N`, l'esecuzione continua con l'istruzione successiva (passaggio).  
  
 Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo il primo di questi prefissi.  
  
 Il controllo viene trasferito in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione. (Tali trasferimenti sono limitati gravi e devono usare invece le istruzioni di uscita).  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `switch` opcode. Il `Label[]` argomento è una matrice di etichette che rappresentano gli offset a 32 bit.  
  
-   ILGenerator (OpCode, Label[])  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo dei `Switch` opcode per generare una tabella di collegamento usando una matrice di <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Esegue un'istruzione di chiamata al metodo con suffisso tale da rimuovere lo stack frame del metodo corrente prima dell'esecuzione dell'istruzione di chiamata effettiva.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 14|della parte finale.|La chiamata successiva termina metodi correnti|  
  
 Non è disponibile alcun comportamento di transizione dello stack definito per questa istruzione.  
  
 Il `tail` istruzione di prefisso deve precedere immediatamente un <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, o <xref:System.Reflection.Emit.OpCodes.Callvirt> (istruzione). Indica che i frame dello stack del metodo corrente deve essere rimosso prima che venga eseguita l'istruzione di chiamata. Implica inoltre che il valore restituito dalla chiamata seguente è anche il valore restituito dal metodo corrente e la chiamata di conseguenza può essere convertita in un passaggio di cross-method.  
  
 Lo stack deve essere vuoto tranne per gli argomenti in fase di trasferimento per la chiamata seguente. Istruzione che segue l'istruzione di chiamata deve essere una ret. È pertanto la sequenza di codice solo valido `tail. call` (o `calli` o `callvirt`). Corrette istruzioni Microsoft Intermediate Language (MSIL) non devono creare rami per il `call` (istruzione), ma può creare rami successivo <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 Il frame corrente non può essere eliminato quando il controllo viene trasferito dal codice non attendibile a codice attendibile, in quanto si comprometterebbe la protezione dell'identità del codice. La sicurezza di .NET Framework controlla è pertanto possibile che il `tail` deve essere ignorata, lasciando standard <xref:System.Reflection.Emit.OpCodes.Call> (istruzione). Analogamente, per poter consentire l'uscita da un'area sincronizzata dopo la chiamata restituisce, il `tail` prefisso viene ignorato se utilizzata per terminare un metodo contrassegnato come sincronizzato.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `tail` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Istanza di un oggetto Opcode.</param>
        <summary>Restituisce true o false se il codice operativo fornito accetta un argomento a byte singolo.</summary>
        <returns>
          <see langword="True" /> o <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere utilizzato per trovare quali codici operativi MSIL vengono "forma abbreviata", per l'uso nel codice ottimizzato.  
  
 `TakesSingleByteArgument` Restituisce `true` se il <xref:System.Reflection.Emit.OpCode> istanza accetta un argomento a byte singolo nei casi seguenti:  
  
-   Il codice operativo esegue un'istruzione branch a un indirizzo di dimensioni dei byte (ad esempio, <xref:System.Reflection.Emit.OpCodes.Br_S> e <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   Il codice operativo inserisce un valore di byte di stack (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   Il codice operativo fa riferimento a una variabile o argomento tramite il byte "forma breve" (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> e <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 In caso contrario restituirà `false`.  
  
 L'esempio seguente viene illustrato l'utilizzo di `TakesSingleByteArgument` tramite il riflesso per il `OpCodes` classe e la verifica per vedere se ogni `OpCode` campo accetta un argomento a byte singolo.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Genera l'oggetto eccezione attualmente nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|7A|throw|Genera un'eccezione.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto (a un'eccezione) viene inserito nello stack.  
  
2.  Il riferimento all'oggetto viene estratto dallo stack e l'eccezione generata.  
  
 Il `throw` istruzione genera l'oggetto eccezione (tipo `O`) attualmente nello stack.  
  
 <xref:System.NullReferenceException> viene generata se il riferimento all'oggetto è un riferimento null.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `throw` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica che un indirizzo attualmente all'inizio dello stack di valutazione potrebbe non essere allineato rispetto alla dimensione standard dell'istruzione <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> o <see langword="cpblk" /> immediatamente successiva.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 12 &LT; `unsigned int8` >|non è allineato. `alignment`|Indica che l'istruzione di puntatore successiva potrebbe essere non allineato.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
 `Unaligned` Specifica che l'indirizzo (un puntatore non gestito `native int`) nello stack potrebbe non essere allineato rispetto alla dimensione standard dell'istruzione immediatamente successiva `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` (istruzione). Vale a dire, per un <xref:System.Reflection.Emit.OpCodes.Ldind_I4> l'allineamento dell'indirizzo potrebbe non essere a un limite di 4 byte (istruzione). Per la `initblk` e `cpblk` l'allineamento predefinito è dipendente dall'architettura (4 byte su processori a 32 bit, a 8 byte in CPU a 64 bit). I generatori di codice che non si limitano l'output a una dimensione parola a 32 bit è necessario usare `unaligned` se l'allineamento non è noto in fase di compilazione a 8 byte.  
  
 Il valore di allineamento deve essere 1, 2 o 4 e indica che il codice generato deve presupporre che l'indirizzo è byte, a byte doppio o quadruplo, rispettivamente. Si noti che temporaneo puntatori (tipo `*`) sono sempre allineati.  
  
 Mentre l'allineamento per un `cpblk` istruzione logicamente richiederebbe due numeri, una per l'origine e uno per la destinazione, non ha alcun impatto apprezzabile sulle prestazioni se solo il numero più basso è specificato.  
  
 Il `unaligned` e `volatile` possono essere combinati in qualsiasi ordine. Devono precedere immediatamente un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` (istruzione). Solo le <xref:System.Reflection.Emit.OpCodes.Volatile> è consentito un prefisso per il <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> istruzioni.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possono usare overload del metodo di `unaligned` opcode:  
  
-   ILGenerator (OpCode, etichetta)  
  
-   ILGenerator (Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte la rappresentazione boxed di un tipo di valore nel relativo formato unboxed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|79 < `T` >|eseguire la conversione unboxing `valType`|Estrae i dati di tipo valore da `obj`, la relativa rappresentazione in forma di tipo boxed.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto viene inserito nello stack.  
  
2.  Il riferimento all'oggetto viene estratto dallo stack e a conversione unboxing a un puntatore di tipo valore.  
  
3.  Il puntatore di tipo valore viene inserito nello stack.  
  
 Un tipo di valore ha due rappresentazioni separate all'interno di Common Language Infrastructure (CLI):  
  
-   Modulo "non elaborato" usato quando un tipo di valore viene incorporato all'interno di un altro oggetto.  
  
-   Un modulo 'boxed', in cui i dati nel tipo di valore viene eseguito il wrapping (boxed) in un oggetto in modo che possano esistere come entità indipendenti.  
  
 Il `unbox` istruzione converte il riferimento all'oggetto (tipo `O`), la rappresentazione boxed di un tipo valore, a un puntatore di tipo valore (un puntatore gestito, tipo `&`), la relativa forma unboxed. Il tipo di valore fornito (`valType`) è un token di metadati che indica il tipo del tipo di valore contenuto all'interno dell'oggetto boxed.  
  
 A differenza <xref:System.Reflection.Emit.OpCodes.Box>, che è necessario per creare una copia di un tipo di valore per l'uso dell'oggetto, `unbox` non è necessario per copiare il tipo di valore dall'oggetto. In genere calcola semplicemente l'indirizzo del tipo di valore che è già presente all'interno dell'oggetto boxed.  
  
 <xref:System.InvalidCastException> viene generata se l'oggetto non viene sottoposto a boxing come `valType`.  
  
 <xref:System.NullReferenceException> viene generata se il riferimento all'oggetto è un riferimento null.  
  
 <xref:System.TypeLoadException> viene generata se il valore di tipo `valType` nebyla nalezena. Ciò in genere viene rilevata quando istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, anziché in fase di esecuzione.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `unbox` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte la rappresentazione boxed di un tipo specificato nell'istruzione nel relativo formato unboxed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft intermediate language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|A5 &LT; `T` >|unbox. Any `typeTok`|Estrarre i dati da `obj`, la relativa rappresentazione in forma di tipo boxed.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un riferimento all'oggetto `obj` viene inserito nello stack.  
  
2.  Il riferimento all'oggetto viene estratto dallo stack e a conversione unboxing nel tipo specificato nell'istruzione.  
  
3.  Il tipo di valore o riferimento oggetto risultante viene inserito nello stack.  
  
 Quando applicato a forma di un tipo di valore boxed il `unbox.any` istruzione estrae il valore racchiuso `obj` (di tipo `O`) ed è pertanto equivalente a `unbox` seguita da `ldobj`.  
  
 Quando applicato a un tipo riferimento, il `unbox.any` istruzione ha lo stesso effetto `castclass` `typeTok`.  
  
 Se l'operando `typeTok` è un parametro di tipo generico, quindi il comportamento di runtime è determinato dal tipo specificato per tale parametro di tipo generico.  
  
 <xref:System.InvalidCastException> Se viene generata `obj` non è un tipo boxed.  
  
 <xref:System.NullReferenceException> Se viene generata `obj` è un riferimento null.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `unbox.any` opcode:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che un indirizzo attualmente all'inizio dello stack di valutazione potrebbe essere volatile e che i risultati della lettura del percorso non possono essere memorizzati nella cache o che non è possibile eliminare archivi multipli in tale percorso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|FE 13|volatile.|Indica che il riferimento al puntatore successivo è volatile.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  Un indirizzo viene inserito nello stack.  
  
 `volatile`. Specifica che l'indirizzo è un indirizzo volatile (vale a dire, è possibile farvi esternamente al thread corrente di esecuzione) e i risultati di lettura che non possa essere memorizzati nella cache di percorso o che non è possibile eliminare archivi multipli in tale posizione. Uso di `volatile` interessa solo accesso in questione; gli altri accessi nello stesso percorso devono essere contrassegnati separatamente. Accesso a percorsi volatile non è necessario eseguire in modo atomico.  
  
 Il <xref:System.Reflection.Emit.OpCodes.Unaligned> e `volatile` possono essere combinati in qualsiasi ordine. Devono precedere immediatamente un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` (istruzione). Solo le `volatile` è consentito un prefisso per il <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> istruzioni.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `volatile` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcola l'operazione XOR bit per bit dei primi due valori dello stack di valutazione, inserendo il risultato nello stack di valutazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nella tabella seguente sono elencate le istruzioni formato esadecimale e Microsoft Intermediate Language (MSIL) assembly, insieme a un breve riepilogo di riferimento:  
  
|Formato|Formato di assembly|Descrizione|  
|------------|---------------------|-----------------|  
|61|xor|Calcola il XOR bit per bit su due valori integer e restituisce un valore integer.|  
  
 Il comportamento di transizione dello stack, in ordine sequenziale, è:  
  
1.  `value1` viene inserito nello stack.  
  
2.  `value2` viene inserito nello stack.  
  
3.  `value2` e `value1` vengono estratti dallo stack e i bit per bit XOR calcolato.  
  
4.  L'operazione XOR `value2` e `value1` viene inserito nello stack.  
  
 Il `xor` istruzione calcola l'operazione XOR dei primi due valori nello stack e lascia il risultato nello stack.  
  
 `Xor` è un'operazione specifica del numero intero.  
  
 Quanto segue <xref:System.Reflection.Emit.ILGenerator.Emit%2A> possibile usare overload del metodo di `xor` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>