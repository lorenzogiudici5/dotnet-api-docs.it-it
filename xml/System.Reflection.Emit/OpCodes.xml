<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a136bc8fb48fe619f1be21928afbfcd9094d7463" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30474585" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="45e2e-101">Fornisce le rappresentazioni dei campi delle istruzioni MSIL (Microsoft Intermediate Language) per la creazione da parte dei membri della classe <see cref="T:System.Reflection.Emit.ILGenerator" />, ad esempio il metodo <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="45e2e-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-102">Per una descrizione dettagliata dei codici operativi membro, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition III: CIL Instruction Set" e "Partition II: metadati definizione e la semantica".</span><span class="sxs-lookup"><span data-stu-id="45e2e-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="45e2e-103">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="45e2e-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45e2e-104">Nell'esempio seguente viene illustrata la costruzione di un metodo dinamico utilizzando <xref:System.Reflection.Emit.ILGenerator> per generare `OpCodes` in un <xref:System.Reflection.Emit.MethodBuilder>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-105">Somma due valori e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-105">Adds two values and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-106">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-107">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-107">Format</span></span>|<span data-ttu-id="45e2e-108">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-108">Assembly Format</span></span>|<span data-ttu-id="45e2e-109">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-110">58</span><span class="sxs-lookup"><span data-stu-id="45e2e-110">58</span></span>|<span data-ttu-id="45e2e-111">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-111">add</span></span>|<span data-ttu-id="45e2e-112">Aggiunge due valori numerici, restituendo un nuovo valore numerico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="45e2e-113">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-114">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-115">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-116">`value2` e `value1` vengono estratti dallo stack; `value1` viene aggiunto a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="45e2e-117">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-118">Overflow non viene rilevato per operazioni su numeri interi (per gestire l'overflow appropriato, vedere <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="45e2e-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="45e2e-119">Aggiunta di integer determina il passaggio al valore iniziale, anziché una saturazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="45e2e-120">Ad esempio, supponendo di valori integer a 8 bit in cui `value1` è impostata su 255 e `value2` è impostato su 1, il risultato sarà 0 anziché 256.</span><span class="sxs-lookup"><span data-stu-id="45e2e-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="45e2e-121">Restituisce un overflow a virgola mobile `+inf` (`PositiveInfinity`) o `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="45e2e-122">Nella tabella seguente sono elencati i tipi di operando accettabili e i tipi di dati corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="45e2e-123">Se è presente alcuna voce per una particolare combinazione di tipi (ad esempio, `int32` e `float`; `int32` e `int64`), è un non valido Microsoft Intermediate Language (MSIL) e genera un errore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="45e2e-124">Operando</span><span class="sxs-lookup"><span data-stu-id="45e2e-124">operand</span></span>|<span data-ttu-id="45e2e-125">tipo di value1</span><span class="sxs-lookup"><span data-stu-id="45e2e-125">value1 type</span></span>|<span data-ttu-id="45e2e-126">tipo di value2</span><span class="sxs-lookup"><span data-stu-id="45e2e-126">value2 type</span></span>|<span data-ttu-id="45e2e-127">Tipo di risultato</span><span class="sxs-lookup"><span data-stu-id="45e2e-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="45e2e-128">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="45e2e-129">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="45e2e-130">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="45e2e-131">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="45e2e-132">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="45e2e-133">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="45e2e-134">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="45e2e-135">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="45e2e-136">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="45e2e-137">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="45e2e-138">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="45e2e-139">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="45e2e-140">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="45e2e-141">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="45e2e-142">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `add` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-143">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-144">Somma due valori interi, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-145">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-146">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-146">Format</span></span>|<span data-ttu-id="45e2e-147">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-147">Assembly Format</span></span>|<span data-ttu-id="45e2e-148">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-149">D6</span><span class="sxs-lookup"><span data-stu-id="45e2e-149">D6</span></span>|<span data-ttu-id="45e2e-150">add.ovf</span><span class="sxs-lookup"><span data-stu-id="45e2e-150">add.ovf</span></span>|<span data-ttu-id="45e2e-151">Aggiunge due valori integer con segno con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="45e2e-152">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-153">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-154">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-155">`value2` e `value1` vengono estratti dallo stack; `value1` viene aggiunto a `value2` con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="45e2e-156">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-157"><xref:System.OverflowException> viene generata se il risultato non è rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-158">È possibile eseguire questa operazione sui valori signed integer.</span><span class="sxs-lookup"><span data-stu-id="45e2e-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="45e2e-159">Per i valori a virgola mobile, usare <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="45e2e-160">Nella tabella seguente sono elencati i tipi di operando accettabili e i tipi di dati corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="45e2e-161">Se è presente alcuna voce per una particolare combinazione di tipi (ad esempio, `int32` e `float`; `int32` e `int64`), è un'istruzione non valida di Microsoft Intermediate Language (MSIL) e genera un errore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="45e2e-162">Operando</span><span class="sxs-lookup"><span data-stu-id="45e2e-162">operand</span></span>|<span data-ttu-id="45e2e-163">tipo di value1</span><span class="sxs-lookup"><span data-stu-id="45e2e-163">value1 type</span></span>|<span data-ttu-id="45e2e-164">tipo di value2</span><span class="sxs-lookup"><span data-stu-id="45e2e-164">value2 type</span></span>|<span data-ttu-id="45e2e-165">Tipo di risultato</span><span class="sxs-lookup"><span data-stu-id="45e2e-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="45e2e-166">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="45e2e-167">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="45e2e-168">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="45e2e-169">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="45e2e-170">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="45e2e-171">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="45e2e-172">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="45e2e-173">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="45e2e-174">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="45e2e-175">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="45e2e-176">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="45e2e-177">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="45e2e-178">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="45e2e-179">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="45e2e-180">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `add.ovf` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-181">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-182">Somma due valori interi senza segno, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-183">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-184">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-184">Format</span></span>|<span data-ttu-id="45e2e-185">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-185">Assembly Format</span></span>|<span data-ttu-id="45e2e-186">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-187">D7</span><span class="sxs-lookup"><span data-stu-id="45e2e-187">D7</span></span>|<span data-ttu-id="45e2e-188">add.ovf.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-188">add.ovf.un</span></span>|<span data-ttu-id="45e2e-189">Aggiunge due valori integer senza segno con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="45e2e-190">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-191">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-192">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-193">`value2` e `value1` vengono estratti dallo stack; `value1` viene aggiunto a `value2` con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="45e2e-194">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-195"><xref:System.OverflowException> viene generata se il risultato non è rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-196">È possibile eseguire questa operazione sui valori signed integer.</span><span class="sxs-lookup"><span data-stu-id="45e2e-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="45e2e-197">Per i valori a virgola mobile, usare <xref:System.Reflection.Emit.OpCodes.Add>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="45e2e-198">Nella tabella seguente sono elencati i tipi di operando accettabili e i tipi di dati corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="45e2e-199">Se è presente alcuna voce per una particolare combinazione di tipi (ad esempio, `int32` e `float`; `int32` e `int64`), è un'istruzione non valida di Microsoft Intermediate Language (MSIL) e genera un errore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="45e2e-200">Operando</span><span class="sxs-lookup"><span data-stu-id="45e2e-200">operand</span></span>|<span data-ttu-id="45e2e-201">tipo di value1</span><span class="sxs-lookup"><span data-stu-id="45e2e-201">value1 type</span></span>|<span data-ttu-id="45e2e-202">tipo di value2</span><span class="sxs-lookup"><span data-stu-id="45e2e-202">value2 type</span></span>|<span data-ttu-id="45e2e-203">Tipo di risultato</span><span class="sxs-lookup"><span data-stu-id="45e2e-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="45e2e-204">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="45e2e-205">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="45e2e-206">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="45e2e-207">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="45e2e-208">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="45e2e-209">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="45e2e-210">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="45e2e-211">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="45e2e-212">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="45e2e-213">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="45e2e-214">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="45e2e-215">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="45e2e-216">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="45e2e-217">aggiunta</span><span class="sxs-lookup"><span data-stu-id="45e2e-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="45e2e-218">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `add.ovf.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-219">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-220">Calcola l'operatore AND bit per bit di due valori e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-221">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-222">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-222">Format</span></span>|<span data-ttu-id="45e2e-223">Istruzione</span><span class="sxs-lookup"><span data-stu-id="45e2e-223">Instruction</span></span>|<span data-ttu-id="45e2e-224">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="45e2e-225">5F</span><span class="sxs-lookup"><span data-stu-id="45e2e-225">5F</span></span>|<span data-ttu-id="45e2e-226">e</span><span class="sxs-lookup"><span data-stu-id="45e2e-226">and</span></span>|<span data-ttu-id="45e2e-227">Determina l'AND bit per bit di due valori integer.</span><span class="sxs-lookup"><span data-stu-id="45e2e-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="45e2e-228">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-229">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-230">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-231">`value1` e `value2` vengono estratti dallo stack; viene calcolato l'AND bit per bit dei due valori.</span><span class="sxs-lookup"><span data-stu-id="45e2e-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="45e2e-232">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-233">Il `and` istruzione calcola l'AND bit per bit dei primi due valori nello stack e lascia il risultato nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-234">`And` è un'operazione specifica del numero intero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="45e2e-235">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `and` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-236">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-237">Restituisce un puntatore non gestito all'elenco di argomenti del metodo corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-237">Returns an unmanaged pointer to the argument list of the current method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-238">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-239">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-239">Format</span></span>|<span data-ttu-id="45e2e-240">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-240">Assembly Format</span></span>|<span data-ttu-id="45e2e-241">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="45e2e-242">FE 00</span></span>|<span data-ttu-id="45e2e-243">arglist</span><span class="sxs-lookup"><span data-stu-id="45e2e-243">arglist</span></span>|<span data-ttu-id="45e2e-244">Restituisce un handle di elenco di argomenti per il metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="45e2e-245">Sullo stack di valutazione viene eseguito da questa operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="45e2e-246">Il `arglist` istruzione restituisce un handle opaco (un puntatore non gestito, di tipo `native int`) che rappresenta l'elenco di argomenti del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="45e2e-247">Questo handle è valido solo per la durata del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="45e2e-248">È tuttavia possibile passare l'handle ad altri metodi, purché sia il metodo corrente del thread di controllo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="45e2e-249">È possibile eseguire solo il `arglist` istruzione all'interno di un metodo che accetta un numero variabile di argomenti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="45e2e-250">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `arglist` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-252">Trasferisce il controllo a un'istruzione di destinazione se due valori sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-252">Transfers control to a target instruction if two values are equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-253">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-254">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-254">Format</span></span>|<span data-ttu-id="45e2e-255">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-255">Assembly Format</span></span>|<span data-ttu-id="45e2e-256">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-257">3B < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-257">3B < `int32` ></span></span>|<span data-ttu-id="45e2e-258">beq `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-258">beq `target`</span></span>|<span data-ttu-id="45e2e-259">Branch all'istruzione di destinazione all'offset `target` se i due valori sono uguali.</span><span class="sxs-lookup"><span data-stu-id="45e2e-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="45e2e-260">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-261">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-262">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-263">`value2` e `value1` vengono estratti dallo stack; se `value1` è uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-264">Il `beq` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è uguale a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="45e2e-265">L'effetto è equivale all'esecuzione di un `ceq` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-266">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-267">I tipi di operando accettabili sono indicati di seguito:</span><span class="sxs-lookup"><span data-stu-id="45e2e-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="45e2e-268">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45e2e-269">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione (tali trasferimenti sono limitati gravi e deve utilizzare il <xref:System.Reflection.Emit.OpCodes.Leave> istruzione alternativa).</span><span class="sxs-lookup"><span data-stu-id="45e2e-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="45e2e-270">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `beq` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-271">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-272">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se due valori sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-272">Transfers control to a target instruction (short form) if two values are equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-273">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-274">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-274">Format</span></span>|<span data-ttu-id="45e2e-275">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-275">Assembly Format</span></span>|<span data-ttu-id="45e2e-276">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-277">2E < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-277">2E < `int8` ></span></span>|<span data-ttu-id="45e2e-278">beq. s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-278">beq.s `target`</span></span>|<span data-ttu-id="45e2e-279">Branch all'istruzione di destinazione all'offset `target` se uguale, forma breve</span><span class="sxs-lookup"><span data-stu-id="45e2e-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="45e2e-280">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-281">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-282">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-283">`value2` e `value1` vengono estratti dallo stack; se `value1` è uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-284">Il `beq.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è uguale a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="45e2e-285">L'effetto è equivale all'esecuzione di un `ceq` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-286">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-287">I tipi di operando accettabili sono indicati di seguito:</span><span class="sxs-lookup"><span data-stu-id="45e2e-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="45e2e-288">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45e2e-289">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione (tali trasferimenti sono limitati gravi e deve utilizzare il <xref:System.Reflection.Emit.OpCodes.Leave> istruzione alternativa).</span><span class="sxs-lookup"><span data-stu-id="45e2e-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="45e2e-290">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `beq.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-291">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-292">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore o uguale al secondo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-293">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-294">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-294">Format</span></span>|<span data-ttu-id="45e2e-295">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-295">Assembly Format</span></span>|<span data-ttu-id="45e2e-296">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-297">3C `<int32>`</span><span class="sxs-lookup"><span data-stu-id="45e2e-297">3C `<int32>`</span></span>|<span data-ttu-id="45e2e-298">bge `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-298">bge `target`</span></span>|<span data-ttu-id="45e2e-299">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore o uguale al secondo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="45e2e-300">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-301">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-302">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-303">`value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore o uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-304">Il `bge` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è maggiore o uguale a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="45e2e-305">L'effetto è identico all'esecuzione di un `clt.un` istruzione seguita da un `brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-306">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-307">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-308">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-309">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bge` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-310">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-311">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore o uguale al secondo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-312">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-313">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-313">Format</span></span>|<span data-ttu-id="45e2e-314">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-314">Assembly Format</span></span>|<span data-ttu-id="45e2e-315">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-316">2F `<int8>`</span><span class="sxs-lookup"><span data-stu-id="45e2e-316">2F `<int8>`</span></span>|<span data-ttu-id="45e2e-317">bge. s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-317">bge.s `target`</span></span>|<span data-ttu-id="45e2e-318">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore o uguale al secondo, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-319">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-320">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-321">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-322">`value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore o uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-323">Il `bge.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è maggiore o uguale a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="45e2e-324">L'effetto è identico all'esecuzione di un `clt.un` istruzione seguita da un `brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-325">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-326">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-327">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-328">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bge.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-329">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-330">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-331">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-332">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-332">Format</span></span>|<span data-ttu-id="45e2e-333">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-333">Assembly Format</span></span>|<span data-ttu-id="45e2e-334">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="45e2e-335">41 `<int32>`</span></span>|<span data-ttu-id="45e2e-336">bge. un `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-336">bge.un `target`</span></span>|<span data-ttu-id="45e2e-337">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore o uguale al secondo (valori senza segno).</span><span class="sxs-lookup"><span data-stu-id="45e2e-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="45e2e-338">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-339">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-340">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-341">`value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore o uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-342">Il `bge.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è maggiore o uguale a `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-343">L'effetto è identico all'esecuzione di un `clt` istruzione seguita da un `brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-344">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-345">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-346">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-347">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bge.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-348">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-349">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-350">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-351">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-351">Format</span></span>|<span data-ttu-id="45e2e-352">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-352">Assembly Format</span></span>|<span data-ttu-id="45e2e-353">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-354">34 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-354">34 < `int8` ></span></span>|<span data-ttu-id="45e2e-355">bge.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-355">bge.un.s `target`</span></span>|<span data-ttu-id="45e2e-356">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore o uguale al secondo (valori senza segno), la forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45e2e-357">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-358">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-359">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-360">`value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore o uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-361">Il `bge.un.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è maggiore o uguale a `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-362">L'effetto è identico all'esecuzione di un `clt` istruzione seguita da un `brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-363">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-364">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-365">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-366">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bge.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-367">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-368">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore del secondo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-368">Transfers control to a target instruction if the first value is greater than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-369">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-370">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-370">Format</span></span>|<span data-ttu-id="45e2e-371">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-371">Assembly Format</span></span>|<span data-ttu-id="45e2e-372">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-373">3D < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-373">3D < `int32` ></span></span>|<span data-ttu-id="45e2e-374">bgt `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-374">bgt `target`</span></span>|<span data-ttu-id="45e2e-375">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore del secondo valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="45e2e-376">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-377">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-378">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-379">`value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore di `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-380">Il `bgt` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è maggiore di `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="45e2e-381">L'effetto è identico all'esecuzione di un `cgt` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-382">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-383">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-384">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-385">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bgt` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-386">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-387">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore del secondo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-388">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-389">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-389">Format</span></span>|<span data-ttu-id="45e2e-390">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-390">Assembly Format</span></span>|<span data-ttu-id="45e2e-391">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-392">30 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-392">30 < `int8` ></span></span>|<span data-ttu-id="45e2e-393">bgt.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-393">bgt.s `target`</span></span>|<span data-ttu-id="45e2e-394">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore del secondo valore, la forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-395">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-396">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-397">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-398">`value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore di `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-399">Il `bgt.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è maggiore di `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="45e2e-400">L'effetto è identico all'esecuzione di un `cgt` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-401">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-402">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-403">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-404">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bgt.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-405">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-406">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-407">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-408">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-408">Format</span></span>|<span data-ttu-id="45e2e-409">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-409">Assembly Format</span></span>|<span data-ttu-id="45e2e-410">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-411">42 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-411">42 < `int32` ></span></span>|<span data-ttu-id="45e2e-412">bgt.un `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-412">bgt.un `target`</span></span>|<span data-ttu-id="45e2e-413">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore del secondo valore (valori senza segno).</span><span class="sxs-lookup"><span data-stu-id="45e2e-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="45e2e-414">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-415">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-416">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-417">`value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore di `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-418">Il `bgt.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è maggiore di `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-419">L'effetto è identico all'esecuzione di un `cgt.un` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-420">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-421">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-422">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-423">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bgt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-424">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-425">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è maggiore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-426">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-427">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-427">Format</span></span>|<span data-ttu-id="45e2e-428">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-428">Assembly Format</span></span>|<span data-ttu-id="45e2e-429">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-430">35 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-430">35 < `int8` ></span></span>|<span data-ttu-id="45e2e-431">bgt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-431">bgt.un.s `target`</span></span>|<span data-ttu-id="45e2e-432">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è maggiore del secondo valore (valori senza segno), la forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45e2e-433">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-434">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-435">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-436">`value2` e `value1` vengono estratti dallo stack; se `value1` è maggiore di `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-437">Il `bgt.un.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è maggiore di `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-438">L'effetto è identico all'esecuzione di un `cgt.un` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-439">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-440">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-441">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-442">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bgt.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-443">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-444">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore o uguale al secondo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-445">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-446">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-446">Format</span></span>|<span data-ttu-id="45e2e-447">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-447">Assembly Format</span></span>|<span data-ttu-id="45e2e-448">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-449">3E `<int32>`</span><span class="sxs-lookup"><span data-stu-id="45e2e-449">3E `<int32>`</span></span>|<span data-ttu-id="45e2e-450">Disattiva `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-450">ble `target`</span></span>|<span data-ttu-id="45e2e-451">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore o uguale al secondo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="45e2e-452">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-453">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-454">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-455">`value2` e `value1` vengono estratti dallo stack; se `value1` è minore o uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-456">Il `ble` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è minore o uguale a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="45e2e-457">L'effetto è identico all'esecuzione di un `cgt` istruzione (`cgt.un` per valori di float) seguita da un `brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-458">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-459">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-460">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-461">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ble` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-462">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-463">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore o uguale al secondo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-464">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-465">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-465">Format</span></span>|<span data-ttu-id="45e2e-466">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-466">Assembly Format</span></span>|<span data-ttu-id="45e2e-467">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="45e2e-468">31 `<int8>`</span></span>|<span data-ttu-id="45e2e-469">ble. s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-469">ble.s `target`</span></span>|<span data-ttu-id="45e2e-470">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore o uguale al secondo, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-471">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-472">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-473">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-474">`value2` e `value1` vengono estratti dallo stack; se `value1` è minore o uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-475">Il `ble.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è minore o uguale a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="45e2e-476">L'effetto è identico all'esecuzione di un `cgt` istruzione (`cgt.un` per valori di float) seguita da un`brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-477">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-478">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-479">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-480">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ble.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-481">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-482">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore o uguale al secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-483">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-484">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-484">Format</span></span>|<span data-ttu-id="45e2e-485">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-485">Assembly Format</span></span>|<span data-ttu-id="45e2e-486">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="45e2e-487">43 `<int32>`</span></span>|<span data-ttu-id="45e2e-488">ble. un `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-488">ble.un `target`</span></span>|<span data-ttu-id="45e2e-489">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore o uguale al secondo (valori senza segno).</span><span class="sxs-lookup"><span data-stu-id="45e2e-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="45e2e-490">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-491">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-492">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-493">`value2` e `value1` vengono estratti dallo stack; se `value1` è minore o uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-494">Il `ble.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è minore o uguale a `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-495">L'effetto è identico all'esecuzione di un `cgt.un` istruzione (`cgt` per valori di float) seguita da un `brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-496">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-497">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-498">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-499">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ble.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-500">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-501">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore o uguale al secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-502">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-503">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-503">Format</span></span>|<span data-ttu-id="45e2e-504">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-504">Assembly Format</span></span>|<span data-ttu-id="45e2e-505">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="45e2e-506">36 `<int8>`</span></span>|<span data-ttu-id="45e2e-507">ble.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-507">ble.un.s `target`</span></span>|<span data-ttu-id="45e2e-508">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore o uguale al secondo (valori senza segno), la forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45e2e-509">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-510">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-511">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-512">`value2` e `value1` vengono estratti dallo stack; se `value1` è minore o uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-513">Il `ble.un.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è minore o uguale a `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-514">L'effetto è identico all'esecuzione di un `cgt.un` istruzione (`cgt` per valori di float) seguita da un `brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-515">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-516">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-517">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-518">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ble.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-519">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-520">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore del secondo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-520">Transfers control to a target instruction if the first value is less than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-521">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-522">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-522">Format</span></span>|<span data-ttu-id="45e2e-523">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-523">Assembly Format</span></span>|<span data-ttu-id="45e2e-524">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-525">3F < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-525">3F < `int32` ></span></span>|<span data-ttu-id="45e2e-526">blt `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-526">blt `target`</span></span>|<span data-ttu-id="45e2e-527">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="45e2e-528">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-529">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-530">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-531">`value2` e `value1` vengono estratti dallo stack; se `value1` è minore di `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-532">Il `blt` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è minore o uguale a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="45e2e-533">L'effetto è identico all'esecuzione di un `clt` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-534">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-535">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-536">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-537">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `blt` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-538">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-539">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore del secondo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-540">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-541">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-541">Format</span></span>|<span data-ttu-id="45e2e-542">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-542">Assembly Format</span></span>|<span data-ttu-id="45e2e-543">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-544">32 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-544">32 < `int8` ></span></span>|<span data-ttu-id="45e2e-545">blt. s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-545">blt.s `target`</span></span>|<span data-ttu-id="45e2e-546">Ramo per l'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-547">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-548">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-549">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-550">`value2` e `value1` vengono estratti dallo stack; se `value1` è minore di `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-551">Il `blt.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è minore di `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="45e2e-552">L'effetto è identico all'esecuzione di un `clt` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-553">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-554">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-555">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-556">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `blt.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-557">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-558">Trasferisce il controllo a un'istruzione di destinazione se il primo valore è minore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-559">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-560">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-560">Format</span></span>|<span data-ttu-id="45e2e-561">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-561">Assembly Format</span></span>|<span data-ttu-id="45e2e-562">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-563">44 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-563">44 < `int32` ></span></span>|<span data-ttu-id="45e2e-564">blt.un `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-564">blt.un `target`</span></span>|<span data-ttu-id="45e2e-565">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo valore (valori senza segno).</span><span class="sxs-lookup"><span data-stu-id="45e2e-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="45e2e-566">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-567">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-568">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-569">`value2` e `value1` vengono estratti dallo stack; se `value1` è minore di `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-570">Il `blt.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è minore di `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-571">L'effetto è identico all'esecuzione di un `clt.un` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-572">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-573">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-574">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-575">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `blt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-576">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-577">Trasferisce il controllo a un'istruzione di destinazione (forma breve) se il primo valore è minore del secondo, durante il confronto di valori interi senza segno o valori float non ordinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-578">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-579">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-579">Format</span></span>|<span data-ttu-id="45e2e-580">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-580">Assembly Format</span></span>|<span data-ttu-id="45e2e-581">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-582">37 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-582">37 < `int8` ></span></span>|<span data-ttu-id="45e2e-583">blt.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-583">blt.un.s `target`</span></span>|<span data-ttu-id="45e2e-584">Branch all'istruzione di destinazione in corrispondenza dell'offset specificato se il primo valore è minore del secondo valore (valori senza segno), la forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45e2e-585">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-586">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-587">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-588">`value2` e `value1` vengono estratti dallo stack; se `value1` è minore di `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-589">Il `blt.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` è minore di `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-590">L'effetto è identico all'esecuzione di un `clt.un` istruzione seguita da un `brtrue` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-591">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-592">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-593">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-594">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `blt.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-595">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-596">Trasferisce il controllo a un'istruzione di destinazione quando due valori interi senza segno o valori float non ordinati non sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-597">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-598">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-598">Format</span></span>|<span data-ttu-id="45e2e-599">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-599">Assembly Format</span></span>|<span data-ttu-id="45e2e-600">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-601">40 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-601">40 < `int32` ></span></span>|<span data-ttu-id="45e2e-602">bne. un `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-602">bne.un `target`</span></span>|<span data-ttu-id="45e2e-603">Ramo di destinazione istruzione in corrispondenza dell'offset specificato, se due valori unsigned integer non sono uguali (valori senza segno).</span><span class="sxs-lookup"><span data-stu-id="45e2e-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="45e2e-604">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-605">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-606">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-607">`value2` e `value1` vengono estratti dallo stack; se `value1` non è uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-608">Il `bne.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` non è uguale a `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-609">L'effetto è identico all'esecuzione di un `ceq` istruzione seguita da un `brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-610">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-611">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-612">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-613">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bne.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-614">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-615">Trasferisce il controllo a un'istruzione di destinazione (forma breve) quando due valori interi senza segno o valori float non ordinati non sono uguali.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-616">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-617">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-617">Format</span></span>|<span data-ttu-id="45e2e-618">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-618">Assembly Format</span></span>|<span data-ttu-id="45e2e-619">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-620">33 < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-620">33 < `int8` ></span></span>|<span data-ttu-id="45e2e-621">bne.un.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-621">bne.un.s `target`</span></span>|<span data-ttu-id="45e2e-622">Ramo di destinazione dell'istruzione in corrispondenza dell'offset specificato, se due valori unsigned integer non sono uguali (valori senza segno), forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45e2e-623">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-624">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-625">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-626">`value2` e `value1` vengono estratti dallo stack; se `value1` non è uguale a `value2`, viene eseguita l'operazione di diramazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45e2e-627">Il `bne.un` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value1` non è uguale a `value2`, se confrontata mediante l'intero senza segno o valori float non ordinati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45e2e-628">L'effetto è identico all'esecuzione di un `ceq` istruzione seguita da un `brfalse` ramo all'istruzione di destinazione specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45e2e-629">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-630">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-631">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-632">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `bne.un.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-633">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-634">Converte un tipo di valore in un riferimento a un oggetto di tipo <see langword="O" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-634">Converts a value type to an object reference (type <see langword="O" />).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-635">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-636">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-636">Format</span></span>|<span data-ttu-id="45e2e-637">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-637">Assembly Format</span></span>|<span data-ttu-id="45e2e-638">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-639">8C < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-639">8C < `T` ></span></span>|<span data-ttu-id="45e2e-640">box `valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="45e2e-640">box `valTypeToken`</span></span>|<span data-ttu-id="45e2e-641">Convertire un tipo di valore (del tipo specificato `valTypeToken`) a un oggetto true.</span><span class="sxs-lookup"><span data-stu-id="45e2e-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="45e2e-642">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-643">Un tipo di valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-644">Il tipo di valore viene estratto dallo stack; il `box` viene eseguita l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="45e2e-645">Un riferimento all'oggetto per il tipo di valore "boxed" risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-646">Un tipo di valore dispone di due rappresentazioni separate all'interno di Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="45e2e-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="45e2e-647">'Non elaborato' modulo quando un tipo di valore incorporato all'interno di un altro oggetto o nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="45e2e-648">Un modulo 'boxed', in cui i dati nel tipo di valore viene inseriti (boxed) in un oggetto affinché possano esistere come entità indipendenti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="45e2e-649">Il `box` istruzione converte il tipo 'non elaborati' valore unboxed in un riferimento all'oggetto (tipo `O`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="45e2e-650">Questa operazione viene eseguita creando un nuovo oggetto e copiando i dati dal tipo di valore nell'oggetto appena allocato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="45e2e-651">`valTypeToken` è un token di metadati che indica il tipo del tipo di valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-652"><xref:System.OutOfMemoryException> viene generata se la memoria è insufficiente per soddisfare la richiesta.</span><span class="sxs-lookup"><span data-stu-id="45e2e-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="45e2e-653"><xref:System.TypeLoadException> viene generata se la classe non può essere trovata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="45e2e-654">In genere, questo viene rilevato quando Microsoft Intermediate Language (MSIL) viene convertito in codice nativo, anziché in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-655">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `box` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-656">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-657">Trasferisce il controllo a un'istruzione di destinazione in modo incondizionato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-657">Unconditionally transfers control to a target instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-658">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-659">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-659">Format</span></span>|<span data-ttu-id="45e2e-660">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-660">Assembly Format</span></span>|<span data-ttu-id="45e2e-661">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-662">38 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-662">38 < `int32` ></span></span>|<span data-ttu-id="45e2e-663">Brasile `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-663">br `target`</span></span>|<span data-ttu-id="45e2e-664">Rami di un'istruzione di destinazione in corrispondenza dell'offset specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="45e2e-665">Sullo stack di valutazione viene eseguito da questa operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="45e2e-666">Il `br` istruzione trasferisce il controllo a un'istruzione di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="45e2e-667">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-668">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-669">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-670">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `br` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-671">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-672">Trasferisce il controllo a un'istruzione di destinazione in modo incondizionato (forma breve).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-672">Unconditionally transfers control to a target instruction (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-673">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-674">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-674">Format</span></span>|<span data-ttu-id="45e2e-675">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-675">Assembly Format</span></span>|<span data-ttu-id="45e2e-676">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-677">2B < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-677">2B < `int8` ></span></span>|<span data-ttu-id="45e2e-678">br.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-678">br.s `target`</span></span>|<span data-ttu-id="45e2e-679">Rami di un'istruzione di destinazione in corrispondenza dell'offset specificato, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-680">Sullo stack di valutazione viene eseguito da questa operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="45e2e-681">Il `br.s` istruzione trasferisce il controllo a un'istruzione di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="45e2e-682">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-683">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-684">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-685">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `br.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-686">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-687">Segnala a Common Language Infrastructure (CLI) di indicare al debugger che è stato raggiunto un punto di interruzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-688">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-689">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-689">Format</span></span>|<span data-ttu-id="45e2e-690">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-690">Assembly Format</span></span>|<span data-ttu-id="45e2e-691">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-692">01</span><span class="sxs-lookup"><span data-stu-id="45e2e-692">01</span></span>|<span data-ttu-id="45e2e-693">break</span><span class="sxs-lookup"><span data-stu-id="45e2e-693">break</span></span>|<span data-ttu-id="45e2e-694">indica al debugger che è stato raggiunto un punto di interruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="45e2e-695">Sullo stack di valutazione viene eseguito da questa operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="45e2e-696">Il `break` l'istruzione è in fase di debug.</span><span class="sxs-lookup"><span data-stu-id="45e2e-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="45e2e-697">Segnala l'interfaccia CLI di indicare al debugger che è stato raggiunto un punto di interruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="45e2e-698">Non ha alcun altro effetto sullo stato dell'interprete.</span><span class="sxs-lookup"><span data-stu-id="45e2e-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="45e2e-699">Il `break` istruzione è il più piccolo possibile un'istruzione dimensioni l'applicazione di patch con un punto di interruzione e la generazione di interferire con il codice circostante.</span><span class="sxs-lookup"><span data-stu-id="45e2e-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="45e2e-700">Il `break` istruzione può intercettare a un debugger, non eseguire alcuna operazione o generare un'eccezione di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="45e2e-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="45e2e-701">Il comportamento esatto è definito dall'implementazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="45e2e-702">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `break` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-703">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-704">Trasferisce il controllo a un'istruzione di destinazione se <paramref name="value" /> è <see langword="false" />, un riferimento null (<see langword="Nothing" /> in Visual Basic) oppure zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-705">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-706">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-706">Format</span></span>|<span data-ttu-id="45e2e-707">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-707">Assembly Format</span></span>|<span data-ttu-id="45e2e-708">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-709">39 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-709">39 < `int32` ></span></span>|<span data-ttu-id="45e2e-710">brfalse `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="45e2e-711">rispettivi brnull `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="45e2e-712">brzero `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-712">brzero `target`</span></span>|<span data-ttu-id="45e2e-713">Esegue la diramazione in un'istruzione di destinazione in corrispondenza dell'offset specificato se `false`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="45e2e-714">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-715">`value` viene inserito nello stack da un'operazione precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="45e2e-716">`value` viene estratto dallo stack; Se `value` è `false`, creare un ramo a `target`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="45e2e-717">Il `brfalse` istruzione (e i rispettivi alias `brnull` e `brzero`) trasferisce il controllo all'istruzione di destinazione specificato se `value` (di tipo `int32`, `int64`, il riferimento all'oggetto `O`gestita puntatore `&`, puntatore temporaneo `*`, `native int`) è uguale a zero (`false`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="45e2e-718">Se `value` è diverso da zero (`true`) l'esecuzione continua con l'istruzione successiva.</span><span class="sxs-lookup"><span data-stu-id="45e2e-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="45e2e-719">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-720">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-721">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-722">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `brfalse` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-723">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-724">Trasferisce il controllo a un'istruzione di destinazione se <paramref name="value" /> è <see langword="false" />, un riferimento null oppure zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-725">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-726">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-726">Format</span></span>|<span data-ttu-id="45e2e-727">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-727">Assembly Format</span></span>|<span data-ttu-id="45e2e-728">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-729">2C <`int8` ></span></span>|<span data-ttu-id="45e2e-730">brfalse. s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="45e2e-731">brnull.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="45e2e-732">brzero.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-732">brzero.s `target`</span></span>|<span data-ttu-id="45e2e-733">Esegue la diramazione in un'istruzione di destinazione in corrispondenza dell'offset specificato se `false`, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-734">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-735">`value` viene inserito nello stack da un'operazione precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="45e2e-736">`value` viene estratto dallo stack; Se `value` è `false`, creare un ramo a `target`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="45e2e-737">Il `brfalse.s` istruzione (e i rispettivi alias `brnull` e `brzero`) trasferisce il controllo all'istruzione di destinazione specificato se `value` (di tipo `int32`, `int64`, il riferimento all'oggetto `O`gestita puntatore `&`, puntatore temporaneo `*`, `native int`) è uguale a zero (`false`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="45e2e-738">Se `value` è diverso da zero (`true`) l'esecuzione continua con l'istruzione successiva.</span><span class="sxs-lookup"><span data-stu-id="45e2e-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="45e2e-739">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-740">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-741">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-742">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `brfalse.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-743">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-744">Trasferisce il controllo a un'istruzione di destinazione se <paramref name="value" /> è <see langword="true" />, diverso da null o da zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-745">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-746">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-746">Format</span></span>|<span data-ttu-id="45e2e-747">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-747">Assembly Format</span></span>|<span data-ttu-id="45e2e-748">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-749">3A < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-749">3A < `int32` ></span></span>|<span data-ttu-id="45e2e-750">brtrue `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="45e2e-751">brinst, che rappresenta `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-751">brinst `target`</span></span>|<span data-ttu-id="45e2e-752">Ramo in un'istruzione di destinazione in corrispondenza dell'offset specificato, se diverso da zero (`true`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="45e2e-753">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-754">`value` viene inserito nello stack da un'operazione precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="45e2e-755">`value` viene estratto dallo stack; Se `value` è `true`, creare un ramo a `target`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="45e2e-756">Il `brtrue` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value` (tipo `native int`) è diverso da zero (`true`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="45e2e-757">Se `value` è zero (`false`) l'esecuzione continua con l'istruzione successiva.</span><span class="sxs-lookup"><span data-stu-id="45e2e-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="45e2e-758">Se `value` è un riferimento all'oggetto (tipo `O`) quindi `brinst` (un alias per `brtrue`) trasferisce il controllo se rappresenta un'istanza di un oggetto (ad esempio, se non è il riferimento di oggetto null; vedere <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="45e2e-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="45e2e-759">L'istruzione di destinazione è rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-760">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-761">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-762">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `brtrue` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-763">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-764">Trasferisce il controllo a un'istruzione di destinazione (forma breve), se <paramref name="value" /> è <see langword="true" />, diverso da null oppure diverso da zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-765">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-766">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-766">Format</span></span>|<span data-ttu-id="45e2e-767">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-767">Assembly Format</span></span>|<span data-ttu-id="45e2e-768">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-769">2D < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-769">2D < `int8` ></span></span>|<span data-ttu-id="45e2e-770">brtrue.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="45e2e-771">brinst.s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-771">brinst.s `target`</span></span>|<span data-ttu-id="45e2e-772">Ramo in un'istruzione di destinazione in corrispondenza dell'offset specificato, se diverso da zero (`true`), forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="45e2e-773">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-774">`value` viene inserito nello stack da un'operazione precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="45e2e-775">`value` viene estratto dallo stack; Se `value` è `true`, creare un ramo a `target`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="45e2e-776">Il `brtrue.s` istruzione trasferisce il controllo all'istruzione di destinazione specificato se `value` (tipo `native int`) è diverso da zero (`true`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="45e2e-777">Se `value` è zero (`false`) l'esecuzione continua con l'istruzione successiva.</span><span class="sxs-lookup"><span data-stu-id="45e2e-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="45e2e-778">Se `value` è un riferimento all'oggetto (tipo `O`) quindi `brinst` (un alias per `brtrue`) trasferisce il controllo se rappresenta un'istanza di un oggetto (ad esempio, se non è il riferimento di oggetto null; vedere <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span><span class="sxs-lookup"><span data-stu-id="45e2e-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="45e2e-779">L'istruzione di destinazione è rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-780">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45e2e-781">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-782">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `brtrue.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-783">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-784">Chiama il metodo indicato dal descrittore di metodo passato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-784">Calls the method indicated by the passed method descriptor.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-785">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-786">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-786">Format</span></span>|<span data-ttu-id="45e2e-787">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-787">Assembly Format</span></span>|<span data-ttu-id="45e2e-788">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-789">28 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-789">28 < `T` ></span></span>|<span data-ttu-id="45e2e-790">Chiamata `methodDesc`</span><span class="sxs-lookup"><span data-stu-id="45e2e-790">call `methodDesc`</span></span>|<span data-ttu-id="45e2e-791">Chiamare il metodo descritto da `methodDesc`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="45e2e-792">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-793">Gli argomenti del metodo `arg1` tramite `argN` vengono inseriti nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-794">Gli argomenti del metodo `arg1` tramite `argN` vengono estratti dallo stack; viene eseguita la chiamata al metodo con questi argomenti e il controllo viene trasferito al metodo a cui fa riferimento il descrittore del metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="45e2e-795">Al termine, un valore restituito è generato dal metodo chiamato e inviato al chiamante.</span><span class="sxs-lookup"><span data-stu-id="45e2e-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="45e2e-796">Il valore restituito viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-797">Il `call` istruzione chiama il metodo indicato dal descrittore di metodo passato con l'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="45e2e-798">Descrittore del metodo è un token di metadati che indica il metodo da chiamare e il numero, tipo e ordine degli argomenti che sono stati inseriti nello stack deve essere passato al metodo, nonché la convenzione di chiamata da utilizzare.</span><span class="sxs-lookup"><span data-stu-id="45e2e-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="45e2e-799">Il `call` istruzione può essere immediatamente preceduto da un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) per specificare che lo stato del metodo corrente deve essere rilasciata prima di trasferire il controllo del prefisso.</span><span class="sxs-lookup"><span data-stu-id="45e2e-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="45e2e-800">Se la chiamata trasferisce il controllo a un metodo di attendibilità superiore rispetto al metodo di origine, lo stack frame non viene rilasciato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="45e2e-801">Al contrario, l'esecuzione continua automaticamente come se il `tail` non è stato specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="45e2e-802">Il token di metadati contiene informazioni sufficienti per determinare se la chiamata di un metodo statico, un metodo di istanza, un metodo virtuale o una funzione globale.</span><span class="sxs-lookup"><span data-stu-id="45e2e-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="45e2e-803">In tutti questi casi l'indirizzo di destinazione viene determinato interamente dal descrittore del metodo (confrontare questa operazione con il <xref:System.Reflection.Emit.OpCodes.Callvirt> istruzione per la chiamata di metodi virtuali, in cui l'indirizzo di destinazione dipende inoltre dal tipo di runtime dell'istanza riferimento inserito prima di <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span><span class="sxs-lookup"><span data-stu-id="45e2e-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="45e2e-804">Gli argomenti vengono inseriti nello stack in ordine da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="45e2e-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="45e2e-805">Il primo argomento, viene calcolato e inserito in stack, quindi il secondo argomento e il terzo, fino a quando non sono tutti gli argomenti necessari sopra lo stack in ordine decrescente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="45e2e-806">Esistono tre importanti casi speciali:</span><span class="sxs-lookup"><span data-stu-id="45e2e-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="45e2e-807">Le chiamate a un'istanza (o virtuali) metodo deve inserire il riferimento all'istanza prima di qualsiasi argomento visibile all'utente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="45e2e-808">Il riferimento all'istanza non deve essere un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="45e2e-809">La firma contenuta nei metadati non contiene una voce nell'elenco di parametri per il `this` puntatore; utilizza invece un bit per indicare se il metodo richiede il passaggio di `this` puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="45e2e-810">È possibile chiamare un metodo virtuale utilizzando `call` (anziché `callvirt`); ciò indica che il metodo deve essere risolto utilizzando la classe specificata dal metodo, piuttosto che come specificato in modo dinamico dall'oggetto richiamato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="45e2e-811">Si noti che un delegato `Invoke` metodo può essere chiamato con il `call` o `callvirt` (istruzione).</span><span class="sxs-lookup"><span data-stu-id="45e2e-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="45e2e-812"><xref:System.Security.SecurityException> può essere generata se la protezione del sistema non concede al chiamante di accedere al metodo chiamato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="45e2e-813">Il controllo di sicurezza può verificarsi quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45e2e-814">Quando si chiamano metodi System. Object sui tipi di valore, è consigliabile utilizzare il `constrained` Anteponi il `callvirt` istruzione invece di generare un `call` istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="45e2e-815">Questo elimina la necessità di generare un IL diverso a seconda se il tipo di valore esegue l'override del metodo, evitare un potenziale problema di controllo delle versioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="45e2e-816">È consigliabile utilizzare il `constrained` prefisso quando si chiamano metodi di interfaccia sui tipi di valore, poiché il metodo con tipo di valore che implementa il metodo di interfaccia può essere modificato utilizzando un `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="45e2e-817">Questi problemi sono descritti più dettagliatamente il <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span><span class="sxs-lookup"><span data-stu-id="45e2e-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="45e2e-818">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload è possibile utilizzare il `call` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-819">ILGenerator (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="45e2e-820">ILGenerator.EmitCall (OpCode, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="45e2e-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45e2e-821">Il <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> metodo è fornito per `varargs` chiamate.</span><span class="sxs-lookup"><span data-stu-id="45e2e-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="45e2e-822">Utilizzare il <xref:System.Reflection.Emit.ILGenerator.Emit%2A> metodo per le chiamate normali.</span><span class="sxs-lookup"><span data-stu-id="45e2e-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-823">Chiama il metodo indicato nello stack di valutazione, come un puntatore a un punto di ingresso, con gli argomenti descritti da una convenzione di chiamata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-824">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-825">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-825">Format</span></span>|<span data-ttu-id="45e2e-826">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-826">Assembly Format</span></span>|<span data-ttu-id="45e2e-827">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-828">29 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-828">29 < `T` ></span></span>|<span data-ttu-id="45e2e-829">calli `callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="45e2e-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="45e2e-830">Chiama il metodo a cui puntato con gli argomenti descritti dalla convenzione di chiamata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="45e2e-831">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-832">Gli argomenti del metodo `arg1` tramite `argN` vengono inseriti nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-833">Il puntatore di ingresso del metodo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-834">Gli argomenti del metodo `arg1` tramite `argN` e il puntatore di ingresso del metodo vengono estratti dallo stack; viene eseguita la chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="45e2e-835">Al termine, un valore restituito è generato dal metodo chiamato e inviato al chiamante.</span><span class="sxs-lookup"><span data-stu-id="45e2e-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="45e2e-836">Il valore restituito viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-837">Il `calli` istruzione chiama il puntatore di ingresso del metodo con gli argomenti `arg1` tramite `argN`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="45e2e-838">I tipi di questi argomenti sono descritti dalla convenzione di chiamata specifica (`callSiteDesc`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="45e2e-839">Il `calli` istruzione può essere immediatamente preceduto da un `tail` prefisso (<xref:System.Reflection.Emit.OpCodes.Tailcall>) per specificare che lo stato del metodo corrente deve essere rilasciata prima di trasferire il controllo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="45e2e-840">Se la chiamata trasferisce il controllo a un metodo di attendibilità superiore rispetto al metodo di origine, lo stack frame non essere rilasciato. al contrario, l'esecuzione continua automaticamente come se il `tail` non è stato specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="45e2e-841">Si presuppone che il puntatore di ingresso del metodo specifico puntatore a codice nativo (il computer di destinazione) che può essere chiamato in modo legittimo con gli argomenti descritti dalla convenzione di chiamata (un token di metadati per una firma autonoma).</span><span class="sxs-lookup"><span data-stu-id="45e2e-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="45e2e-842">Tale puntatore può essere creata usando il <xref:System.Reflection.Emit.OpCodes.Ldftn> o <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> istruzioni, oppure passato dal codice nativo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="45e2e-843">La convenzione di chiamata non è selezionata in modo dinamico, pertanto il codice che utilizza un `calli` istruzione non funziona correttamente se la destinazione non utilizza effettivamente la convenzione di chiamata specificati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="45e2e-844">Gli argomenti vengono inseriti nello stack in ordine da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="45e2e-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="45e2e-845">Il primo argomento, viene calcolato e inserito in stack, quindi il secondo argomento e il terzo, fino a quando non sono tutti gli argomenti necessari sopra lo stack in ordine decrescente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="45e2e-846">La sequenza di codice di compilazione di un argomento per un'istanza o un metodo virtuale deve inserire il riferimento all'istanza (che non deve essere un riferimento null) prima di qualsiasi argomento visibile all'utente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="45e2e-847"><xref:System.Security.SecurityException> può essere generata se la protezione del sistema non concede al chiamante di accedere al metodo chiamato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="45e2e-848">Il controllo di sicurezza può verificarsi quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-849">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> metodi possono essere utilizzati per eseguire un `calli` istruzione nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="45e2e-850">Si noti che `calli` deve essere chiamato tramite i metodi che seguono anziché utilizzando il <xref:System.Reflection.Emit.ILGenerator.Emit%2A> classe per collocare l'istruzione direttamente sullo stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="45e2e-851">ILGenerator. EmitCalli (Opcode, CallingConventions, Type, Type [], Type[]) per chiamate che utilizzano una convenzione di chiamata gestita.</span><span class="sxs-lookup"><span data-stu-id="45e2e-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="45e2e-852">ILGenerator. EmitCalli (Opcode, CallingConvention, Type, Type[]) per chiamate che utilizzano una convenzione di chiamata non gestita.</span><span class="sxs-lookup"><span data-stu-id="45e2e-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-853">Chiama un metodo ad associazione tardiva su un oggetto, inserendo il valore restituito nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-854">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-855">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-855">Format</span></span>|<span data-ttu-id="45e2e-856">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-856">Assembly Format</span></span>|<span data-ttu-id="45e2e-857">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-858">6F < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-858">6F < `T` ></span></span>|<span data-ttu-id="45e2e-859">callvirt `method`</span><span class="sxs-lookup"><span data-stu-id="45e2e-859">callvirt `method`</span></span>|<span data-ttu-id="45e2e-860">Chiama un metodo specifico associato `obj`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="45e2e-861">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-862">Un riferimento all'oggetto `obj` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-863">Gli argomenti del metodo `arg1` tramite `argN` vengono inseriti nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-864">Gli argomenti del metodo `arg1` tramite `argN` e il riferimento all'oggetto `obj` vengono estratti dallo stack; viene eseguita la chiamata al metodo con questi argomenti e il controllo viene trasferito al metodo nel `obj` a cui fa riferimento il metodo token di metadati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="45e2e-865">Al termine, un valore restituito è generato dal metodo chiamato e inviato al chiamante.</span><span class="sxs-lookup"><span data-stu-id="45e2e-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="45e2e-866">Il valore restituito viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-867">Il `callvirt` istruzione chiama un metodo ad associazione tardiva su un oggetto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="45e2e-868">Ovvero, il metodo viene scelto in base al tipo di runtime di `obj` anziché la classe in fase di compilazione visibile nel puntatore al metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="45e2e-869">`Callvirt` Consente di chiamare entrambe virtuale metodi di istanza.</span><span class="sxs-lookup"><span data-stu-id="45e2e-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="45e2e-870">Il `callvirt` istruzione può essere immediatamente preceduto da un `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) per specificare che lo stack frame corrente deve essere rilasciato prima di trasferire il controllo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="45e2e-871">Se la chiamata trasferisce il controllo a un metodo di attendibilità superiore rispetto al metodo originale, lo stack frame non essere rilasciato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="45e2e-872">Il token di metadati del metodo fornisce il nome, una classe e firma del metodo da chiamare.</span><span class="sxs-lookup"><span data-stu-id="45e2e-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="45e2e-873">La classe associata `obj` è la classe di cui è un'istanza.</span><span class="sxs-lookup"><span data-stu-id="45e2e-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="45e2e-874">Se la classe definisce un metodo non statico che corrisponde al nome del metodo indicato e firma, questo metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="45e2e-875">In caso contrario, tutte le classi nella catena di classe di base di questa classe vengono controllate nell'ordine.</span><span class="sxs-lookup"><span data-stu-id="45e2e-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="45e2e-876">È un errore se non è stato trovato alcun metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="45e2e-877">`Callvirt` estrae l'oggetto e gli argomenti associati dallo stack di valutazione prima di chiamare il metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="45e2e-878">Se il metodo ha un valore restituito, viene inserito nello stack al completamento del metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="45e2e-879">Sul lato del chiamato, il `obj` parametro avviene come argomento 0, `arg1` come argomento 1 e così via.</span><span class="sxs-lookup"><span data-stu-id="45e2e-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="45e2e-880">Gli argomenti vengono inseriti nello stack in ordine da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="45e2e-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="45e2e-881">Il primo argomento, viene calcolato e inserito in stack, quindi il secondo argomento e il terzo, fino a quando non sono tutti gli argomenti necessari sopra lo stack in ordine decrescente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="45e2e-882">Il riferimento all'istanza `obj` (sempre necessario per `callvirt`) deve essere inserito prima di qualsiasi argomento visibile all'utente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="45e2e-883">La firma (contenuta nel token di metadati) non debba contenere una voce nell'elenco di parametri per questa puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="45e2e-884">Si noti che un metodo virtuale può essere chiamato anche utilizzando la <xref:System.Reflection.Emit.OpCodes.Call> istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="45e2e-885"><xref:System.MissingMethodException> viene generata un'eccezione se non è stato possibile trovare un metodo non statico con il nome specificato e la firma nella classe associata a `obj` o le relative classi base.</span><span class="sxs-lookup"><span data-stu-id="45e2e-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="45e2e-886">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, anziché in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-887"><xref:System.NullReferenceException> viene generata se obj è null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="45e2e-888"><xref:System.Security.SecurityException> viene generata se la protezione del sistema non concede al chiamante di accedere al metodo chiamato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="45e2e-889">Il controllo di sicurezza può verificarsi quando il codice CIL viene convertito in codice nativo piuttosto che in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45e2e-890">Quando si chiamano metodi System. Object sui tipi di valore, è consigliabile utilizzare il `constrained` Anteponi il `callvirt` istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="45e2e-891">Questo elimina la necessità di generare un IL diverso a seconda se il tipo di valore esegue l'override del metodo, evitare un potenziale problema di controllo delle versioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="45e2e-892">È consigliabile utilizzare il `constrained` prefisso quando si chiamano metodi di interfaccia sui tipi di valore, poiché il metodo con tipo di valore che implementa il metodo di interfaccia può essere modificato utilizzando un `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="45e2e-893">Questi problemi sono descritti più dettagliatamente il <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span><span class="sxs-lookup"><span data-stu-id="45e2e-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="45e2e-894">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `callvirt` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-895">ILGenerator (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="45e2e-896">ILGenerator.EmitCall (OpCode, MethodInfo, Type[])</span><span class="sxs-lookup"><span data-stu-id="45e2e-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-897">Tenta di eseguire il cast di un oggetto passato per riferimento alla classe specificata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-897">Attempts to cast an object passed by reference to the specified class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-898">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-899">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-899">Format</span></span>|<span data-ttu-id="45e2e-900">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-900">Assembly Format</span></span>|<span data-ttu-id="45e2e-901">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-902">74 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-902">74 < `T` ></span></span>|<span data-ttu-id="45e2e-903">castclass `class`</span><span class="sxs-lookup"><span data-stu-id="45e2e-903">castclass `class`</span></span>|<span data-ttu-id="45e2e-904">Esegue il cast di un oggetto in un nuovo oggetto di tipo `class`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="45e2e-905">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-906">Riferimento a un oggetto viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-907">Il riferimento all'oggetto viene estratto dallo stack; l'oggetto di riferimento viene eseguito il cast dell'oggetto specificato `class`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="45e2e-908">In caso contrario, nuovo riferimento a un oggetto viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-909">Il `castclass` istruzione tenta di eseguire il cast il riferimento all'oggetto (tipo `O`) nella parte superiore dello stack di in una classe specificata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="45e2e-910">La nuova classe viene specificata un token di metadati che indica la classe desiderata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="45e2e-911">Se la classe dell'oggetto all'inizio dello stack non implementa la nuova classe (presupponendo che la nuova classe è un'interfaccia) e non è una classe derivata della nuova classe di un oggetto <xref:System.InvalidCastException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="45e2e-912">Se il riferimento all'oggetto è un riferimento null, `castclass` ha esito positivo e restituisce il nuovo oggetto come un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-913"><xref:System.InvalidCastException> viene generata se obj non è possibile eseguire il cast alla classe.</span><span class="sxs-lookup"><span data-stu-id="45e2e-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="45e2e-914"><xref:System.TypeLoadException> viene generata se non è possibile trovare la classe.</span><span class="sxs-lookup"><span data-stu-id="45e2e-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="45e2e-915">In genere, questo viene rilevato quando un'istruzione di Microsoft Intermediate Language (MSIL) viene convertita in codice nativo piuttosto che in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-915">This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-916">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `castclass` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-917">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-918">Confronta due valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-918">Compares two values.</span>
          </span>
          <span data-ttu-id="45e2e-919">Se tali valori sono uguali, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-920">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-921">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-921">Format</span></span>|<span data-ttu-id="45e2e-922">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-922">Assembly Format</span></span>|<span data-ttu-id="45e2e-923">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="45e2e-924">FE 01</span></span>|<span data-ttu-id="45e2e-925">ceq</span><span class="sxs-lookup"><span data-stu-id="45e2e-925">ceq</span></span>|<span data-ttu-id="45e2e-926">Inserisce 1 se `value1` è uguale a `value2`; in caso contrario inserisce 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="45e2e-927">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-928">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-929">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-930">`value2` e `value1` vengono estratti dallo stack; `value1` viene confrontato con `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="45e2e-931">Se `value1` è uguale a `value2`, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-932">Il `ceq` istruzione confronta `value1` e `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="45e2e-933">Se `value1` è uguale a `value2`, quindi 1 (di tipo `int32`) viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="45e2e-934">In caso contrario, 0 (di tipo `int32`) viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-935">Per un numero a virgola mobile, `ceq` restituirà 0 se i numeri non sono ordinati (uno o entrambi sono NaN).</span><span class="sxs-lookup"><span data-stu-id="45e2e-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="45e2e-936">I valori infiniti sono uguali a se stessi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="45e2e-937">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ceq` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-939">Confronta due valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-939">Compares two values.</span>
          </span>
          <span data-ttu-id="45e2e-940">Se il primo valore è maggiore del secondo, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-941">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-942">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-942">Format</span></span>|<span data-ttu-id="45e2e-943">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-943">Assembly Format</span></span>|<span data-ttu-id="45e2e-944">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="45e2e-945">FE 02</span></span>|<span data-ttu-id="45e2e-946">cgt</span><span class="sxs-lookup"><span data-stu-id="45e2e-946">cgt</span></span>|<span data-ttu-id="45e2e-947">Inserisce 1 se `value1` è maggiore di `value2`; in caso contrario inserisce 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="45e2e-948">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-949">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-950">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-951">`value2` e `value1` vengono estratti dallo stack; `cgt` verifica se `value1` è maggiore di `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="45e2e-952">Se `value1` è maggiore di `value2`, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-953">Il `cgt` istruzione confronta `value1` e `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="45e2e-954">Se `value1` è rigorosamente maggiore `value2`, quindi un `int32` valore 1 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="45e2e-955">In caso contrario, un `int32` il valore 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="45e2e-956">Per i numeri a virgola mobile, `cgt` restituisce 0 se i numeri sono ordinati (ovvero, se uno o entrambi gli argomenti sono NaN).</span><span class="sxs-lookup"><span data-stu-id="45e2e-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="45e2e-957">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `cgt` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-958">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-959">Confronta due valori senza segno o non ordinati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-959">Compares two unsigned or unordered values.</span>
          </span>
          <span data-ttu-id="45e2e-960">Se il primo valore è maggiore del secondo, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-961">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-962">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-962">Format</span></span>|<span data-ttu-id="45e2e-963">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-963">Assembly Format</span></span>|<span data-ttu-id="45e2e-964">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="45e2e-965">FE 03</span></span>|<span data-ttu-id="45e2e-966">cgt.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-966">cgt.un</span></span>|<span data-ttu-id="45e2e-967">Inserisce 1 se `value1` è maggiore di `value2`; in caso contrario inserisce 0 (valori senza segno).</span><span class="sxs-lookup"><span data-stu-id="45e2e-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="45e2e-968">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-969">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-970">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-971">`value2` e `value1` vengono estratti dallo stack; `cgt.un` verifica se `value1` è maggiore di `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="45e2e-972">Se `value1` è maggiore di `value2`, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-973">Un `int32` valore 1 viene inserito nello stack, se una delle seguenti è `true` :</span><span class="sxs-lookup"><span data-stu-id="45e2e-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="45e2e-974">Per i numeri a virgola mobile, `value1` non è ordinato rispetto a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="45e2e-975">Per i valori integer `value1` è rigorosamente maggiore `value2` se considerati come numeri senza segno.</span><span class="sxs-lookup"><span data-stu-id="45e2e-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="45e2e-976">In caso contrario un `int32` il valore 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-977">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `cgt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-978">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-979">Genera un'eccezione <see cref="T:System.ArithmeticException" /> se il valore non è un numero finito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-980">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-981">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-981">Format</span></span>|<span data-ttu-id="45e2e-982">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-982">Assembly Format</span></span>|<span data-ttu-id="45e2e-983">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-984">C3</span><span class="sxs-lookup"><span data-stu-id="45e2e-984">C3</span></span>|<span data-ttu-id="45e2e-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="45e2e-985">ckfinite</span></span>|<span data-ttu-id="45e2e-986">generare <xref:System.ArithmeticException> se il valore non è un numero finito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="45e2e-987">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-988">`value` viene inserito nello stack...</span><span class="sxs-lookup"><span data-stu-id="45e2e-988">`value` is pushed onto the stack..</span></span>  
  
2.  <span data-ttu-id="45e2e-989">`value` viene estratto dallo stack e `ckfinite` istruzione viene eseguita su di esso.</span><span class="sxs-lookup"><span data-stu-id="45e2e-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="45e2e-990">`value` viene nuovamente inserito nello stack se viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-991">Il `ckfinite instruction` genera <xref:System.ArithmeticException> se `value` (un numero a virgola mobile) è un valore "non è un numero" (NaN) o un `+-` valore infinito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="45e2e-992">`Ckfinite` lascia il valore nello stack, se viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="45e2e-993">Esecuzione non è specificata se `value` non è un numero a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="45e2e-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="45e2e-994"><xref:System.ArithmeticException> viene generata se `value` non è un numero di 'normal'.</span><span class="sxs-lookup"><span data-stu-id="45e2e-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="45e2e-995">Si noti che una particolare eccezione o una classe derivata di <xref:System.ArithmeticException> potrebbe essere più appropriato, passando il valore non corretto per il gestore di eccezioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="45e2e-996">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ckfinite` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-997">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-998">Confronta due valori.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-998">Compares two values.</span>
          </span>
          <span data-ttu-id="45e2e-999">Se il primo valore è inferiore al secondo, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1000">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1001">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1001">Format</span></span>|<span data-ttu-id="45e2e-1002">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1002">Assembly Format</span></span>|<span data-ttu-id="45e2e-1003">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="45e2e-1004">FE 04</span></span>|<span data-ttu-id="45e2e-1005">clt</span><span class="sxs-lookup"><span data-stu-id="45e2e-1005">clt</span></span>|<span data-ttu-id="45e2e-1006">Inserisce 1 se `value1` è minore di `value2`; in caso contrario inserisce 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="45e2e-1007">Il comportamento di transizione dello stack, in ordine sequenziale, è: `value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1007">The stack transitional behavior, in sequential order, is: `value1` is pushed onto the stack.</span></span>  
  
1.  <span data-ttu-id="45e2e-1008">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1008">`value2` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1009">`value2` e `value1` vengono estratti dallo stack; `clt` verifica se `value1` è minore di `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1009">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
3.  <span data-ttu-id="45e2e-1010">Se `value1` è minore di `value2`, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1010">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1011">Il `clt` istruzione confronta `value1` e `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1011">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="45e2e-1012">Se `value1` è rigorosamente minore di `value2`, quindi un `int32` valore 1 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1012">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="45e2e-1013">In caso contrario, un `int32` il valore 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1013">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="45e2e-1014">Per i numeri a virgola mobile, `clt` restituisce 0 se i numeri sono ordinati (ovvero, se uno o entrambi gli argomenti sono NaN).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1014">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="45e2e-1015">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `clt` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1015">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1016">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1016">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1017">Confronta i due valori senza segno o non ordinati <paramref name="value1" /> e <paramref name="value2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1017">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span>
          </span>
          <span data-ttu-id="45e2e-1018">Se <paramref name="value1" /> è minore di <paramref name="value2" />, nello stack di valutazione viene inserito il valore intero 1 <see langword="(int32" />); in caso contrario, viene inserito 0 (<see langword="int32" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1018">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1019">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1019">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1020">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1020">Format</span></span>|<span data-ttu-id="45e2e-1021">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1021">Assembly Format</span></span>|<span data-ttu-id="45e2e-1022">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1022">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1023">FE 05</span><span class="sxs-lookup"><span data-stu-id="45e2e-1023">FE 05</span></span>|<span data-ttu-id="45e2e-1024">clt.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1024">clt.un</span></span>|<span data-ttu-id="45e2e-1025">Inserisce 1 se `value1` è minore di `value2`; in caso contrario inserisce 0 (valori senza segno).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1025">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="45e2e-1026">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1026">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1027">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1027">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1028">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1028">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-1029">`value2` e `value1` vengono estratti dallo stack; `clt.un` verifica se `value1` è minore di `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1029">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="45e2e-1030">Se `value1` è minore di `value2`, 1 viene inserito nello stack; in caso contrario 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1030">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1031">Il `clt.un` istruzione confronta `value1` e `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1031">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="45e2e-1032">Un `int32` valore 1 viene inserito nello stack in presenza di una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1032">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="45e2e-1033">`value1` è minore `value2` (come per `clt`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1033">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="45e2e-1034">Per i numeri a virgola mobile, `value1` non è ordinato rispetto a `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1034">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="45e2e-1035">Per i valori integer `value1` è rigorosamente minore di `value2` se considerati come numeri senza segno.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1035">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="45e2e-1036">In caso contrario, un `int32` il valore 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1036">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1037">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `clt.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1038">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1039">Vincola il tipo su cui viene eseguita una chiamata al metodo virtuale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1039">Constrains the type on which a virtual method call is made.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1040">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1040">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1041">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1041">Format</span></span>|<span data-ttu-id="45e2e-1042">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1042">Assembly Format</span></span>|<span data-ttu-id="45e2e-1043">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1044">FE 16 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-1044">FE 16 < `T` ></span></span>|<span data-ttu-id="45e2e-1045">vincolato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1045">constrained.</span></span> `thisType`|<span data-ttu-id="45e2e-1046">Chiamata di un metodo virtuale su un tipo è vincolato per essere tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1046">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="45e2e-1047">Il `constrained` è consentito solo in un `callvirt` istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1047">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="45e2e-1048">Lo stato dello stack a questo punto di codice MSIL deve essere come segue:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1048">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="45e2e-1049">Un puntatore gestito, `ptr`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1049">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="45e2e-1050">Il tipo di `ptr` deve essere un puntatore gestito (`&`) a `thisType`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1050">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="45e2e-1051">Si noti che questo è diverso da quello di un senza prefisso `callvirt` (istruzione), che prevede un riferimento a `thisType`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1051">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="45e2e-1052">Gli argomenti del metodo `arg1` tramite `argN` vengono inseriti nello stack, proprio come con un senza prefisso `callvirt` istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1052">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="45e2e-1053">Il `constrained` prefisso è progettato per consentire `callvirt` istruzioni da eseguire in un uniform modo indipendentemente dal fatto che `thisType` è un tipo di valore o un tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1053">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="45e2e-1054">Quando un `callvirt` `method` istruzione è preceduto da `constrained` `thisType`, l'istruzione viene eseguita nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1054">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="45e2e-1055">Se `thisType` è un tipo di riferimento (anziché un tipo di valore), quindi `ptr` viene dereferenziato e passato come il puntatore 'this' per il `callvirt` di `method`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1055">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="45e2e-1056">Se `thisType` è un tipo di valore e `thisType` implementa `method` quindi `ptr` viene passato senza modifiche come il puntatore 'this' per un `call` `method` (istruzione), per l'implementazione di `method` da `thisType`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1056">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="45e2e-1057">Se `thisType` è un tipo di valore e `thisType` non implementa `method` quindi `ptr` è dereferenziato, sottoposto a boxing e passato come il puntatore 'this' per il `callvirt` `method` istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1057">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="45e2e-1058">Quest'ultimo caso può verificarsi solo quando `method` è stato definito in <xref:System.Object>, <xref:System.ValueType>, o <xref:System.Enum> e non esegue l'override `thisType`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1058">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="45e2e-1059">In questo caso, la conversione boxing, una copia dell'oggetto originale da eseguire.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1059">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="45e2e-1060">Tuttavia, poiché nessuno dei metodi di <xref:System.Object>, <xref:System.ValueType>, e <xref:System.Enum> modificare lo stato dell'oggetto, questo evento non può essere rilevato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1060">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="45e2e-1061">Il `constrained` prefisso supporta generatori IL per creare codice generico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1061">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="45e2e-1062">In genere il `callvirt` istruzione non è valido nei tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1062">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="45e2e-1063">In alternativa è necessario che i compilatori di linguaggio intermedio svolgere in modo efficace la trasformazione 'this' descritta in precedenza in fase di compilazione, a seconda del tipo di `ptr` e il metodo chiamato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1063">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="45e2e-1064">Tuttavia, quando `ptr` è un tipo generico è noto in fase di compilazione non è possibile eseguire questa trasformazione in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1064">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="45e2e-1065">Il `constrained` opcode consente ai compilatori di linguaggio intermedio di effettuare una chiamata a una funzione virtuale in un uniform modo indipendentemente dal fatto che `ptr` è un tipo di valore o un tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1065">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="45e2e-1066">Sebbene sia progettato per il caso in cui `thisType` è una variabile di tipo generico, la `constrained` prefisso anche funziona per i tipi non generici e può ridurre la complessità della generazione delle chiamate virtuali nei linguaggi che la differenza tra i tipi di valore e tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1066">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="45e2e-1067">Utilizzo di `constrained` prefisso consente anche di evitare i potenziali problemi di controllo delle versioni con tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1067">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="45e2e-1068">Se il `constrained` prefisso non viene utilizzato IL diverso deve essere inviato a seconda se un tipo di valore esegue l'override di un metodo System. Object.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1068">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="45e2e-1069">Ad esempio, se un tipo di valore `V` esegue l'override del metodo ToString, un `call` `V.ToString()` viene generata un'istruzione; in caso contrario, un `box` (istruzione) e un `callvirt` `Object.ToString()` istruzione vengono generati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1069">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="45e2e-1070">Può sorgere un problema di controllo delle versioni nel primo caso, se la sostituzione verrà rimossa in seguito in quest'ultimo caso se successivamente viene aggiunto un override.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1070">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="45e2e-1071">Il `constrained` prefisso può anche essere utilizzato per la chiamata di metodi di interfaccia sui tipi di valore, perché il metodo che implementa il metodo di interfaccia del tipo di valore può essere modificato utilizzando un `MethodImpl`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1071">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="45e2e-1072">Se il `constrained` prefisso non viene utilizzato, il compilatore viene imposto di scegliere quale il valore metodi del tipo da associare in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1072">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="45e2e-1073">Utilizzo di `constrained` prefisso consente il codice MSIL associare il metodo che implementa il metodo di interfaccia in fase di esecuzione, anziché in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1073">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="45e2e-1074">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `constrained` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1074">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1075">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1075">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1076">Converte il valore all'inizio dello stack di valutazione in <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1076">Converts the value on top of the evaluation stack to <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1077">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1077">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1078">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1078">Format</span></span>|<span data-ttu-id="45e2e-1079">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1079">Assembly Format</span></span>|<span data-ttu-id="45e2e-1080">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1080">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1081">D3</span><span class="sxs-lookup"><span data-stu-id="45e2e-1081">D3</span></span>|<span data-ttu-id="45e2e-1082">conv.i</span><span class="sxs-lookup"><span data-stu-id="45e2e-1082">conv.i</span></span>|<span data-ttu-id="45e2e-1083">Convertire `native int`, inserendo `native int` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1083">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1084">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1084">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1085">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1085">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1086">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1086">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1087">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1087">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1088">Il `conv.i` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1088">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1089">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1089">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1090">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1090">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1091">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1091">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1092">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1092">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1093">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1093">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1094">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1094">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1095">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1095">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1096">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1096">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1097">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1097">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1098">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1098">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1099">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1099">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1100">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1100">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1101">Converte il valore all'inizio dello stack di valutazione in <see langword="int8" />, quindi lo estende, aggiungendo spazi, a <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1101">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1102">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1102">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1103">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1103">Format</span></span>|<span data-ttu-id="45e2e-1104">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1104">Assembly Format</span></span>|<span data-ttu-id="45e2e-1105">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1105">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1106">67</span><span class="sxs-lookup"><span data-stu-id="45e2e-1106">67</span></span>|<span data-ttu-id="45e2e-1107">conv.i1</span><span class="sxs-lookup"><span data-stu-id="45e2e-1107">conv.i1</span></span>|<span data-ttu-id="45e2e-1108">Convertire `int8`, inserendo `int32` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1108">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1109">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1109">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1110">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1110">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1111">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1111">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1112">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1112">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1113">Il `conv.i1` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1113">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1114">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1114">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1115">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1115">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1116">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1116">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1117">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1117">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1118">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1118">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1119">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1119">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1120">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1120">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1121">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1121">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1122">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1122">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1123">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1123">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1124">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1124">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1125">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1125">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1126">Converte il valore all'inizio dello stack di valutazione in <see langword="int16" />, quindi lo estende, aggiungendo spazi, a <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1126">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1127">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1127">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1128">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1128">Format</span></span>|<span data-ttu-id="45e2e-1129">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1129">Assembly Format</span></span>|<span data-ttu-id="45e2e-1130">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1130">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1131">68</span><span class="sxs-lookup"><span data-stu-id="45e2e-1131">68</span></span>|<span data-ttu-id="45e2e-1132">conv.i2</span><span class="sxs-lookup"><span data-stu-id="45e2e-1132">conv.i2</span></span>|<span data-ttu-id="45e2e-1133">Convertire `int16`, inserendo `int32` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1133">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1134">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1134">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1135">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1135">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1136">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1136">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1137">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1137">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1138">Il `conv.i2` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1138">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1139">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1139">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1140">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1140">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1141">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1141">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1142">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1142">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1143">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1143">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1144">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1144">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1145">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1145">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1146">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1146">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1147">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1147">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1148">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1148">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1149">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1149">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1150">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1150">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1151">Converte il valore all'inizio dello stack di valutazione in <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1151">Converts the value on top of the evaluation stack to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1152">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1152">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1153">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1153">Format</span></span>|<span data-ttu-id="45e2e-1154">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1154">Assembly Format</span></span>|<span data-ttu-id="45e2e-1155">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1155">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1156">69</span><span class="sxs-lookup"><span data-stu-id="45e2e-1156">69</span></span>|<span data-ttu-id="45e2e-1157">conv.i4</span><span class="sxs-lookup"><span data-stu-id="45e2e-1157">conv.i4</span></span>|<span data-ttu-id="45e2e-1158">Convertire `int32`, inserendo `int32` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1158">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1159">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1159">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1160">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1160">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1161">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1161">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1162">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1162">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1163">Il `conv.i4` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1163">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1164">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1164">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1165">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1165">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1166">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1166">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1167">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1167">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1168">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1168">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1169">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1169">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1170">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1170">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1171">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1171">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1172">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1172">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1173">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1173">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1174">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1175">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1175">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1176">Converte il valore all'inizio dello stack di valutazione in <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1176">Converts the value on top of the evaluation stack to <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1177">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1178">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1178">Format</span></span>|<span data-ttu-id="45e2e-1179">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1179">Assembly Format</span></span>|<span data-ttu-id="45e2e-1180">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1181">6A</span><span class="sxs-lookup"><span data-stu-id="45e2e-1181">6A</span></span>|<span data-ttu-id="45e2e-1182">conv.i8</span><span class="sxs-lookup"><span data-stu-id="45e2e-1182">conv.i8</span></span>|<span data-ttu-id="45e2e-1183">Convertire `int64`, inserendo `int64` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1183">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1184">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1185">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1185">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1186">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1186">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1187">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1187">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1188">Il `conv.i8` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1188">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1189">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1189">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1190">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1190">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1191">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1191">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1192">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1192">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1193">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1193">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1194">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1194">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1195">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1195">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1196">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1196">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1197">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1197">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1198">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1198">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1199">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1199">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1200">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1200">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1201">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="native int" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1201">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1202">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1202">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1203">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1203">Format</span></span>|<span data-ttu-id="45e2e-1204">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1204">Assembly Format</span></span>|<span data-ttu-id="45e2e-1205">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1205">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1206">D4</span><span class="sxs-lookup"><span data-stu-id="45e2e-1206">D4</span></span>|<span data-ttu-id="45e2e-1207">conv.ovf.i</span><span class="sxs-lookup"><span data-stu-id="45e2e-1207">conv.ovf.i</span></span>|<span data-ttu-id="45e2e-1208">Convertire un `native int` (sullo stack come `native int`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1208">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1209">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1209">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1210">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1210">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1211">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1211">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1212">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1212">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1213">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1213">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1214">Il `conv.ovf.i` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1214">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1215">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1215">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1216">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1216">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1217">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1217">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1218"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1218"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1219">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1219">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1220">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1220">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1221">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="native int" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1221">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1222">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1222">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1223">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1223">Format</span></span>|<span data-ttu-id="45e2e-1224">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1224">Assembly Format</span></span>|<span data-ttu-id="45e2e-1225">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1225">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1226">8A</span><span class="sxs-lookup"><span data-stu-id="45e2e-1226">8A</span></span>|<span data-ttu-id="45e2e-1227">conv.ovf.i.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1227">conv.ovf.i.un</span></span>|<span data-ttu-id="45e2e-1228">Converte un valore senza segno in un `native int` (sullo stack come `native int`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1228">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1229">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1229">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1230">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1230">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1231">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1231">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1232">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1232">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1233">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1233">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1234">Il `conv.ovf.i.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1234">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1235">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1235">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1236">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1236">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1237">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1237">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1238"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1238"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1239">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1240">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1240">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1241">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="int8" /> con segno e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1241">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1242">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1242">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1243">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1243">Format</span></span>|<span data-ttu-id="45e2e-1244">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1244">Assembly Format</span></span>|<span data-ttu-id="45e2e-1245">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1245">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1246">B3</span><span class="sxs-lookup"><span data-stu-id="45e2e-1246">B3</span></span>|<span data-ttu-id="45e2e-1247">conv.ovf.i1</span><span class="sxs-lookup"><span data-stu-id="45e2e-1247">conv.ovf.i1</span></span>|<span data-ttu-id="45e2e-1248">Convertire un `int8` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1248">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1249">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1249">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1250">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1250">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1251">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1251">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1252">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1252">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1253">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1253">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1254">Il `conv.ovf.i1` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1254">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1255">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1255">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1256">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1256">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1257">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1257">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1258"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1258"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1259">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1259">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1260">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1260">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1261">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="int8" /> con segno e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1261">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1262">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1262">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1263">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1263">Format</span></span>|<span data-ttu-id="45e2e-1264">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1264">Assembly Format</span></span>|<span data-ttu-id="45e2e-1265">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1265">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1266">82</span><span class="sxs-lookup"><span data-stu-id="45e2e-1266">82</span></span>|<span data-ttu-id="45e2e-1267">conv.ovf.i1.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1267">conv.ovf.i1.un</span></span>|<span data-ttu-id="45e2e-1268">Converte un valore senza segno in un `int8` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1268">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1269">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1269">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1270">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1270">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1271">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1271">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1272">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1272">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1273">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1273">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1274">Il `conv.ovf.i1.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1274">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1275">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1275">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1276">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1276">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1277">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1277">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1278"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1278"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1279">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i1.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1280">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1281">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="int16" /> con segno e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1281">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1282">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1283">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1283">Format</span></span>|<span data-ttu-id="45e2e-1284">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1284">Assembly Format</span></span>|<span data-ttu-id="45e2e-1285">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1286">B5</span><span class="sxs-lookup"><span data-stu-id="45e2e-1286">B5</span></span>|<span data-ttu-id="45e2e-1287">conv.ovf.i2</span><span class="sxs-lookup"><span data-stu-id="45e2e-1287">conv.ovf.i2</span></span>|<span data-ttu-id="45e2e-1288">Convertire un `int16` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1288">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1289">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1290">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1290">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1291">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1291">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1292">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1292">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1293">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1293">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1294">Il `conv.ovf.i2` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1294">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1295">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1295">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1296">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1296">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1297">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1297">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1298"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1298"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1299">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1299">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1300">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1300">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1301">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="int16" /> con segno e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1301">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1302">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1302">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1303">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1303">Format</span></span>|<span data-ttu-id="45e2e-1304">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1304">Assembly Format</span></span>|<span data-ttu-id="45e2e-1305">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1305">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1306">83</span><span class="sxs-lookup"><span data-stu-id="45e2e-1306">83</span></span>|<span data-ttu-id="45e2e-1307">conv.ovf.i2.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1307">conv.ovf.i2.un</span></span>|<span data-ttu-id="45e2e-1308">Converte un valore senza segno in un `int16` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1308">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1309">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1309">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1310">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1310">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1311">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1311">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1312">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1312">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1313">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1313">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1314">Il `conv.ovf.i2.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1314">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1315">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1315">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1316">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1316">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1317">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1317">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1318"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1318"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1319">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i2.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1319">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1320">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1320">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1321">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="int32" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1321">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1322">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1322">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1323">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1323">Format</span></span>|<span data-ttu-id="45e2e-1324">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1324">Assembly Format</span></span>|<span data-ttu-id="45e2e-1325">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1325">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1326">B7</span><span class="sxs-lookup"><span data-stu-id="45e2e-1326">B7</span></span>|<span data-ttu-id="45e2e-1327">conv.ovf.i4</span><span class="sxs-lookup"><span data-stu-id="45e2e-1327">conv.ovf.i4</span></span>|<span data-ttu-id="45e2e-1328">Convertire un `int32` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1328">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1329">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1329">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1330">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1330">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1331">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1331">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1332">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1332">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1333">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1333">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1334">Il `conv.ovf.i4` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1334">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1335">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1335">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1336">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1336">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1337">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1337">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1338"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1338"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1339">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1339">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1340">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1340">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1341">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="int32" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1341">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1342">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1342">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1343">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1343">Format</span></span>|<span data-ttu-id="45e2e-1344">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1344">Assembly Format</span></span>|<span data-ttu-id="45e2e-1345">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1345">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1346">84</span><span class="sxs-lookup"><span data-stu-id="45e2e-1346">84</span></span>|<span data-ttu-id="45e2e-1347">conv.ovf.i4.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1347">conv.ovf.i4.un</span></span>|<span data-ttu-id="45e2e-1348">Converte un valore senza segno in un `int32` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1348">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1349">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1349">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1350">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1350">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1351">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1351">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1352">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1352">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1353">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1353">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1354">Il `conv.ovf.i4.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1354">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1355">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1355">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1356">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1356">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1357">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1357">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1358"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1358"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1359">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i4.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1360">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1360">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1361">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="int64" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1361">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1362">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1363">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1363">Format</span></span>|<span data-ttu-id="45e2e-1364">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1364">Assembly Format</span></span>|<span data-ttu-id="45e2e-1365">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1366">B9</span><span class="sxs-lookup"><span data-stu-id="45e2e-1366">B9</span></span>|<span data-ttu-id="45e2e-1367">conv.ovf.i8</span><span class="sxs-lookup"><span data-stu-id="45e2e-1367">conv.ovf.i8</span></span>|<span data-ttu-id="45e2e-1368">Convertire un `int64` (sullo stack come `int64`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1368">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1369">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1370">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1370">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1371">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1371">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1372">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1372">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1373">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1373">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1374">Il `conv.ovf.i8` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1374">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1375">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1375">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1376">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1376">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1377">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1377">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1378"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1378"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1379">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1379">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1380">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1380">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1381">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="int64" /> con segno, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1381">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1382">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1382">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1383">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1383">Format</span></span>|<span data-ttu-id="45e2e-1384">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1384">Assembly Format</span></span>|<span data-ttu-id="45e2e-1385">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1385">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1386">85</span><span class="sxs-lookup"><span data-stu-id="45e2e-1386">85</span></span>|<span data-ttu-id="45e2e-1387">conv.ovf.i8.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1387">conv.ovf.i8.un</span></span>|<span data-ttu-id="45e2e-1388">Converte un valore senza segno in un `int64` (sullo stack come `int64`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1388">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1389">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1389">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1390">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1390">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1391">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1391">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1392">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1392">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1393">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1393">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1394">Il `conv.ovf.i8.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1394">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1395">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1395">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1396">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1396">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1397">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1397">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1398"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1398"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1399">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.i8.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1399">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1400">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1400">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1401">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned native int" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1401">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1402">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1402">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1403">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1403">Format</span></span>|<span data-ttu-id="45e2e-1404">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1404">Assembly Format</span></span>|<span data-ttu-id="45e2e-1405">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1405">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1406">D5</span><span class="sxs-lookup"><span data-stu-id="45e2e-1406">D5</span></span>|<span data-ttu-id="45e2e-1407">conv.ovf.u</span><span class="sxs-lookup"><span data-stu-id="45e2e-1407">conv.ovf.u</span></span>|<span data-ttu-id="45e2e-1408">Convertire un `unsigned native int` (sullo stack come `native int`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1408">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1409">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1409">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1410">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1410">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1411">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1411">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1412">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1412">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1413">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1413">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1414">Il `conv.ovf.u` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1414">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1415">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1415">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1416">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1416">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1417">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1417">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1418"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1418"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1419">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.u` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1419">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1420">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1420">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1421">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned native int" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1421">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1422">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1422">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1423">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1423">Format</span></span>|<span data-ttu-id="45e2e-1424">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1424">Assembly Format</span></span>|<span data-ttu-id="45e2e-1425">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1425">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1426">8B</span><span class="sxs-lookup"><span data-stu-id="45e2e-1426">8B</span></span>|<span data-ttu-id="45e2e-1427">conv.ovf.u.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1427">conv.ovf.u.un</span></span>|<span data-ttu-id="45e2e-1428">Converte un valore senza segno in un `unsigned native int` (sullo stack come `native int`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1428">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1429">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1429">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1430">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1430">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1431">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1431">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1432">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1432">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1433">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1433">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1434">Il `conv.ovf.u.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1434">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1435">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1435">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1436">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1436">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1437">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1437">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1438"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1438"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1439">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.uvf.u.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1439">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1440">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1440">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1441">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned int8" /> e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1441">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1442">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1442">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1443">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1443">Format</span></span>|<span data-ttu-id="45e2e-1444">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1444">Assembly Format</span></span>|<span data-ttu-id="45e2e-1445">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1445">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1446">B4</span><span class="sxs-lookup"><span data-stu-id="45e2e-1446">B4</span></span>|<span data-ttu-id="45e2e-1447">conv.ovf.u1</span><span class="sxs-lookup"><span data-stu-id="45e2e-1447">conv.ovf.u1</span></span>|<span data-ttu-id="45e2e-1448">Convertire un `unsigned int8` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1448">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1449">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1449">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1450">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1450">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1451">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1451">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1452">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1452">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1453">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1453">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1454">Il `conv.ovf.u1` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1454">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1455">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1455">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1456">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1456">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1457">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1457">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1458"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1458"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1459">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1460">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1460">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1461">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned int8" /> e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1461">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1462">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1462">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1463">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1463">Format</span></span>|<span data-ttu-id="45e2e-1464">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1464">Assembly Format</span></span>|<span data-ttu-id="45e2e-1465">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1466">86</span><span class="sxs-lookup"><span data-stu-id="45e2e-1466">86</span></span>|<span data-ttu-id="45e2e-1467">conv.ovf.u1.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1467">conv.ovf.u1.un</span></span>|<span data-ttu-id="45e2e-1468">Converte un valore senza segno in un `unsigned int8` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1468">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1469">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1470">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1470">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1471">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1471">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1472">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1472">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1473">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1473">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1474">Il `conv.ovf.u1.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1474">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1475">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1475">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1476">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1476">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1477">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1477">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1478"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1478"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1479">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.u1.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1479">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1480">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1480">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1481">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned int16" /> e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1481">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1482">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1482">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1483">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1483">Format</span></span>|<span data-ttu-id="45e2e-1484">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1484">Assembly Format</span></span>|<span data-ttu-id="45e2e-1485">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1485">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1486">B6</span><span class="sxs-lookup"><span data-stu-id="45e2e-1486">B6</span></span>|<span data-ttu-id="45e2e-1487">conv.ovf.u2</span><span class="sxs-lookup"><span data-stu-id="45e2e-1487">conv.ovf.u2</span></span>|<span data-ttu-id="45e2e-1488">Convertire un `unsigned int16` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1488">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1489">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1489">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1490">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1490">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1491">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1491">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1492">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1492">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1493">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1493">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1494">Il `conv.ovf.u2` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1494">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1495">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1495">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1496">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1496">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1497">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1497">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1498"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1498"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1499">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1500">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1500">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1501">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned int16" /> e lo estende a <see langword="int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1501">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1502">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1503">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1503">Format</span></span>|<span data-ttu-id="45e2e-1504">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1504">Assembly Format</span></span>|<span data-ttu-id="45e2e-1505">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1506">87</span><span class="sxs-lookup"><span data-stu-id="45e2e-1506">87</span></span>|<span data-ttu-id="45e2e-1507">conv.ovf.u2.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1507">conv.ovf.u2.un</span></span>|<span data-ttu-id="45e2e-1508">Converte un valore senza segno in un `unsigned int16` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1508">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1509">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1510">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1510">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1511">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1511">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1512">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1512">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1513">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1513">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1514">Il `conv.ovf.u2.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1514">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1515">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1515">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1516">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1516">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1517">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1517">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1518"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1518"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1519">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.u2.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1519">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1520">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1520">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1521">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1521">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1522">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1522">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1523">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1523">Format</span></span>|<span data-ttu-id="45e2e-1524">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1524">Assembly Format</span></span>|<span data-ttu-id="45e2e-1525">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1525">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1526">B8</span><span class="sxs-lookup"><span data-stu-id="45e2e-1526">B8</span></span>|<span data-ttu-id="45e2e-1527">conv.ovf.u4</span><span class="sxs-lookup"><span data-stu-id="45e2e-1527">conv.ovf.u4</span></span>|<span data-ttu-id="45e2e-1528">Convertire un `unsigned int32` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1528">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1529">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1529">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1530">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1530">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1531">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1531">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1532">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1532">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1533">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1533">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1534">Il `conv.ovf.u4` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1534">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1535">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1535">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1536">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1536">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1537">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1537">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1538"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1538"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1539">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1539">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1540">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1540">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1541">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned int32" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1541">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1542">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1542">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1543">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1543">Format</span></span>|<span data-ttu-id="45e2e-1544">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1544">Assembly Format</span></span>|<span data-ttu-id="45e2e-1545">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1545">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1546">88</span><span class="sxs-lookup"><span data-stu-id="45e2e-1546">88</span></span>|<span data-ttu-id="45e2e-1547">conv.ovf.u4.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1547">conv.ovf.u4.un</span></span>|<span data-ttu-id="45e2e-1548">Converte un valore senza segno in un `unsigned int32` (sullo stack come `int32`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1548">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1549">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1549">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1550">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1550">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1551">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1551">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1552">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1552">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1553">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1553">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1554">Il `conv.ovf.u4.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1554">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1555">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1555">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1556">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1556">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1557">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1557">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1558"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1558"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1559">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.u4.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1559">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1560">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1560">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1561">Converte il valore con segno all'inizio dello stack di valutazione in <see langword="unsigned int64" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1561">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1562">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1562">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1563">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1563">Format</span></span>|<span data-ttu-id="45e2e-1564">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1564">Assembly Format</span></span>|<span data-ttu-id="45e2e-1565">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1565">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1566">BA</span><span class="sxs-lookup"><span data-stu-id="45e2e-1566">BA</span></span>|<span data-ttu-id="45e2e-1567">conv.ovf.u8</span><span class="sxs-lookup"><span data-stu-id="45e2e-1567">conv.ovf.u8</span></span>|<span data-ttu-id="45e2e-1568">Convertire un `unsigned int64` (sullo stack come `int64`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1568">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1569">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1569">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1570">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1570">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1571">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1571">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1572">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1572">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1573">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1573">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1574">Il `conv.ovf.u8` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1574">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1575">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1575">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1576">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1576">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1577">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1577">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1578"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1578"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1579">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.u8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1579">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1580">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1580">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1581">Converte il valore senza segno all'inizio dello stack di valutazione in <see langword="unsigned int64" />, generando un'eccezione <see cref="T:System.OverflowException" /> in caso di overflow.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1581">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1582">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1582">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1583">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1583">Format</span></span>|<span data-ttu-id="45e2e-1584">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1584">Assembly Format</span></span>|<span data-ttu-id="45e2e-1585">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1585">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1586">89</span><span class="sxs-lookup"><span data-stu-id="45e2e-1586">89</span></span>|<span data-ttu-id="45e2e-1587">conv.ovf.u8.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1587">conv.ovf.u8.un</span></span>|<span data-ttu-id="45e2e-1588">Converte un valore senza segno in un `unsigned int64` (sullo stack come `int64`) e genera un'eccezione in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1588">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45e2e-1589">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1589">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1590">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1590">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1591">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1591">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45e2e-1592">Se si verifica un overflow, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1592">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45e2e-1593">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1593">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1594">Il `conv.ovf.u8.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, inserendo il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1594">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1595">Se il valore è troppo grande o troppo piccolo per essere rappresentato dal tipo di destinazione, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1595">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45e2e-1596">Le conversioni da numeri a virgola mobile a valori interi troncano il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1596">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45e2e-1597">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.ovf.i` o `conv.ovf.u` vengono utilizzati, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1597">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-1598"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1598"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-1599">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.ovf.u8.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1599">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1600">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1600">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1601">Converte il valore intero senza segno all'inizio dello stack di valutazione in <see langword="float32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1601">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1602">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1602">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1603">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1603">Format</span></span>|<span data-ttu-id="45e2e-1604">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1604">Assembly Format</span></span>|<span data-ttu-id="45e2e-1605">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1605">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1606">76</span><span class="sxs-lookup"><span data-stu-id="45e2e-1606">76</span></span>|<span data-ttu-id="45e2e-1607">conv.r.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1607">conv.r.un</span></span>|<span data-ttu-id="45e2e-1608">Converti intero senza segno a virgola mobile, inserendo `F` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1608">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1609">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1609">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1610">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1610">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1611">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1611">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1612">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1612">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1613">Il `conv.r.un` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1613">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1614">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1614">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1615">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1615">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1616">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1616">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1617">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1617">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1618">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1618">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1619">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1619">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1620">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1620">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1621">Se si verifica un overflow nella conversione di un tipo a virgola mobile a un numero intero di `result` restituito non è specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1621">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="45e2e-1622">Il `conv.r.un` operazione accetta un valore integer dallo stack, interpreta come senza segno e lo sostituisce con un numero a virgola mobile per rappresentare il numero intero: entrambi un `float32`, se ciò è sufficiente per rappresentare il valore integer senza perdita di precisione, altrimenti un `float64`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1622">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="45e2e-1623">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1623">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="45e2e-1624">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.r.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1624">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1625">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1625">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1626">Converte il valore all'inizio dello stack di valutazione in <see langword="float32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1626">Converts the value on top of the evaluation stack to <see langword="float32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1627">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1627">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1628">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1628">Format</span></span>|<span data-ttu-id="45e2e-1629">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1629">Assembly Format</span></span>|<span data-ttu-id="45e2e-1630">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1630">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1631">6B</span><span class="sxs-lookup"><span data-stu-id="45e2e-1631">6B</span></span>|<span data-ttu-id="45e2e-1632">conv.r4</span><span class="sxs-lookup"><span data-stu-id="45e2e-1632">conv.r4</span></span>|<span data-ttu-id="45e2e-1633">Convertire `float32`, inserendo `F` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1633">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1634">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1634">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1635">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1635">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1636">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1636">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1637">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1637">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1638">Il `conv.r4` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1638">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1639">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1639">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1640">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1640">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1641">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1641">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1642">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1642">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1643">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1643">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1644">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1644">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1645">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1645">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1646">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1646">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1647">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1647">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="45e2e-1648">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1648">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1649">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1649">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1650">Converte il valore all'inizio dello stack di valutazione in <see langword="float64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1650">Converts the value on top of the evaluation stack to <see langword="float64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1651">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1651">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1652">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1652">Format</span></span>|<span data-ttu-id="45e2e-1653">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1653">Assembly Format</span></span>|<span data-ttu-id="45e2e-1654">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1654">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1655">6C</span><span class="sxs-lookup"><span data-stu-id="45e2e-1655">6C</span></span>|<span data-ttu-id="45e2e-1656">conv.r8</span><span class="sxs-lookup"><span data-stu-id="45e2e-1656">conv.r8</span></span>|<span data-ttu-id="45e2e-1657">Convertire `float64`, inserendo `F` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1657">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1658">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1658">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1659">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1659">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1660">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1660">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1661">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1661">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1662">Il `conv.r8` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1662">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1663">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1663">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1664">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1664">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1665">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1665">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1666">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1666">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1667">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1667">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1668">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1668">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1669">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1669">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1670">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1670">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1671">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1671">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="45e2e-1672">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1672">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1673">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1673">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1674">Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned native int" /> e lo estende a <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1674">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1675">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1675">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1676">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1676">Format</span></span>|<span data-ttu-id="45e2e-1677">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1677">Assembly Format</span></span>|<span data-ttu-id="45e2e-1678">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1678">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1679">E0</span><span class="sxs-lookup"><span data-stu-id="45e2e-1679">E0</span></span>|<span data-ttu-id="45e2e-1680">conv.u</span><span class="sxs-lookup"><span data-stu-id="45e2e-1680">conv.u</span></span>|<span data-ttu-id="45e2e-1681">Convertire `unsigned native int`, inserendo `native int` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1681">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1682">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1682">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1683">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1683">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1684">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1684">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1685">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1685">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1686">Il `conv.u` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1686">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1687">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1687">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1688">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1688">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1689">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1689">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1690">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1690">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1691">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1691">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1692">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1692">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1693">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1693">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1694">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1694">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1695">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1695">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1696">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1696">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1697">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.u` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1697">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1698">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1698">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1699">Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned int8" /> e lo estende a <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1699">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1700">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1700">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1701">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1701">Format</span></span>|<span data-ttu-id="45e2e-1702">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1702">Assembly Format</span></span>|<span data-ttu-id="45e2e-1703">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1703">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1704">D2</span><span class="sxs-lookup"><span data-stu-id="45e2e-1704">D2</span></span>|<span data-ttu-id="45e2e-1705">conv.u1</span><span class="sxs-lookup"><span data-stu-id="45e2e-1705">conv.u1</span></span>|<span data-ttu-id="45e2e-1706">Convertire `int8`, inserendo `int32` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1706">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1707">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1707">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1708">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1708">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1709">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1709">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1710">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1710">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1711">Il `conv.u1` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1711">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1712">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1712">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1713">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1713">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1714">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1714">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1715">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1715">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1716">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1716">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1717">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1717">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1718">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1718">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1719">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1719">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1720">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1720">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1721">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1721">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1722">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1723">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1723">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1724">Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned int16" /> e lo estende a <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1724">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1725">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1726">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1726">Format</span></span>|<span data-ttu-id="45e2e-1727">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1727">Assembly Format</span></span>|<span data-ttu-id="45e2e-1728">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1729">D1</span><span class="sxs-lookup"><span data-stu-id="45e2e-1729">D1</span></span>|<span data-ttu-id="45e2e-1730">conv.u2</span><span class="sxs-lookup"><span data-stu-id="45e2e-1730">conv.u2</span></span>|<span data-ttu-id="45e2e-1731">Convertire `int16`, inserendo `int32` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1731">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1732">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1732">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1733">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1733">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1734">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1734">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1735">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1735">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1736">Il `conv.u2` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1736">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1737">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1737">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1738">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1738">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1739">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1739">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1740">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1740">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1741">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1741">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1742">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1742">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1743">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1743">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1744">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1744">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1745">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1745">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1746">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1746">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1747">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1747">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1748">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1748">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1749">Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned int32" /> e lo estende a <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1749">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1750">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1750">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1751">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1751">Format</span></span>|<span data-ttu-id="45e2e-1752">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1752">Assembly Format</span></span>|<span data-ttu-id="45e2e-1753">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1753">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1754">6D</span><span class="sxs-lookup"><span data-stu-id="45e2e-1754">6D</span></span>|<span data-ttu-id="45e2e-1755">conv.u4</span><span class="sxs-lookup"><span data-stu-id="45e2e-1755">conv.u4</span></span>|<span data-ttu-id="45e2e-1756">Convertire `unsigned int32`, inserendo `int32` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1756">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1757">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1757">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1758">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1758">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1759">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1759">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1760">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1760">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1761">Il `conv.u4` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1761">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1762">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1762">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1763">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1763">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1764">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1764">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1765">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1765">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1766">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1766">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1767">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1767">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1768">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1768">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1769">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1769">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1770">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1770">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1771">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1771">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1772">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1772">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1773">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1773">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1774">Converte il valore all'inizio dello stack di valutazione in <see langword="unsigned int64" /> e lo estende a <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1774">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1775">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1775">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1776">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1776">Format</span></span>|<span data-ttu-id="45e2e-1777">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1777">Assembly Format</span></span>|<span data-ttu-id="45e2e-1778">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1778">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1779">6E</span><span class="sxs-lookup"><span data-stu-id="45e2e-1779">6E</span></span>|<span data-ttu-id="45e2e-1780">conv.u8</span><span class="sxs-lookup"><span data-stu-id="45e2e-1780">conv.u8</span></span>|<span data-ttu-id="45e2e-1781">Convertire `int64`, inserendo `int64` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1781">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1782">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1782">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1783">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1783">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1784">`value` viene estratto dallo stack e la conversione viene tentata l'operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1784">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45e2e-1785">Se la conversione ha esito positivo, il valore risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1785">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1786">Il `conv.u8` codice converte il `value` all'inizio dello stack per il tipo specificato nel codice operativo, lasciando il valore convertito all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1786">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45e2e-1787">Valori integer minore di 4 byte vengono estesi a `int32` quando vengono caricati nello stack di valutazione (a meno che non `conv.i` o `conv.u` viene utilizzato, nel qual caso il risultato è `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1787">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45e2e-1788">I valori a virgola mobile vengono convertiti nel `F` tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1788">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45e2e-1789">Conversione da numeri a virgola mobile a valori integer tronca il numero verso lo zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1789">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45e2e-1790">Durante la conversione da un `float64` per un `float32`, precisione può essere persa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1790">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45e2e-1791">Se `value` è troppo grande per essere contenuta in un `float32 (F)`, infinito positivo (se `value` è un valore positivo) o infinito negativo (se `value` è negativo) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1791">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45e2e-1792">Se si verifica un overflow convertire un tipo integer a un altro, i bit più significativi vengono troncati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1792">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45e2e-1793">Se il risultato è minore di un `int32`, il valore è con segno esteso per riempire lo slot.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1793">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45e2e-1794">Conversione di un tipo a virgola mobile a un intero il valore restituito non è specificata se si verifica un overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1794">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45e2e-1795">Non vengono mai generate eccezioni quando si utilizza questo campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1795">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45e2e-1796">Vedere <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> per ottenere istruzioni equivalenti che verranno generata un'eccezione quando il tipo di risultato non corretto può rappresentare il valore del risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1796">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45e2e-1797">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `conv.u8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1797">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1798">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1798">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1799">Copia un numero specificato di byte da un indirizzo di origine a un indirizzo di destinazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1799">Copies a specified number bytes from a source address to a destination address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1800">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1800">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1801">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1801">Format</span></span>|<span data-ttu-id="45e2e-1802">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1802">Assembly Format</span></span>|<span data-ttu-id="45e2e-1803">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1803">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1804">FE 17</span><span class="sxs-lookup"><span data-stu-id="45e2e-1804">FE 17</span></span>|<span data-ttu-id="45e2e-1805">cpblk</span><span class="sxs-lookup"><span data-stu-id="45e2e-1805">cpblk</span></span>|<span data-ttu-id="45e2e-1806">Copiare i dati da un blocco di memoria a un altro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1806">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="45e2e-1807">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1807">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1808">L'indirizzo di destinazione viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1808">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1809">L'indirizzo di origine viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1809">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-1810">Il numero di byte da copiare è inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1810">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-1811">Il numero di byte, l'indirizzo di origine e l'indirizzo di destinazione viene estratti dallo stack; il numero specificato di byte viene copiato dall'indirizzo di origine per l'indirizzo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1811">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="45e2e-1812">Il `cpblk` istruzione copia un numero (tipo `unsigned int32`) di byte da un indirizzo di origine (di tipo `*`, `native int`, o `&`) a un indirizzo di destinazione (di tipo `*`, `native int`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1812">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="45e2e-1813">Il comportamento di `cpblk` non è specificato se le aree di origine e di destinazione si sovrappongono.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1813">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="45e2e-1814">`cpblk` si presuppone che l'origine e destinazione risolto sono allineati alle dimensioni fisiche del computer.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1814">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="45e2e-1815">Il `cpblk` istruzione può essere immediatamente preceduto dal `unaligned.<prefix>` per indicare che l'origine o destinazione non è allineata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1815">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="45e2e-1816">L'operazione del `cpblk` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1816">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-1817"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1817"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-1818">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `cpblk` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1819">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1819">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1820">Copia il tipo di valore individuato in corrispondenza dell'indirizzo di un oggetto di tipo <see langword="&amp;" />, <see langword="*" /> o <see langword="native int" /> nell'indirizzo dell'oggetto di destinazione, di tipo <see langword="&amp;" />, <see langword="*" /> o <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1820">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1821">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1821">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1822">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1822">Format</span></span>|<span data-ttu-id="45e2e-1823">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1823">Assembly Format</span></span>|<span data-ttu-id="45e2e-1824">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1824">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1825">70 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-1825">70 < `T` ></span></span>|<span data-ttu-id="45e2e-1826">cpobj `classTok`</span><span class="sxs-lookup"><span data-stu-id="45e2e-1826">cpobj `classTok`</span></span>|<span data-ttu-id="45e2e-1827">Copia un valore di tipo da un oggetto di origine a un oggetto di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1827">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="45e2e-1828">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1828">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1829">Il riferimento all'oggetto di destinazione viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1829">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1830">Il riferimento all'oggetto di origine viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1830">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-1831">I riferimenti agli due oggetti vengono estratti dallo stack; il tipo di valore in corrispondenza dell'indirizzo dell'oggetto di origine viene copiato nell'indirizzo dell'oggetto di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1831">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="45e2e-1832">Il comportamento di `cpobj` non è specificato se l'origine e la destinazione oggetto riferimenti non sono puntatori a istanze della classe rappresentata dal token di classe `classTok` (un `typeref` o `typedef`), o se `classTok` non rappresenta un tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1832">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="45e2e-1833"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1833"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-1834">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `cpobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1834">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1835">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1835">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1836">Divide due valori e inserisce il risultato come valore in virgola mobile (di tipo <see langword="F" />) o quoziente (di tipo <see langword="int32" />) nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1836">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1837">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1837">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1838">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1838">Format</span></span>|<span data-ttu-id="45e2e-1839">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1839">Assembly Format</span></span>|<span data-ttu-id="45e2e-1840">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1840">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1841">5B</span><span class="sxs-lookup"><span data-stu-id="45e2e-1841">5B</span></span>|<span data-ttu-id="45e2e-1842">div</span><span class="sxs-lookup"><span data-stu-id="45e2e-1842">div</span></span>|<span data-ttu-id="45e2e-1843">Divide due valori e restituisce un risultato a virgola mobile o il quoziente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1843">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="45e2e-1844">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1844">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1845">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1845">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1846">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1846">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-1847">`value2` e `value1` vengono estratti dallo stack; `value1` viene diviso per `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1847">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="45e2e-1848">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1848">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1849">`result` = `value1` div value2 soddisfa le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1849">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="45e2e-1850">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1850">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="45e2e-1851">Sign (`result`) = +, se accedere (`value1`) = segno (`value2`), o-, se segno (`value1`) ~ = segno (`value2`)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1851">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="45e2e-1852">Il `div` istruzione calcola il risultato e lo inserisce nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1852">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1853">Divisione di interi troncata a zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1853">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="45e2e-1854">Divisione di un numero finito per zero genera il valore di infinito firmato correttamente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1854">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="45e2e-1855">Divisione di zero per zero o infinito da infinito produce il valore NaN (Not-A-Number).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1855">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="45e2e-1856">Qualsiasi numero diviso infinito produrrà un valore pari a zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1856">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="45e2e-1857">Le operazioni integrali generano <xref:System.ArithmeticException> se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1857">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="45e2e-1858">Questa situazione può verificarsi se `value1` è il massimo valore negativo, e `value2` è -1.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1858">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="45e2e-1859">Le operazioni integrali generano <xref:System.DivideByZeroException> se `value2` è zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1859">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="45e2e-1860">Si noti che nelle piattaforme basate su Intel su un <xref:System.OverflowException> viene generata quando il (minint div -1).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1860">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="45e2e-1861">Operazioni a virgola mobile non generano mai un'eccezione (producono NaN o valori infiniti invece).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1861">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="45e2e-1862">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `div` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1862">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1863">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1863">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1864">Divide due valori interi senza segno e inserisce il risultato (<see langword="int32" />) nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1864">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1865">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1865">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1866">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1866">Format</span></span>|<span data-ttu-id="45e2e-1867">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1867">Assembly Format</span></span>|<span data-ttu-id="45e2e-1868">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1868">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1869">5C</span><span class="sxs-lookup"><span data-stu-id="45e2e-1869">5C</span></span>|<span data-ttu-id="45e2e-1870">div.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-1870">div.un</span></span>|<span data-ttu-id="45e2e-1871">Divide due valori senza segno, restituendo un quoziente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1871">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="45e2e-1872">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1872">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1873">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1873">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1874">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1874">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-1875">`value2` e `value1` vengono estratti dallo stack; `value1` viene diviso per `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1875">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="45e2e-1876">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1876">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1877">Il `div.un` istruzione calcola `value1` diviso `value2`, entrambi come interi senza segno e inserisce il `result` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1877">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1878">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `div.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1878">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1879">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1879">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1880">Copia il valore corrente più in alto nello stack di valutazione e inserisce la copia nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1880">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1881">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1881">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1882">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1882">Format</span></span>|<span data-ttu-id="45e2e-1883">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1883">Assembly Format</span></span>|<span data-ttu-id="45e2e-1884">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1884">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1885">25</span><span class="sxs-lookup"><span data-stu-id="45e2e-1885">25</span></span>|<span data-ttu-id="45e2e-1886">dup</span><span class="sxs-lookup"><span data-stu-id="45e2e-1886">dup</span></span>|<span data-ttu-id="45e2e-1887">Duplica il valore all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1887">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-1888">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1888">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1889">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1889">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1890">`value` viene rimosso dallo stack per la duplicazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1890">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="45e2e-1891">`value` viene nuovamente inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1891">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-1892">Un valore duplicato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1892">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1893">Il `dup` istruzione Duplica l'elemento superiore dello stack e lascia primi due valori identici.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1893">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="45e2e-1894">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `dup` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1895">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1895">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1896">Trasferisce il controllo dalla clausola <see langword="filter" /> di un'eccezione nuovamente al gestore di eccezioni di Common Language Infrastructure (CLI).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1896">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1897">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1897">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1898">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1898">Format</span></span>|<span data-ttu-id="45e2e-1899">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1899">Assembly Format</span></span>|<span data-ttu-id="45e2e-1900">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1900">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1901">FE 11</span><span class="sxs-lookup"><span data-stu-id="45e2e-1901">FE 11</span></span>|<span data-ttu-id="45e2e-1902">endfilter</span><span class="sxs-lookup"><span data-stu-id="45e2e-1902">endfilter</span></span>|<span data-ttu-id="45e2e-1903">Clausola di filtro al fine di gestione delle eccezioni SEH.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1903">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="45e2e-1904">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1904">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1905">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1905">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1906">`value` viene estratto dallo stack; `endfilter` viene eseguita e il controllo viene trasferito al gestore di eccezioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1906">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="45e2e-1907">`Value` (che deve essere di tipo `int32` e fa parte di un set specifico di valori) viene restituito dalla clausola di filtro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1907">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="45e2e-1908">Deve essere uno di:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1908">It should be one of:</span></span>  
  
-   <span data-ttu-id="45e2e-1909">`exception_continue_search` (`value` = 0) per continuare la ricerca di un gestore di eccezioni</span><span class="sxs-lookup"><span data-stu-id="45e2e-1909">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="45e2e-1910">`exception_execute_handler` (`value` = 1) per avviare la seconda fase della gestione delle eccezioni in cui i blocchi vengono eseguiti fino a quando il gestore associato alla clausola di filtro si trova.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1910">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="45e2e-1911">Una volta individuato, il gestore viene eseguito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1911">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="45e2e-1912">Altri valori integer produrrà risultati non specificati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1912">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="45e2e-1913">Il punto di ingresso di un filtro, come illustrato nella tabella delle eccezioni del metodo, deve essere la prima istruzione nel blocco di codice del filtro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1913">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="45e2e-1914">Il `endfilter` istruzione deve essere l'ultima istruzione nel blocco di codice del filtro (pertanto può essere presente una sola `endfilter` per ogni blocco di filtro).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1914">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="45e2e-1915">Dopo l'esecuzione di `endfilter` (istruzione), il controllo passa di nuovo per il meccanismo di gestione delle eccezioni CLI.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1915">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="45e2e-1916">Il controllo non può essere trasferito in un blocco di filtro solo tramite il meccanismo di eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1916">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="45e2e-1917">Controllo non può essere trasferito all'esterno di un blocco di filtro solo tramite l'utilizzo di un `throw` istruzione o l'esecuzione finale `endfilter` istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1917">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="45e2e-1918">Non è possibile incorporare un `try` blocco all'interno di un `filter` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1918">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="45e2e-1919">Se viene generata un'eccezione all'interno di `filter` blocco, questo viene intercettato e un valore pari a 0 (`exception_continue_search`) viene restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1919">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="45e2e-1920">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `endfilter` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1920">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1921">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1921">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1922">Trasferisce il controllo dalla clausola <see langword="fault" /> o <see langword="finally" /> di un blocco di eccezioni al gestore di eccezioni di Common Language Infrastructure (CLI).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1922">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1923">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1923">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1924">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1924">Format</span></span>|<span data-ttu-id="45e2e-1925">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1925">Assembly Format</span></span>|<span data-ttu-id="45e2e-1926">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1926">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1927">DC</span><span class="sxs-lookup"><span data-stu-id="45e2e-1927">DC</span></span>|<span data-ttu-id="45e2e-1928">endfinally</span><span class="sxs-lookup"><span data-stu-id="45e2e-1928">endfinally</span></span><br /><br /> <span data-ttu-id="45e2e-1929">endfault</span><span class="sxs-lookup"><span data-stu-id="45e2e-1929">endfault</span></span>|<span data-ttu-id="45e2e-1930">Termina il `finally` o `fault` clausola di un blocco di eccezioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1930">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="45e2e-1931">Alcuni comportamenti sono caratteristici nessuno stack transizione per questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1931">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-1932">`Endfinally` e `endfault` segnalare la fine del `finally` o `fault` clausola in modo che la rimozione dello stack può continuare finché non viene richiamato il gestore di eccezioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1932">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="45e2e-1933">Il `endfinally` o `endfault` istruzione trasferisce il controllo al meccanismo delle eccezioni CLI.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1933">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="45e2e-1934">Il meccanismo quindi Cerca successivo `finally` clausola nella catena se il blocco protetto è stato terminato con un'istruzione leave.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1934">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="45e2e-1935">Se il blocco protetto è stato terminato con un'eccezione, l'interfaccia CLI eseguirà la ricerca per i prossimi `finally` o `fault`, oppure immettere il gestore di eccezioni scelto durante la prima sessione di gestione delle eccezioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1935">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="45e2e-1936">Un `endfinally` istruzione può essere presente solo livello lessicale interno un `finally` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1936">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="45e2e-1937">A differenza di `endfilter` (istruzione), non è necessario che il blocco terminano con un `endfinally` istruzioni e possono essere tante `endfinally` istruzioni all'interno del blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1937">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="45e2e-1938">Le stesse restrizioni si applicano al `endfault` istruzione e `fault` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1938">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="45e2e-1939">Il controllo non può essere trasferito in un `finally` (o `fault`) blocco tranne tramite il meccanismo di eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1939">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="45e2e-1940">Il controllo non può essere trasferito da un `finally` (o `fault`) blocco eccezione mediante l'utilizzo di un `throw` istruzione o l'esecuzione di `endfinally` (o `endfault`) (istruzione).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1940">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="45e2e-1941">In particolare, è possibile "uscire da" di un `finally` (o `fault`) blocco oppure eseguire un <xref:System.Reflection.Emit.OpCodes.Ret> o <xref:System.Reflection.Emit.OpCodes.Leave> istruzione all'interno di un `finally` (o `fault`) blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1941">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="45e2e-1942">Si noti che il `endfault` e `endfinally` sono alias, ovvero corrispondono allo stesso codice operativo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1942">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="45e2e-1943">Le operazioni seguenti <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `endfinally` (`endfault`) opcode, nonché il `ILGenerator` metodo <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1943">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="45e2e-1944">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1944">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="45e2e-1945">ILGenerator.EndExceptionBlock()</span><span class="sxs-lookup"><span data-stu-id="45e2e-1945">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1946">Inizializza un blocco specificato di memoria in corrispondenza di un indirizzo specifico su una dimensione e un valore iniziale dati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1946">Initializes a specified block of memory at a specific address to a given size and initial value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1947">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1947">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1948">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1948">Format</span></span>|<span data-ttu-id="45e2e-1949">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1949">Assembly Format</span></span>|<span data-ttu-id="45e2e-1950">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1950">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1951">FE 18</span><span class="sxs-lookup"><span data-stu-id="45e2e-1951">FE 18</span></span>|<span data-ttu-id="45e2e-1952">initblk</span><span class="sxs-lookup"><span data-stu-id="45e2e-1952">initblk</span></span>|<span data-ttu-id="45e2e-1953">Impostare ogni posizione in un blocco di memoria per un determinato valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1953">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="45e2e-1954">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1954">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1955">Un indirizzo iniziale viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1955">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1956">Un valore di inizializzazione viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1956">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-1957">Il numero di byte da inizializzare viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1957">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-1958">Il numero di byte, il valore di inizializzazione e l'indirizzo iniziale vengono estratti dallo stack e l'inizializzazione viene eseguita in base ai relativi valori.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1958">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="45e2e-1959">Il `initblk` il numero di set di istruzioni (`unsigned int32`) di byte a partire dall'indirizzo specificato (di tipo `native int`, `&`, o `*`) sul valore di inizializzazione (di tipo `unsigned int8`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-1959">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="45e2e-1960">`initblk` si presuppone che l'indirizzo iniziale è allineato alle dimensioni fisiche del computer.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1960">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="45e2e-1961">L'operazione del `initblk` istruzioni possono essere modificate da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1961">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-1962"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1962"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-1963">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `initblk` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1963">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1964">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1964">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1965">Inizializza ciascun campo del tipo di valore in corrispondenza di un indirizzo specifico su un riferimento Null o uno 0 di tipo primitivo appropriato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1965">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1966">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1966">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1967">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1967">Format</span></span>|<span data-ttu-id="45e2e-1968">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1968">Assembly Format</span></span>|<span data-ttu-id="45e2e-1969">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1969">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1970">FE 15 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-1970">FE 15 < `T` ></span></span>|<span data-ttu-id="45e2e-1971">`initobj` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="45e2e-1971">`initobj` `typeTok`</span></span>|<span data-ttu-id="45e2e-1972">Inizializza un tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1972">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="45e2e-1973">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1973">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1974">L'indirizzo del tipo di valore per inizializzare viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1974">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1975">L'indirizzo viene estratto dallo stack; il tipo di valore in corrispondenza dell'indirizzo specificato viene inizializzato come tipo `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1975">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="45e2e-1976">Il `initobj` istruzione Inizializza ciascun campo del tipo di valore specificato dall'indirizzo inserito (di tipo `native int`, `&`, o `*`) su un riferimento null o uno 0 di tipo primitivo appropriato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1976">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="45e2e-1977">Dopo la chiamata di questo metodo, l'istanza è pronta per un metodo del costruttore da chiamare.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1977">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="45e2e-1978">Se `typeTok` è un tipo riferimento, questa istruzione ha lo stesso effetto `ldnull` seguito da `stind.ref`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1978">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="45e2e-1979">A differenza di <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` non chiama il metodo del costruttore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1979">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="45e2e-1980">`Initobj` è destinato all'inizializzazione dei tipi di valore, mentre `newobj` viene utilizzato per allocare e inizializzare gli oggetti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1980">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="45e2e-1981">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `initobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-1982">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-1982">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-1983">Verifica se un riferimento a un oggetto di tipo <see langword="O" /> è un'istanza di una classe particolare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-1983">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-1984">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-1985">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-1985">Format</span></span>|<span data-ttu-id="45e2e-1986">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-1986">Assembly Format</span></span>|<span data-ttu-id="45e2e-1987">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-1987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-1988">75 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-1988">75 < `T` ></span></span>|<span data-ttu-id="45e2e-1989">isinst `class`</span><span class="sxs-lookup"><span data-stu-id="45e2e-1989">isinst `class`</span></span>|<span data-ttu-id="45e2e-1990">Verifica se un riferimento all'oggetto è un'istanza di `class`, che restituisce un riferimento null oppure un'istanza di tale classe o interfaccia.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1990">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="45e2e-1991">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-1991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-1992">Riferimento a un oggetto viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1992">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-1993">Il riferimento all'oggetto viene estratto dallo stack e testato per verificare se si tratta di un'istanza della classe passata `class`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1993">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="45e2e-1994">Il risultato (un riferimento all'oggetto o un riferimento null) viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1994">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-1995">`Class` è un token di metadati che indica la classe desiderata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1995">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="45e2e-1996">Se la classe dell'oggetto all'inizio dello stack implementa `class` (se `class` è un'interfaccia) o è una classe derivata di `class` (se `class` è una classe normale), quindi ne viene eseguito il cast nel tipo `class` e il risultato viene inserito nello stack, esattamente come se <xref:System.Reflection.Emit.OpCodes.Castclass> fosse stata chiamata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1996">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="45e2e-1997">In caso contrario, un riferimento null viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1997">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="45e2e-1998">Se il riferimento all'oggetto stesso è un riferimento null, quindi `isinst` Analogamente restituisce un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1998">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-1999"><xref:System.TypeLoadException> viene generata se non è possibile trovare la classe.</span><span class="sxs-lookup"><span data-stu-id="45e2e-1999"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="45e2e-2000">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2000">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-2001">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `isinst` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2002">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2002">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2003">Esce dal metodo corrente e passa a quello specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2003">Exits current method and jumps to specified method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2004">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2005">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2005">Format</span></span>|<span data-ttu-id="45e2e-2006">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2006">Assembly Format</span></span>|<span data-ttu-id="45e2e-2007">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2008">27 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2008">27 < `T` ></span></span>|<span data-ttu-id="45e2e-2009">jmp `method`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2009">jmp `method`</span></span>|<span data-ttu-id="45e2e-2010">Esce dal metodo corrente e passa al metodo specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2010">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="45e2e-2011">Alcuni comportamenti sono caratteristici nessuno stack transizione per questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2011">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-2012">Il `jmp` istruzione (jump) trasferisce il controllo al metodo specificato da `method`, ovvero un token di metadati per un riferimento al metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2012">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="45e2e-2013">Gli argomenti correnti vengono trasferiti al metodo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2013">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="45e2e-2014">Stack di valutazione deve essere vuoto quando viene eseguita questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2014">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="45e2e-2015">Convenzione di chiamata, numero e tipo di argomenti in corrispondenza dell'indirizzo di destinazione deve corrispondere a quello del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2015">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="45e2e-2016">Il `jmp` istruzione non può essere utilizzata per trasferire il controllo di un `try`, `filter`, `catch`, o `finally` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2016">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="45e2e-2017">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `jmp` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2017">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2018">ILGenerator (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2018">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2019">Carica un argomento (a cui fa riferimento un valore di indice specificato) nello stack.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2019">Loads an argument (referenced by a specified index value) onto the stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2020">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2021">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2021">Format</span></span>|<span data-ttu-id="45e2e-2022">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2022">Assembly Format</span></span>|<span data-ttu-id="45e2e-2023">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2024">FE 09 &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2024">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="45e2e-2025">ldarg `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2025">ldarg `index`</span></span>|<span data-ttu-id="45e2e-2026">Carica l'argomento in `index` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2026">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2027">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2028">Valore dell'argomento in `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2028">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2029">Il `ldarg` istruzione inserisce l'argomento indicizzato in `index`, in cui gli argomenti sono indicizzati da 0 in avanti, nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2029">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2030">Il `ldarg` istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2030">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45e2e-2031">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2031">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45e2e-2032">Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il `ldarg` istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato (vedere il <xref:System.Reflection.Emit.OpCodes.Arglist> istruzioni per altri dettagli).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2032">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="45e2e-2033">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2033">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-2034">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2034">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-2035">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldarg` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2035">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2036">ILGenerator (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2036">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2037">Carica l'argomento in corrispondenza dell'indice 0 nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2037">Loads the argument at index 0 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2038">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2038">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2039">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2039">Format</span></span>|<span data-ttu-id="45e2e-2040">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2040">Assembly Format</span></span>|<span data-ttu-id="45e2e-2041">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2041">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2042">02</span><span class="sxs-lookup"><span data-stu-id="45e2e-2042">02</span></span>|<span data-ttu-id="45e2e-2043">ldarg.0</span><span class="sxs-lookup"><span data-stu-id="45e2e-2043">ldarg.0</span></span>|<span data-ttu-id="45e2e-2044">Carica l'argomento 0 nello stack</span><span class="sxs-lookup"><span data-stu-id="45e2e-2044">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="45e2e-2045">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2045">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2046">Il valore dell'argomento in corrispondenza dell'indice 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2046">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2047">Il `ldarg.0` istruzione rappresenta una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2047">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="45e2e-2048">Il `ldarg.0` istruzione inserisce l'argomento dell'indice 0 nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2048">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2049">Il `ldarg.0` istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2049">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45e2e-2050">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2050">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45e2e-2051">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2051">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-2052">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2052">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-2053">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldarg.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2053">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2054">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2054">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2055">Carica l'argomento in corrispondenza dell'indice 1 nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2055">Loads the argument at index 1 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2056">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2056">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2057">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2057">Format</span></span>|<span data-ttu-id="45e2e-2058">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2058">Assembly Format</span></span>|<span data-ttu-id="45e2e-2059">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2059">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2060">03</span><span class="sxs-lookup"><span data-stu-id="45e2e-2060">03</span></span>|<span data-ttu-id="45e2e-2061">ldarg.1</span><span class="sxs-lookup"><span data-stu-id="45e2e-2061">ldarg.1</span></span>|<span data-ttu-id="45e2e-2062">Carica l'argomento 1 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2062">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2063">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2063">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2064">Il valore dell'argomento in corrispondenza dell'indice 1 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2064">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2065">Il `ldarg.1` istruzione rappresenta una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 1.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2065">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="45e2e-2066">Il `ldarg.1` istruzione inserisce l'argomento dell'indice 1 nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2066">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2067">Il `ldarg.1` istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2067">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45e2e-2068">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2068">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45e2e-2069">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2069">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-2070">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2070">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-2071">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldarg.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2071">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2072">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2072">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2073">Carica l'argomento in corrispondenza dell'indice 2 nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2073">Loads the argument at index 2 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2074">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2074">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2075">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2075">Format</span></span>|<span data-ttu-id="45e2e-2076">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2076">Assembly Format</span></span>|<span data-ttu-id="45e2e-2077">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2077">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2078">04</span><span class="sxs-lookup"><span data-stu-id="45e2e-2078">04</span></span>|<span data-ttu-id="45e2e-2079">ldarg.2</span><span class="sxs-lookup"><span data-stu-id="45e2e-2079">ldarg.2</span></span>|<span data-ttu-id="45e2e-2080">Carica l'argomento 2 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2080">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2081">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2081">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2082">Il valore dell'argomento in corrispondenza dell'indice 2 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2082">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2083">Il `ldarg.2` istruzione rappresenta una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 2.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2083">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="45e2e-2084">Il `ldarg.2` istruzione inserisce l'argomento dell'indice 2 nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2084">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2085">Il `ldarg.2` istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2085">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45e2e-2086">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2086">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45e2e-2087">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2087">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-2088">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2088">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-2089">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldarg.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2089">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2090">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2090">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2091">Carica l'argomento in corrispondenza dell'indice 3 nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2091">Loads the argument at index 3 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2092">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2092">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2093">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2093">Format</span></span>|<span data-ttu-id="45e2e-2094">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2094">Assembly Format</span></span>|<span data-ttu-id="45e2e-2095">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2095">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2096">05</span><span class="sxs-lookup"><span data-stu-id="45e2e-2096">05</span></span>|<span data-ttu-id="45e2e-2097">ldarg.3</span><span class="sxs-lookup"><span data-stu-id="45e2e-2097">ldarg.3</span></span>|<span data-ttu-id="45e2e-2098">Carica l'argomento 3 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2098">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2099">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2099">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2100">Il valore dell'argomento in corrispondenza dell'indice 3 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2100">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2101">Il `ldarg.3` istruzione rappresenta una codifica efficiente per il caricamento del valore di argomento in corrispondenza dell'indice 3.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2101">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="45e2e-2102">Il `ldarg.3` istruzione inserisce l'argomento dell'indice 3 nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2102">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2103">Il `ldarg.3` istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2103">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45e2e-2104">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2104">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45e2e-2105">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2105">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-2106">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2106">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-2107">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldarg.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2107">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2108">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2108">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2109">Carica l'argomento (a cui fa riferimento un indice specificato in forma breve) nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2109">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2110">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2111">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2111">Format</span></span>|<span data-ttu-id="45e2e-2112">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2112">Assembly Format</span></span>|<span data-ttu-id="45e2e-2113">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2114">0E &LT; `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2114">0E < `unsigned int8` ></span></span>|<span data-ttu-id="45e2e-2115">ldarg.s `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2115">ldarg.s `index`</span></span>|<span data-ttu-id="45e2e-2116">Carica l'argomento in `index` nello stack, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2116">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-2117">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2118">Valore dell'argomento in `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2118">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2119">Il `ldarg.s` istruzione rappresenta una codifica efficiente per il caricamento degli argomenti indicizzati da 4 a 255.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2119">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="45e2e-2120">Il `ldarg.s` istruzione inserisce l'argomento indicizzato in `index`, in cui gli argomenti sono indicizzati da 0 in avanti, nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2120">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2121">Il `ldarg.s` istruzione può essere utilizzato per caricare un tipo di valore o un valore primitivo nello stack copiandoli da un argomento in entrata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2121">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45e2e-2122">Il tipo del valore dell'argomento è identico al tipo dell'argomento, come specificato dalla firma del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2122">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45e2e-2123">Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il `ldarg.s` istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato (vedere il <xref:System.Reflection.Emit.OpCodes.Arglist> istruzioni per altri dettagli).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2123">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="45e2e-2124">Gli argomenti che contengono un valore integer minore di 4 byte vengono espansi nel tipo `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2124">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-2125">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2125">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-2126">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldarg.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2126">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2127">ILGenerator (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2127">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2128">Carica l'indirizzo di un argomento nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2128">Load an argument address onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2129">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2129">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2130">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2130">Format</span></span>|<span data-ttu-id="45e2e-2131">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2131">Assembly Format</span></span>|<span data-ttu-id="45e2e-2132">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2132">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2133">FE 0A &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2133">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="45e2e-2134">ldarga `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2134">ldarga `index`</span></span>|<span data-ttu-id="45e2e-2135">Recupera l'indirizzo dell'argomento indicizzato da `index`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2135">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="45e2e-2136">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2136">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2137">L'indirizzo `addr` dell'argomento indicizzato da `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2137">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2138">Il `ldarga` istruzione recupera l'indirizzo (di tipo `*`) dell'argomento indicizzato da `index`, in cui gli argomenti sono indicizzati da 0 in avanti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2138">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="45e2e-2139">L'indirizzo `addr` allineato sempre a un limite naturale sul computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2139">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="45e2e-2140">Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il `ldarga` istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2140">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="45e2e-2141">`ldarga` viene utilizzato per il passaggio di parametri per riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2141">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="45e2e-2142">Per gli altri casi, <xref:System.Reflection.Emit.OpCodes.Ldarg> e <xref:System.Reflection.Emit.OpCodes.Starg> deve essere utilizzato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2142">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="45e2e-2143">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldarga` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2143">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2144">ILGenerator (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2144">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2145">Carica l'indirizzo di un argomento, in forma breve, nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2145">Load an argument address, in short form, onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2146">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2146">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2147">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2147">Format</span></span>|<span data-ttu-id="45e2e-2148">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2148">Assembly Format</span></span>|<span data-ttu-id="45e2e-2149">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2149">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2150">0F < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2150">0F < `unsigned int8` ></span></span>|<span data-ttu-id="45e2e-2151">ldarga.s `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2151">ldarga.s `index`</span></span>|<span data-ttu-id="45e2e-2152">Recupera l'indirizzo dell'argomento indicizzato da `index`, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2152">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-2153">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2153">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2154">L'indirizzo `addr` dell'argomento indicizzato da `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2154">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2155">`ldarga.s` (la versione abbreviata di `ldarga`) è una codifica più efficiente e deve essere utilizzato per i numeri da 0 a 255 argomenti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2155">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="45e2e-2156">Il `ldarga.s` istruzione recupera l'indirizzo (di tipo`*`) dell'argomento indicizzato da `index`, in cui gli argomenti sono indicizzati da 0 in avanti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2156">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="45e2e-2157">L'indirizzo `addr` allineato sempre a un limite naturale sul computer di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2157">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="45e2e-2158">Per le procedure che accettano un elenco di argomenti a lunghezza variabile, il `ldarga.s` istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2158">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="45e2e-2159">`ldarga.s` viene utilizzato per il passaggio di parametri per riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2159">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="45e2e-2160">Per gli altri casi, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> e <xref:System.Reflection.Emit.OpCodes.Starg_S> deve essere utilizzato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2160">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="45e2e-2161">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldarga.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2161">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2162">ILGenerator (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2162">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2163">Inserisce un valore fornito di tipo <see langword="int32" /> nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2163">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2164">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2164">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2165">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2165">Format</span></span>|<span data-ttu-id="45e2e-2166">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2166">Assembly Format</span></span>|<span data-ttu-id="45e2e-2167">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2167">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2168">20 < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2168">20 < `int32` ></span></span>|<span data-ttu-id="45e2e-2169">ldc.i4 `num`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2169">ldc.i4 `num`</span></span>|<span data-ttu-id="45e2e-2170">Inserisce il valore `num` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2170">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2171">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2171">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2172">Il valore `num` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2172">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2173">Si noti che sono disponibili speciali codifiche brevi e pertanto più efficiente, per i numeri interi da -128 a 127 e specialmente codifiche brevi per -1 e 8.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2173">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="45e2e-2174">Tutte le codifiche short push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2174">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="45e2e-2175">Codifiche più vengono utilizzate per i valori integer a 8 byte e 4 e 8 numeri a virgola mobile in byte, nonché i valori a 4 byte che non rientrano nei form di breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2175">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="45e2e-2176">Esistono tre modi per inserire una costante integer a 8 byte nello stack</span><span class="sxs-lookup"><span data-stu-id="45e2e-2176">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="45e2e-2177">Utilizzare il <xref:System.Reflection.Emit.OpCodes.Ldc_I8> istruzione per le costanti che devono essere espressi in più di 32 bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2177">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="45e2e-2178">Utilizzare il <xref:System.Reflection.Emit.OpCodes.Ldc_I4> istruzione seguita da un <xref:System.Reflection.Emit.OpCodes.Conv_I8> per le costanti che richiedono da 9 a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="45e2e-2179">Utilizzare un'istruzione abbreviata seguita da un <xref:System.Reflection.Emit.OpCodes.Conv_I8> per le costanti che possono essere espressi con un massimo di 8 bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2179">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="45e2e-2180">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2181">ILGenerator (OpCode, int)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2181">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2182">Inserisce il valore intero 0 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2182">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2183">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2184">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2184">Format</span></span>|<span data-ttu-id="45e2e-2185">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2185">Assembly Format</span></span>|<span data-ttu-id="45e2e-2186">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2187">16</span><span class="sxs-lookup"><span data-stu-id="45e2e-2187">16</span></span>|<span data-ttu-id="45e2e-2188">ldc.i4.0</span><span class="sxs-lookup"><span data-stu-id="45e2e-2188">ldc.i4.0</span></span>|<span data-ttu-id="45e2e-2189">Inserisce 0 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2189">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2190">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2191">Il valore 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2191">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2192">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2192">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2193">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2193">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2194">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2194">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2195">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2195">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2196">Inserisce il valore intero 1 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2196">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2197">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2197">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2198">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2198">Format</span></span>|<span data-ttu-id="45e2e-2199">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2199">Assembly Format</span></span>|<span data-ttu-id="45e2e-2200">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2200">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2201">17</span><span class="sxs-lookup"><span data-stu-id="45e2e-2201">17</span></span>|<span data-ttu-id="45e2e-2202">ldc.i4.1</span><span class="sxs-lookup"><span data-stu-id="45e2e-2202">ldc.i4.1</span></span>|<span data-ttu-id="45e2e-2203">Inserisce 1 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2203">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2204">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2204">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2205">Il valore 1 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2205">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2206">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2206">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2207">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2207">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2208">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2209">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2209">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2210">Inserisce il valore intero 2 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2210">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2211">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2212">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2212">Format</span></span>|<span data-ttu-id="45e2e-2213">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2213">Assembly Format</span></span>|<span data-ttu-id="45e2e-2214">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2215">18</span><span class="sxs-lookup"><span data-stu-id="45e2e-2215">18</span></span>|<span data-ttu-id="45e2e-2216">ldc.i4.2</span><span class="sxs-lookup"><span data-stu-id="45e2e-2216">ldc.i4.2</span></span>|<span data-ttu-id="45e2e-2217">Inserisce 2 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2217">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2218">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2219">Il valore 2 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2219">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2220">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2220">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2221">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2221">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2222">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2222">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2223">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2223">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2224">Inserisce il valore intero 3 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2224">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2225">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2225">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2226">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2226">Format</span></span>|<span data-ttu-id="45e2e-2227">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2227">Assembly Format</span></span>|<span data-ttu-id="45e2e-2228">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2228">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2229">19</span><span class="sxs-lookup"><span data-stu-id="45e2e-2229">19</span></span>|<span data-ttu-id="45e2e-2230">ldc.i4.3</span><span class="sxs-lookup"><span data-stu-id="45e2e-2230">ldc.i4.3</span></span>|<span data-ttu-id="45e2e-2231">Inserisce 3 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2231">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2232">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2232">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2233">Il valore 3 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2233">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2234">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2234">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2235">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2235">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2236">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2236">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2237">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2237">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2238">Inserisce il valore intero 4 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2238">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2239">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2239">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2240">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2240">Format</span></span>|<span data-ttu-id="45e2e-2241">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2241">Assembly Format</span></span>|<span data-ttu-id="45e2e-2242">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2242">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2243">1A</span><span class="sxs-lookup"><span data-stu-id="45e2e-2243">1A</span></span>|<span data-ttu-id="45e2e-2244">ldc.i4.4</span><span class="sxs-lookup"><span data-stu-id="45e2e-2244">ldc.i4.4</span></span>|<span data-ttu-id="45e2e-2245">Inserisce 4 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2245">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2246">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2246">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2247">Il valore 4 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2247">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2248">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2248">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2249">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2249">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2250">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2251">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2252">Inserisce il valore intero 5 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2252">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2253">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2254">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2254">Format</span></span>|<span data-ttu-id="45e2e-2255">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2255">Assembly Format</span></span>|<span data-ttu-id="45e2e-2256">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2257">1B</span><span class="sxs-lookup"><span data-stu-id="45e2e-2257">1B</span></span>|<span data-ttu-id="45e2e-2258">ldc.i4.5</span><span class="sxs-lookup"><span data-stu-id="45e2e-2258">ldc.i4.5</span></span>|<span data-ttu-id="45e2e-2259">Inserisce 5 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2259">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2260">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2261">Il valore 5 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2261">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2262">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2262">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2263">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2263">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2264">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.5` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2264">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2265">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2265">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2266">Inserisce il valore intero 6 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2266">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2267">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2267">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2268">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2268">Format</span></span>|<span data-ttu-id="45e2e-2269">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2269">Assembly Format</span></span>|<span data-ttu-id="45e2e-2270">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2270">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2271">1C</span><span class="sxs-lookup"><span data-stu-id="45e2e-2271">1C</span></span>|<span data-ttu-id="45e2e-2272">ldc.i4.6</span><span class="sxs-lookup"><span data-stu-id="45e2e-2272">ldc.i4.6</span></span>|<span data-ttu-id="45e2e-2273">Inserisce 6 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2273">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2274">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2274">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2275">Il valore 6 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2275">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2276">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2276">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2277">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2277">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2278">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.6` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2278">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2279">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2279">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2280">Inserisce il valore intero 7 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2280">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2281">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2281">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2282">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2282">Format</span></span>|<span data-ttu-id="45e2e-2283">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2283">Assembly Format</span></span>|<span data-ttu-id="45e2e-2284">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2284">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2285">1D</span><span class="sxs-lookup"><span data-stu-id="45e2e-2285">1D</span></span>|<span data-ttu-id="45e2e-2286">ldc.i4.7</span><span class="sxs-lookup"><span data-stu-id="45e2e-2286">ldc.i4.7</span></span>|<span data-ttu-id="45e2e-2287">Inserisce 7 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2287">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2288">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2288">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2289">Il valore 7 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2289">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2290">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2290">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2291">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2291">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2292">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.7` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2293">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2293">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2294">Inserisce il valore intero 8 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2294">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2295">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2296">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2296">Format</span></span>|<span data-ttu-id="45e2e-2297">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2297">Assembly Format</span></span>|<span data-ttu-id="45e2e-2298">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2299">1E</span><span class="sxs-lookup"><span data-stu-id="45e2e-2299">1E</span></span>|<span data-ttu-id="45e2e-2300">ldc.i4.8</span><span class="sxs-lookup"><span data-stu-id="45e2e-2300">ldc.i4.8</span></span>|<span data-ttu-id="45e2e-2301">Inserisce 8 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2301">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2302">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2303">Il valore 8 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2303">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2304">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2304">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2305">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2305">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2306">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2306">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2307">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2307">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2308">Inserisce il valore intero -1 nello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2308">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2309">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2309">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2310">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2310">Format</span></span>|<span data-ttu-id="45e2e-2311">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2311">Assembly Format</span></span>|<span data-ttu-id="45e2e-2312">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2312">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2313">15</span><span class="sxs-lookup"><span data-stu-id="45e2e-2313">15</span></span>|<span data-ttu-id="45e2e-2314">ldc.i4.m1</span><span class="sxs-lookup"><span data-stu-id="45e2e-2314">ldc.i4.m1</span></span>|<span data-ttu-id="45e2e-2315">Inserisce -1 nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2315">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2316">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2316">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2317">Il valore -1 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2317">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2318">Si tratta di una speciale codifica breve per il push dell'integer 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2318">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45e2e-2319">Tutte le codifiche short speciali push interi a 4 byte nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2319">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2320">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.m1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2321">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2322">Inserisce il valore fornito <see langword="int8" /> nello stack di valutazione come <see langword="int32" /> (forma breve).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2322">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2323">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2324">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2324">Format</span></span>|<span data-ttu-id="45e2e-2325">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2325">Assembly Format</span></span>|<span data-ttu-id="45e2e-2326">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2327">1F < `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2327">1F < `int8` ></span></span>|<span data-ttu-id="45e2e-2328">ldc.i4.s `num`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2328">ldc.i4.s `num`</span></span>|<span data-ttu-id="45e2e-2329">Inserisce `num` nello stack come `int32`, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2329">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-2330">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2331">Il valore `num` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2331">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2332">`ldc.i4.s` è una codifica più efficiente per l'inserimento di numeri interi compresi tra -128 a 127 nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2332">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2333">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i4.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2333">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2334">ILGenerator (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2334">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2335">Inserisce un valore fornito di tipo <see langword="int64" /> nello stack di valutazione come <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2335">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2336">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2336">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2337">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2337">Format</span></span>|<span data-ttu-id="45e2e-2338">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2338">Assembly Format</span></span>|<span data-ttu-id="45e2e-2339">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2339">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2340">21 < `int64` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2340">21 < `int64` ></span></span>|<span data-ttu-id="45e2e-2341">ldc.i8 `num`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2341">ldc.i8 `num`</span></span>|<span data-ttu-id="45e2e-2342">Inserisce `num` nello stack come `int64`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2342">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="45e2e-2343">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2343">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2344">Il valore `num` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2344">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2345">Questa codifica inserisce un `int64` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2345">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2346">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2346">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2347">ILGenerator (OpCode, long)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2347">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2348">Inserisce un valore fornito di tipo <see langword="float32" /> nello stack di valutazione come tipo <see langword="F" /> (float).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2348">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2349">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2349">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2350">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2350">Format</span></span>|<span data-ttu-id="45e2e-2351">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2351">Assembly Format</span></span>|<span data-ttu-id="45e2e-2352">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2352">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2353">22 < `float32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2353">22 < `float32` ></span></span>|<span data-ttu-id="45e2e-2354">ldc.r4 `num`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2354">ldc.r4 `num`</span></span>|<span data-ttu-id="45e2e-2355">Inserisce `num` nello stack come `F`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2355">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="45e2e-2356">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2356">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2357">Il valore `num` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2357">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2358">Questa codifica inserisce un `float32` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2358">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2359">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2359">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2360">ILGenerator (OpCode, singolo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2360">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2361">Inserisce un valore fornito di tipo <see langword="float64" /> nello stack di valutazione come tipo <see langword="F" /> (float).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2361">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2362">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2362">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2363">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2363">Format</span></span>|<span data-ttu-id="45e2e-2364">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2364">Assembly Format</span></span>|<span data-ttu-id="45e2e-2365">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2365">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2366">23 < `float64` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2366">23 < `float64` ></span></span>|<span data-ttu-id="45e2e-2367">ldc.r8 `num`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2367">ldc.r8 `num`</span></span>|<span data-ttu-id="45e2e-2368">Inserisce `num` nello stack come `F`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2368">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="45e2e-2369">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2369">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2370">Il valore `num` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2370">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2371">Questa codifica inserisce un `float64` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2371">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2372">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldc.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2373">ILGenerator (OpCode, double)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2373">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2374">Carica l'elemento in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo specificato nell'istruzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2374">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2375">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2375">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2376">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2376">Format</span></span>|<span data-ttu-id="45e2e-2377">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2377">Assembly Format</span></span>|<span data-ttu-id="45e2e-2378">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2379">A3 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2379">A3 < `T` ></span></span>|<span data-ttu-id="45e2e-2380">ldelem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2380">ldelem `typeTok`</span></span>|<span data-ttu-id="45e2e-2381">Carica l'elemento in `index` all'inizio dello stack come tipo `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2381">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="45e2e-2382">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2383">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2383">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2384">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2384">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2385">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2385">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2386">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2386">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2387">Il `ldelem` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2387">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2388">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2388">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2389">Il tipo del valore restituito è specificato il token `typeTok` nell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2389">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="45e2e-2390"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2390"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2391"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite superiore di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2391"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2392">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2392">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2393">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2393">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2394">Carica l'elemento con tipo <see langword="native int" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="native int" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2394">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2395">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2395">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2396">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2396">Format</span></span>|<span data-ttu-id="45e2e-2397">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2397">Assembly Format</span></span>|<span data-ttu-id="45e2e-2398">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2398">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2399">97</span><span class="sxs-lookup"><span data-stu-id="45e2e-2399">97</span></span>|<span data-ttu-id="45e2e-2400">ldelem.i</span><span class="sxs-lookup"><span data-stu-id="45e2e-2400">ldelem.i</span></span>|<span data-ttu-id="45e2e-2401">Carica l'elemento con il tipo `native int` in `index` all'inizio dello stack come un `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2401">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="45e2e-2402">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2402">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2403">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2403">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2404">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2404">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2405">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2405">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2406">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2406">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2407">Il `ldelem.i` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2407">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2408">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2408">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2409">Il valore restituito per `ldelem.i` è `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2409">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-2410">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2410">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2411"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2411"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2412"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2412"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2413"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2413"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2414">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2414">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2415">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2415">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2416">Carica l'elemento con tipo <see langword="int8" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2416">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2417">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2417">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2418">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2418">Format</span></span>|<span data-ttu-id="45e2e-2419">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2419">Assembly Format</span></span>|<span data-ttu-id="45e2e-2420">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2420">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2421">90</span><span class="sxs-lookup"><span data-stu-id="45e2e-2421">90</span></span>|<span data-ttu-id="45e2e-2422">ldelem.i1</span><span class="sxs-lookup"><span data-stu-id="45e2e-2422">ldelem.i1</span></span>|<span data-ttu-id="45e2e-2423">Carica l'elemento con il tipo `int8` in `index` all'inizio dello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2423">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2424">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2424">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2425">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2425">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2426">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2426">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2427">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2427">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2428">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2428">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2429">Il `ldelem.i1` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2429">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2430">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2430">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2431">Il valore restituito per `ldelem.i1` è `int8`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2431">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="45e2e-2432">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2432">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2433"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2433"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2434"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2434"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2435"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2435"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2436">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2436">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2437">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2437">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2438">Carica l'elemento con tipo <see langword="int16" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2438">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2439">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2439">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2440">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2440">Format</span></span>|<span data-ttu-id="45e2e-2441">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2441">Assembly Format</span></span>|<span data-ttu-id="45e2e-2442">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2442">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2443">92</span><span class="sxs-lookup"><span data-stu-id="45e2e-2443">92</span></span>|<span data-ttu-id="45e2e-2444">ldelem.i2</span><span class="sxs-lookup"><span data-stu-id="45e2e-2444">ldelem.i2</span></span>|<span data-ttu-id="45e2e-2445">Carica l'elemento con il tipo `int16` in `index` all'inizio dello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2445">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2446">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2446">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2447">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2447">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2448">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2448">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2449">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2449">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2450">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2450">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2451">Il `ldelem.i2` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2451">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2452">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2452">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2453">Il valore restituito per `ldelem.i2` è `int16`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2453">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="45e2e-2454">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2454">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2455"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2455"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2456"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2456"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2457"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2457"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2458">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2458">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2459">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2459">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2460">Carica l'elemento con tipo <see langword="int32" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2460">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2461">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2461">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2462">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2462">Format</span></span>|<span data-ttu-id="45e2e-2463">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2463">Assembly Format</span></span>|<span data-ttu-id="45e2e-2464">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2464">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2465">94</span><span class="sxs-lookup"><span data-stu-id="45e2e-2465">94</span></span>|<span data-ttu-id="45e2e-2466">ldelem.i4</span><span class="sxs-lookup"><span data-stu-id="45e2e-2466">ldelem.i4</span></span>|<span data-ttu-id="45e2e-2467">Carica l'elemento con il tipo `int32` in `index` all'inizio dello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2467">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2468">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2468">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2469">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2469">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2470">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2470">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2471">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2471">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2472">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2472">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2473">Il `ldelem.i4` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2473">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2474">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2474">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2475">Il valore restituito per `ldelem.i4` è `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2475">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="45e2e-2476">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2476">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2477"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2477"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2478"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2478"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2479"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2479"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2480">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2481">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2482">Carica l'elemento con tipo <see langword="int64" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int64" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2482">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2483">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2484">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2484">Format</span></span>|<span data-ttu-id="45e2e-2485">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2485">Assembly Format</span></span>|<span data-ttu-id="45e2e-2486">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2487">96</span><span class="sxs-lookup"><span data-stu-id="45e2e-2487">96</span></span>|<span data-ttu-id="45e2e-2488">ldelem.i8</span><span class="sxs-lookup"><span data-stu-id="45e2e-2488">ldelem.i8</span></span>|<span data-ttu-id="45e2e-2489">Carica l'elemento con il tipo `int64` in `index` all'inizio dello stack come un `int64`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2489">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="45e2e-2490">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2491">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2491">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2492">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2492">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2493">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2493">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2494">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2494">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2495">Il `ldelem.i8` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2495">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2496">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2496">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2497">Il valore restituito per `ldelem.i8` è `int64`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2497">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="45e2e-2498">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2498">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2499"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2499"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2500"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2500"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2501"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2501"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2502">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2502">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2503">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2503">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2504">Carica l'elemento con tipo <see langword="float32" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo <see langword="F" /> (float).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2504">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2505">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2505">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2506">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2506">Format</span></span>|<span data-ttu-id="45e2e-2507">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2507">Assembly Format</span></span>|<span data-ttu-id="45e2e-2508">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2508">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2509">98</span><span class="sxs-lookup"><span data-stu-id="45e2e-2509">98</span></span>|<span data-ttu-id="45e2e-2510">ldelem.r4</span><span class="sxs-lookup"><span data-stu-id="45e2e-2510">ldelem.r4</span></span>|<span data-ttu-id="45e2e-2511">Carica l'elemento con il tipo `float32` in `index` all'inizio dello stack come un tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2511">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="45e2e-2512">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2512">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2513">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2513">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2514">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2514">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2515">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2515">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2516">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2516">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2517">Il `ldelem.r4` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2517">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2518">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2518">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2519">Il valore restituito per `ldelem.r4` è `float32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2519">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="45e2e-2520">Valori a virgola mobile vengono convertiti nel tipo `F` quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2520">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2521"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2521"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2522"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2522"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2523"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2523"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2524">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2524">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2525">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2525">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2526">Carica l'elemento con tipo <see langword="float64" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo <see langword="F" /> (float).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2526">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2527">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2527">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2528">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2528">Format</span></span>|<span data-ttu-id="45e2e-2529">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2529">Assembly Format</span></span>|<span data-ttu-id="45e2e-2530">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2530">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2531">99</span><span class="sxs-lookup"><span data-stu-id="45e2e-2531">99</span></span>|<span data-ttu-id="45e2e-2532">ldelem.r8</span><span class="sxs-lookup"><span data-stu-id="45e2e-2532">ldelem.r8</span></span>|<span data-ttu-id="45e2e-2533">Carica l'elemento con il tipo `float64` in `index` all'inizio dello stack come tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2533">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="45e2e-2534">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2534">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2535">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2535">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2536">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2536">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2537">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2537">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2538">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2538">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2539">Il `ldelem.r8` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2539">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2540">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2540">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2541">Il valore restituito per `ldelem.r8` è `float64`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2541">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="45e2e-2542">Valori a virgola mobile vengono convertiti nel tipo `F` quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2542">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2543"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2543"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2544"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2544"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2545"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2545"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2546">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2546">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2547">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2547">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2548">Carica l'elemento contenente un riferimento a un oggetto in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come tipo <see langword="O" /> (riferimento a un oggetto).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2548">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2549">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2549">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2550">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2550">Format</span></span>|<span data-ttu-id="45e2e-2551">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2551">Assembly Format</span></span>|<span data-ttu-id="45e2e-2552">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2552">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2553">9A</span><span class="sxs-lookup"><span data-stu-id="45e2e-2553">9A</span></span>|<span data-ttu-id="45e2e-2554">ldelem.ref</span><span class="sxs-lookup"><span data-stu-id="45e2e-2554">ldelem.ref</span></span>|<span data-ttu-id="45e2e-2555">Carica l'elemento con un riferimento all'oggetto in `index` all'inizio dello stack come tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2555">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="45e2e-2556">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2556">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2557">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2557">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2558">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2558">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2559">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2559">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2560">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2560">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2561">Il `ldelem.ref` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2561">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2562">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2562">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2563">Il valore restituito per `ldelem.ref` è di tipo `O` (riferimento all'oggetto).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2563">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="45e2e-2564"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2564"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2565"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2565"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2566"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2566"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2567">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2567">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2568">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2568">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2569">Carica l'elemento con tipo <see langword="unsigned int8" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2569">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2570">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2570">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2571">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2571">Format</span></span>|<span data-ttu-id="45e2e-2572">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2572">Assembly Format</span></span>|<span data-ttu-id="45e2e-2573">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2573">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2574">91</span><span class="sxs-lookup"><span data-stu-id="45e2e-2574">91</span></span>|<span data-ttu-id="45e2e-2575">ldelem.u1</span><span class="sxs-lookup"><span data-stu-id="45e2e-2575">ldelem.u1</span></span>|<span data-ttu-id="45e2e-2576">Carica l'elemento con il tipo `unsigned int8` in `index` all'inizio dello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2576">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2577">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2577">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2578">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2578">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2579">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2579">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2580">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2580">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2581">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2581">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2582">Il `ldelem.u1` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2582">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2583">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2583">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2584">Il valore restituito per `ldelem.u1` è `int8`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2584">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="45e2e-2585">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2585">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2586"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2586"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2587"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2587"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2588"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2588"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2589">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2589">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2590">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2590">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2591">Carica l'elemento con tipo <see langword="unsigned int16" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2591">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2592">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2592">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2593">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2593">Format</span></span>|<span data-ttu-id="45e2e-2594">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2594">Assembly Format</span></span>|<span data-ttu-id="45e2e-2595">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2595">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2596">93</span><span class="sxs-lookup"><span data-stu-id="45e2e-2596">93</span></span>|<span data-ttu-id="45e2e-2597">ldelem.u2</span><span class="sxs-lookup"><span data-stu-id="45e2e-2597">ldelem.u2</span></span>|<span data-ttu-id="45e2e-2598">Carica l'elemento con il tipo `unsigned int16` in corrispondenza dell'indice di inizio dello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2598">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2599">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2599">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2600">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2600">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2601">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2601">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2602">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2602">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2603">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2603">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2604">Il `ldelem.u2` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2604">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2605">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2605">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2606">Il valore restituito per `ldelem.u2` è `int16`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2606">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="45e2e-2607">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2607">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2608"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2608"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2609"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2609"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2610"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2610"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2611">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2611">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2612">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2612">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2613">Carica l'elemento con tipo <see langword="unsigned int32" /> in corrispondenza dell'indice di matrice specificato all'inizio dello stack di valutazione come <see langword="int32" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2613">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2614">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2614">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2615">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2615">Format</span></span>|<span data-ttu-id="45e2e-2616">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2616">Assembly Format</span></span>|<span data-ttu-id="45e2e-2617">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2617">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2618">95</span><span class="sxs-lookup"><span data-stu-id="45e2e-2618">95</span></span>|<span data-ttu-id="45e2e-2619">ldelem.u4</span><span class="sxs-lookup"><span data-stu-id="45e2e-2619">ldelem.u4</span></span>|<span data-ttu-id="45e2e-2620">Carica l'elemento con il tipo `unsigned int32` in corrispondenza dell'indice di inizio dello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2620">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2621">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2621">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2622">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2622">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2623">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2623">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2624">`index` e `array` vengono estratti dallo stack; il valore archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2624">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2625">Il valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2625">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2626">Il `ldelem.u4` istruzione carica il valore dell'elemento con indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2626">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2627">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2627">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2628">Il valore restituito per `ldelem.u4` è `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2628">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="45e2e-2629">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2629">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2630"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2630"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2631"><xref:System.ArrayTypeMismatchException> viene generata se matrice non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2631"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2632"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2632"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2633">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelem.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2633">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2634">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2634">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2635">Carica l'indirizzo dell'elemento di matrice in corrispondenza di un indice di matrice specificato all'inizio dello stack di valutazione come tipo <see langword="&amp;" /> (puntatore gestito).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2635">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2636">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2636">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2637">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2637">Format</span></span>|<span data-ttu-id="45e2e-2638">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2638">Assembly Format</span></span>|<span data-ttu-id="45e2e-2639">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2639">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2640">8F < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2640">8F < `T` ></span></span>|<span data-ttu-id="45e2e-2641">ldelema `class`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2641">ldelema `class`</span></span>|<span data-ttu-id="45e2e-2642">Carica l'indirizzo dell'elemento di matrice in `index` all'inizio dello stack di valutazione come tipo `&` (puntatore gestito).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2642">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="45e2e-2643">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2643">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2644">Un riferimento all'oggetto `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2644">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2645">Un valore di indice `index` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2645">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-2646">`index` e `array` vengono estratti dallo stack; l'indirizzo archiviato nella posizione `index` in `array` viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2646">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45e2e-2647">L'indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2647">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2648">Il `ldelema` viene utilizzato per recuperare l'indirizzo di un oggetto in un particolare indice in una matrice di oggetti (di tipo `class`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2648">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="45e2e-2649">Il `ldelema` istruzione carica l'indirizzo del valore in corrispondenza dell'indice `index` (tipo `native int`) nella matrice unidimensionale in base zero `array` e lo inserisce nella parte superiore dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2649">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45e2e-2650">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2650">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-2651">Il valore deve essere di tipo `class` passato con l'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2651">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="45e2e-2652">Il valore restituito per `ldelema` è un puntatore gestito (tipo `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2652">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="45e2e-2653">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2653">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2654"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2654"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-2655"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2655"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-2656"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2656"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-2657">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldelema` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2657">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2658">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2658">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2659">Trova il valore di un campo nell'oggetto il cui riferimento si trova attualmente nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2659">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2660">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2660">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2661">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2661">Format</span></span>|<span data-ttu-id="45e2e-2662">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2662">Assembly Format</span></span>|<span data-ttu-id="45e2e-2663">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2663">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2664">7B < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2664">7B < `T` ></span></span>|<span data-ttu-id="45e2e-2665">ldfld `field`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2665">ldfld `field`</span></span>|<span data-ttu-id="45e2e-2666">Inserisce il valore di un campo in un oggetto specificato nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2666">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2667">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2667">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2668">Un riferimento all'oggetto (o un puntatore) viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2668">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2669">Il riferimento all'oggetto (o un puntatore) viene estratto dallo stack; il valore del campo specificato nell'oggetto viene trovato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2669">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="45e2e-2670">Il valore archiviato nel campo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2670">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2671">Il `ldfld` istruzione inserisce il valore di un campo a cui si trova in un oggetto di nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2671">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="45e2e-2672">L'oggetto deve essere sullo stack come un riferimento all'oggetto (tipo `O`), un puntatore gestito (tipo `&`), un puntatore non gestito (tipo `native int`), un puntatore temporaneo (tipo `*`), o un'istanza di un tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2672">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="45e2e-2673">L'utilizzo di un puntatore non gestito non è consentito in codice verificabile.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2673">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="45e2e-2674">Il campo dell'oggetto è specificato da un token di metadati che deve fare riferimento a un membro di campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2674">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="45e2e-2675">Il tipo restituito è lo stesso di quello associato al campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2675">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="45e2e-2676">Il campo può essere un campo di istanza (nel qual caso l'oggetto non deve essere un riferimento null) o un campo statico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2676">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="45e2e-2677">Il `ldfld` istruzione può essere preceduta da una o entrambe le <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2677">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="45e2e-2678"><xref:System.NullReferenceException> viene generata se l'oggetto è null e il campo non è statico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2678"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="45e2e-2679"><xref:System.MissingFieldException> viene generata se il campo specificato non viene trovato nei metadati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2679"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="45e2e-2680">In genere, questo viene verificato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2680">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="45e2e-2681">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2681">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2682">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2682">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2683">Trova l'indirizzo di un campo nell'oggetto il cui riferimento si trova attualmente nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2683">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2684">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2684">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2685">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2685">Format</span></span>|<span data-ttu-id="45e2e-2686">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2686">Assembly Format</span></span>|<span data-ttu-id="45e2e-2687">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2687">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2688">7C < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2688">7C < `T` ></span></span>|<span data-ttu-id="45e2e-2689">ldflda `field`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2689">ldflda `field`</span></span>|<span data-ttu-id="45e2e-2690">Inserisce l'indirizzo di `field` in un oggetto specificato nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2690">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2691">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2691">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2692">Un riferimento all'oggetto (o un puntatore) viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2692">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2693">Il riferimento all'oggetto (o un puntatore) viene estratto dallo stack; l'indirizzo del campo specificato nell'oggetto è stato trovato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2693">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="45e2e-2694">L'indirizzo del campo specificato è inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2694">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2695">Il `ldflda` istruzione inserisce l'indirizzo di un campo a cui si trova in un oggetto di nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2695">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="45e2e-2696">L'oggetto deve essere sullo stack come un riferimento all'oggetto (tipo `O`), un puntatore gestito (tipo `&`), un puntatore non gestito (tipo `native int`), un puntatore temporaneo (tipo `*`), o un'istanza di un tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2696">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="45e2e-2697">L'utilizzo di un puntatore non gestito non è consentito in codice verificabile.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2697">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="45e2e-2698">Il campo dell'oggetto è specificato da un token di metadati che deve fare riferimento a un membro di campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2698">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="45e2e-2699">Il valore restituito da `ldflda` è un puntatore gestito (tipo `&`), a meno che l'oggetto viene inserito nello stack come un puntatore non gestito, nel qual caso l'indirizzo del mittente è anche un puntatore non gestito (tipo `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2699">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="45e2e-2700">Il `ldflda` istruzione può essere preceduta da una o entrambe le <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2700">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="45e2e-2701"><xref:System.InvalidOperationException> viene generata se l'oggetto non è presente all'interno del dominio applicazione da cui si accede.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2701"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="45e2e-2702">Impossibile caricare l'indirizzo di un campo che non è all'interno di accesso al dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2702">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="45e2e-2703"><xref:System.NullReferenceException> viene generata se l'oggetto è null e il campo non è statico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2703"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="45e2e-2704"><xref:System.MissingFieldException> viene generata se il campo specificato non viene trovato nei metadati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2704"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="45e2e-2705">In genere, questo viene verificato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2705">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="45e2e-2706">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldflda` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2706">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2707">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2707">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2708">Inserisce un puntatore non gestito di tipo <see langword="native int" /> al codice nativo che implementa un metodo specifico nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2708">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2709">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2709">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2710">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2710">Format</span></span>|<span data-ttu-id="45e2e-2711">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2711">Assembly Format</span></span>|<span data-ttu-id="45e2e-2712">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2712">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2713">FE 06 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-2713">FE 06 < `T` ></span></span>|<span data-ttu-id="45e2e-2714">ldftn `method`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2714">ldftn `method`</span></span>|<span data-ttu-id="45e2e-2715">Inserisce un puntatore a un metodo a cui fa riferimento `method` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2715">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2716">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2716">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2717">Il puntatore non gestito a un metodo specifico viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2717">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2718">Il metodo specifico (`method`) può essere chiamato utilizzando il <xref:System.Reflection.Emit.OpCodes.Calli> istruzione se fa riferimento a un metodo gestito (o uno stub che esegue la transizione da gestito a codice non gestito).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2718">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="45e2e-2719">Il valore restituito punta al codice nativo usando il convenzione di chiamata del CLR.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2719">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="45e2e-2720">L'indicatore di misura del metodo non deve essere passato al codice nativo non gestito come una routine di callback.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2720">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="45e2e-2721">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldftn` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2721">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2722">ILGenerator (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2722">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2723">Carica indirettamente un valore di tipo <see langword="native int" /> come <see langword="native int" /> nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2723">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2724">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2724">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2725">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2725">Format</span></span>|<span data-ttu-id="45e2e-2726">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2726">Assembly Format</span></span>|<span data-ttu-id="45e2e-2727">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2727">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2728">4D</span><span class="sxs-lookup"><span data-stu-id="45e2e-2728">4D</span></span>|<span data-ttu-id="45e2e-2729">ldind.i</span><span class="sxs-lookup"><span data-stu-id="45e2e-2729">ldind.i</span></span>|<span data-ttu-id="45e2e-2730">Carica il `native int` valore all'indirizzo `addr` nello stack come un `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2730">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="45e2e-2731">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2731">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2732">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2732">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2733">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2733">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2734">Il valore recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2734">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2735">Il `ldind.i` istruzione carica indirettamente un `native int` valore dall'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come un `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2735">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-2736">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2736">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2737">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2737">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2738">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2738">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2739">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2739">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2740">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2740">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2741">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2741">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2742">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2742">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2743">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2743">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2744"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2744"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2745">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2745">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2746">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2746">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2747">Carica indirettamente un valore di tipo <see langword="int8" /> come <see langword="int32" /> nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2747">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2748">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2748">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2749">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2749">Format</span></span>|<span data-ttu-id="45e2e-2750">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2750">Assembly Format</span></span>|<span data-ttu-id="45e2e-2751">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2751">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2752">46</span><span class="sxs-lookup"><span data-stu-id="45e2e-2752">46</span></span>|<span data-ttu-id="45e2e-2753">ldind.i1</span><span class="sxs-lookup"><span data-stu-id="45e2e-2753">ldind.i1</span></span>|<span data-ttu-id="45e2e-2754">Carica il `int8` valore all'indirizzo `addr` nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2754">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2755">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2755">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2756">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2756">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2757">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2757">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2758">Il valore recuperato viene inserito nello stack...</span><span class="sxs-lookup"><span data-stu-id="45e2e-2758">The fetched value is pushed onto the stack..</span></span>  
  
 <span data-ttu-id="45e2e-2759">Il `ldind.i1` istruzione carica indirettamente un `int8` valore dall'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2759">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45e2e-2760">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2760">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2761">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2761">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2762">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2762">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2763">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2763">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2764">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2764">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2765">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2765">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2766">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2766">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2767">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2767">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2768"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2768"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2769">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2770">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2770">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2771">Carica indirettamente un valore di tipo <see langword="int16" /> come <see langword="int32" /> nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2771">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2772">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2773">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2773">Format</span></span>|<span data-ttu-id="45e2e-2774">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2774">Assembly Format</span></span>|<span data-ttu-id="45e2e-2775">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2776">48</span><span class="sxs-lookup"><span data-stu-id="45e2e-2776">48</span></span>|<span data-ttu-id="45e2e-2777">ldind.i2</span><span class="sxs-lookup"><span data-stu-id="45e2e-2777">ldind.i2</span></span>|<span data-ttu-id="45e2e-2778">Carica il `int16` valore all'indirizzo `addr` nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2778">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2779">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2780">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2780">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2781">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2781">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2782">Il valore recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2782">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2783">Il `ldind.i2` istruzione carica indirettamente un `int16` valore dall'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2783">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45e2e-2784">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2784">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2785">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2785">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2786">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2786">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2787">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2787">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2788">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2788">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2789">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2789">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2790">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2790">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2791">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2791">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2792"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2792"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2793">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2793">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2794">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2794">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2795">Carica indirettamente un valore di tipo <see langword="int32" /> come <see langword="int32" /> nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2795">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2796">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2796">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2797">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2797">Format</span></span>|<span data-ttu-id="45e2e-2798">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2798">Assembly Format</span></span>|<span data-ttu-id="45e2e-2799">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2799">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2800">4A</span><span class="sxs-lookup"><span data-stu-id="45e2e-2800">4A</span></span>|<span data-ttu-id="45e2e-2801">ldind.i4</span><span class="sxs-lookup"><span data-stu-id="45e2e-2801">ldind.i4</span></span>|<span data-ttu-id="45e2e-2802">Carica il `int32` valore all'indirizzo `addr` nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2802">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2803">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2803">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2804">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2804">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2805">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2805">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2806">Il valore recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2806">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2807">Il `ldind.i4` istruzione carica indirettamente un `int32` valore dall'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2807">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45e2e-2808">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2808">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2809">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2809">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2810">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2810">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2811">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2811">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2812">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2812">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2813">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2813">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2814">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2814">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2815">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2815">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2816"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2816"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2817">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2817">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2818">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2818">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2819">Carica indirettamente un valore di tipo <see langword="int64" /> come <see langword="int64" /> nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2819">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2820">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2820">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2821">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2821">Format</span></span>|<span data-ttu-id="45e2e-2822">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2822">Assembly Format</span></span>|<span data-ttu-id="45e2e-2823">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2823">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2824">4C</span><span class="sxs-lookup"><span data-stu-id="45e2e-2824">4C</span></span>|<span data-ttu-id="45e2e-2825">ldind.i8</span><span class="sxs-lookup"><span data-stu-id="45e2e-2825">ldind.i8</span></span>|<span data-ttu-id="45e2e-2826">Carica il `int64` valore all'indirizzo `addr` nello stack come un `int64`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2826">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="45e2e-2827">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2827">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2828">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2828">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2829">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2829">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2830">Il valore recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2830">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2831">Il `ldind.i8` istruzione carica indirettamente un `int64` valore dall'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come un `int64`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2831">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="45e2e-2832">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2832">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2833">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2833">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2834">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2834">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2835">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2835">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2836">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2836">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2837">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2837">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2838">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2838">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2839">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2839">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2840"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2840"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2841">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2841">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2842">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2842">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2843">Carica indirettamente un valore di tipo <see langword="float32" /> come un tipo <see langword="F" /> (float) nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2843">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2844">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2844">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2845">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2845">Format</span></span>|<span data-ttu-id="45e2e-2846">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2846">Assembly Format</span></span>|<span data-ttu-id="45e2e-2847">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2847">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2848">4E</span><span class="sxs-lookup"><span data-stu-id="45e2e-2848">4E</span></span>|<span data-ttu-id="45e2e-2849">ldind.r4</span><span class="sxs-lookup"><span data-stu-id="45e2e-2849">ldind.r4</span></span>|<span data-ttu-id="45e2e-2850">Carica il `float32` valore all'indirizzo `addr` nello stack come un tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2850">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="45e2e-2851">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2851">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2852">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2852">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2853">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2853">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2854">Il valore recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2854">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2855">Il `ldind.r4` istruzione carica indirettamente un `float32` valore dall'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come un tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2855">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="45e2e-2856">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2856">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2857">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2857">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2858">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2858">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2859">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2859">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2860">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2860">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2861">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2861">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2862">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2862">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2863">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2863">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2864"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2864"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2865">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2865">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2866">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2866">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2867">Carica indirettamente un valore di tipo <see langword="float64" /> come un tipo <see langword="F" /> (float) nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2867">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2868">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2868">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2869">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2869">Format</span></span>|<span data-ttu-id="45e2e-2870">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2870">Assembly Format</span></span>|<span data-ttu-id="45e2e-2871">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2871">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2872">4F</span><span class="sxs-lookup"><span data-stu-id="45e2e-2872">4F</span></span>|<span data-ttu-id="45e2e-2873">ldind.r8</span><span class="sxs-lookup"><span data-stu-id="45e2e-2873">ldind.r8</span></span>|<span data-ttu-id="45e2e-2874">Carica il `float64` valore all'indirizzo `addr` nello stack come un tipo `F`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2874">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="45e2e-2875">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2875">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2876">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2876">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2877">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2877">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2878">Il valore recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2878">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2879">Il `ldind.r8` istruzione carica indirettamente un `float64` valore dall'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come un `float64`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2879">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="45e2e-2880">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2880">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2881">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2881">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2882">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2882">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2883">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2883">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2884">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2884">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2885">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2885">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2886">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2886">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2887">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2887">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2888"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2888"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2889">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2889">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2890">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2890">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2891">Carica indirettamente un riferimento a un oggetto come un tipo <see langword="O" /> (riferimento a un oggetto) nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2891">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2892">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2892">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2893">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2893">Format</span></span>|<span data-ttu-id="45e2e-2894">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2894">Assembly Format</span></span>|<span data-ttu-id="45e2e-2895">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2895">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2896">50</span><span class="sxs-lookup"><span data-stu-id="45e2e-2896">50</span></span>|<span data-ttu-id="45e2e-2897">ldind.ref</span><span class="sxs-lookup"><span data-stu-id="45e2e-2897">ldind.ref</span></span>|<span data-ttu-id="45e2e-2898">Carica il riferimento all'oggetto all'indirizzo `addr` nello stack come un tipo `O`</span><span class="sxs-lookup"><span data-stu-id="45e2e-2898">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="45e2e-2899">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2899">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2900">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2900">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2901">L'indirizzo viene estratto dallo stack; il riferimento all'oggetto si trova in corrispondenza dell'indirizzo viene recuperato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2901">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2902">Il riferimento recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2902">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2903">Il `ldind.ref` istruzione carica indirettamente il riferimento all'oggetto l'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2903">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="45e2e-2904">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2904">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2905">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2905">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2906">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2906">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2907">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2907">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2908">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2908">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2909">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2909">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2910">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2910">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2911">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2911">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2912"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2912"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2913">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2913">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2914">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2914">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2915">Carica indirettamente un valore di tipo <see langword="unsigned int8" /> come <see langword="int32" /> nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2915">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2916">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2916">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2917">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2917">Format</span></span>|<span data-ttu-id="45e2e-2918">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2918">Assembly Format</span></span>|<span data-ttu-id="45e2e-2919">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2919">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2920">47</span><span class="sxs-lookup"><span data-stu-id="45e2e-2920">47</span></span>|<span data-ttu-id="45e2e-2921">ldind.u1</span><span class="sxs-lookup"><span data-stu-id="45e2e-2921">ldind.u1</span></span>|<span data-ttu-id="45e2e-2922">Carica il `unsigned int8` valore all'indirizzo `addr` nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2922">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2923">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2923">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2924">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2924">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2925">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2925">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2926">Il valore recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2926">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2927">Il `ldind.u1` istruzione carica indirettamente un `unsigned int8` valore dall'indirizzo specificato (di tipo`native int`, `&`, o \*) nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2927">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45e2e-2928">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2928">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2929">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2929">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2930">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2930">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2931">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2931">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2932">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2932">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2933">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2933">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2934">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2934">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2935">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2935">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2936"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2936"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2937">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.u1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2938">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2939">Carica indirettamente un valore di tipo <see langword="unsigned int16" /> come <see langword="int32" /> nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2939">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2940">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2940">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2941">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2941">Format</span></span>|<span data-ttu-id="45e2e-2942">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2942">Assembly Format</span></span>|<span data-ttu-id="45e2e-2943">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2943">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2944">49</span><span class="sxs-lookup"><span data-stu-id="45e2e-2944">49</span></span>|<span data-ttu-id="45e2e-2945">ldind.u2</span><span class="sxs-lookup"><span data-stu-id="45e2e-2945">ldind.u2</span></span>|<span data-ttu-id="45e2e-2946">Carica il `unsigned int16` valore all'indirizzo `addr` nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2946">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2947">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2947">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2948">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2948">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2949">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2949">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2950">Il valore recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2950">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2951">Il `ldind.u2` istruzione carica indirettamente un `unsigned int16` valore dall'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2951">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45e2e-2952">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2952">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2953">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2953">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2954">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2954">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2955">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2955">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2956">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2956">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2957">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2957">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2958">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2958">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2959">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2959">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2960"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2960"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2961">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.u2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2961">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2962">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2962">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2963">Carica indirettamente un valore di tipo <see langword="unsigned int32" /> come <see langword="int32" /> nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2963">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2964">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2964">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2965">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2965">Format</span></span>|<span data-ttu-id="45e2e-2966">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2966">Assembly Format</span></span>|<span data-ttu-id="45e2e-2967">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2967">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2968">4B</span><span class="sxs-lookup"><span data-stu-id="45e2e-2968">4B</span></span>|<span data-ttu-id="45e2e-2969">ldind.u4</span><span class="sxs-lookup"><span data-stu-id="45e2e-2969">ldind.u4</span></span>|<span data-ttu-id="45e2e-2970">Carica il `unsigned int32` valore all'indirizzo `addr` nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2970">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-2971">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2971">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2972">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2972">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2973">L'indirizzo viene estratto dallo stack; viene recuperato il valore che si trova in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2973">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45e2e-2974">Il valore recuperato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2974">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2975">Il `ldind.u4` istruzione carica indirettamente un `unsigned int32` valore dall'indirizzo specificato (di tipo `native int`, `&`, o \*) nello stack come un `int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2975">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45e2e-2976">Tutti i `ldind` istruzioni sono collegamenti a un <xref:System.Reflection.Emit.OpCodes.Ldobj> istruzione che specifica la classe di valore incorporato corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2976">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45e2e-2977">Si noti che i valori integer con meno di 4 byte sono estesi a `int32` (non `native int`) quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2977">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45e2e-2978">I valori a virgola mobile vengono convertiti in `F` tipo quando vengono caricati nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2978">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-2979">Impostato sul formato corretto Microsoft Intermediate Language (MSIL) garantisce che il `ldind` vengono utilizzate le istruzioni in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2979">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45e2e-2980">L'indirizzo inizialmente inserito nello stack deve essere allineato alla dimensione standard di oggetti nel computer o un <xref:System.NullReferenceException> può verificarsi (vedere il <xref:System.Reflection.Emit.OpCodes.Unaligned> istruzione per misure preventive di prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-2980">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45e2e-2981">I risultati di tutte le istruzioni MSIL che restituiscono indirizzi (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) sono allineati in modo sicuro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2981">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45e2e-2982">Per i tipi di dati maggiori di 1 byte, l'ordinamento dei byte è dipendente dalla CPU di destinazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2982">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45e2e-2983">Il codice che dipende l'ordine dei byte potrebbe non funzionare in tutte le piattaforme.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2983">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45e2e-2984"><xref:System.NullReferenceException> può essere generata se viene rilevato un indirizzo non valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2984"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45e2e-2985">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldind.u4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2985">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-2986">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-2986">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-2987">Inserisce il numero di elementi di una matrice unidimensionale in base zero nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-2987">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-2988">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2988">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-2989">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-2989">Format</span></span>|<span data-ttu-id="45e2e-2990">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-2990">Assembly Format</span></span>|<span data-ttu-id="45e2e-2991">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-2991">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-2992">8E</span><span class="sxs-lookup"><span data-stu-id="45e2e-2992">8E</span></span>|<span data-ttu-id="45e2e-2993">ldlen</span><span class="sxs-lookup"><span data-stu-id="45e2e-2993">ldlen</span></span>|<span data-ttu-id="45e2e-2994">Inserisce la lunghezza (di tipo `natural unsigned int`) di una matrice nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2994">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-2995">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-2995">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-2996">Riferimento a un oggetto in una matrice viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2996">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-2997">Il riferimento alla matrice viene estratto dallo stack e la lunghezza viene calcolata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2997">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="45e2e-2998">La lunghezza viene inserita nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2998">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-2999">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-2999">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3000">La lunghezza viene restituita come un `natural unsigned int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3000">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="45e2e-3001"><xref:System.NullReferenceException> viene generata se il riferimento alla matrice è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3001"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3002">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldlen` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3003">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3003">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3004">Carica la variabile locale in corrispondenza di un indice specifico nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3004">Loads the local variable at a specific index onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3005">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3006">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3006">Format</span></span>|<span data-ttu-id="45e2e-3007">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3007">Assembly Format</span></span>|<span data-ttu-id="45e2e-3008">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3009">FE 0C &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3009">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="45e2e-3010">ldloc `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3010">ldloc `index`</span></span>|<span data-ttu-id="45e2e-3011">Carica la variabile locale in corrispondenza dell'indice `index` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3011">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3012">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3012">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3013">Il valore della variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3013">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3014">Il `ldloc` istruzione inserisce il contenuto del numero della variabile locale in corrispondenza dell'indice passato nello stack di valutazione, in cui le variabili locali vengono numerate a partire da 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3014">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45e2e-3015">Le variabili locali vengono inizializzate su 0 prima del metodo solo se il flag di inizializzazione nel metodo è true.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3015">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="45e2e-3016">Sono disponibili 65.535 (2 ^ 16 - 1) le variabili locali possibili (0-65.534).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3016">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="45e2e-3017">Indice 65.535 non è valido in quanto implementazioni simili utilizzeranno un integer a 2 byte per tenere traccia sia un indice locale, insieme al numero totale di variabili locali per un metodo specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3017">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="45e2e-3018">Se un indice di 65535 è stato reso valido, sarebbe necessario un valore integer più ampio tenere traccia del numero di variabili locali in tale metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3018">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="45e2e-3019">Il `ldloc.0`, `ldloc.1`, `ldloc.2`, e `ldloc.3` istruzioni forniscono una codifica efficiente per l'accesso alle prime quattro variabili locali.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3019">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="45e2e-3020">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3020">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45e2e-3021">Vedere le variabili partizione i locali che sono minori di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3021">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-3022">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3022">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-3023">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload è possibile utilizzare il `ldloc` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3023">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3024">ILGenerator (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3024">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="45e2e-3025">ILGenerator (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3025">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3026">Carica la variabile locale in corrispondenza dell'indice 0 nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3026">Loads the local variable at index 0 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3027">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3027">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3028">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3028">Format</span></span>|<span data-ttu-id="45e2e-3029">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3029">Assembly Format</span></span>|<span data-ttu-id="45e2e-3030">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3030">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3031">06</span><span class="sxs-lookup"><span data-stu-id="45e2e-3031">06</span></span>|<span data-ttu-id="45e2e-3032">ldloc.0</span><span class="sxs-lookup"><span data-stu-id="45e2e-3032">ldloc.0</span></span>|<span data-ttu-id="45e2e-3033">Carica la variabile locale in corrispondenza dell'indice 0 nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3033">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3034">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3034">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3035">Il valore della variabile locale in corrispondenza dell'indice 0 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3035">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3036">`ldloc.0` rappresenta una codifica particolarmente efficace per <xref:System.Reflection.Emit.OpCodes.Ldloc>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3036">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="45e2e-3037">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3037">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45e2e-3038">Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3038">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-3039">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3039">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-3040">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldloc.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3040">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3041">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3041">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3042">Carica la variabile locale in corrispondenza dell'indice 1 nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3042">Loads the local variable at index 1 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3043">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3043">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3044">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3044">Format</span></span>|<span data-ttu-id="45e2e-3045">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3045">Assembly Format</span></span>|<span data-ttu-id="45e2e-3046">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3046">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3047">07</span><span class="sxs-lookup"><span data-stu-id="45e2e-3047">07</span></span>|<span data-ttu-id="45e2e-3048">ldloc.1</span><span class="sxs-lookup"><span data-stu-id="45e2e-3048">ldloc.1</span></span>|<span data-ttu-id="45e2e-3049">Carica la variabile locale in corrispondenza dell'indice 1 nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3049">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3050">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3050">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3051">Il valore della variabile locale in corrispondenza dell'indice 1 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3051">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3052">`ldloc.1` rappresenta una codifica particolarmente efficace per <xref:System.Reflection.Emit.OpCodes.Ldloc>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 1.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3052">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="45e2e-3053">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3053">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45e2e-3054">Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3054">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-3055">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3055">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-3056">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldloc.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3056">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3057">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3057">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3058">Carica la variabile locale in corrispondenza dell'indice 2 nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3058">Loads the local variable at index 2 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3059">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3059">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3060">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3060">Format</span></span>|<span data-ttu-id="45e2e-3061">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3061">Assembly Format</span></span>|<span data-ttu-id="45e2e-3062">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3062">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3063">08</span><span class="sxs-lookup"><span data-stu-id="45e2e-3063">08</span></span>|<span data-ttu-id="45e2e-3064">ldloc.2</span><span class="sxs-lookup"><span data-stu-id="45e2e-3064">ldloc.2</span></span>|<span data-ttu-id="45e2e-3065">Carica la variabile locale in corrispondenza dell'indice 2 nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3065">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3066">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3066">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3067">Il valore della variabile locale in corrispondenza dell'indice 2 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3067">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3068">`ldloc.2` rappresenta una codifica particolarmente efficace per <xref:System.Reflection.Emit.OpCodes.Ldloc>, che consente l'accesso alla variabile locale in corrispondenza dell'indice 2.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3068">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="45e2e-3069">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3069">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45e2e-3070">Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3070">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-3071">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-3072">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldloc.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3073">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3074">Carica la variabile locale in corrispondenza dell'indice 3 nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3074">Loads the local variable at index 3 onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3075">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3076">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3076">Format</span></span>|<span data-ttu-id="45e2e-3077">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3077">Assembly Format</span></span>|<span data-ttu-id="45e2e-3078">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3079">09</span><span class="sxs-lookup"><span data-stu-id="45e2e-3079">09</span></span>|<span data-ttu-id="45e2e-3080">ldloc.3</span><span class="sxs-lookup"><span data-stu-id="45e2e-3080">ldloc.3</span></span>|<span data-ttu-id="45e2e-3081">Carica la variabile locale in corrispondenza dell'indice 3 nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3081">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3082">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3083">Il valore della variabile locale in corrispondenza dell'indice 3 viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3083">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3084">`ldloc.3` rappresenta una codifica particolarmente efficace per <xref:System.Reflection.Emit.OpCodes.Ldloc>, che consente di accedere alla variabile locale in corrispondenza dell'indice 3.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3084">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="45e2e-3085">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3085">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45e2e-3086">Le variabili locali che sono inferiori a 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3086">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-3087">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3087">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-3088">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldloc.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3088">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3089">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3089">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3090">Carica la variabile locale in corrispondenza di un indice specifico nello stack di valutazione, forma breve.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3090">Loads the local variable at a specific index onto the evaluation stack, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3091">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3091">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3092">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3092">Format</span></span>|<span data-ttu-id="45e2e-3093">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3093">Assembly Format</span></span>|<span data-ttu-id="45e2e-3094">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3094">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3095">11 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3095">11 < `unsigned int8` ></span></span>|<span data-ttu-id="45e2e-3096">ldloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3096">ldloc.s `index`</span></span>|<span data-ttu-id="45e2e-3097">Carica la variabile locale in corrispondenza dell'indice `index` nello stack, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3097">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-3098">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3098">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3099">Il valore della variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3099">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3100">Il `ldloc.s` istruzione inserisce il contenuto del numero della variabile locale in corrispondenza dell'indice passato nello stack di valutazione, in cui le variabili locali vengono numerate a partire da 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3100">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45e2e-3101">Prima di inserire il metodo se il flag di inizializzazione nel metodo è true, le variabili locali vengono inizializzate a 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3101">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="45e2e-3102">Sono disponibili 256 (2 ^ 8) variabili locali (0-255) in forma breve, ovvero una codifica più efficiente `ldloc`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3102">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="45e2e-3103">Il tipo del valore è uguale al tipo della variabile locale, viene specificato nell'intestazione del metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3103">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45e2e-3104">Vedere le variabili partizione i locali che sono minori di 4 byte vengono espanse per digitare `int32` quando vengono caricati nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3104">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45e2e-3105">I valori a virgola mobile vengono espansi fino alle dimensioni native (tipo `F`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3105">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45e2e-3106">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload è possibile utilizzare il `ldloc.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3106">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3107">ILGenerator (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3107">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="45e2e-3108">ILGenerator (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3108">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3109">Carica l'indirizzo della variabile locale in corrispondenza di un indice specifico nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3109">Loads the address of the local variable at a specific index onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3110">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3110">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3111">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3111">Format</span></span>|<span data-ttu-id="45e2e-3112">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3112">Assembly Format</span></span>|<span data-ttu-id="45e2e-3113">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3113">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3114">FE OD &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3114">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="45e2e-3115">ldloca `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3115">ldloca `index`</span></span>|<span data-ttu-id="45e2e-3116">Carica l'indirizzo della variabile locale in `index` nello stack di valutazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3116">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3117">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3117">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3118">L'indirizzo archiviato nella variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3118">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3119">Il `ldloca` istruzione inserisce l'indirizzo del numero della variabile locale in corrispondenza dell'indice passato nello stack, in cui le variabili locali sono numerate a partire da 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3119">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45e2e-3120">Il valore inserito nello stack è già allineato correttamente per l'utilizzo con istruzioni come <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3120">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="45e2e-3121">Il risultato è un puntatore temporaneo (tipo `*`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3121">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="45e2e-3122">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldloca` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3122">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3123">ILGenerator (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3123">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3124">Carica l'indirizzo della variabile locale in corrispondenza di un indice specifico nello stack di valutazione, forma breve.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3124">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3125">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3125">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3126">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3126">Format</span></span>|<span data-ttu-id="45e2e-3127">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3127">Assembly Format</span></span>|<span data-ttu-id="45e2e-3128">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3128">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3129">12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3129">12 < `unsigned int8` ></span></span>|<span data-ttu-id="45e2e-3130">ldloca.s `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3130">ldloca.s `index`</span></span>|<span data-ttu-id="45e2e-3131">Carica l'indirizzo della variabile locale in `index` nello stack di valutazione, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3131">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-3132">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3132">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3133">L'indirizzo archiviato nella variabile locale in corrispondenza dell'indice specificato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3133">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3134">Il `ldloca.s` istruzione inserisce l'indirizzo del numero della variabile locale in corrispondenza dell'indice passato nello stack, in cui le variabili locali sono numerate a partire da 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3134">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45e2e-3135">Il valore inserito nello stack è già allineato correttamente per l'utilizzo con istruzioni come <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3135">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="45e2e-3136">Il risultato è un puntatore temporaneo (tipo `*`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3136">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="45e2e-3137">Il `ldloca.s` istruzione fornisce una codifica efficiente per l'utilizzo con le variabili locali, tra 0 e 255.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3137">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="45e2e-3138">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldloca.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3138">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3139">ILGenerator (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3139">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3140">Inserisce un riferimento null di tipo <see langword="O" /> nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3140">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3141">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3141">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3142">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3142">Format</span></span>|<span data-ttu-id="45e2e-3143">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3143">Assembly Format</span></span>|<span data-ttu-id="45e2e-3144">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3144">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3145">14</span><span class="sxs-lookup"><span data-stu-id="45e2e-3145">14</span></span>|<span data-ttu-id="45e2e-3146">ldnull</span><span class="sxs-lookup"><span data-stu-id="45e2e-3146">ldnull</span></span>|<span data-ttu-id="45e2e-3147">Inserisce un riferimento null nello stack</span><span class="sxs-lookup"><span data-stu-id="45e2e-3147">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="45e2e-3148">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3148">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3149">Riferimento a un oggetto null viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3149">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3150">`ldnull` Inserisce un riferimento null (tipo `O`) nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3150">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="45e2e-3151">Viene utilizzato per inizializzare i percorsi prima che siano compilati con i dati oppure quando è obsoleto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3151">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="45e2e-3152">`ldnull` fornisce un riferimento null indipendente dalle dimensioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3152">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="45e2e-3153">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldnull` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3153">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3154">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3154">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3155">Copia l'oggetto tipo di valore a cui punta un indirizzo all'inizio dello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3155">Copies the value type object pointed to by an address to the top of the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3156">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3156">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3157">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3157">Format</span></span>|<span data-ttu-id="45e2e-3158">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3158">Assembly Format</span></span>|<span data-ttu-id="45e2e-3159">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3159">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3160">71 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3160">71 < `T` ></span></span>|<span data-ttu-id="45e2e-3161">ldobj `class`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3161">ldobj `class`</span></span>|<span data-ttu-id="45e2e-3162">Copia un'istanza del tipo di valore `class` allo stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3162">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3163">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3163">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3164">L'indirizzo di un oggetto di tipo valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3164">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3165">L'indirizzo viene estratto dallo stack e l'istanza a quell'indirizzo specifico viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3165">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="45e2e-3166">Il valore dell'oggetto archiviato in corrispondenza dell'indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3166">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3167">Il `ldobj` istruzione consente di passare un tipo di valore come parametro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3167">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="45e2e-3168">Il `ldobj` istruzione copia il valore a cui puntato `addrOfValObj` (di tipo `&`, `*`, o `native int`) all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3168">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="45e2e-3169">Il numero di byte copiati dipende dalle dimensioni della classe (come specificato da di `class` parametro).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3169">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="45e2e-3170">Il `class` parametro è un token di metadati che rappresenta il tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3170">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="45e2e-3171">L'operazione del `ldobj` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3171">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3172"><xref:System.TypeLoadException> viene generata se non è possibile trovare la classe.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3172"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="45e2e-3173">In genere, questo viene rilevato quando l'istruzione di Microsoft Intermediate Language (MSIL) viene convertito in codice nativo piuttosto che in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3173">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-3174">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3174">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3175">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3175">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3176">Inserisce il valore di un campo statico nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3176">Pushes the value of a static field onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3177">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3177">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3178">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3178">Format</span></span>|<span data-ttu-id="45e2e-3179">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3179">Assembly Format</span></span>|<span data-ttu-id="45e2e-3180">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3180">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3181">7E < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3181">7E < `T` ></span></span>|<span data-ttu-id="45e2e-3182">ldsfld `field`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3182">ldsfld `field`</span></span>|<span data-ttu-id="45e2e-3183">Inserire il valore di `field` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3183">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3184">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3184">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3185">Il valore del campo specifico viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3185">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3186">Il `ldsfld` istruzione inserisce il valore di un valore statico (condiviso tra tutte le istanze di una classe) campo nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3186">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="45e2e-3187">Il tipo restituito è quello associato al token di metadati passato `field`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3187">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="45e2e-3188">Il `ldsfld` istruzione può disporre di un <xref:System.Reflection.Emit.OpCodes.Volatile> prefisso.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3188">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="45e2e-3189">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldsfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3189">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3190">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3190">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3191">Inserisce l'indirizzo di un campo statico nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3191">Pushes the address of a static field onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3192">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3192">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3193">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3193">Format</span></span>|<span data-ttu-id="45e2e-3194">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3194">Assembly Format</span></span>|<span data-ttu-id="45e2e-3195">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3195">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3196">7F < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3196">7F < `T` ></span></span>|<span data-ttu-id="45e2e-3197">ldsflda `field`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3197">ldsflda `field`</span></span>|<span data-ttu-id="45e2e-3198">Inserisce l'indirizzo di `field` nello stack</span><span class="sxs-lookup"><span data-stu-id="45e2e-3198">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="45e2e-3199">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3199">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3200">L'indirizzo di un campo specifico viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3200">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3201">Il `ldsflda` istruzione inserisce l'indirizzo di un valore statico (condiviso tra tutte le istanze di una classe) campo nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3201">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="45e2e-3202">L'indirizzo può essere rappresentato come un puntatore temporaneo (tipo `*`) se il token di metadati `field` fa riferimento a un tipo la cui memoria è gestita.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3202">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="45e2e-3203">In caso contrario, corrisponde a un puntatore non gestito (tipo `native int`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3203">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="45e2e-3204">Si noti che `field` può essere un valore statico globale con un indirizzo virtuale relativo assegnato (l'offset del campo dall'indirizzo di base in cui il file PE contiene viene caricato in memoria) in cui la memoria è gestita.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3204">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="45e2e-3205">Il `ldsflda` istruzione può disporre di un <xref:System.Reflection.Emit.OpCodes.Volatile> prefisso.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3205">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="45e2e-3206"><xref:System.MissingFieldException> viene generata se il campo non viene trovato nei metadati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3206"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="45e2e-3207">In genere, questo viene verificato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3207">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-3208">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldsflda` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3208">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3209">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3209">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3210">Inserisce un nuovo riferimento a un oggetto in un valore letterale stringa archiviato nei metadati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3210">Pushes a new object reference to a string literal stored in the metadata.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3211">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3211">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3212">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3212">Format</span></span>|<span data-ttu-id="45e2e-3213">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3213">Assembly Format</span></span>|<span data-ttu-id="45e2e-3214">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3214">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3215">72 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3215">72 < `T` ></span></span>|<span data-ttu-id="45e2e-3216">ldstr `mdToken`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3216">ldstr `mdToken`</span></span>|<span data-ttu-id="45e2e-3217">Inserisce un oggetto stringa per il token di stringa di metadati `mdToken`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3217">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="45e2e-3218">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3218">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3219">Riferimento a una stringa di un oggetto viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3219">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3220">Il `ldstr` istruzione inserisce un riferimento all'oggetto (tipo `O`) a un nuovo oggetto stringa che rappresenta la stringa letterale archiviata nei metadati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3220">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="45e2e-3221">Il `ldstr` istruzione alloca la quantità di memoria necessaria ed esegue qualsiasi conversione di formato è necessario convertire il valore letterale stringa dal formato utilizzato nel file di formato di stringa richiesto in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3221">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-3222">Common Language Infrastructure (CLI) garantisce che il risultato di due `ldstr` istruzioni che fanno riferimento a due token di metadati che hanno la stessa sequenza di caratteri restituiscano esattamente lo stesso oggetto di stringa (un processo noto come "inserimento di stringa").</span><span class="sxs-lookup"><span data-stu-id="45e2e-3222">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="45e2e-3223">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldstr` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3224">ILGenerator (OpCode, stringa)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3224">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3225">Converte un token di metadati nella relativa rappresentazione di runtime, inserendolo nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3225">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3226">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3227">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3227">Format</span></span>|<span data-ttu-id="45e2e-3228">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3228">Assembly Format</span></span>|<span data-ttu-id="45e2e-3229">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3230">D0 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3230">D0 < `T` ></span></span>|<span data-ttu-id="45e2e-3231">ldtoken `token`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3231">ldtoken `token`</span></span>|<span data-ttu-id="45e2e-3232">Converte un token di metadati nella relativa rappresentazione di runtime.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3232">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="45e2e-3233">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3234">Il token passato viene convertito in un `RuntimeHandle` e inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3234">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3235">Il `ldtoken` istruzione inserisce un `RuntimeHandle` per il token di metadati specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3235">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="45e2e-3236">Oggetto `RuntimeHandle` può essere un `fieldref/fielddef`, `methodref/methoddef`, o un `typeref/typedef`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3236">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="45e2e-3237">Il valore inserito nello stack può essere utilizzato nelle chiamate a `Reflection` metodi nella libreria di classi di sistema.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3237">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="45e2e-3238">Per informazioni sugli handle di runtime, vedere le seguenti classi: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, e <xref:System.RuntimeMethodHandle>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3238">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="45e2e-3239">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload è possibile utilizzare il `ldtoken` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3239">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3240">ILGenerator (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3240">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="45e2e-3241">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3241">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="45e2e-3242">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3242">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3243">Inserisce un puntatore non gestito di tipo (<see langword="native int" />) al codice nativo che implementa un particolare metodo virtual con un oggetto specificato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3243">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3244">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3244">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3245">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3245">Format</span></span>|<span data-ttu-id="45e2e-3246">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3246">Assembly Format</span></span>|<span data-ttu-id="45e2e-3247">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3247">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3248">FE 07 &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3248">FE 07 < `T` ></span></span>|<span data-ttu-id="45e2e-3249">ldvirtftn `method`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3249">ldvirtftn `method`</span></span>|<span data-ttu-id="45e2e-3250">Inserisce il puntatore a un metodo virtual `method` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3250">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3251">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3251">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3252">Riferimento a un oggetto viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3252">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3253">Il riferimento all'oggetto viene estratto dallo stack e l'indirizzo del punto di ingresso al metodo (come specificato dal token di metadati `method`) viene cercata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3253">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="45e2e-3254">Puntatore a `method` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3254">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3255">Il puntatore non gestito risulta inserito nello stack dal `ldvirtftn` istruzione può essere chiamato utilizzando il <xref:System.Reflection.Emit.OpCodes.Calli> istruzione se fa riferimento a un metodo gestito (o uno stub che esegue la transizione da gestito a codice non gestito).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3255">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="45e2e-3256">Il puntatore non gestito fa riferimento al codice nativo usando il convenzione di chiamata del CLR.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3256">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="45e2e-3257">L'indicatore di misura del metodo non deve essere passato al codice nativo non gestito come una routine di callback.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3257">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="45e2e-3258">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ldvirtftn` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3258">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3259">ILGenerator (OpCode, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3259">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3260">Esce da un'area protetta di codice, trasferendo il controllo in modo incondizionato a un'istruzione di destinazione specifica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3260">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3261">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3261">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3262">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3262">Format</span></span>|<span data-ttu-id="45e2e-3263">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3263">Assembly Format</span></span>|<span data-ttu-id="45e2e-3264">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3264">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3265">DD < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3265">DD < `int32` ></span></span>|<span data-ttu-id="45e2e-3266">lasciare `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3266">leave `target`</span></span>|<span data-ttu-id="45e2e-3267">Esce da un'area protetta di codice.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3267">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="45e2e-3268">Non vi è alcun comportamento di transizione dello stack specificato per questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3268">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3269">Il `leave` istruzione trasferisce il controllo all'istruzione di destinazione specifica, rappresentata come offset con segno a 4 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3269">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3270">Il `leave` è simile all'istruzione il `br` (istruzione), ma consente di uscire da un `try`, `filter`, o `catch` blocco mentre le normali istruzioni branch possono essere utilizzate solo in tale blocco per trasferire il controllo all'interno di .</span><span class="sxs-lookup"><span data-stu-id="45e2e-3270">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="45e2e-3271">Il `leave` istruzione svuota lo stack di valutazione e assicura che circostanti appropriati `finally` i blocchi vengono eseguiti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3271">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="45e2e-3272">Non è possibile utilizzare un `leave` per uscire dall'istruzione di un `finally` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3272">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="45e2e-3273">Per facilitare la generazione di codice per i gestori di eccezioni è valida all'interno di un blocco catch per utilizzare un `leave` istruzione per trasferire il controllo a qualsiasi istruzione all'interno associato `try` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3273">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="45e2e-3274">Se un'istruzione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3274">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45e2e-3275">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload è possibile utilizzare il `leave` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3275">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3276">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3276">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3277">Esce da un'area protetta di codice, trasferendo il controllo in modo incondizionato a un'istruzione di destinazione (forma breve).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3277">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3278">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3278">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3279">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3279">Format</span></span>|<span data-ttu-id="45e2e-3280">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3280">Assembly Format</span></span>|<span data-ttu-id="45e2e-3281">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3281">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3282">GERMANIA &LT; `int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3282">DE < `int8` ></span></span>|<span data-ttu-id="45e2e-3283">leave. s `target`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3283">leave.s `target`</span></span>|<span data-ttu-id="45e2e-3284">Uscire da un'area protetta di codice, la forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3284">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-3285">Non vi è alcun comportamento di transizione dello stack specificato per questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3285">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3286">Il `leave.s` istruzione trasferisce il controllo all'istruzione di destinazione passata, rappresentata come offset con segno a 1 byte dall'inizio dell'istruzione successiva all'istruzione corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3286">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3287">Il `leave.s` è simile all'istruzione il `br` (istruzione), ma consente di uscire da un `try`, `filter`, o `catch` blocco mentre le normali istruzioni branch possono essere utilizzate solo in tale blocco per trasferire il controllo all'interno di .</span><span class="sxs-lookup"><span data-stu-id="45e2e-3287">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="45e2e-3288">Il `leave.s` istruzione svuota lo stack di valutazione e assicura che circostanti appropriati `finally` i blocchi vengono eseguiti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3288">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="45e2e-3289">Non è possibile utilizzare un `leave.s` per uscire dall'istruzione di un `finally` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3289">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="45e2e-3290">Per facilitare la generazione di codice per i gestori di eccezioni è valida all'interno di un blocco catch per utilizzare un `leave.s` istruzione per trasferire il controllo a qualsiasi istruzione all'interno associato `try` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3290">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="45e2e-3291">Se un'istruzione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3291">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45e2e-3292">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `leave.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3292">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3293">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3293">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3294">Esegue l'allocazione di un numero di byte dal pool di memoria dinamica locale e inserisce l'indirizzo (un puntatore transitorio di tipo <see langword="*" />) del primo byte allocato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3294">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3295">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3295">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3296">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3296">Format</span></span>|<span data-ttu-id="45e2e-3297">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3297">Assembly Format</span></span>|<span data-ttu-id="45e2e-3298">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3298">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3299">FE 0F</span><span class="sxs-lookup"><span data-stu-id="45e2e-3299">FE 0F</span></span>|<span data-ttu-id="45e2e-3300">localloc</span><span class="sxs-lookup"><span data-stu-id="45e2e-3300">localloc</span></span>|<span data-ttu-id="45e2e-3301">Allocare spazio dall'heap locale.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3301">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="45e2e-3302">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3302">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3303">Il numero di byte da allocare viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3303">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3304">Il numero di byte viene estratto dallo stack; una quantità di memoria corrispondente alla dimensione viene allocata dall'heap locale.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3304">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="45e2e-3305">Un puntatore al primo byte della memoria allocata viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3305">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3306">Il `localloc` istruzione alloca `size` (tipo `natural unsigned int`) pool e restituisce l'indirizzo di byte da memoria dinamica locale (un puntatore temporaneo, il tipo `*`) del primo byte allocato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3306">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="45e2e-3307">Il blocco di memoria restituito viene inizializzato su 0 solo se il flag di inizializzazione nel metodo `true`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3307">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="45e2e-3308">Quando il metodo corrente esegue un <xref:System.Reflection.Emit.OpCodes.Ret>, il pool di memoria locale è reso disponibile per il riutilizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3308">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="45e2e-3309">L'indirizzo risulta è allineato in modo che qualsiasi tipo di dati primitivi possa essere archiviata utilizzando il `stind` istruzioni (ad esempio <xref:System.Reflection.Emit.OpCodes.Stind_I4>) e caricati utilizzando il `ldind` istruzioni (ad esempio <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3309">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="45e2e-3310">Il `localloc` istruzione non può verificarsi all'interno di un `filter`, `catch`, `finally`, o `fault` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3310">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="45e2e-3311"><xref:System.StackOverflowException> viene generata se la memoria è insufficiente per soddisfare la richiesta.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3311"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="45e2e-3312">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `localloc` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3312">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3313">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3313">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3314">Inserisce un riferimento tipizzato a un'istanza di un tipo specifico nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3314">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3315">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3315">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3316">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3316">Format</span></span>|<span data-ttu-id="45e2e-3317">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3317">Assembly Format</span></span>|<span data-ttu-id="45e2e-3318">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3318">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3319">C6 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3319">C6 < `T` ></span></span>|<span data-ttu-id="45e2e-3320">mkrefany `class`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3320">mkrefany `class`</span></span>|<span data-ttu-id="45e2e-3321">Inserisce un riferimento tipizzato di tipo `class` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3321">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3322">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3322">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3323">Puntatore alla porzione di dati viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3323">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3324">Il puntatore viene estratto e convertito in un riferimento tipizzato di tipo `class`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3324">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="45e2e-3325">Il riferimento tipizzato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3325">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3326">Il `mkrefany` istruzione supporta il passaggio dei riferimenti tipizzati in modo dinamico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3326">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="45e2e-3327">Il puntatore deve essere di tipo `&`, `*`, o `native int`e contiene l'indirizzo di una porzione di dati valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3327">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="45e2e-3328">`Class` è il token di classe che descrive il tipo di dati a cui fa riferimento il puntatore del mouse.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3328">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="45e2e-3329">`Mkrefany` Inserisce un riferimento tipizzato nello stack, fornendo un descrittore opaco del puntatore e il tipo `class`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3329">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="45e2e-3330">L'operazione è valida solo consentita su un riferimento tipizzato consiste nel passarlo a un metodo che richiede un riferimento tipizzato come parametro.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3330">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="45e2e-3331">Il chiamato può quindi utilizzare il <xref:System.Reflection.Emit.OpCodes.Refanytype> e <xref:System.Reflection.Emit.OpCodes.Refanyval> istruzioni per recuperare rispettivamente il tipo (classe) e l'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3331">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="45e2e-3332"><xref:System.TypeLoadException> viene generata se `class` non è stato trovato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3332"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="45e2e-3333">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3333">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-3334">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `mkrefany` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3335">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3335">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3336">Moltiplica due valori e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3336">Multiplies two values and pushes the result on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3337">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3338">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3338">Format</span></span>|<span data-ttu-id="45e2e-3339">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3339">Assembly Format</span></span>|<span data-ttu-id="45e2e-3340">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3341">5A</span><span class="sxs-lookup"><span data-stu-id="45e2e-3341">5A</span></span>|<span data-ttu-id="45e2e-3342">mul</span><span class="sxs-lookup"><span data-stu-id="45e2e-3342">mul</span></span>|<span data-ttu-id="45e2e-3343">Moltiplica due valori nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3343">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3344">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3345">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3345">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3346">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3346">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3347">`value2` e `value1` vengono estratti dallo stack; `value1` viene moltiplicato per `value2`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3347">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="45e2e-3348">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3348">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3349">Il `mul` istruzione moltiplica `value1` da `value2` e inserisce il risultato nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3349">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="45e2e-3350">Operazioni su numeri interi troncano automaticamente i bit superiori in caso di overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3350">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="45e2e-3351">Vedere <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> per un numero intero specifica operazione con la gestione dell'overflow di moltiplicazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3351">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="45e2e-3352">Per i tipi a virgola mobile, 0 \* infinito = NaN.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3352">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="45e2e-3353">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `mul` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3353">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3354">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3354">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3355">Moltiplica due valori interi, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3355">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3356">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3356">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3357">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3357">Format</span></span>|<span data-ttu-id="45e2e-3358">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3358">Assembly Format</span></span>|<span data-ttu-id="45e2e-3359">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3359">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3360">D8</span><span class="sxs-lookup"><span data-stu-id="45e2e-3360">D8</span></span>|<span data-ttu-id="45e2e-3361">mul.ovf</span><span class="sxs-lookup"><span data-stu-id="45e2e-3361">mul.ovf</span></span>|<span data-ttu-id="45e2e-3362">Moltiplica due valori integer nello stack con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3362">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="45e2e-3363">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3363">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3364">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3364">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3365">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3365">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3366">`value2` e `value1` vengono estratti dallo stack; `value1` viene moltiplicato per `value2`, con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3366">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="45e2e-3367">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3367">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3368">Il `mul.ovf` istruzione moltiplica l'intero `value1` da integer `value2` e inserisce il risultato nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3368">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="45e2e-3369">Se il risultato non rientra nel tipo del risultato, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3369">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-3370"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3370"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-3371">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `mul.ovf` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3371">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3372">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3372">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3373">Moltiplica due valori interi senza segno, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3373">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3374">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3374">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3375">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3375">Format</span></span>|<span data-ttu-id="45e2e-3376">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3376">Assembly Format</span></span>|<span data-ttu-id="45e2e-3377">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3377">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3378">D9</span><span class="sxs-lookup"><span data-stu-id="45e2e-3378">D9</span></span>|<span data-ttu-id="45e2e-3379">mul.ovf.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-3379">mul.ovf.un</span></span>|<span data-ttu-id="45e2e-3380">Moltiplica due valori senza segno nello stack con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3380">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="45e2e-3381">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3381">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3382">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3382">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3383">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3383">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3384">`value2` e `value1` vengono estratti dallo stack; `value1` viene moltiplicato per `value2`, con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3384">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="45e2e-3385">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3385">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3386">Il `mul.ovf.un` istruzione moltiplica l'intero senza segno `value1` dall'intero senza segno `value2` e inserisce il risultato nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3386">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="45e2e-3387">Se il risultato non rientra nel tipo del risultato, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3387">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-3388"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3388"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-3389">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `mul.ovf.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3389">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3390">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3390">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3391">Nega un valore e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3391">Negates a value and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3392">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3392">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3393">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3393">Format</span></span>|<span data-ttu-id="45e2e-3394">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3394">Assembly Format</span></span>|<span data-ttu-id="45e2e-3395">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3395">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3396">65</span><span class="sxs-lookup"><span data-stu-id="45e2e-3396">65</span></span>|<span data-ttu-id="45e2e-3397">neg</span><span class="sxs-lookup"><span data-stu-id="45e2e-3397">neg</span></span>|<span data-ttu-id="45e2e-3398">Nega il valore attualmente all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3398">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3399">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3399">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3400">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3400">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3401">Un valore è estratto dallo stack e negazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3401">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="45e2e-3402">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3402">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3403">Il `neg` istruzione Nega il valore e inserisce il risultato all'inizio dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3403">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="45e2e-3404">Il tipo restituito è lo stesso tipo dell'operando.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3404">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="45e2e-3405">Negazione di valori integrali è standard in complemento a due negazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3405">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="45e2e-3406">In particolare, la negazione del numero più negativo (che non ha una controparte positiva) produce il numero più negativo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3406">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="45e2e-3407">Per rilevare l'utilizzo di overflow di <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> istruzione invece (sottrazione da 0).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3407">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="45e2e-3408">La negazione di un numero a virgola mobile non è possibile overflow e la negazione di NaN restituisce NaN.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3408">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="45e2e-3409">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `neg` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3409">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3410">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3410">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3411">Inserisce un riferimento a un oggetto in una matrice unidimensionale in base zero i cui elementi sono di un tipo specifico nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3411">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3412">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3412">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3413">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3413">Format</span></span>|<span data-ttu-id="45e2e-3414">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3414">Assembly Format</span></span>|<span data-ttu-id="45e2e-3415">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3415">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3416">8D < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3416">8D < `T` ></span></span>|<span data-ttu-id="45e2e-3417">newarr `etype`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3417">newarr `etype`</span></span>|<span data-ttu-id="45e2e-3418">Crea una nuova matrice con gli elementi di tipo `etype`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3418">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="45e2e-3419">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3419">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3420">Il numero di elementi nella matrice viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3420">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3421">Il numero di elementi viene estratto dallo stack e la matrice viene creata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3421">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="45e2e-3422">Riferimento a un oggetto nella nuova matrice viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3422">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3423">Il `newarr` istruzione inserisce un riferimento all'oggetto (tipo `O`) in una nuova matrice unidimensionale in base zero i cui elementi sono di tipo `etype` (un token di metadati che descrive il tipo).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3423">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="45e2e-3424">Il numero di elementi nella nuova matrice deve essere specificato come un `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3424">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="45e2e-3425">Intervallo di indici di matrice valido compreso tra zero e il numero massimo di elementi meno uno.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3425">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="45e2e-3426">Gli elementi della matrice possono essere qualsiasi tipo, inclusi i tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3426">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="45e2e-3427">Le matrici unidimensionali in base zero di numeri vengono create utilizzando un token di metadati di riferimento al tipo di valore appropriato (<xref:System.Int32>e così via).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3427">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="45e2e-3428">Elementi della matrice vengono inizializzati a 0 del tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3428">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="45e2e-3429">Matrici unidimensionali a base e le matrici multidimensionali vengono create utilizzando <xref:System.Reflection.Emit.OpCodes.Newobj> anziché `newarr`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3429">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="45e2e-3430">Più comunemente, vengono creati utilizzando i metodi della <xref:System.Array> classe .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3430">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="45e2e-3431"><xref:System.OutOfMemoryException> viene generata se la memoria è insufficiente per soddisfare la richiesta.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3431"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="45e2e-3432"><xref:System.OverflowException> viene generata se `numElems` è minore di 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3432"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="45e2e-3433">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `newarr` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3434">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3434">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3435">Crea un nuovo oggetto o una nuova istanza di un tipo di valore, inserendo un riferimento a un oggetto (di tipo <see langword="O" />) nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3435">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3436">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3436">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3437">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3437">Format</span></span>|<span data-ttu-id="45e2e-3438">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3438">Assembly Format</span></span>|<span data-ttu-id="45e2e-3439">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3439">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3440">73 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3440">73 < `T` ></span></span>|<span data-ttu-id="45e2e-3441">newobj `ctor`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3441">newobj `ctor`</span></span>|<span data-ttu-id="45e2e-3442">Alloca un oggetto o valore di tipo non inizializzato e chiama il metodo costruttore `ctor`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3442">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="45e2e-3443">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3443">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3444">Argomenti `arg1` tramite `argn` vengono inseriti nello stack in sequenza.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3444">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="45e2e-3445">Argomenti `argn` tramite `arg1` vengono estratti dallo stack e passati a `ctor` per la creazione dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3445">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="45e2e-3446">Un riferimento al nuovo oggetto viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3446">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3447">Il `newobj` istruzione crea un nuovo oggetto o una nuova istanza di un tipo valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3447">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="45e2e-3448">`Ctor` è un token di metadati (un `methodref` o `methoddef` che deve essere contrassegnato come costruttore) che indica il nome, una classe e firma del costruttore da chiamare.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3448">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="45e2e-3449">Il `newobj` istruzione consente di allocare una nuova istanza della classe associata a `ctor` e inizializza tutti i campi nella nuova istanza su 0 (del tipo appropriato) o riferimenti null come appropriato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3449">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="45e2e-3450">Viene quindi chiamato il costruttore `ctor` con gli argomenti specificati insieme all'istanza appena creata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3450">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="45e2e-3451">Dopo la chiamata al costruttore, l'ora inizializzato riferimento all'oggetto (tipo `O`) viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3451">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3452">Dal punto di vista del costruttore, l'oggetto non inizializzato è l'argomento 0 e gli altri argomenti passati a newobj seguono in ordine.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3452">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="45e2e-3453">Tutte le matrici unidimensionali in base zero vengono create utilizzando <xref:System.Reflection.Emit.OpCodes.Newarr>, non `newobj`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3453">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="45e2e-3454">D'altra parte, tutte le altre matrici (più di una dimensione oppure unidimensionali, ma non in base zero) vengono create utilizzando `newobj`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3454">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="45e2e-3455">Tipi di valore non vengono in genere creati utilizzando `newobj`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3455">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="45e2e-3456">In genere vengono allocati come argomenti o variabili locali, utilizzando `newarr` (per matrici unidimensionali in base zero), o come campi di oggetti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3456">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="45e2e-3457">Dopo aver allocato, vengono inizializzati utilizzando <xref:System.Reflection.Emit.OpCodes.Initobj>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3457">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="45e2e-3458">Tuttavia, il `newobj` istruzione può essere utilizzata per creare una nuova istanza di un tipo di valore nello stack, che può quindi essere passato come argomento, archiviato in un ambiente locale e così via.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3458">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="45e2e-3459"><xref:System.OutOfMemoryException> viene generata se la memoria è insufficiente per soddisfare la richiesta.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3459"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="45e2e-3460"><xref:System.MissingMethodException> viene generata se un metodo del costruttore `ctor` con il nome indicato, classe e la firma non è state trovate.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3460"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="45e2e-3461">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, anziché in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3461">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-3462">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `newobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3462">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3463">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3464">Riempie lo spazio se i codici operativi sono corretti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3464">Fills space if opcodes are patched.</span>
          </span>
          <span data-ttu-id="45e2e-3465">Non viene eseguita alcuna operazione significativa sebbene possa essere usato un ciclo di elaborazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3465">No meaningful operation is performed although a processing cycle can be consumed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3466">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3466">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3467">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3467">Format</span></span>|<span data-ttu-id="45e2e-3468">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3468">Assembly Format</span></span>|<span data-ttu-id="45e2e-3469">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3469">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3470">00</span><span class="sxs-lookup"><span data-stu-id="45e2e-3470">00</span></span>|<span data-ttu-id="45e2e-3471">NOP</span><span class="sxs-lookup"><span data-stu-id="45e2e-3471">nop</span></span>|<span data-ttu-id="45e2e-3472">Esegue un'operazione senza comportamento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3472">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="45e2e-3473">Non vi è alcun comportamento di transizione dello stack definito per questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3473">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3474">Il `nop` non esegue alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3474">The `nop` operation does nothing.</span></span> <span data-ttu-id="45e2e-3475">È progettato per riempire lo spazio se i codici operativi sono corretti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3475">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="45e2e-3476">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `nop` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3476">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3477">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3477">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3478">Calcola il complemento bit per bit del valore intero all'inizio dello stack e inserisce il risultato nello stack di valutazione come lo stesso tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3478">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3479">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3479">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3480">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3480">Format</span></span>|<span data-ttu-id="45e2e-3481">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3481">Assembly Format</span></span>|<span data-ttu-id="45e2e-3482">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3482">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3483">66</span><span class="sxs-lookup"><span data-stu-id="45e2e-3483">66</span></span>|<span data-ttu-id="45e2e-3484">not</span><span class="sxs-lookup"><span data-stu-id="45e2e-3484">not</span></span>|<span data-ttu-id="45e2e-3485">Calcola il complemento bit per bit di un valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3485">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="45e2e-3486">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3486">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3487">`value` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3487">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3488">`value` viene estratto dallo stack e il bit per bit complemento calcolata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3488">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="45e2e-3489">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3489">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3490">Il `not` istruzione calcola il complemento bit per bit di un valore integer e inserisce il risultato nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3490">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="45e2e-3491">Il tipo restituito è lo stesso tipo dell'operando.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3491">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="45e2e-3492">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `not` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3492">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3493">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3493">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3494">Calcola il complemento bit per bit dei due valori interi all'inizio dello stack e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3494">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3495">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3495">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3496">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3496">Format</span></span>|<span data-ttu-id="45e2e-3497">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3497">Assembly Format</span></span>|<span data-ttu-id="45e2e-3498">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3498">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3499">60</span><span class="sxs-lookup"><span data-stu-id="45e2e-3499">60</span></span>|<span data-ttu-id="45e2e-3500">oppure</span><span class="sxs-lookup"><span data-stu-id="45e2e-3500">or</span></span>|<span data-ttu-id="45e2e-3501">Calcola il bit per bit o due valori integer, restituisce un valore integer.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3501">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="45e2e-3502">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3502">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3503">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3503">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3504">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3504">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3505">`value2` e `value1` vengono estratti dallo stack e relativo OR calcolata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3505">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="45e2e-3506">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3506">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3507">Il `or` istruzione calcola l'OR bit per bit dei due valori sopra lo stack, inserendo il risultato nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3507">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3508">`Or` è un'operazione specifica del numero intero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3508">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="45e2e-3509">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `or` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3509">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3510">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3510">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3511">Rimuove il valore attualmente all'inizio dello stack.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3511">Removes the value currently on top of the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3512">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3512">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3513">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3513">Format</span></span>|<span data-ttu-id="45e2e-3514">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3514">Assembly Format</span></span>|<span data-ttu-id="45e2e-3515">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3515">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3516">26</span><span class="sxs-lookup"><span data-stu-id="45e2e-3516">26</span></span>|<span data-ttu-id="45e2e-3517">pop</span><span class="sxs-lookup"><span data-stu-id="45e2e-3517">pop</span></span>|<span data-ttu-id="45e2e-3518">Estrae il valore dallo stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3518">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3519">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3519">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3520">Il primo valore viene estratto dallo stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3520">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3521">Il `pop` istruzione rimuove il primo elemento dallo stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3521">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3522">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `pop` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3522">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3523">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3523">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3524">Si tratta di un'istruzione riservata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3524">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3525">Si tratta di un'istruzione riservata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3525">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3526">Si tratta di un'istruzione riservata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3526">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3527">Si tratta di un'istruzione riservata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3527">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3528">Si tratta di un'istruzione riservata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3528">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3529">Si tratta di un'istruzione riservata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3529">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3530">Si tratta di un'istruzione riservata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3530">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3531">Si tratta di un'istruzione riservata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3531">This is a reserved instruction.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3532">Specifica che la successiva operazione sull'indirizzo di matrice non comporta l'esecuzione di alcun controllo del tipo in fase di esecuzione e che viene restituito un puntatore gestito la cui modificabilità è limitata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3532">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3533">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3533">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3534">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3534">Format</span></span>|<span data-ttu-id="45e2e-3535">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3535">Assembly Format</span></span>|<span data-ttu-id="45e2e-3536">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3536">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3537">FE 1E</span><span class="sxs-lookup"><span data-stu-id="45e2e-3537">FE 1E</span></span>|<span data-ttu-id="45e2e-3538">sola lettura.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3538">readonly.</span></span>|<span data-ttu-id="45e2e-3539">Specificare che l'operazione di indirizzo matrice successivi non esegue alcun controllo di tipo in fase di esecuzione e che restituisce un puntatore gestito mutabilità è limitata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3539">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="45e2e-3540">Questo prefisso può trovarsi solo immediatamente precedente il `ldelema` di istruzioni e le chiamate a speciale `Address` metodo sulle matrici.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3540">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="45e2e-3541">Il relativo effetto sulle operazioni successive ha un duplice:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3541">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="45e2e-3542">In fase di esecuzione, viene eseguita alcuna operazione di controllo di tipo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3542">At run time, no type check operation is performed.</span></span> <span data-ttu-id="45e2e-3543">Si noti che è in genere un controllo di tipo implicito per il `ldelema` e `stelem` matrici di tipi di istruzioni quando vengono utilizzate nel riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3543">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="45e2e-3544">Non è mai un controllo del tipo in fase di esecuzione per le classi di valore, in modo `readonly` viene eseguita alcuna operazione in questo caso.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3544">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="45e2e-3545">Il verificatore considera il risultato dell'operazione di indirizzo come un puntatore gestito mutabilità è limitata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3545">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="45e2e-3546">Il puntatore ha mutabilità limitata poiché il tipo di definizione controlla se il valore può essere modificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3546">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="45e2e-3547">Per le classi di valore che non espongono campi pubblici o i metodi di aggiornamento del valore, il puntatore è di sola lettura (da qui il nome del prefisso).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3547">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="45e2e-3548">In particolare, le classi che rappresentano i tipi primitivi (ad esempio, System. Int32) espongono modificatori e pertanto sono di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3548">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="45e2e-3549">Un puntatore gestito limitato in questo modo può essere utilizzato solo nei modi seguenti:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3549">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="45e2e-3550">Come il `object` parametro per il `ldfld`, `ldflda`, `stfld`, `call`, o`constrained callvirt` istruzioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3550">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="45e2e-3551">Come il `pointer` parametro per il `ldobj` istruzione o a uno del `ldind` istruzioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3551">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="45e2e-3552">Come il `source` parametro per il `cpobj` istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3552">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3553">Tutte le altre operazioni non consentite, incluse la `stobj`, `initobj`, o `mkrefany` operazioni o uno qualsiasi del `stind` istruzioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3553">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="45e2e-3554">Lo scopo del `readonly` prefisso consiste nell'evitare di un controllo del tipo durante il recupero di un elemento da una matrice in codice generico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3554">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="45e2e-3555">Ad esempio, l'espressione `arr[i].m()`, in cui il tipo di elemento della matrice `arr` è un tipo generico che può disporre di un'interfaccia con metodo `m`, può essere compilata nel seguente codice MSIL.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3555">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="45e2e-3556">Senza il `readonly` prefisso, il `ldelema` istruzione eseguirebbe un controllo del tipo nel caso in cui! 0 è un tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3556">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="45e2e-3557">Non solo è inefficiente questo controllo di tipo, ma non è semanticamente corretto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3557">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="45e2e-3558">Il controllo dei tipi per `ldelema` è una corrispondenza esatta, che è troppo complessa.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3558">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="45e2e-3559">Se nella matrice sono sottoclassi di tipo! 0, il codice precedente avrà esito negativo il controllo dei tipi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3559">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="45e2e-3560">L'indirizzo dell'elemento della matrice verrà recuperato, invece dell'elemento stesso, per disporre di un handle per `arr[i]` che utilizzi entrambi i tipi di valore e tipi di riferimento e pertanto può essere passati al `constrained callvirt` istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3560">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3561">In generale sarebbe unsafe ignora il controllo in fase di esecuzione se la matrice sono presenti elementi di un tipo riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3561">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="45e2e-3562">Per maggiore sicurezza, è necessario assicurarsi che nessuna modifica nella matrice viene effettuata tramite l'indicatore di misura.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3562">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="45e2e-3563">Le regole di sistema di verifica garantiscono tale requisito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3563">The verifier rules ensure this.</span></span> <span data-ttu-id="45e2e-3564">Il puntatore gestito con restrizioni può essere passato come l'oggetto di chiamate di metodo di istanza, pertanto non è in senso stretto sola lettura per i tipi di valore, ma nessun problema di sicurezza di tipo per tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3564">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="45e2e-3565">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `readonly` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3565">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3566">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3566">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3567">Recupera il token di tipo incorporato in un riferimento tipizzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3567">Retrieves the type token embedded in a typed reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3568">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3568">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3569">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3569">Format</span></span>|<span data-ttu-id="45e2e-3570">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3570">Assembly Format</span></span>|<span data-ttu-id="45e2e-3571">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3571">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3572">FE 1D</span><span class="sxs-lookup"><span data-stu-id="45e2e-3572">FE 1D</span></span>|<span data-ttu-id="45e2e-3573">refanytype</span><span class="sxs-lookup"><span data-stu-id="45e2e-3573">refanytype</span></span>|<span data-ttu-id="45e2e-3574">Inserisce il token di tipo archiviato in un riferimento tipizzato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3574">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="45e2e-3575">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3575">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3576">Riferimento a un tipo valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3576">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3577">Il riferimento tipizzato viene estratto dallo stack e recuperare il relativo token di tipo corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3577">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="45e2e-3578">Il token di tipo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3578">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3579">Un riferimento tipizzato contiene un token di tipo e un indirizzo per un'istanza dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3579">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="45e2e-3580">Il `refanytype` istruzione recupera il token di tipo incorporato nel riferimento tipizzato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3580">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="45e2e-3581">Vedere il <xref:System.Reflection.Emit.OpCodes.Mkrefany> istruzione per informazioni sulla creazione di riferimenti tipizzati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3581">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="45e2e-3582">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `refanytype` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3582">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3583">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3583">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3584">Recupera l'indirizzo (di tipo <see langword="&amp;" />) incorporato in un riferimento tipizzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3584">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3585">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3585">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3586">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3586">Format</span></span>|<span data-ttu-id="45e2e-3587">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3587">Assembly Format</span></span>|<span data-ttu-id="45e2e-3588">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3588">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3589">C2 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3589">C2 < `T` ></span></span>|<span data-ttu-id="45e2e-3590">refanyval `type`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3590">refanyval `type`</span></span>|<span data-ttu-id="45e2e-3591">Inserisce l'indirizzo archiviato in un riferimento tipizzato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3591">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="45e2e-3592">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3592">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3593">Riferimento a un tipo valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3593">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3594">Il riferimento tipizzato viene estratto dallo stack e recuperare l'indirizzo del corrispondente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3594">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="45e2e-3595">L'indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3595">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3596">Un riferimento tipizzato contiene un token di tipo e un indirizzo per un'istanza dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3596">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="45e2e-3597">Il `refanyval` istruzione recupera l'indirizzo incorporato di un riferimento tipizzato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3597">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="45e2e-3598">Il tipo incorporato nel riferimento tipizzato fornito nello stack deve corrispondere al tipo specificato da `type` (un token di metadati, ovvero un `typedef` o `typeref`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3598">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="45e2e-3599">Vedere il <xref:System.Reflection.Emit.OpCodes.Mkrefany> istruzione per il contenuto correlato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3599">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="45e2e-3600"><xref:System.InvalidCastException> viene generata se `type` non è identico al tipo memorizzato nel riferimento del tipo (in questo caso, `type` specificata per la classe di <xref:System.Reflection.Emit.OpCodes.Mkrefany> istruzione di costruzione ha un riferimento tipizzato).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3600"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="45e2e-3601"><xref:System.TypeLoadException> viene generata se `type` non è stato trovato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3601"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="45e2e-3602">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `refanyval` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3602">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3603">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3603">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3604">Divide due valori e inserisce il resto nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3604">Divides two values and pushes the remainder onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3605">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3605">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3606">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3606">Format</span></span>|<span data-ttu-id="45e2e-3607">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3607">Assembly Format</span></span>|<span data-ttu-id="45e2e-3608">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3608">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3609">5D</span><span class="sxs-lookup"><span data-stu-id="45e2e-3609">5D</span></span>|<span data-ttu-id="45e2e-3610">REM</span><span class="sxs-lookup"><span data-stu-id="45e2e-3610">rem</span></span>|<span data-ttu-id="45e2e-3611">Inserisce il resto della divisione `value1` da `value2` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3611">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="45e2e-3612">ReplaceThisText</span><span class="sxs-lookup"><span data-stu-id="45e2e-3612">ReplaceThisText</span></span>  
  
 <span data-ttu-id="45e2e-3613">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3613">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3614">Oggetto `value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3614">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3615">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3615">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3616">`value2` e `value1` vengono estratti dallo stack e il resto della `value1` `div` `value2` calcolato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3616">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="45e2e-3617">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3617">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3618">`result` = `value1` `rem` `value2` soddisfa le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3618">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="45e2e-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), e:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="45e2e-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign (`result`) = segno (`value1`), dove `div` è l'istruzione di divisione che troncata a zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="45e2e-3621">Se `value2` è uguale a zero o `value1` è infinito, il risultato è NaN.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3621">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="45e2e-3622">Se `value2` è infinito, il risultato è `value1` (negato per `-infinity`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3622">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="45e2e-3623">Le operazioni integrali generano <xref:System.DivideByZeroException> se `value2` è zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3623">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="45e2e-3624">Si noti che nelle piattaforme basate su Intel un <xref:System.OverflowException> viene generata un'eccezione durante il calcolo (minint `rem` -1).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3624">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="45e2e-3625">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `rem` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3626">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3627">Divide due valori senza segno e inserisce il resto nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3627">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3628">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3629">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3629">Format</span></span>|<span data-ttu-id="45e2e-3630">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3630">Assembly Format</span></span>|<span data-ttu-id="45e2e-3631">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3632">5E</span><span class="sxs-lookup"><span data-stu-id="45e2e-3632">5E</span></span>|<span data-ttu-id="45e2e-3633">rem.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-3633">rem.un</span></span>|<span data-ttu-id="45e2e-3634">Inserisce il resto della divisione senza segno `value1` da unsigned `value2` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3634">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3635">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3636">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3636">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3637">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3637">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3638">`value2` e `value1` vengono estratti dallo stack e il resto della `value1` `div` `value2` calcolato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3638">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="45e2e-3639">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3639">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3640">`result` = `value1` `rem.un` `value2` soddisfa le condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3640">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="45e2e-3641">`result` = `value1` - `value2` x (`value1` `div.un` `value2`), e:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3641">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="45e2e-3642">0 = `result`  <  `value2`, dove `div.un` è l'istruzione di divisione senza segno.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3642">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3643">Il `rem.un` istruzione calcola `result` e lo inserisce nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3643">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="45e2e-3644">`Rem.un` considera i propri argomenti come interi senza segno, mentre <xref:System.Reflection.Emit.OpCodes.Rem> li considera come interi con segno.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3644">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="45e2e-3645">`Rem.un` non è specificato per i numeri a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3645">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="45e2e-3646">Le operazioni integrali generano <xref:System.DivideByZeroException> se `value2` è zero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3646">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="45e2e-3647">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `rem.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3647">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3648">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3648">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3649">Restituisce il risultato del metodo corrente, inserendo il valore restituito (se presente) dallo stack di valutazione del chiamato nello stack di valutazione del chiamante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3649">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3650">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3650">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3651">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3651">Format</span></span>|<span data-ttu-id="45e2e-3652">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3652">Assembly Format</span></span>|<span data-ttu-id="45e2e-3653">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3653">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3654">2A</span><span class="sxs-lookup"><span data-stu-id="45e2e-3654">2A</span></span>|<span data-ttu-id="45e2e-3655">RET</span><span class="sxs-lookup"><span data-stu-id="45e2e-3655">ret</span></span>|<span data-ttu-id="45e2e-3656">Restituisce dal metodo, eventualmente restituendo un valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3656">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="45e2e-3657">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3657">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3658">Il valore restituito viene estratto dallo stack di valutazione del chiamato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3658">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3659">Il valore restituito ottenuto nel passaggio 1 viene inserito nello stack di valutazione chiamante.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3659">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="45e2e-3660">Se il valore restituito non è presente nello stack di valutazione chiamato, viene restituito alcun valore (Nessuna transizione sullo stack per il metodo chiamato o chiamante).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3660">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="45e2e-3661">Il tipo del valore restituito, se presente, il metodo corrente determina il tipo di valore da recuperare dalla parte superiore dello stack e copiare nello stack del metodo che ha chiamato il metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3661">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="45e2e-3662">Lo stack di valutazione per il metodo corrente deve essere vuoto tranne per il valore da restituire.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3662">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="45e2e-3663">Il `ret` istruzione non può essere utilizzata per trasferire il controllo di un`try`, `filter`, `catch`, o `finally` blocco.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3663">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="45e2e-3664">Dall'interno un `try` o `catch`, utilizzare il <xref:System.Reflection.Emit.OpCodes.Leave> istruzione con una destinazione di un `ret` istruzione all'esterno di tutti i blocchi di eccezioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3664">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="45e2e-3665">Poiché il `filter` e `finally` blocchi sono logicamente parte della gestione delle eccezioni e non il metodo in cui è incorporato il proprio codice, correttamente generate istruzioni Microsoft Intermediate Language (MSIL) non eseguono un metodo viene restituito all'interno di un `filter` o `finally`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3665">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="45e2e-3666">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `ret` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3666">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3667">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3667">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3668">Genera nuovamente l'eccezione corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3668">Rethrows the current exception.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3669">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3669">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3670">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3670">Format</span></span>|<span data-ttu-id="45e2e-3671">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3671">Assembly Format</span></span>|<span data-ttu-id="45e2e-3672">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3672">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3673">FE 1A</span><span class="sxs-lookup"><span data-stu-id="45e2e-3673">FE 1A</span></span>|<span data-ttu-id="45e2e-3674">rethrow</span><span class="sxs-lookup"><span data-stu-id="45e2e-3674">rethrow</span></span>|<span data-ttu-id="45e2e-3675">Genera nuovamente l'eccezione corrente</span><span class="sxs-lookup"><span data-stu-id="45e2e-3675">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="45e2e-3676">Nessun comportamento di transizione dello stack è definito per questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3676">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3677">Il `rethrow` istruzione è consentita solo all'interno del corpo di un `catch` gestore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3677">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="45e2e-3678">Genera la stessa eccezione che è stata intercettata da questo gestore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3678">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="45e2e-3679">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `rethrow` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3679">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3680">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3680">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3681">Sposta un valore intero verso sinistra (spostando gli zeri) di un numero specificato di bit, inserendo il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3681">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3682">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3682">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3683">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3683">Format</span></span>|<span data-ttu-id="45e2e-3684">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3684">Assembly Format</span></span>|<span data-ttu-id="45e2e-3685">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3685">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3686">62</span><span class="sxs-lookup"><span data-stu-id="45e2e-3686">62</span></span>|<span data-ttu-id="45e2e-3687">shl</span><span class="sxs-lookup"><span data-stu-id="45e2e-3687">shl</span></span>|<span data-ttu-id="45e2e-3688">Sposta un valore integer a sinistra (spostando gli zeri).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3688">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="45e2e-3689">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3689">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3690">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3690">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3691">La quantità di bit da spostare viene inserita nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3691">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3692">Il numero di bit da spostare e il valore viene estratto dallo stack; il valore viene spostato a sinistra del numero specificato di bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3692">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="45e2e-3693">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3693">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3694">Il `shl` istruzione sposta il valore (tipo `int32`, `int64` o `native int`) a sinistra del numero specificato di bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3694">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="45e2e-3695">Il numero di bit è un valore di tipo `int32` o `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3695">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="45e2e-3696">Se il numero di bit da spostare è maggiore o uguale alla larghezza (in bit) del valore fornito non è specificato il valore restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3696">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="45e2e-3697">`Shl` Inserisce un bit zero nella posizione più bassa su ogni turno.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3697">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="45e2e-3698">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `shl` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3699">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3700">Sposta un valore intero verso destra (spostando il segno) di un numero specificato di bit, inserendo il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3700">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3701">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3702">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3702">Format</span></span>|<span data-ttu-id="45e2e-3703">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3703">Assembly Format</span></span>|<span data-ttu-id="45e2e-3704">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3705">63</span><span class="sxs-lookup"><span data-stu-id="45e2e-3705">63</span></span>|<span data-ttu-id="45e2e-3706">shr</span><span class="sxs-lookup"><span data-stu-id="45e2e-3706">shr</span></span>|<span data-ttu-id="45e2e-3707">Sposta un valore integer a destra (spostando il segno).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3707">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="45e2e-3708">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3709">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3709">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3710">La quantità di bit da spostare viene inserita nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3710">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3711">Il numero di bit da spostare e il valore viene estratto dallo stack; il valore viene spostato a destra del numero specificato di bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3711">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="45e2e-3712">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3712">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3713">Il `shr.un` istruzione sposta il valore (tipo `int32`, `int64` o `native int`) a destra del numero specificato di bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3713">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="45e2e-3714">Il numero di bit è un valore di tipo `int32` o `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3714">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="45e2e-3715">Se il numero di bit da spostare è maggiore o uguale alla larghezza (in bit) del valore fornito non è specificato il valore restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3715">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="45e2e-3716">`Shr` Consente di replicare il bit più significativo per ogni turno, mantenendo il segno del valore originale di `result`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3716">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="45e2e-3717">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `shr` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3717">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3718">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3718">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3719">Sposta un valore intero senza segno verso destra (spostando gli zeri) di un numero specificato di bit, inserendo il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3719">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3720">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3720">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3721">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3721">Format</span></span>|<span data-ttu-id="45e2e-3722">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3722">Assembly Format</span></span>|<span data-ttu-id="45e2e-3723">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3723">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3724">64</span><span class="sxs-lookup"><span data-stu-id="45e2e-3724">64</span></span>|<span data-ttu-id="45e2e-3725">shr.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-3725">shr.un</span></span>|<span data-ttu-id="45e2e-3726">Sposta un valore integer a destra (spostando gli zeri).</span><span class="sxs-lookup"><span data-stu-id="45e2e-3726">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="45e2e-3727">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3727">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3728">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3728">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3729">La quantità di bit da spostare viene inserita nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3729">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3730">Il numero di bit da spostare e il valore viene estratto dallo stack; il valore viene spostato a destra del numero specificato di bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3730">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="45e2e-3731">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3731">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3732">Il `shr.un` istruzione sposta il valore (tipo `int32`, `int64` o `native int`) a destra del numero specificato di bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3732">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="45e2e-3733">Il numero di bit è un valore di tipo `int32`, `int64` o `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3733">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="45e2e-3734">Se il numero di bit da spostare è maggiore o uguale alla larghezza (in bit) del valore fornito non è specificato il valore restituito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3734">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="45e2e-3735">`Shr.un` Inserisce un bit zero nella posizione più alta in ogni turno.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3735">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="45e2e-3736">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `shr.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3736">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3737">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3737">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3738">Inserisce la dimensione in byte del tipo di valore fornito nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3738">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3739">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3739">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3740">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3740">Format</span></span>|<span data-ttu-id="45e2e-3741">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3741">Assembly Format</span></span>|<span data-ttu-id="45e2e-3742">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3742">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3743">FE 1C &LT; `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3743">FE 1C < `T` ></span></span>|<span data-ttu-id="45e2e-3744">sizeof `valType`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3744">sizeof `valType`</span></span>|<span data-ttu-id="45e2e-3745">Inserisce la dimensione in byte, di un tipo di valore come un `unsigned int32`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3745">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="45e2e-3746">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3746">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3747">Le dimensioni (in byte) del tipo di valore fornito (`valType`) viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3747">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3748">`valType` deve essere un token di metadati (un `typeref` o `typedef`) che specifica un tipo di valore, un tipo di riferimento o un parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3748">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="45e2e-3749">Per un tipo riferimento, la dimensione restituita è la dimensione di un valore di riferimento del corrispondente tipo (4 byte in sistemi a 32 bit), non alle dimensioni dei dati archiviati negli oggetti a cui fa riferimento il valore di riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3749">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="45e2e-3750">Un parametro di tipo generico può essere utilizzato solo nel corpo del tipo o metodo che lo definisce.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3750">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="45e2e-3751">Quando viene creata un'istanza di tipo o metodo, il parametro di tipo generico viene sostituito da un tipo di valore o tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3751">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="45e2e-3752">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `sizeof` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3752">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3753">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3753">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3754">Archivia il valore all'inizio dello stack di valutazione nello slot di argomento in corrispondenza di un indice specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3754">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3755">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3755">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3756">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3756">Format</span></span>|<span data-ttu-id="45e2e-3757">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3757">Assembly Format</span></span>|<span data-ttu-id="45e2e-3758">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3758">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3759">FE 0B &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3759">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="45e2e-3760">starg `num`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3760">starg `num`</span></span>|<span data-ttu-id="45e2e-3761">Estrae il valore dallo stack e lo archivia in uno slot di argomento `num`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3761">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="45e2e-3762">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3762">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3763">Il valore attualmente all'inizio dello stack viene estratto e inserito in uno slot di argomento `num`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3763">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="45e2e-3764">Il `starg` istruzione estrae un valore dallo stack e lo inserisce nello slot di argomento `num`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3764">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="45e2e-3765">Il tipo del valore deve corrispondere al tipo dell'argomento, come specificato nella firma del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3765">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="45e2e-3766">Per le procedure che accettano un elenco di argomenti variabili, il `starg` istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3766">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="45e2e-3767">Esecuzione di un archivio in argomenti che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack all'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3767">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="45e2e-3768">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata con l'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3768">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45e2e-3769">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `starg` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3770">ILGenerator (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3770">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3771">Archivia il valore all'inizio dello stack di valutazione nello slot di argomento in corrispondenza di un indice specificato, forma breve.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3771">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3772">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3773">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3773">Format</span></span>|<span data-ttu-id="45e2e-3774">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3774">Assembly Format</span></span>|<span data-ttu-id="45e2e-3775">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3776">10 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3776">10 < `unsigned int8` ></span></span>|<span data-ttu-id="45e2e-3777">starg.s `num`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3777">starg.s `num`</span></span>|<span data-ttu-id="45e2e-3778">Estrae il valore dallo stack e lo archivia in uno slot di argomento `num`, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3778">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-3779">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3780">Il valore attualmente all'inizio dello stack viene estratto e inserito in uno slot di argomento `num`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3780">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="45e2e-3781">Il `starg.s` istruzione estrae un valore dallo stack e lo inserisce nello slot di argomento `num`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3781">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="45e2e-3782">Il tipo del valore deve corrispondere al tipo dell'argomento, come specificato nella firma del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3782">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="45e2e-3783">Il `starg.s` istruzione fornisce una codifica efficiente per l'utilizzo con i primi 256 argomenti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3783">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="45e2e-3784">Per le procedure che accettano un elenco di argomenti variabili, il `starg.s` istruzione può essere utilizzata solo per gli argomenti, non quelli nella parte variabile della firma iniziali fissato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3784">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="45e2e-3785">Esecuzione di un archivio in argomenti che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack all'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3785">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="45e2e-3786">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata con l'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3786">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45e2e-3787">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `starg.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3787">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3788">ILGenerator (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3788">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3789">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore presente nello stack di valutazione, il cui tipo è specificato nell'istruzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3789">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3790">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3790">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3791">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3791">Format</span></span>|<span data-ttu-id="45e2e-3792">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3792">Assembly Format</span></span>|<span data-ttu-id="45e2e-3793">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3793">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3794">A4 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3794">A4 < `T` ></span></span>|<span data-ttu-id="45e2e-3795">st elem `typeTok`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3795">stelem `typeTok`</span></span>|<span data-ttu-id="45e2e-3796">Sostituisce l'elemento di matrice in corrispondenza dell'indice specificato con un valore di tipo `typeTok` nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3796">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3797">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3797">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3798">Un riferimento a una matrice, oggetto `array`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3798">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3799">Un valore di indice, `index`, a un elemento in `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3799">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3800">Un valore del tipo specificato nell'istruzione viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3800">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-3801">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3801">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45e2e-3802">Il `stelem` istruzione sostituisce il valore dell'elemento in corrispondenza dell'indice specificato in base zero nella matrice unidimensionale `array` con il valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3802">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="45e2e-3803">Il valore è il tipo specificato dal token `typeTok` nell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3803">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="45e2e-3804">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3804">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3805">L'indice è di tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3805">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-3806"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3806"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3807"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3807"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-3808"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3808"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-3809">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stelem` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3809">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3810">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3810">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3811">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="native int" /> sullo stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3811">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3812">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3812">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3813">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3813">Format</span></span>|<span data-ttu-id="45e2e-3814">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3814">Assembly Format</span></span>|<span data-ttu-id="45e2e-3815">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3815">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3816">9B</span><span class="sxs-lookup"><span data-stu-id="45e2e-3816">9B</span></span>|<span data-ttu-id="45e2e-3817">stelem.i</span><span class="sxs-lookup"><span data-stu-id="45e2e-3817">stelem.i</span></span>|<span data-ttu-id="45e2e-3818">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `native int` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3818">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3819">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3819">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3820">Un riferimento a una matrice, oggetto `array`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3820">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3821">Un indice valido per un elemento in `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3821">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3822">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3822">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-3823">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3823">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45e2e-3824">Il `stelem.i` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `native int` valore inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3824">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3825">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3825">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3826">L'indice è di tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3826">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-3827"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3827"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3828"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3828"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-3829"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3829"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-3830">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stelem.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3830">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3831">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3831">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3832">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="int8" /> sullo stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3832">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3833">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3833">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3834">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3834">Format</span></span>|<span data-ttu-id="45e2e-3835">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3835">Assembly Format</span></span>|<span data-ttu-id="45e2e-3836">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3836">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3837">9C</span><span class="sxs-lookup"><span data-stu-id="45e2e-3837">9C</span></span>|<span data-ttu-id="45e2e-3838">stelem.i1</span><span class="sxs-lookup"><span data-stu-id="45e2e-3838">stelem.i1</span></span>|<span data-ttu-id="45e2e-3839">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `int8` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3839">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3840">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3840">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3841">Un riferimento a una matrice, oggetto `array`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3841">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3842">Un indice valido per un elemento in `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3842">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3843">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3843">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-3844">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3844">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45e2e-3845">Il `stelem.i1` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `int8` valore inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3845">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3846">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3846">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3847">L'indice è di tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3847">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-3848"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3848"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3849"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3849"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-3850"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3850"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-3851">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stelem.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3851">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3852">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3852">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3853">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="int16" /> sullo stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3853">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3854">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3855">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3855">Format</span></span>|<span data-ttu-id="45e2e-3856">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3856">Assembly Format</span></span>|<span data-ttu-id="45e2e-3857">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3858">9D</span><span class="sxs-lookup"><span data-stu-id="45e2e-3858">9D</span></span>|<span data-ttu-id="45e2e-3859">stelem.i2</span><span class="sxs-lookup"><span data-stu-id="45e2e-3859">stelem.i2</span></span>|<span data-ttu-id="45e2e-3860">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `int16` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3860">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3861">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3862">Un riferimento a una matrice, oggetto `array`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3862">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3863">Un indice valido per un elemento in `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3863">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3864">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3864">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-3865">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3865">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45e2e-3866">Il `stelem.i2` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `int16` valore inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3866">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3867">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3867">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3868">L'indice è di tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3868">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-3869"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3869"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3870"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3870"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-3871"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3871"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-3872">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stelem.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3872">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3873">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3873">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3874">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="int32" /> sullo stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3874">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3875">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3875">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3876">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3876">Format</span></span>|<span data-ttu-id="45e2e-3877">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3877">Assembly Format</span></span>|<span data-ttu-id="45e2e-3878">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3878">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3879">9E</span><span class="sxs-lookup"><span data-stu-id="45e2e-3879">9E</span></span>|<span data-ttu-id="45e2e-3880">stelem.i4</span><span class="sxs-lookup"><span data-stu-id="45e2e-3880">stelem.i4</span></span>|<span data-ttu-id="45e2e-3881">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `int32` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3881">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3882">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3882">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3883">Un riferimento a una matrice, oggetto `array`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3883">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3884">Un indice valido per un elemento in `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3884">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3885">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3885">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-3886">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3886">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45e2e-3887">Il `stelem.i4` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `int32` valore inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3887">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3888">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3888">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3889">L'indice è di tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3889">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-3890"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3890"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3891"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3891"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-3892"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3892"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-3893">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stelem.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3893">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3894">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3894">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3895">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="int64" /> sullo stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3895">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3896">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3896">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3897">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3897">Format</span></span>|<span data-ttu-id="45e2e-3898">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3898">Assembly Format</span></span>|<span data-ttu-id="45e2e-3899">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3899">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3900">9F</span><span class="sxs-lookup"><span data-stu-id="45e2e-3900">9F</span></span>|<span data-ttu-id="45e2e-3901">stelem.i8</span><span class="sxs-lookup"><span data-stu-id="45e2e-3901">stelem.i8</span></span>|<span data-ttu-id="45e2e-3902">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `int64` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3902">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3903">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3903">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3904">Un riferimento a una matrice, oggetto `array`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3904">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3905">Un indice valido per un elemento in `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3905">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3906">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3906">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-3907">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3907">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45e2e-3908">Il `stelem.i8` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `int64` valore inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3908">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3909">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3909">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3910">L'indice è di tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3910">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-3911"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3911"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3912"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3912"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-3913"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3913"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-3914">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stelem.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3914">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3915">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3915">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3916">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="float32" /> sullo stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3916">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3917">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3917">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3918">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3918">Format</span></span>|<span data-ttu-id="45e2e-3919">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3919">Assembly Format</span></span>|<span data-ttu-id="45e2e-3920">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3920">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3921">A0</span><span class="sxs-lookup"><span data-stu-id="45e2e-3921">A0</span></span>|<span data-ttu-id="45e2e-3922">stelem.r4</span><span class="sxs-lookup"><span data-stu-id="45e2e-3922">stelem.r4</span></span>|<span data-ttu-id="45e2e-3923">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `float32` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3923">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3924">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3924">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3925">Un riferimento a una matrice, oggetto `array`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3925">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3926">Un indice valido per un elemento in `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3926">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3927">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3927">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-3928">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3928">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45e2e-3929">Il `stelem.r4` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `float32` valore inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3929">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3930">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3930">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3931">L'indice è di tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3931">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-3932"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3932"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3933"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3933"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-3934"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3934"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-3935">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stelem.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3935">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3936">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3936">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3937">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore <see langword="float64" /> sullo stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3937">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3938">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3938">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3939">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3939">Format</span></span>|<span data-ttu-id="45e2e-3940">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3940">Assembly Format</span></span>|<span data-ttu-id="45e2e-3941">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3941">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3942">A1</span><span class="sxs-lookup"><span data-stu-id="45e2e-3942">A1</span></span>|<span data-ttu-id="45e2e-3943">stelem.r8</span><span class="sxs-lookup"><span data-stu-id="45e2e-3943">stelem.r8</span></span>|<span data-ttu-id="45e2e-3944">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `float64` valore nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3944">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3945">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3945">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3946">Un riferimento a una matrice, oggetto `array`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3946">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3947">Un indice valido per un elemento in `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3947">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3948">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3948">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-3949">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3949">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45e2e-3950">Il `stelem.r8` istruzione sostituisce il valore dell'elemento `index` nella matrice unidimensionale `array` con il `float64` valore inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3950">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3951">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3951">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3952">L'indice è di tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3952">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-3953"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3953"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3954"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3954"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-3955"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3955"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-3956">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stelem.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3956">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3957">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3957">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3958">Sostituisce l'elemento di matrice in corrispondenza di un indice specificato con il valore di un riferimento a un oggetto (di tipo <see langword="O" />) sullo stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3958">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3959">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3959">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3960">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3960">Format</span></span>|<span data-ttu-id="45e2e-3961">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3961">Assembly Format</span></span>|<span data-ttu-id="45e2e-3962">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3962">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3963">A2</span><span class="sxs-lookup"><span data-stu-id="45e2e-3963">A2</span></span>|<span data-ttu-id="45e2e-3964">stelem.ref</span><span class="sxs-lookup"><span data-stu-id="45e2e-3964">stelem.ref</span></span>|<span data-ttu-id="45e2e-3965">Sostituisce un elemento di matrice in corrispondenza dell'indice specificato con il `ref` valore (tipo `O`) nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3965">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="45e2e-3966">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3966">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3967">Un riferimento a una matrice, oggetto `array`, viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3967">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3968">Un indice valido per un elemento in `array` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3968">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3969">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3969">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45e2e-3970">Il valore dell'indice e il riferimento della matrice vengono estratti dallo stack; il valore viene inserito nell'elemento di matrice in corrispondenza dell'indice specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3970">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45e2e-3971">Il `stelem.ref` istruzione sostituisce il valore dell'elemento in corrispondenza dell'indice specificato nella matrice unidimensionale `array` con il `ref` (tipo `O`) valore inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3971">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-3972">Le matrici sono oggetti e sono pertanto rappresentate da un valore di tipo `O`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3972">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45e2e-3973">L'indice è di tipo `native int`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3973">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45e2e-3974">Si noti che `stelem.ref` esegue il cast in modo implicito il valore fornito per il tipo di elemento di `array` prima di assegnare il valore all'elemento della matrice.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3974">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="45e2e-3975">Questa operazione può non riuscire, anche per il codice di verifica.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3975">This cast can fail, even for verified code.</span></span> <span data-ttu-id="45e2e-3976">In questo modo il `stelem.ref` istruzione può generare <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3976">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="45e2e-3977">Per le matrici unidimensionali che non sono in base zero e per le matrici multidimensionali, di <xref:System.Array> classe fornisce un <xref:System.Array.SetValue%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3977">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="45e2e-3978"><xref:System.NullReferenceException> viene generata se `array` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3978"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-3979"><xref:System.IndexOutOfRangeException> viene generata se `index` è negativo o maggiore del limite di `array`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3979"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45e2e-3980"><xref:System.ArrayTypeMismatchException> viene generata se `array` non contiene elementi del tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3980"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45e2e-3981">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stelem.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-3982">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-3982">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-3983">Sostituisce il valore archiviato nel campo di un riferimento a un oggetto o puntatore con un nuovo valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-3983">Replaces the value stored in the field of an object reference or pointer with a new value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-3984">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-3985">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-3985">Format</span></span>|<span data-ttu-id="45e2e-3986">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-3986">Assembly Format</span></span>|<span data-ttu-id="45e2e-3987">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-3987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-3988">7D < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-3988">7D < `T` ></span></span>|<span data-ttu-id="45e2e-3989">stfld `field`</span><span class="sxs-lookup"><span data-stu-id="45e2e-3989">stfld `field`</span></span>|<span data-ttu-id="45e2e-3990">Sostituisce il valore di `field` dell'oggetto con un nuovo valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3990">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="45e2e-3991">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-3991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-3992">Un riferimento a un oggetto o puntatore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3992">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-3993">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3993">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-3994">Il valore e il riferimento o puntatore all'oggetto vengono estratti dallo stack; il valore di `field` viene sostituito con il valore fornito nell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3994">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="45e2e-3995">Il `stfld` istruzione sostituisce il valore di un campo di un oggetto (tipo `O`) o tramite un puntatore (tipo `native int`, `&`, o `*`) con un valore specifico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3995">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="45e2e-3996">`Field` è un token di metadati che fa riferimento a un riferimento al membro di campo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3996">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="45e2e-3997">Il `stfld` istruzione può disporre di un prefisso di uno o entrambi <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3997">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="45e2e-3998"><xref:System.NullReferenceException> viene generata se il riferimento all'oggetto o il puntatore è un riferimento null e il campo non statico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3998"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="45e2e-3999"><xref:System.MissingFieldException> viene generata se `field` non viene trovato nei metadati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-3999"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="45e2e-4000">Questo viene controllato in genere quando l'istruzione di Microsoft Intermediate Language (MSIL) viene convertita in codice nativo, non in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4000">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-4001">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4002">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4002">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4003">Memorizza un valore di tipo <see langword="native int" /> in corrispondenza di un indirizzo fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4003">Stores a value of type <see langword="native int" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4004">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4005">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4005">Format</span></span>|<span data-ttu-id="45e2e-4006">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4006">Assembly Format</span></span>|<span data-ttu-id="45e2e-4007">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4008">DF</span><span class="sxs-lookup"><span data-stu-id="45e2e-4008">DF</span></span>|<span data-ttu-id="45e2e-4009">stind.i</span><span class="sxs-lookup"><span data-stu-id="45e2e-4009">stind.i</span></span>|<span data-ttu-id="45e2e-4010">Archivia un `native int` valore in corrispondenza di un determinato indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4010">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="45e2e-4011">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4011">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4012">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4012">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4013">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4013">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4014">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4014">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45e2e-4015">Il `stind.i` istruzione archivi un `native int` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4015">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45e2e-4016">Tipo di operazione provvisoria richiede che il `stind.i` istruzione sia utilizzata in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4016">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45e2e-4017">L'operazione del `stind.i` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4017">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4018"><xref:System.NullReferenceException> viene generata se `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4018"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45e2e-4019">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stind.i` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4019">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4020">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4020">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4021">Memorizza un valore di tipo <see langword="int8" /> in corrispondenza di un indirizzo fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4021">Stores a value of type <see langword="int8" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4022">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4022">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4023">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4023">Format</span></span>|<span data-ttu-id="45e2e-4024">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4024">Assembly Format</span></span>|<span data-ttu-id="45e2e-4025">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4025">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4026">52</span><span class="sxs-lookup"><span data-stu-id="45e2e-4026">52</span></span>|<span data-ttu-id="45e2e-4027">stind.i1</span><span class="sxs-lookup"><span data-stu-id="45e2e-4027">stind.i1</span></span>|<span data-ttu-id="45e2e-4028">Archivia un `int8` valore in corrispondenza di un determinato indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4028">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="45e2e-4029">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4029">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4030">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4030">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4031">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4031">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4032">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4032">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45e2e-4033">Il `stind.i1` istruzione archivi un `int8` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4033">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45e2e-4034">Tipo di operazione provvisoria richiede che il `stind.i1` istruzione sia utilizzata in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4034">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45e2e-4035">L'operazione del `stind.i1` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4035">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4036"><xref:System.NullReferenceException> viene generata se `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4036"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45e2e-4037">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stind.i1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4038">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4039">Memorizza un valore di tipo <see langword="int16" /> in corrispondenza di un indirizzo fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4039">Stores a value of type <see langword="int16" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4040">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4040">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4041">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4041">Format</span></span>|<span data-ttu-id="45e2e-4042">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4042">Assembly Format</span></span>|<span data-ttu-id="45e2e-4043">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4044">53</span><span class="sxs-lookup"><span data-stu-id="45e2e-4044">53</span></span>|<span data-ttu-id="45e2e-4045">stind.i2</span><span class="sxs-lookup"><span data-stu-id="45e2e-4045">stind.i2</span></span>|<span data-ttu-id="45e2e-4046">Archivia un `int16` valore in corrispondenza di un determinato indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4046">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="45e2e-4047">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4047">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4048">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4048">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4049">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4049">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4050">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4050">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45e2e-4051">Il `stind.i2` istruzione archivi un `int16` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4051">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45e2e-4052">Tipo di operazione provvisoria richiede che il `stind.2i` istruzione sia utilizzata in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4052">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45e2e-4053">L'operazione del `stind.i2` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4053">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4054"><xref:System.NullReferenceException> viene generata se `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4054"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45e2e-4055">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stind.i2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4055">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4056">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4056">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4057">Memorizza un valore di tipo <see langword="int32" /> in corrispondenza di un indirizzo fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4057">Stores a value of type <see langword="int32" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4058">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4058">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4059">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4059">Format</span></span>|<span data-ttu-id="45e2e-4060">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4060">Assembly Format</span></span>|<span data-ttu-id="45e2e-4061">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4061">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4062">54</span><span class="sxs-lookup"><span data-stu-id="45e2e-4062">54</span></span>|<span data-ttu-id="45e2e-4063">stind.i4</span><span class="sxs-lookup"><span data-stu-id="45e2e-4063">stind.i4</span></span>|<span data-ttu-id="45e2e-4064">Archivia un `int32` valore in corrispondenza di un determinato indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4064">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="45e2e-4065">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4065">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4066">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4066">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4067">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4067">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4068">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4068">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45e2e-4069">Il `stind.i4` istruzione archivi un `int32` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4069">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45e2e-4070">Tipo di operazione provvisoria richiede che il `stind.i4` istruzione sia utilizzata in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4070">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45e2e-4071">L'operazione del `stind.i4` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4071">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4072"><xref:System.NullReferenceException> viene generata se `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4072"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45e2e-4073">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stind.i4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4073">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4074">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4074">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4075">Memorizza un valore di tipo <see langword="int64" /> in corrispondenza di un indirizzo fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4075">Stores a value of type <see langword="int64" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4076">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4076">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4077">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4077">Format</span></span>|<span data-ttu-id="45e2e-4078">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4078">Assembly Format</span></span>|<span data-ttu-id="45e2e-4079">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4079">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4080">55</span><span class="sxs-lookup"><span data-stu-id="45e2e-4080">55</span></span>|<span data-ttu-id="45e2e-4081">stind.i8</span><span class="sxs-lookup"><span data-stu-id="45e2e-4081">stind.i8</span></span>|<span data-ttu-id="45e2e-4082">Archivia un `int64` valore in corrispondenza di un determinato indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4082">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="45e2e-4083">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4083">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4084">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4084">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4085">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4085">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4086">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4086">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45e2e-4087">Il `stind.i8` istruzione archivi un `int64` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4087">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45e2e-4088">Tipo di operazione provvisoria richiede che il `stind.i8` istruzione sia utilizzata in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4088">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45e2e-4089">L'operazione del `stind.i` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4089">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4090"><xref:System.NullReferenceException> viene generata se `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4090"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45e2e-4091">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stind.i8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4091">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4092">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4092">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4093">Memorizza un valore di tipo <see langword="float32" /> in corrispondenza di un indirizzo fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4093">Stores a value of type <see langword="float32" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4094">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4094">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4095">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4095">Format</span></span>|<span data-ttu-id="45e2e-4096">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4096">Assembly Format</span></span>|<span data-ttu-id="45e2e-4097">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4097">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4098">56</span><span class="sxs-lookup"><span data-stu-id="45e2e-4098">56</span></span>|<span data-ttu-id="45e2e-4099">stind.r4</span><span class="sxs-lookup"><span data-stu-id="45e2e-4099">stind.r4</span></span>|<span data-ttu-id="45e2e-4100">Archivia un `float32` valore in corrispondenza di un determinato indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4100">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="45e2e-4101">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4101">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4102">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4102">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4103">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4103">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4104">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4104">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45e2e-4105">Il `stind.r4` istruzione archivi un `float32` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4105">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45e2e-4106">Tipo di operazione provvisoria richiede che il `stind.r4` istruzione sia utilizzata in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4106">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45e2e-4107">L'operazione del `stind.r4` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4107">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4108"><xref:System.NullReferenceException> viene generata se `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4108"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45e2e-4109">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stind.r4` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4109">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4110">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4110">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4111">Memorizza un valore di tipo <see langword="float64" /> in corrispondenza di un indirizzo fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4111">Stores a value of type <see langword="float64" /> at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4112">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4112">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4113">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4113">Format</span></span>|<span data-ttu-id="45e2e-4114">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4114">Assembly Format</span></span>|<span data-ttu-id="45e2e-4115">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4115">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4116">57</span><span class="sxs-lookup"><span data-stu-id="45e2e-4116">57</span></span>|<span data-ttu-id="45e2e-4117">stind.r8</span><span class="sxs-lookup"><span data-stu-id="45e2e-4117">stind.r8</span></span>|<span data-ttu-id="45e2e-4118">Archivia un `float64` valore in corrispondenza di un determinato indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4118">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="45e2e-4119">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4119">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4120">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4120">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4121">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4121">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4122">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4122">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45e2e-4123">Il `stind.r8` istruzione archivi un `float64` valore in corrispondenza dell'indirizzo fornito (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4123">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45e2e-4124">Tipo di operazione provvisoria richiede che il `stind.r8` istruzione sia utilizzata in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4124">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45e2e-4125">L'operazione del `stind.r8` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4125">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4126"><xref:System.NullReferenceException> viene generata se `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4126"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45e2e-4127">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stind.r8` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4128">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4128">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4129">Archivia il valore di un riferimento a un oggetto in corrispondenza di un indirizzo fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4129">Stores a object reference value at a supplied address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4130">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4131">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4131">Format</span></span>|<span data-ttu-id="45e2e-4132">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4132">Assembly Format</span></span>|<span data-ttu-id="45e2e-4133">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4134">51</span><span class="sxs-lookup"><span data-stu-id="45e2e-4134">51</span></span>|<span data-ttu-id="45e2e-4135">stind.ref</span><span class="sxs-lookup"><span data-stu-id="45e2e-4135">stind.ref</span></span>|<span data-ttu-id="45e2e-4136">Archivia un riferimento all'oggetto (tipo `O`) valore in corrispondenza di un determinato indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4136">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="45e2e-4137">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4138">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4138">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4139">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4139">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4140">Il valore e l'indirizzo vengono estratti dallo stack; il valore viene archiviato in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4140">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45e2e-4141">Il `stind.ref` istruzione memorizza un valore di riferimento di oggetto in corrispondenza dell'indirizzo specificato (tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4141">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45e2e-4142">Tipo di operazione provvisoria richiede che il `stind.ref` istruzione sia utilizzata in modo coerente con il tipo del puntatore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4142">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45e2e-4143">L'operazione del `stind.ref` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4143">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4144"><xref:System.NullReferenceException> viene generata se `addr` non è allineato naturalmente per il tipo di argomento implicito dal suffisso dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4144"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45e2e-4145">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stind.ref` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4145">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4146">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4146">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4147">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza di un indice specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4147">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4148">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4148">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4149">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4149">Format</span></span>|<span data-ttu-id="45e2e-4150">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4150">Assembly Format</span></span>|<span data-ttu-id="45e2e-4151">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4151">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4152">FE 0E &LT; `unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-4152">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="45e2e-4153">stloc `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-4153">stloc `index`</span></span>|<span data-ttu-id="45e2e-4154">Estrae un valore dallo stack e la archivia nella variabile locale `index`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4154">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="45e2e-4155">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4155">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4156">Un valore viene estratto dallo stack e inserito nella variabile locale `index`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4156">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="45e2e-4157">Il `stloc` istruzione estrae il valore dallo stack di valutazione e lo sposta in numero di variabile locale `index`, in cui le variabili locali sono numerate a partire da 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4157">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45e2e-4158">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4158">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45e2e-4159">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4159">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45e2e-4160">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata con l'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4160">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45e2e-4161">Le istruzioni Microsoft Intermediate Language (MSIL) corrette richiedono che `index` sia un indice locale valido.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4161">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="45e2e-4162">Per il `stloc` (istruzione), `index` deve essere compreso nell'intervallo tra 0 e 65.534 compreso (in particolare, 65535 non è valido).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4162">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="45e2e-4163">Il motivo di 65.535 non è valido: implementazioni simili utilizzeranno un integer a 2 byte per tenere traccia sia un indice locale, nonché il numero totale di variabili locali per un metodo specificato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4163">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="45e2e-4164">Se un indice di 65535 è stato reso valido, sarebbe necessario un valore integer più ampio tenere traccia del numero di variabili locali in tale metodo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4164">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="45e2e-4165">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload è possibile utilizzare il `stloc` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4165">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4166">ILGenerator (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4166">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="45e2e-4167">ILGenerator (OpCode, short)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4167">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4168">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4168">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4169">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4169">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4170">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4170">Format</span></span>|<span data-ttu-id="45e2e-4171">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4171">Assembly Format</span></span>|<span data-ttu-id="45e2e-4172">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4172">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4173">0A</span><span class="sxs-lookup"><span data-stu-id="45e2e-4173">0A</span></span>|<span data-ttu-id="45e2e-4174">stloc.0</span><span class="sxs-lookup"><span data-stu-id="45e2e-4174">stloc.0</span></span>|<span data-ttu-id="45e2e-4175">Estrae un valore dallo stack nella variabile locale 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4175">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="45e2e-4176">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4176">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4177">Un valore viene estratto dallo stack e inserito nella variabile locale indicizzata da 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4177">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="45e2e-4178">Il `stloc.0` istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata da 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4178">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="45e2e-4179">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4179">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45e2e-4180">`stloc.0` è una codifica particolarmente efficace per archiviare i valori nella variabile locale 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4180">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="45e2e-4181">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4181">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45e2e-4182">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata con l'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4182">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45e2e-4183">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stloc.0` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4183">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4184">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4184">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4185">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4185">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4186">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4186">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4187">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4187">Format</span></span>|<span data-ttu-id="45e2e-4188">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4188">Assembly Format</span></span>|<span data-ttu-id="45e2e-4189">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4189">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4190">0B</span><span class="sxs-lookup"><span data-stu-id="45e2e-4190">0B</span></span>|<span data-ttu-id="45e2e-4191">stloc.1</span><span class="sxs-lookup"><span data-stu-id="45e2e-4191">stloc.1</span></span>|<span data-ttu-id="45e2e-4192">Estrae un valore dallo stack nella variabile locale 1.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4192">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="45e2e-4193">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4193">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4194">Un valore viene estratto dallo stack e inserito nella variabile locale indicizzata in base 1.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4194">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="45e2e-4195">Il `stloc.1` istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata in base 1.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4195">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="45e2e-4196">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4196">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45e2e-4197">`stloc.1` è una codifica particolarmente efficace per archiviare i valori nella variabile locale 1.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4197">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="45e2e-4198">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4198">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45e2e-4199">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata con l'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4199">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45e2e-4200">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stloc.1` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4201">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4202">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4202">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4203">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4204">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4204">Format</span></span>|<span data-ttu-id="45e2e-4205">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4205">Assembly Format</span></span>|<span data-ttu-id="45e2e-4206">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4207">0C</span><span class="sxs-lookup"><span data-stu-id="45e2e-4207">0C</span></span>|<span data-ttu-id="45e2e-4208">stloc.2</span><span class="sxs-lookup"><span data-stu-id="45e2e-4208">stloc.2</span></span>|<span data-ttu-id="45e2e-4209">Estrae un valore dallo stack nella variabile locale 2</span><span class="sxs-lookup"><span data-stu-id="45e2e-4209">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="45e2e-4210">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4211">Un valore viene estratto dallo stack e inserito nella variabile locale indicizzata per 2.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4211">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="45e2e-4212">Il `stloc.2` istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata per 2.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4212">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="45e2e-4213">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4213">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45e2e-4214">`stloc.2` è una codifica particolarmente efficace per archiviare i valori nella variabile locale 2.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4214">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="45e2e-4215">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4215">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45e2e-4216">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata con l'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4216">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45e2e-4217">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stloc.2` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4217">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4218">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4218">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4219">Estrae il valore corrente dall'inizio dello stack di valutazione e lo archivia nell'elenco delle variabili locali in corrispondenza dell'indice 3.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4219">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4220">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4220">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4221">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4221">Format</span></span>|<span data-ttu-id="45e2e-4222">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4222">Assembly Format</span></span>|<span data-ttu-id="45e2e-4223">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4223">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4224">0D</span><span class="sxs-lookup"><span data-stu-id="45e2e-4224">0D</span></span>|<span data-ttu-id="45e2e-4225">stloc.3</span><span class="sxs-lookup"><span data-stu-id="45e2e-4225">stloc.3</span></span>|<span data-ttu-id="45e2e-4226">Estrae un valore dallo stack nella variabile locale 3</span><span class="sxs-lookup"><span data-stu-id="45e2e-4226">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="45e2e-4227">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4227">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4228">Un valore viene estratto dallo stack e inserito nella variabile locale indicizzata per 3.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4228">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="45e2e-4229">Il `stloc.3` istruzione estrae il valore dallo stack di valutazione e lo sposta nella variabile locale indicizzata per 3.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4229">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="45e2e-4230">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4230">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45e2e-4231">`stloc.3` è una codifica particolarmente efficace per archiviare i valori nella variabile locale 3.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4231">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="45e2e-4232">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4232">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45e2e-4233">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata con l'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4233">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45e2e-4234">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stloc.3` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4234">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4235">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4235">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4236">Estrae il valore corrente dall'inizio dello stack di valutazione e lo memorizza nell'elenco delle variabili in corrispondenza di <paramref name="index" /> (forma breve).</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4236">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4237">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4237">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4238">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4238">Format</span></span>|<span data-ttu-id="45e2e-4239">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4239">Assembly Format</span></span>|<span data-ttu-id="45e2e-4240">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4240">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4241">13 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-4241">13 < `unsigned int8` ></span></span>|<span data-ttu-id="45e2e-4242">stloc.s `index`</span><span class="sxs-lookup"><span data-stu-id="45e2e-4242">stloc.s `index`</span></span>|<span data-ttu-id="45e2e-4243">Estrae un valore dallo stack e la archivia nella variabile locale `index`, forma breve.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4243">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="45e2e-4244">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4244">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4245">Un valore viene estratto dallo stack e inserito nella variabile locale `index`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4245">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="45e2e-4246">Il `stloc.s` istruzione estrae il valore dallo stack di valutazione e lo sposta in numero di variabile locale `index`, in cui le variabili locali sono numerate a partire da 0.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4246">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45e2e-4247">Il tipo del valore deve corrispondere al tipo di variabile locale, come specificato nella firma locale del metodo corrente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4247">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45e2e-4248">Il `stloc.s` istruzione fornisce una codifica efficiente per le variabili locali 0 e 255.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4248">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="45e2e-4249">Archiviare in variabili locali che contengono un valore integer minore di 4 byte tronca il valore quando passa dallo stack alla variabile locale.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4249">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45e2e-4250">I valori a virgola mobile vengono arrotondati dalla dimensione nativa (tipo `F`) per la dimensione associata con l'argomento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4250">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45e2e-4251">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload è possibile utilizzare il `stloc.s` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4252">ILGenerator (OpCode, LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4252">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="45e2e-4253">ILGenerator (OpCode, byte)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4253">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4254">Copia un valore di un tipo specificato dallo stack di valutazione in un indirizzo di memoria fornito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4254">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4255">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4255">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4256">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4256">Format</span></span>|<span data-ttu-id="45e2e-4257">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4257">Assembly Format</span></span>|<span data-ttu-id="45e2e-4258">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4258">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4259">81 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-4259">81 < `T` ></span></span>|<span data-ttu-id="45e2e-4260">stobj `class`</span><span class="sxs-lookup"><span data-stu-id="45e2e-4260">stobj `class`</span></span>|<span data-ttu-id="45e2e-4261">Archivia un valore di tipo `class` dallo stack nella memoria.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4261">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="45e2e-4262">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4262">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4263">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4263">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4264">Un oggetto di tipo di valore di tipo `class` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4264">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4265">L'oggetto e l'indirizzo vengono estratti dallo stack; l'oggetto di tipo valore viene archiviato in corrispondenza dell'indirizzo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4265">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="45e2e-4266">Il `stobj` istruzione copia l'oggetto di tipo di valore nell'indirizzo specificato dall'indirizzo (un puntatore di tipo `native int`, `*`, o `&`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4266">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="45e2e-4267">Il numero di byte copiati dipende dalle dimensioni della classe rappresentata dal `class`, un token di metadati che rappresenta un tipo di valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4267">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="45e2e-4268">L'operazione del `stobj` istruzione può essere modificato da un immediatamente precedente <xref:System.Reflection.Emit.OpCodes.Volatile> o <xref:System.Reflection.Emit.OpCodes.Unaligned> immediatamente precedente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4268">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4269"><xref:System.TypeLoadException> viene generata se non è possibile trovare la classe.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4269"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="45e2e-4270">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo piuttosto che in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4270">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="45e2e-4271">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stobj` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4271">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4272">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4272">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4273">Sostituisce il valore di un campo statico con un valore dallo stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4273">Replaces the value of a static field with a value from the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4274">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4274">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4275">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4275">Format</span></span>|<span data-ttu-id="45e2e-4276">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4276">Assembly Format</span></span>|<span data-ttu-id="45e2e-4277">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4277">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4278">80 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-4278">80 < `T` ></span></span>|<span data-ttu-id="45e2e-4279">stsfld `field`</span><span class="sxs-lookup"><span data-stu-id="45e2e-4279">stsfld `field`</span></span>|<span data-ttu-id="45e2e-4280">Sostituisce il valore in `field` con un valore fornito.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4280">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="45e2e-4281">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4281">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4282">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4282">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4283">Un valore è estratto dallo stack e archiviato in `field`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4283">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="45e2e-4284">Il `stsfld` istruzione sostituisce il valore di un campo statico con un valore dallo stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4284">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="45e2e-4285">`field` è un token di metadati che deve fare riferimento a un membro del campo statico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4285">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="45e2e-4286">Il `stsfld` istruzione può essere preceduto da <xref:System.Reflection.Emit.OpCodes.Volatile>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4286">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="45e2e-4287"><xref:System.MissingFieldException> viene generata se il campo non viene trovato nei metadati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4287"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="45e2e-4288">In genere, questo viene verificato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, non in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4288">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="45e2e-4289">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `stsfld` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4289">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4290">ILGenerator.Emit(OpCode, FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4290">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4291">Sottrae un valore da un altro e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4291">Subtracts one value from another and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4292">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4292">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4293">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4293">Format</span></span>|<span data-ttu-id="45e2e-4294">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4294">Assembly Format</span></span>|<span data-ttu-id="45e2e-4295">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4295">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4296">59</span><span class="sxs-lookup"><span data-stu-id="45e2e-4296">59</span></span>|<span data-ttu-id="45e2e-4297">sub</span><span class="sxs-lookup"><span data-stu-id="45e2e-4297">sub</span></span>|<span data-ttu-id="45e2e-4298">Sottrae un valore da un altro, ottenendo un nuovo valore numerico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4298">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="45e2e-4299">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4299">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4300">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4300">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4301">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4301">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4302">`value2` e `value1` vengono estratti dallo stack; `value2` viene sottratto `value1`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4302">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="45e2e-4303">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4303">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4304">Overflow non viene rilevato per operazioni su numeri interi (per gestire l'overflow appropriato, vedere <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4304">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="45e2e-4305">Sottrazione di integer determina il passaggio al valore iniziale, anziché una saturazione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4305">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="45e2e-4306">Ad esempio: interi a 8 bit, in cui `value1` è impostato su 0 e `value2` è impostato su 1, il risultato di "wrapping" è 255.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4306">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="45e2e-4307">Restituisce un overflow a virgola mobile `+inf` (`PositiveInfinity`) o `-inf` (`NegativeInfinity`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4307">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="45e2e-4308">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `sub` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4308">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4309">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4309">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4310">Sottrae un valore intero da un altro, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4310">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4311">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4311">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4312">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4312">Format</span></span>|<span data-ttu-id="45e2e-4313">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4313">Assembly Format</span></span>|<span data-ttu-id="45e2e-4314">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4314">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4315">DA</span><span class="sxs-lookup"><span data-stu-id="45e2e-4315">DA</span></span>|<span data-ttu-id="45e2e-4316">sub.ovf</span><span class="sxs-lookup"><span data-stu-id="45e2e-4316">sub.ovf</span></span>|<span data-ttu-id="45e2e-4317">Sottrae un valore integer da un altro con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4317">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="45e2e-4318">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4318">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4319">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4319">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4320">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4320">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4321">`value2` e `value1` vengono estratti dallo stack; `value2` viene sottratto `value1` con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4321">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="45e2e-4322">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4322">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4323"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4323"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-4324">Questa operazione viene eseguita su numeri interi con segno. per i valori a virgola mobile, usare <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4324">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="45e2e-4325">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `sub.ovf` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4325">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4326">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4326">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4327">Sottrae un valore intero senza segno da un altro, esegue un controllo dell'overflow e inserisce il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4327">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4328">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4328">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4329">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4329">Format</span></span>|<span data-ttu-id="45e2e-4330">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4330">Assembly Format</span></span>|<span data-ttu-id="45e2e-4331">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4331">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4332">DB</span><span class="sxs-lookup"><span data-stu-id="45e2e-4332">DB</span></span>|<span data-ttu-id="45e2e-4333">sub.ovf.un</span><span class="sxs-lookup"><span data-stu-id="45e2e-4333">sub.ovf.un</span></span>|<span data-ttu-id="45e2e-4334">Sottrae un valore intero senza segno da un altro con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4334">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="45e2e-4335">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4335">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4336">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4336">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4337">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4337">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4338">`value2` e `value1` vengono estratti dallo stack; `value2` viene sottratto `value1` con un controllo dell'overflow.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4338">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="45e2e-4339">Il risultato viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4339">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4340"><xref:System.OverflowException> viene generata se il risultato non può essere rappresentato nel tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4340"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45e2e-4341">Questa operazione viene eseguita su numeri interi con segno. per i valori a virgola mobile, usare <xref:System.Reflection.Emit.OpCodes.Sub>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4341">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="45e2e-4342">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `sub.ovf.un` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4342">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4343">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4343">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4344">Implementa una tabella di collegamento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4344">Implements a jump table.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4345">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4345">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4346">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4346">Format</span></span>|<span data-ttu-id="45e2e-4347">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4347">Assembly Format</span></span>|<span data-ttu-id="45e2e-4348">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4348">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4349">45 < `unsigned int32` > < `int32` >... < `int32` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-4349">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="45e2e-4350">switch (`N`, `t1`, `t2`... `tN`)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4350">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="45e2e-4351">Passa a uno dei `N` valori.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4351">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="45e2e-4352">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4352">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4353">Un valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4353">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4354">Il valore viene estratto dallo stack e l'esecuzione viene trasferita all'istruzione in corrispondenza dell'offset indicizzato per valore, il cui valore è minore di `N`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4354">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="45e2e-4355">Il `switch` istruzione implementa una tabella di collegamento.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4355">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="45e2e-4356">Il formato dell'istruzione è un `unsigned int32` che rappresenta il numero di destinazioni `N`, seguito da `N` int32 valori che specificano gli obiettivi di passaggio.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4356">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="45e2e-4357">Queste destinazioni vengono rappresentate come offset (positivo o negativo) dall'inizio dell'istruzione che segue tale `switch` istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4357">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4358">Il `switch` istruzione estrae un valore dallo stack e lo confronta con, come un intero senza segno a `N`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4358">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="45e2e-4359">Se il valore è minore di `N`, l'esecuzione viene trasferita all'obiettivo indicizzato per valore, in cui le destinazioni sono numerate da 0 (ad esempio, un valore pari a 0 corrisponde alla prima destinazione, un valore di 1 accetta destinazione secondo e così via).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4359">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="45e2e-4360">Se il valore è maggiore o uguale a `N`, l'esecuzione continua con l'istruzione successiva (passaggio).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4360">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="45e2e-4361">Se l'istruzione di destinazione dispone di uno o più codici di prefisso, il controllo può essere trasferito solo al primo di tali prefissi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4361">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45e2e-4362">Controllare i trasferimenti in e da `try`, `catch`, `filter`, e `finally` blocchi non possono essere eseguiti da questa istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4362">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="45e2e-4363">Tali trasferimenti sono limitati gravi e devono invece utilizzare l'istruzione leave.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4363">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="45e2e-4364">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `switch` opcode.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4364">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="45e2e-4365">Il `Label[]` argomento è una matrice di etichette che rappresentano gli offset a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4365">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="45e2e-4366">ILGenerator.Emit(OpCode, Label[])</span><span class="sxs-lookup"><span data-stu-id="45e2e-4366">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45e2e-4367">Esempio di codice seguente viene illustrato l'utilizzo del `Switch` opcode per generare una tabella di collegamento, usare una matrice di <xref:System.Reflection.Emit.Label>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4367">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4368">Esegue un'istruzione di chiamata al metodo con suffisso tale da rimuovere lo stack frame del metodo corrente prima dell'esecuzione dell'istruzione di chiamata effettiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4368">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4369">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4370">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4370">Format</span></span>|<span data-ttu-id="45e2e-4371">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4371">Assembly Format</span></span>|<span data-ttu-id="45e2e-4372">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4373">FE 14</span><span class="sxs-lookup"><span data-stu-id="45e2e-4373">FE 14</span></span>|<span data-ttu-id="45e2e-4374">tail.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4374">tail.</span></span>|<span data-ttu-id="45e2e-4375">La chiamata successiva termina metodi correnti</span><span class="sxs-lookup"><span data-stu-id="45e2e-4375">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="45e2e-4376">Non è definito per questa istruzione Nessun comportamento di transizione dello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4376">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="45e2e-4377">Il `tail` deve trovarsi immediatamente prima istruzione di prefisso una <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, o <xref:System.Reflection.Emit.OpCodes.Callvirt> (istruzione).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4377">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="45e2e-4378">Indica che stack frame del metodo corrente deve essere rimosso prima che venga eseguita l'istruzione di chiamata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4378">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="45e2e-4379">Implica inoltre che il valore restituito dalla chiamata seguente è anche il valore restituito dal metodo corrente e di conseguenza, la chiamata può essere convertita in un collegamento tra metodi.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4379">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="45e2e-4380">Lo stack deve essere vuoto tranne per gli argomenti vengono trasferiti mediante la chiamata seguente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4380">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="45e2e-4381">Istruzione che segue l'istruzione di chiamata deve essere un'istruzione ret. È pertanto la sequenza di codice valido solo `tail. call` (o `calli` o `callvirt`).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4381">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="45e2e-4382">Le istruzioni Microsoft Intermediate Language (MSIL) corrette non devono creare rami per il `call` (istruzione), ma può creare un ramo alla successiva <xref:System.Reflection.Emit.OpCodes.Ret>.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4382">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="45e2e-4383">Il frame corrente non può essere eliminato quando il controllo viene trasferito da codice non attendibile a codice attendibile, in quanto questo comprometterebbe la protezione dell'identità del codice.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4383">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="45e2e-4384">Controlli di sicurezza di .NET Framework è pertanto possibile che il `tail` venga ignorato, lasciando standard <xref:System.Reflection.Emit.OpCodes.Call> istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4384">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="45e2e-4385">Analogamente, in ordine per consentire l'uscita da un'area a cui si verificano dopo la chiamata restituisce sincronizzata, la `tail` prefisso viene ignorato se utilizzata per terminare un metodo contrassegnato come sincronizzato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4385">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="45e2e-4386">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `tail` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4386">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4387">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4387">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">
          <span data-ttu-id="45e2e-4388">Istanza di un oggetto Opcode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4388">An instance of an Opcode object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="45e2e-4389">Restituisce true o false se il codice operativo fornito accetta un argomento a byte singolo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4389">Returns true or false if the supplied opcode takes a single byte argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="45e2e-4390">
            <see langword="True" /> o <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4390">
              <see langword="True" /> or <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4391">Questo metodo può essere utilizzato per trovare codici MSIL in "forma breve", per l'utilizzo nel codice ottimizzato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4391">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="45e2e-4392">`TakesSingleByteArgument` Restituisce `true` se il <xref:System.Reflection.Emit.OpCode> istanza accetta un argomento a byte singolo nei casi seguenti:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4392">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="45e2e-4393">Il codice operativo esegue un'istruzione branch a un indirizzo dimensioni byte (ad esempio, <xref:System.Reflection.Emit.OpCodes.Br_S> e <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4393">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="45e2e-4394">Il codice operativo inserisce un valore byte nello stack (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4394">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="45e2e-4395">Il codice operativo fa riferimento a una variabile o argomento tramite il byte "forma breve" (ad esempio, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> e <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4395">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="45e2e-4396">In caso contrario restituirà `false`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4396">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="45e2e-4397">Nell'esempio seguente viene illustrato l'utilizzo di `TakesSingleByteArgument` tramite reflection sul `OpCodes` classe e la verifica per vedere se ogni `OpCode` campo accetta un argomento a byte singolo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4397">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4398">Genera l'oggetto eccezione attualmente nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4398">Throws the exception object currently on the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4399">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4399">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4400">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4400">Format</span></span>|<span data-ttu-id="45e2e-4401">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4401">Assembly Format</span></span>|<span data-ttu-id="45e2e-4402">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4402">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4403">7A</span><span class="sxs-lookup"><span data-stu-id="45e2e-4403">7A</span></span>|<span data-ttu-id="45e2e-4404">throw</span><span class="sxs-lookup"><span data-stu-id="45e2e-4404">throw</span></span>|<span data-ttu-id="45e2e-4405">Genera un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4405">Throws an exception.</span></span>|  
  
 <span data-ttu-id="45e2e-4406">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4406">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4407">Un riferimento (eccezione) viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4407">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4408">Il riferimento all'oggetto viene estratto dallo stack e l'eccezione generata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4408">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="45e2e-4409">Il `throw` istruzione genera l'oggetto eccezione (tipo `O`) attualmente nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4409">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4410"><xref:System.NullReferenceException> viene generata se il riferimento all'oggetto è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4410"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-4411">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `throw` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4411">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4412">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4412">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4413">Indica che un indirizzo attualmente all'inizio dello stack di valutazione potrebbe non essere allineato rispetto alla dimensione standard dell'istruzione <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" /> o <see langword="cpblk" /> immediatamente successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4413">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4414">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4414">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4415">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4415">Format</span></span>|<span data-ttu-id="45e2e-4416">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4416">Assembly Format</span></span>|<span data-ttu-id="45e2e-4417">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4417">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4418">FE 12 < `unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-4418">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="45e2e-4419">non è allineato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4419">unaligned.</span></span> `alignment`|<span data-ttu-id="45e2e-4420">Indica che l'istruzione di puntatore successiva potrebbe essere non allineato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4420">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="45e2e-4421">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4421">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4422">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4422">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4423">`Unaligned` Specifica che l'indirizzo (un puntatore non gestito, `native int`) nello stack potrebbe non essere allineato rispetto alla dimensione standard dell'istruzione immediatamente successiva `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` (istruzione).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4423">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="45e2e-4424">Ovvero, per un <xref:System.Reflection.Emit.OpCodes.Ldind_I4> istruzione l'allineamento dell'indirizzo non può essere di un limite di 4 byte.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4424">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="45e2e-4425">Per `initblk` e `cpblk` l'allineamento predefinito è dipendente dall'architettura (a 4 byte su processori a 32 bit, 8 byte su processori a 64 bit).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4425">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="45e2e-4426">I generatori di codice il cui output non è limitato a una dimensione di word a 32 bit è necessario utilizzare `unaligned` se l'allineamento non è noto in fase di compilazione a 8 byte.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4426">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="45e2e-4427">Il valore di allineamento deve essere 1, 2 o 4 e indica che il codice generato deve presupporre che l'indirizzo dei byte, a byte doppio o quadruplo, rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4427">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="45e2e-4428">Si noti che temporaneo puntatori (tipo `*`) sono sempre allineati.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4428">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="45e2e-4429">Mentre l'allineamento per un `cpblk` istruzione logicamente richiedono due numeri, uno per l'origine e uno per la destinazione, non ha alcun impatto notevole sulle prestazioni se viene specificato il numero più basso solo.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4429">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="45e2e-4430">Il `unaligned` e `volatile` possono essere combinati in qualsiasi ordine.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4430">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="45e2e-4431">Devono precedere immediatamente un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` (istruzione).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4431">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="45e2e-4432">Solo il <xref:System.Reflection.Emit.OpCodes.Volatile> è consentito un prefisso per il <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> istruzioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4432">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="45e2e-4433">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload è possibile utilizzare il `unaligned` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4434">ILGenerator.Emit(OpCode, Label)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4434">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="45e2e-4435">ILGenerator.Emit(Opcode, Byte)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4435">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4436">Converte la rappresentazione boxed di un tipo di valore nel relativo formato unboxed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4436">Converts the boxed representation of a value type to its unboxed form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4437">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4437">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4438">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4438">Format</span></span>|<span data-ttu-id="45e2e-4439">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4439">Assembly Format</span></span>|<span data-ttu-id="45e2e-4440">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4440">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4441">79 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-4441">79 < `T` ></span></span>|<span data-ttu-id="45e2e-4442">eseguire la conversione unboxing `valType`</span><span class="sxs-lookup"><span data-stu-id="45e2e-4442">unbox `valType`</span></span>|<span data-ttu-id="45e2e-4443">Estrae i dati di tipo di valore da `obj`, la rappresentazione boxed.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4443">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="45e2e-4444">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4444">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4445">Riferimento a un oggetto viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4445">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4446">Il riferimento all'oggetto viene estratto dallo stack e unboxed e a un puntatore di tipo valore.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4446">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="45e2e-4447">Il puntatore di tipo valore viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4447">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4448">Un tipo di valore dispone di due rappresentazioni separate all'interno di Common Language Infrastructure (CLI):</span><span class="sxs-lookup"><span data-stu-id="45e2e-4448">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="45e2e-4449">'Non elaborato' modulo quando un tipo di valore incorporato all'interno di un altro oggetto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4449">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="45e2e-4450">Un modulo 'boxed', in cui i dati nel tipo di valore viene inseriti (boxed) in un oggetto affinché possano esistere come entità indipendenti.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4450">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="45e2e-4451">Il `unbox` istruzione consente di convertire il riferimento all'oggetto (tipo `O`), la rappresentazione boxed di un tipo valore, in un puntatore di tipo valore (un puntatore gestito di tipo `&`), la forma unboxed.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4451">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="45e2e-4452">Tipo di valore fornito (`valType`) è un token di metadati che indica il tipo del tipo di valore contenuto all'interno dell'oggetto boxed.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4452">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="45e2e-4453">A differenza di <xref:System.Reflection.Emit.OpCodes.Box>, che è necessario creare una copia di un tipo di valore per l'utilizzo dell'oggetto, `unbox` non è necessario copiare il tipo di valore dall'oggetto.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4453">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="45e2e-4454">In genere semplicemente calcola l'indirizzo del tipo di valore che è già presente all'interno dell'oggetto boxed.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4454">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="45e2e-4455"><xref:System.InvalidCastException> viene generata se l'oggetto non viene sottoposto a boxing come `valType`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4455"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="45e2e-4456"><xref:System.NullReferenceException> viene generata se il riferimento all'oggetto è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4456"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-4457"><xref:System.TypeLoadException> viene generata se il valore di tipo `valType` non è stato trovato.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4457"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="45e2e-4458">In genere, questo viene rilevato quando le istruzioni Microsoft Intermediate Language (MSIL) vengono convertite in codice nativo, anziché in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4458">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="45e2e-4459">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `unbox` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4460">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4460">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4461">Converte la rappresentazione boxed di un tipo specificato nell'istruzione nel relativo formato unboxed.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4461">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4462">La tabella seguente elenca l'istruzione esadecimale e formato assembly di Microsoft intermediate language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4462">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4463">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4463">Format</span></span>|<span data-ttu-id="45e2e-4464">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4464">Assembly Format</span></span>|<span data-ttu-id="45e2e-4465">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4466">A5 < `T` ></span><span class="sxs-lookup"><span data-stu-id="45e2e-4466">A5 < `T` ></span></span>|<span data-ttu-id="45e2e-4467">unbox. Any `typeTok`</span><span class="sxs-lookup"><span data-stu-id="45e2e-4467">unbox.any `typeTok`</span></span>|<span data-ttu-id="45e2e-4468">Estrarre i dati da `obj`, la rappresentazione boxed.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4468">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="45e2e-4469">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4470">Un riferimento all'oggetto `obj` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4470">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4471">Il riferimento all'oggetto viene estratto dallo stack e unboxed e al tipo specificato nell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4471">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="45e2e-4472">Il tipo di valore o riferimento oggetto risultante viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4472">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4473">Quando applicato a formato boxed del tipo di valore, il `unbox.any` istruzione estrae il valore contenuto in `obj` (di tipo `O`) ed è pertanto equivalente a `unbox` seguito da `ldobj`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4473">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="45e2e-4474">Quando applicato a un tipo riferimento, il `unbox.any` istruzione ha lo stesso effetto `castclass` `typeTok`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4474">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="45e2e-4475">Se l'operando `typeTok` è un parametro di tipo generico, il comportamento di runtime è determinato dal tipo specificato per tale parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4475">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="45e2e-4476"><xref:System.InvalidCastException> viene generata se `obj` non è un tipo boxed.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4476"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="45e2e-4477"><xref:System.NullReferenceException> viene generata se `obj` è un riferimento null.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4477"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="45e2e-4478">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `unbox.any` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4478">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4479">ILGenerator (OpCode, Type)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4479">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4480">Specifica che un indirizzo attualmente all'inizio dello stack di valutazione potrebbe essere volatile e che i risultati della lettura del percorso non possono essere memorizzati nella cache o che non è possibile eliminare archivi multipli in tale percorso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4480">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4481">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4481">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4482">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4482">Format</span></span>|<span data-ttu-id="45e2e-4483">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4483">Assembly Format</span></span>|<span data-ttu-id="45e2e-4484">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4484">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4485">FE 13</span><span class="sxs-lookup"><span data-stu-id="45e2e-4485">FE 13</span></span>|<span data-ttu-id="45e2e-4486">volatile.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4486">volatile.</span></span>|<span data-ttu-id="45e2e-4487">Indica che il riferimento al puntatore successivo è volatile.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4487">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="45e2e-4488">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4488">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4489">Un indirizzo viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4489">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4490">`volatile`.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4490">`volatile`.</span></span> <span data-ttu-id="45e2e-4491">Specifica che l'indirizzo è un indirizzo volatile (vale a dire possono farvi riferimento esternamente al thread corrente di esecuzione) e i risultati della lettura che non può essere memorizzato nella cache di percorso o che non è possibile eliminare archivi multipli in tale percorso.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4491">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="45e2e-4492">Uso di `volatile` interessa solo accesso in questione; gli altri accessi nello stesso percorso devono essere contrassegnati separatamente.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4492">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="45e2e-4493">Accesso a percorsi volatili non è necessario eseguire in modo atomico.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4493">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="45e2e-4494">Il <xref:System.Reflection.Emit.OpCodes.Unaligned> e `volatile` possono essere combinati in qualsiasi ordine.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4494">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="45e2e-4495">Devono precedere immediatamente un `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, o `cpblk` (istruzione).</span><span class="sxs-lookup"><span data-stu-id="45e2e-4495">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="45e2e-4496">Solo il `volatile` è consentito un prefisso per il <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> istruzioni.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4496">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="45e2e-4497">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `volatile` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4497">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4498">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4498">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="45e2e-4499">Calcola l'operazione XOR bit per bit dei primi due valori dello stack di valutazione, inserendo il risultato nello stack di valutazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="45e2e-4499">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45e2e-4500">Nella tabella seguente sono elencate esadecimale dell'istruzione e il formato di assembly di Microsoft Intermediate Language (MSIL), insieme a un breve riepilogo di riferimento:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4500">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45e2e-4501">Formato</span><span class="sxs-lookup"><span data-stu-id="45e2e-4501">Format</span></span>|<span data-ttu-id="45e2e-4502">Formato dell'assembly</span><span class="sxs-lookup"><span data-stu-id="45e2e-4502">Assembly Format</span></span>|<span data-ttu-id="45e2e-4503">Descrizione</span><span class="sxs-lookup"><span data-stu-id="45e2e-4503">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45e2e-4504">61</span><span class="sxs-lookup"><span data-stu-id="45e2e-4504">61</span></span>|<span data-ttu-id="45e2e-4505">xor</span><span class="sxs-lookup"><span data-stu-id="45e2e-4505">xor</span></span>|<span data-ttu-id="45e2e-4506">Calcola il XOR bit per bit su due valori integer e restituisce un valore integer.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4506">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="45e2e-4507">Il comportamento di transizione dello stack, in ordine sequenziale, è:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4507">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45e2e-4508">`value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4508">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45e2e-4509">`value2` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4509">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45e2e-4510">`value2` e `value1` vengono estratti dallo stack e i relativi bit per bit XOR calcolata.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4510">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="45e2e-4511">L'operazione XOR di `value2` e `value1` viene inserito nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4511">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4512">Il `xor` istruzione calcola il XOR bit per bit dei primi due valori nello stack e lascia il risultato nello stack.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4512">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="45e2e-4513">`Xor` è un'operazione specifica del numero intero.</span><span class="sxs-lookup"><span data-stu-id="45e2e-4513">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="45e2e-4514">Nell'esempio <xref:System.Reflection.Emit.ILGenerator.Emit%2A> overload del metodo è possibile utilizzare il `xor` opcode:</span><span class="sxs-lookup"><span data-stu-id="45e2e-4514">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="45e2e-4515">ILGenerator.Emit(OpCode)</span><span class="sxs-lookup"><span data-stu-id="45e2e-4515">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>