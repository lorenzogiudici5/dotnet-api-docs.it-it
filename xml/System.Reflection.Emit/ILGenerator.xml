<Type Name="ILGenerator" FullName="System.Reflection.Emit.ILGenerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0ca2e1013cb2b77f0e0eafae9f9f5baa73cf5d97" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911415" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ILGenerator : System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ILGenerator extends System.Object implements class System.Runtime.InteropServices._ILGenerator" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ILGenerator" />
  <TypeSignature Language="VB.NET" Value="Public Class ILGenerator&#xA;Implements _ILGenerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class ILGenerator : System::Runtime::InteropServices::_ILGenerator" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ILGenerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ILGenerator))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Genera istruzioni MSIL (Microsoft Intermediate Language).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.ILGenerator> viene utilizzato per generare il corpo di metodi e costruttori in assembly dinamici (rappresentato dal <xref:System.Reflection.Emit.MethodBuilder> e <xref:System.Reflection.Emit.ConstructorBuilder> classi) e di metodi dinamici autonomi (rappresentato dalla <xref:System.Reflection.Emit.DynamicMethod> classe). Per ottenere un <xref:System.Reflection.Emit.ILGenerator>, utilizzare il <xref:System.Reflection.Emit.ConstructorBuilder.GetILGenerator%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Emit.MethodBuilder.GetILGenerator%2A?displayProperty=nameWithType> metodi.  
  
 MSIL viene utilizzato come input per un compilatore just-in-time (JIT).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BeginCatchBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginCatchBlock (Type exceptionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginCatchBlock(class System.Type exceptionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginCatchBlock(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginCatchBlock (exceptionType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginCatchBlock(Type ^ exceptionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="exceptionType">Oggetto <see cref="T:System.Type" /> che rappresenta l'eccezione.</param>
        <summary>Inizia un blocco catch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un'istruzione branch alla fine del blocco di eccezioni corrente.  
  
> [!NOTE]
>  Se il blocco di eccezioni di filtro restituisce il `constant exception_execute_handler` (vedere la documentazione relativa a Common Language Infrastructure Instruction Set), l'argomento di `BeginCatchBlock` non è selezionata.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di scelta rapida del `BeginCatchBlock` metodo.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il blocco catch si trova all'interno di un'eccezione filtrata.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="exceptionType" /> è <see langword="null" /> e il blocco di filtro delle eccezioni non ha restituito un valore indicante che i blocchi devono essere eseguiti fino all'individuazione del blocco catch.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso MSIL (Microsoft Intermediate Language) generato non si trova attualmente in un blocco di eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptFilterBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginExceptFilterBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginExceptFilterBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginExceptFilterBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginExceptFilterBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia un blocco di eccezioni per un'eccezione filtrata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea un'istruzione branch alla fine del blocco di eccezioni corrente.  
  
 Se l'oggetto corrente <xref:System.Reflection.Emit.ILGenerator> è associato un <xref:System.Reflection.Emit.DynamicMethod> oggetto, la creazione di blocchi di eccezioni filtrati non è supportato. <xref:System.Reflection.Emit.DynamicILInfo> può essere utilizzato per costruire un metodo dinamico che utilizza i blocchi di eccezioni filtrati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il flusso MSIL (Microsoft Intermediate Language) generato non si trova attualmente in un blocco di eccezioni.  
  
 oppure  
  
 Questa classe <see cref="T:System.Reflection.Emit.ILGenerator" /> appartiene già a una classe <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label BeginExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label BeginExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginExceptionBlock () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label BeginExceptionBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia un blocco di eccezioni per un'eccezione non filtrata.</summary>
        <returns>Etichetta per la fine del blocco. Tale etichetta definisce la posizione corretta per l'esecuzione dei blocchi finally o per terminare il blocco try.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Creazione di un blocco di eccezioni registra alcune informazioni, ma non creare effettivamente qualsiasi codice Microsoft intermediate language (MSIL) nel flusso.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di scelta rapida del `BeginExceptionBlock` metodo.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFaultBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFaultBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFaultBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFaultBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFaultBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFaultBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia un blocco di errori delle eccezioni nel flusso MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Reflection.Emit.ILGenerator> è associato un <xref:System.Reflection.Emit.DynamicMethod> oggetto, la creazione di blocchi di errore di eccezione non è supportato. <xref:System.Reflection.Emit.DynamicILInfo> può essere utilizzato per costruire un metodo dinamico che utilizza blocchi di errori di eccezione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `BeginFaultBlock`.  
  
 [!code-cpp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CPP/ilgenerator_beginfaultblock.cpp#1)]
 [!code-csharp[ILGenerator_BeginFaultBlock#1](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/CS/ilgenerator_beginfaultblock.cs#1)]
 [!code-vb[ILGenerator_BeginFaultBlock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFaultBlock/VB/ilgenerator_beginfaultblock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il linguaggio MSIL generato non si trova attualmente in un blocco di eccezioni.  
  
 oppure  
  
 Questa classe <see cref="T:System.Reflection.Emit.ILGenerator" /> appartiene già a una classe <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginFinallyBlock">
      <MemberSignature Language="C#" Value="public virtual void BeginFinallyBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginFinallyBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginFinallyBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginFinallyBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginFinallyBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia un blocco finally nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `BeginFinallyBlock`.  
  
 [!code-cpp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CPP/ILGenerator_BeginFinallyBlock_2.cpp#2)]
 [!code-csharp[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/CS/ilgenerator_beginfinallyblock_2.cs#2)]
 [!code-vb[ILGenerator_BeginFinallyBlock_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_BeginFinallyBlock_2/VB/ilgenerator_beginfinallyblock_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Il linguaggio MSIL generato non si trova attualmente in un blocco di eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginScope">
      <MemberSignature Language="C#" Value="public virtual void BeginScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.BeginScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizia un ambito lessicale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per generare informazioni sui simboli. Le variabili locali dichiarate dopo <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A> nell'ambito fino a quando il corrispondente <xref:System.Reflection.Emit.ILGenerator.EndScope%2A> viene chiamato.  
  
 Se l'oggetto corrente <xref:System.Reflection.Emit.ILGenerator> è associato un <xref:System.Reflection.Emit.DynamicMethod> dell'oggetto, non supporta le informazioni sui simboli.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `BeginScope` e `EndScope`.  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questa classe <see cref="T:System.Reflection.Emit.ILGenerator" /> appartiene già a una classe <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeclareLocal">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dichiara una variabile locale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="localType">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo della variabile locale.</param>
        <summary>Dichiara una variabile locale del tipo specificato.</summary>
        <returns>Variabile locale dichiarata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La variabile locale viene creata nell'ambito lessicale corrente; ad esempio, se viene emessa in codice un `for` ciclo (`For` ciclo in Visual Basic), l'ambito della variabile è il ciclo.  
  
 Una variabile locale creata con questo overload non è stato aggiunto. Per creare una variabile bloccata per l'utilizzo con i puntatori non gestiti, utilizzare il <xref:System.Reflection.Emit.ILGenerator.DeclareLocal%28System.Type%2CSystem.Boolean%29> overload del metodo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del `DeclareLocal` metodo. Questo codice è parte di un esempio di codice per la <xref:System.Reflection.Emit.LocalBuilder> classe.  
  
 [!code-cpp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/cpp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CPP/localbuilder_sample_4.cpp#2)]
 [!code-csharp[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/csharp/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/CS/localbuilder_sample_4.cs#2)]
 [!code-vb[LocalBuilder_Sample_SetLocalSymInfo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/LocalBuilder_Sample_SetLocalSymInfo/VB/localbuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il tipo contenitore è stato creato dal metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclareLocal">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.LocalBuilder DeclareLocal(class System.Type localType, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeclareLocal (localType As Type, pinned As Boolean) As LocalBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::LocalBuilder ^ DeclareLocal(Type ^ localType, bool pinned);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.LocalBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localType" Type="System.Type" />
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="localType">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo della variabile locale.</param>
        <param name="pinned">
          <see langword="true" /> per bloccare l'oggetto in memoria; in caso contrario, <see langword="false" />.</param>
        <summary>Dichiara una variabile locale del tipo specificato che facoltativamente può bloccare l'oggetto a cui fa riferimento la variabile.</summary>
        <returns>Oggetto <see cref="T:System.Reflection.Emit.LocalBuilder" /> che rappresenta la variabile locale.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La variabile locale viene creata nell'ambito lessicale corrente; ad esempio, se viene emessa in codice un `for` ciclo (`For` ciclo in Visual Basic), l'ambito della variabile è il ciclo.  
  
 Nel codice unsafe, un oggetto deve essere bloccato affinché sia possibile farvi riferimento da un puntatore non gestito. Mentre l'oggetto di riferimento è bloccato, non può essere spostato da garbage collection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localType" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il tipo contenitore è stato creato dal metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 oppure  
  
 Il corpo del metodo contenitore è stato creato dal metodo <see cref="M:System.Reflection.Emit.MethodBuilder.CreateMethodBody(System.Byte[],System.Int32)" />.</exception>
        <exception cref="T:System.NotSupportedException">Il metodo a cui l'oggetto <see cref="T:System.Reflection.Emit.ILGenerator" /> è associato non è rappresentato da un oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLabel">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Emit.Label DefineLabel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.Emit.Label DefineLabel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.DefineLabel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineLabel () As Label" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::Label DefineLabel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.Label</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dichiara una nuova etichetta.</summary>
        <returns>Restituisce una nuova etichetta che può essere utilizzata come token per la creazione di rami.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostare la posizione dell'etichetta all'interno del flusso, è necessario chiamare <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>.  
  
 Questo è un token e non rappresenta una posizione particolare all'interno del flusso.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di scelta rapida del `DefineLabel` metodo.  
  
 [!code-cpp[System.Reflection.Emit.Label Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.Label Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.Label Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.Label Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Emit">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserisce un'istruzione nel flusso MSIL (Microsoft Intermediate Language) per il compilatore JIT (Just-In-Time).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL (Microsoft Intermediate Language) da inserire nel flusso.</param>
        <summary>Inserisce l'istruzione specificata nel flusso di istruzioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `opcode` parametro richiede un argomento, il chiamante deve garantire che la lunghezza dell'argomento corrisponda alla lunghezza del parametro dichiarato. In caso contrario, i risultati potrebbero essere imprevedibili. Ad esempio, se l'istruzione Emit richiede un operando a 2 byte e il chiamante fornisce un operando a 4 byte, il runtime genererà due byte aggiuntivi per il flusso di istruzioni. Questi byte aggiuntivi sarà <xref:System.Reflection.Emit.OpCodes.Nop> istruzioni.  
  
 I valori dell'istruzione sono definiti <xref:System.Reflection.Emit.OpCodes>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `Emit` per generare output MSIL tramite un'istanza di <xref:System.Reflection.Emit.ILGenerator>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, byte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, unsigned int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Byte arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da inserire nel flusso.</param>
        <param name="arg">Argomento del carattere inserito nel flusso subito dopo l'istruzione.</param>
        <summary>Inserisce l'istruzione e l'argomento del carattere specificati nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, double arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, double arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da inserire nel flusso. definita nell'enumerazione <see langword="OpCodes" />.</param>
        <param name="arg">Argomento numerico inserito nel flusso subito dopo l'istruzione.</param>
        <summary>Inserisce l'istruzione e l'argomento numerico specificati nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, short arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int16 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int16)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, short arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso.</param>
        <param name="arg">Argomento <see langword="Int" /> inserito nel flusso subito dopo l'istruzione.</param>
        <summary>Inserisce l'istruzione e l'argomento numerico specificati nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, int arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, int arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da inserire nel flusso.</param>
        <param name="arg">Argomento numerico inserito nel flusso subito dopo l'istruzione.</param>
        <summary>Inserisce l'istruzione e l'argomento numerico specificati nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, long arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int64 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, long arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da inserire nel flusso.</param>
        <param name="arg">Argomento numerico inserito nel flusso subito dopo l'istruzione.</param>
        <summary>Inserisce l'istruzione e l'argomento numerico specificati nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::ConstructorInfo ^ con);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso.</param>
        <param name="con">
          <see langword="ConstructorInfo" /> che rappresenta un costruttore.</param>
        <summary>Inserisce l'istruzione e il token di metadati specificati per il costruttore indicato nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 Il percorso di `con` viene registrato in modo che il flusso di istruzioni possa essere corretto, se necessario, durante il salvataggio del modulo in un file eseguibile portabile (PE).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> è <see langword="null" />. Questa eccezione è nuova nell'oggetto [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::Label label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="label" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso.</param>
        <param name="label">Etichetta per la quale creare un ramo dalla posizione in questione.</param>
        <summary>Inserisce l'istruzione specificata nel flusso MSIL (Microsoft Intermediate Language) e lascia spazio per includere un'etichetta dopo l'esecuzione delle correzioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 Le etichette vengono create utilizzando <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A>, e la posizione all'interno del flusso è corretta tramite <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>. Se viene utilizzata un'istruzione a byte singolo, l'etichetta può rappresentare un passaggio di al massimo 127 byte all'interno del flusso. `opcode` deve rappresentare un'istruzione branch. Poiché i rami le istruzioni sono relative, `label` verrà sostituito con l'offset corretto al ramo durante il processo di correzione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata la creazione di un metodo con una tabella di collegamento dinamico. La tabella di passaggio viene compilata utilizzando una matrice di <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.Emit.Label[] labels) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, cli::array &lt;System::Reflection::Emit::Label&gt; ^ labels);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="labels" Type="System.Reflection.Emit.Label[]" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso.</param>
        <param name="labels">Matrice di oggetti label per la quale creare un ramo dalla posizione in questione. Verranno utilizzate tutte le etichette.</param>
        <summary>Inserisce l'istruzione specificata nel flusso MSIL (Microsoft Intermediate Language) e lascia spazio per includere un'etichetta dopo l'esecuzione delle correzioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Genera una tabella di opzioni.  
  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 Le etichette vengono create utilizzando <xref:System.Reflection.Emit.ILGenerator.DefineLabel%2A> e la posizione all'interno del flusso è corretta tramite <xref:System.Reflection.Emit.ILGenerator.MarkLabel%2A>. Se viene utilizzata un'istruzione a byte singolo, l'etichetta può rappresentare un passaggio di al massimo 127 byte all'interno del flusso. `opcode` deve rappresentare un'istruzione branch. Poiché i rami le istruzioni sono relative, `label` verrà sostituito con l'offset corretto al ramo durante il processo di correzione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata la creazione di un metodo con una tabella di collegamento dinamico. La tabella di passaggio viene compilata utilizzando una matrice di <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> è <see langword="null" />. Questa eccezione è nuova nell'oggetto [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)].</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.LocalBuilder local) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::LocalBuilder ^ local);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="local" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso.</param>
        <param name="local">Una variabile locale.</param>
        <summary>Inserisce l'istruzione specificata nel flusso MSIL (Microsoft Intermediate Language), seguita dall'indice della variabile locale indicata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il metodo padre del parametro <paramref name="local" /> non corrisponde al metodo associato a tale <see cref="T:System.Reflection.Emit.ILGenerator" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="local" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="opcode" /> è un'istruzione a byte singolo e <paramref name="local" /> rappresenta una variabile locale con un indice maggiore di <see langword="Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.Emit.SignatureHelper signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::Emit::SignatureHelper ^ signature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="signature" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso.</param>
        <param name="signature">Supporto per la costruzione di un token di firme.</param>
        <summary>Inserisce l'istruzione specificata e un token di firme nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="signature" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::FieldInfo ^ field);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso.</param>
        <param name="field">
          <see langword="FieldInfo" /> che rappresenta un campo.</param>
        <summary>Inserisce l'istruzione e il token di metadati specificati per il campo indicato nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione. Il percorso di `field` viene registrato in modo che il flusso di istruzioni possa essere corretto, se necessario, durante il salvataggio del modulo in un file eseguibile portabile (PE).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo meth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo meth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ meth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="meth" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso.</param>
        <param name="meth">
          <see langword="MethodInfo" /> che rappresenta un metodo.</param>
        <summary>Inserisce l'istruzione specificata nel flusso MSIL (Microsoft Intermediate Language), seguita dal token di metadati per il metodo indicato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 Il percorso di `meth` viene registrato in modo che il flusso di istruzioni possa essere corretto, se necessario, durante il salvataggio del modulo in un file eseguibile portabile (PE).  
  
 Se `meth` rappresenta un metodo generico, deve essere una definizione di metodo generico. Vale a dire, il relativo [MethodInfo. IsGenericMethodDefinition](xref:System.Reflection.MethodBase.IsGenericMethodDefinition) proprietà deve essere `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="meth" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="meth" /> è un metodo generico per il quale la proprietà <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> è <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public void Emit (System.Reflection.Emit.OpCode opcode, sbyte arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, int8 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Emit(System::Reflection::Emit::OpCode opcode, System::SByte arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da inserire nel flusso.</param>
        <param name="arg">Argomento del carattere inserito nel flusso subito dopo l'istruzione.</param>
        <summary>Inserisce l'istruzione e l'argomento del carattere specificati nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, float arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, float32 arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, float arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="arg" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da inserire nel flusso.</param>
        <param name="arg">Argomento <see langword="Single" /> inserito nel flusso subito dopo l'istruzione.</param>
        <summary>Inserisce l'istruzione e l'argomento numerico specificati nel flusso di istruzioni MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso.</param>
        <param name="str">Oggetto <see langword="String" /> da creare.</param>
        <summary>Inserisce l'istruzione specificata nel flusso MSIL (Microsoft Intermediate Language), seguita dal token di metadati per la stringa indicata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione. Il percorso di `str` è registrata per correzioni future se il modulo viene salvato in un file eseguibile portabile (PE).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Emit">
      <MemberSignature Language="C#" Value="public virtual void Emit (System.Reflection.Emit.OpCode opcode, Type cls);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Emit(valuetype System.Reflection.Emit.OpCode opcode, class System.Type cls) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Emit(System::Reflection::Emit::OpCode opcode, Type ^ cls);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="cls" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da inserire nel flusso.</param>
        <param name="cls">Oggetto <see langword="Type" />.</param>
        <summary>Inserisce l'istruzione specificata nel flusso MSIL (Microsoft Intermediate Language), seguita dal token di metadati per il tipo indicato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I valori dell'istruzione sono definiti nel `OpCodes` enumerazione. Il percorso di `cls` viene registrato in modo che il token può essere corretto, se necessario, durante il salvataggio del modulo in un file eseguibile portabile (PE).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cls" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EmitCall">
      <MemberSignature Language="C#" Value="public virtual void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCall(valuetype System.Reflection.Emit.OpCode opcode, class System.Reflection.MethodInfo methodInfo, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCall(System::Reflection::Emit::OpCode opcode, System::Reflection::MethodInfo ^ methodInfo, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="methodInfo" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso. Deve essere <see cref="F:System.Reflection.Emit.OpCodes.Call" />, <see cref="F:System.Reflection.Emit.OpCodes.Callvirt" /> o <see cref="F:System.Reflection.Emit.OpCodes.Newobj" />.</param>
        <param name="methodInfo">Metodo <see langword="varargs" /> da chiamare.</param>
        <param name="optionalParameterTypes">Tipi degli argomenti facoltativi se il metodo è un metodo <see langword="varargs" />; in caso contrario, <see langword="null" />.</param>
        <summary>Inserisce un'istruzione <see langword="call" /> o <see langword="callvirt" /> nel flusso MSIL (Microsoft Intermediate Language) per chiamare un metodo <see langword="varargs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> metodo viene utilizzato per generare chiamate a `varargs` metodi perché non esiste nessun overload della funzione di <xref:System.Reflection.Emit.ILGenerator.Emit%2A> metodo che specifica i tipi di parametro degli argomenti variabili.  
  
 Per generare chiamate ai metodi che non utilizzano il <xref:System.Reflection.CallingConventions.VarArgs> la convenzione di chiamata, utilizzare il <xref:System.Reflection.Emit.ILGenerator.Emit%28System.Reflection.Emit.OpCode%2CSystem.Reflection.MethodInfo%29> overload del metodo.  
  
## <a name="version-information"></a>Informazioni sulla versione  
 A partire da .NET Framework versione 2.0, il <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> metodo non genera un'eccezione quando vengono specificati tipi di parametro facoltativi per un metodo che non è `varargs`. <xref:System.InvalidProgramException> viene generata quando viene eseguita la chiamata.  
  
   
  
## Examples  
 Esempio di codice seguente genera due metodi, ovvero un `varargs` metodo e un metodo che chiama il `varargs` metodo. Il `EmitCall` metodo viene utilizzato per generare la chiamata al `varargs` metodo.  
  
 [!code-cpp[Emit.ArgIterator#1](~/samples/snippets/cpp/VS_Snippets_CLR/Emit.ArgIterator/cpp/source.cpp#1)]
 [!code-csharp[Emit.ArgIterator#1](~/samples/snippets/csharp/VS_Snippets_CLR/Emit.ArgIterator/cs/source.cs#1)]
 [!code-vb[Emit.ArgIterator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Emit.ArgIterator/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="opcode" /> non specifica una chiamata al metodo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="methodInfo" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La convenzione di chiamata per il metodo non è <see langword="varargs" />, ma vengono forniti tipi di parametro facoltativi. Questa eccezione viene generata nelle versioni 1.0 e 1.1 di .NET Framework. Nelle versioni successive non viene generata alcuna eccezione.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitCalli">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserisce un'istruzione <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> nel flusso MSIL (Microsoft Intermediate Language).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Runtime.InteropServices.CallingConvention unmanagedCallConv, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Runtime::InteropServices::CallingConvention unmanagedCallConv, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="unmanagedCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso. Deve essere <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</param>
        <param name="unmanagedCallConv">Convenzione di chiamata non gestita da utilizzare.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> del risultato.</param>
        <param name="parameterTypes">Tipi di argomenti necessari per l'istruzione.</param>
        <summary>Inserisce un'istruzione <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> nel flusso di istruzioni MSIL (Microsoft Intermediate Language), specificando una convenzione di chiamata non gestita per la chiamata indiretta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> per inserire un <xref:System.Reflection.Emit.OpCodes.Calli> istruzione nel flusso. Non utilizzare la proprietà <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di scelta rapida del <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> metodo per chiamare un metodo di tipo non gestito esterno alla classe dinamica.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.EmitCalli Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.EmitCalli Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitCalli">
      <MemberSignature Language="C#" Value="public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitCalli(valuetype System.Reflection.Emit.OpCode opcode, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type[] optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitCalli(System::Reflection::Emit::OpCode opcode, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opcode" Type="System.Reflection.Emit.OpCode" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="optionalParameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="opcode">Istruzione MSIL da emettere nel flusso. Deve essere <see cref="F:System.Reflection.Emit.OpCodes.Calli" />.</param>
        <param name="callingConvention">Convenzione di chiamata gestita da utilizzare.</param>
        <param name="returnType">Oggetto <see cref="T:System.Type" /> del risultato.</param>
        <param name="parameterTypes">Tipi di argomenti necessari per l'istruzione.</param>
        <param name="optionalParameterTypes">Tipi di argomenti facoltativi per le chiamate a <see langword="varargs" />.</param>
        <summary>Inserisce un'istruzione <see cref="F:System.Reflection.Emit.OpCodes.Calli" /> nel flusso di istruzioni MSIL (Microsoft Intermediate Language), specificando una convenzione di chiamata gestita per la chiamata indiretta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> per inserire un <xref:System.Reflection.Emit.OpCodes.Calli> istruzione nel flusso. Non utilizzare la proprietà <xref:System.Reflection.Emit.ILGenerator.Emit%2A>.  
  
 Se `optionalParameterTypes` specifica gli argomenti facoltativi, `callingConvention` deve includere il <xref:System.Reflection.CallingConventions.VarArgs?displayProperty=nameWithType> flag.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="optionalParameterTypes" /> non è <see langword="null" />, ma <paramref name="callingConvention" /> non include il flag <see cref="F:System.Reflection.CallingConventions.VarArgs" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EmitWriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Funzioni di supporto utilizzate per creare una chiamata al metodo <see cref="M:System.Console.WriteLine" /> con tipi di valori diversi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.Emit.LocalBuilder localBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.Emit.LocalBuilder localBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.Emit.LocalBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::Emit::LocalBuilder ^ localBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localBuilder" Type="System.Reflection.Emit.LocalBuilder" />
      </Parameters>
      <Docs>
        <param name="localBuilder">Variabile locale il cui valore deve essere scritto nella console.</param>
        <summary>Crea il linguaggio MSIL (Microsoft Intermediate Language) necessario per chiamare <see cref="Overload:System.Console.WriteLine" /> con la variabile locale specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di `localBuilder` deve corrispondere al tipo di parametro di un overload del <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di scelta rapida del <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> metodo per scrivere una stringa sulla console in un metodo dinamico.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il tipo di <paramref name="localBuilder" /> è <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.EnumBuilder" />, che non sono valori supportati.  
  
 oppure  
  
 Nessun overload di <see cref="Overload:System.Console.WriteLine" /> accetta il tipo di <paramref name="localBuilder" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localBuilder" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (System.Reflection.FieldInfo fld);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(class System.Reflection.FieldInfo fld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (fld As FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::Reflection::FieldInfo ^ fld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fld" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="fld">Campo il cui valore deve essere scritto nella console.</param>
        <summary>Crea il flusso MSIL (Microsoft Intermediate Language) necessario per chiamare il metodo <see cref="Overload:System.Console.WriteLine" /> con il campo indicato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il tipo di `fld` deve corrispondere al tipo di parametro di un overload del <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 Esempio di codice riportato di seguito viene illustrato l'utilizzo del <xref:System.Reflection.Emit.ILGenerator.EmitWriteLine%2A> metodo per scrivere una stringa sulla console in un metodo dinamico.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Non è presente alcun overload del metodo <see cref="Overload:System.Console.WriteLine" /> che accetti il tipo del campo specificato.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fld" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il tipo del campo è <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.EnumBuilder" />, oggetti non supportati.</exception>
      </Docs>
    </Member>
    <Member MemberName="EmitWriteLine">
      <MemberSignature Language="C#" Value="public virtual void EmitWriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EmitWriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EmitWriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EmitWriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EmitWriteLine(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Stringa da stampare.</param>
        <summary>Crea il flusso MSIL (Microsoft Intermediate Language) necessario per chiamare il metodo <see cref="Overload:System.Console.WriteLine" /> con una stringa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La stringa deve già definita.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di scelta rapida del `EmitWriteLine` metodo per scrivere una stringa sulla console in un metodo dinamico.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndExceptionBlock">
      <MemberSignature Language="C#" Value="public virtual void EndExceptionBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndExceptionBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndExceptionBlock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndExceptionBlock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndExceptionBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina un blocco di eccezioni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente illustra l'uso di scelta rapida del `EndExceptionBlock` metodo.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Il blocco di eccezioni finale si trova in una posizione non prevista nel flusso del codice.</exception>
        <exception cref="T:System.NotSupportedException">Il flusso MSIL (Microsoft Intermediate Language) generato non si trova attualmente in un blocco di eccezioni.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndScope">
      <MemberSignature Language="C#" Value="public virtual void EndScope ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.EndScope" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndScope ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndScope();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina un ambito lessicale.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene utilizzato per generare informazioni sui simboli. Viene utilizzato con <xref:System.Reflection.Emit.ILGenerator.BeginScope%2A>.  
  
 Se l'oggetto corrente <xref:System.Reflection.Emit.ILGenerator> è associato un <xref:System.Reflection.Emit.DynamicMethod> dell'oggetto, non supporta le informazioni sui simboli.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `BeginScope` e `EndScope`.  
  
 [!code-cpp[ILGenerator_Begin_EndScope#2](~/samples/snippets/cpp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CPP/ilgenerator_begin_endscope.cpp#2)]
 [!code-csharp[ILGenerator_Begin_EndScope#2](~/samples/snippets/csharp/VS_Snippets_CLR/ILGenerator_Begin_EndScope/CS/ilgenerator_begin_endscope.cs#2)]
 [!code-vb[ILGenerator_Begin_EndScope#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ILGenerator_Begin_EndScope/VB/ilgenerator_begin_endscope.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Questa classe <see cref="T:System.Reflection.Emit.ILGenerator" /> appartiene già a una classe <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ILOffset">
      <MemberSignature Language="C#" Value="public virtual int ILOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ILOffset" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ILGenerator.ILOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ILOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ILOffset { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'offset corrente, in byte, nel flusso Microsoft Intermediate Language (MSIL) emesso dall'oggetto <see cref="T:System.Reflection.Emit.ILGenerator" />.</summary>
        <value>Offset nel flusso MSIL in corrispondenza del quale verrà emessa l'istruzione successiva.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è trasparente e può essere chiamato da codice parzialmente attendibile.  
  
 Se il <xref:System.Reflection.Emit.ILGenerator.ILOffset%2A> proprietà avviene prima che sono state generate eventuali istruzioni MSIL, restituisce 0 (zero).  
  
 Quando MSIL viene generato per i linguaggi dinamici, questa proprietà può essere utilizzata per eseguire il mapping di offset nel flusso MSIL per i numeri di riga di codice sorgente. Per fornire analisi dello stack quando vengono generate eccezioni, è possono utilizzare le informazioni risultanti.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkLabel">
      <MemberSignature Language="C#" Value="public virtual void MarkLabel (System.Reflection.Emit.Label loc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkLabel(valuetype System.Reflection.Emit.Label loc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkLabel(System.Reflection.Emit.Label)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkLabel (loc As Label)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkLabel(System::Reflection::Emit::Label loc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loc" Type="System.Reflection.Emit.Label" />
      </Parameters>
      <Docs>
        <param name="loc">Etichetta per la quale impostare un indice.</param>
        <summary>Contrassegna la posizione corrente del flusso MSIL (Microsoft Intermediate Language) con l'etichetta indicata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un'etichetta non può essere definita più volte.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di scelta rapida di `MarkLabel` per l'implementazione MSIL rami in un metodo dinamico.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="loc" /> rappresenta un indice non valido nella matrice delle etichette.  
  
 oppure  
  
 È già stato definito un indice per <paramref name="loc" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MarkSequencePoint">
      <MemberSignature Language="C#" Value="public virtual void MarkSequencePoint (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MarkSequencePoint(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32 startLine, int32 startColumn, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MarkSequencePoint (document As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MarkSequencePoint(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, int startLine, int startColumn, int endLine, int endColumn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="document">Documento per il quale definire il punto di sequenza.</param>
        <param name="startLine">Riga di inizio del punto di sequenza.</param>
        <param name="startColumn">Colonna nella riga di inizio del punto di sequenza.</param>
        <param name="endLine">Riga di fine del punto di sequenza.</param>
        <param name="endColumn">Colonna nella riga di fine del punto di sequenza.</param>
        <summary>Contrassegna un punto di sequenza nel flusso MSIL (Microsoft Intermediate Language).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numeri di riga sono indicizzati da 1. Le colonne sono indicizzate da 0.  
  
 Le informazioni sui simboli includono generalmente almeno un offset MSIL per ogni riga di origine. Quando il compilatore JIT (Just-In-Time) sta per compilare un metodo, richiede ai servizi relativi ai profili un elenco di offset MSIL da conservare. Tali offset MSIL sono denominati *punti di sequenza*.  
  
 Se l'oggetto corrente <xref:System.Reflection.Emit.ILGenerator> è associato un <xref:System.Reflection.Emit.DynamicMethod> dell'oggetto, non supporta le informazioni sui simboli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startLine" /> o <paramref name="endLine" /> è &lt;= 0.</exception>
        <exception cref="T:System.NotSupportedException">Questa classe <see cref="T:System.Reflection.Emit.ILGenerator" /> appartiene già a una classe <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ILGenerator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ILGenerator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="rgszNames">Matrice di nomi passata di cui eseguire il mapping.</param>
        <param name="cNames">Conteggio dei nomi di cui eseguire il mapping.</param>
        <param name="lcid">Contesto delle impostazioni locali in cui interpretare i nomi.</param>
        <param name="rgDispId">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</param>
        <summary>Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo per l'accesso a classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetIDsOfNames`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Il metodo viene chiamato ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ILGenerator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informazioni sul tipo da restituire.</param>
        <param name="lcid">Identificatore delle impostazioni locali per le informazioni sul tipo.</param>
        <param name="ppTInfo">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</param>
        <summary>Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo per l'accesso a classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfo`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Il metodo viene chiamato ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ILGenerator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ILGenerator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ILGenerator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</param>
        <summary>Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo per l'accesso a classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfoCount`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Il metodo viene chiamato ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ILGenerator.Invoke">
      <MemberSignature Language="C#" Value="void _ILGenerator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ILGenerator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ILGenerator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ILGenerator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ILGenerator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ILGenerator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica il membro.</param>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="lcid">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</param>
        <param name="wFlags">Flag che descrivono il contesto della chiamata.</param>
        <param name="pDispParams">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</param>
        <param name="pVarResult">Puntatore alla posizione in cui deve essere archiviato il risultato.</param>
        <param name="pExcepInfo">Puntatore a una struttura contenente informazioni sull'eccezione.</param>
        <param name="puArgErr">Indice del primo argomento che contiene un errore.</param>
        <summary>Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo per l'accesso a classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::Invoke`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Il metodo viene chiamato ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThrowException">
      <MemberSignature Language="C#" Value="public virtual void ThrowException (Type excType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ThrowException(class System.Type excType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.ThrowException(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ThrowException (excType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ThrowException(Type ^ excType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="excType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="excType">Classe del tipo di eccezione da generare.</param>
        <summary>Crea un'istruzione per generare un'eccezione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente illustra l'uso di scelta rapida di `ThrowException` per generare un'eccezione all'interno di codice MSIL di un metodo dinamico.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.ThrowException Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.ThrowException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="excType" /> non è la classe <see cref="T:System.Exception" /> né una classe derivata di <see cref="T:System.Exception" />.  
  
 oppure  
  
 Il tipo non dispone di un costruttore predefinito.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="excType" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string usingNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string usingNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ILGenerator.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (usingNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ usingNamespace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.ILGeneration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usingNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usingNamespace">Specifica lo spazio dei nomi da utilizzare nella valutazione delle variabili locali e controlla l'ambito lessicale attualmente attivo.</param>
        <summary>Specifica lo spazio dei nomi da utilizzare nella valutazione delle variabili locali e controlla l'ambito lessicale attualmente attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'oggetto corrente <xref:System.Reflection.Emit.ILGenerator> è associato un <xref:System.Reflection.Emit.DynamicMethod> dell'oggetto, questo metodo non è supportato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="usingNamespace" /> è zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="usingNamespace" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Questa classe <see cref="T:System.Reflection.Emit.ILGenerator" /> appartiene già a una classe <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>