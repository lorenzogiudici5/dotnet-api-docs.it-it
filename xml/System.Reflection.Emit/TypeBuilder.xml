<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TypeBuilder.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines and creates new instances of classes during run time.</source>
          <target state="translated">Definisce e crea nuove istanze delle classi in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is the root class used to control the creation of dynamic classes in the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> la classe radice viene utilizzata per controllare la creazione di classi dinamiche in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</source>
          <target state="translated">Fornisce un set di routine che consentono di definire le classi, aggiungere campi e i metodi e creare la classe all'interno di un modulo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A new <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be created from a dynamic module by calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Un nuovo <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> può essere creato da un modulo dinamico chiamando il <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph> metodo, che restituisce un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit provides the following options for defining types:</source>
          <target state="translated">La reflection emit offre le opzioni per la definizione dei tipi seguenti:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name.</source>
          <target state="translated">Definire una classe o interfaccia con il nome specificato.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name and attributes.</source>
          <target state="translated">Definire una classe o interfaccia con il nome specificato e attributi.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, and base class.</source>
          <target state="translated">Definire una classe con il nome specificato, attributi e classe di base.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</source>
          <target state="translated">Definire una classe con il nome specificato, attributi, classe di base e il set di interfacce che implementa la classe.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and packing size.</source>
          <target state="translated">Definire una classe con il nome specificato, attributi, classe di base e la dimensione di compressione.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the class size as a whole.</source>
          <target state="translated">Definire una classe con il nome specificato, attributi, classe di base e le dimensioni di classe nel suo complesso.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</source>
          <target state="translated">Definire una classe con il nome specificato, attributi, classe di base, la dimensione di compressione e la dimensione di classe nel suo complesso.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>To create an array type, pointer type, or byref type for an incomplete type that is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method, <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method, respectively.</source>
          <target state="translated">Per creare un tipo di matrice, un tipo di puntatore o un tipo byref per un tipo incompleto è rappresentato da un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto, usare il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> metodo <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> metodo, o <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> (metodo), rispettivamente.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Before a type is used, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> method must be called.</source>
          <target state="translated">Prima che venga utilizzato un tipo, il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> metodo deve essere chiamato.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> completes the creation of the type.</source>
          <target state="translated"><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> aver completato la creazione del tipo.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Following the call to <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, the caller can instantiate the type by using the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and invoke members of the type by using the <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Dopo la chiamata a <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, il chiamante può creare un'istanza di tipo utilizzando il <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> (metodo) e richiamare i membri del tipo utilizzando il <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It is an error to invoke methods that change the implementation of a type after <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> has been called.</source>
          <target state="translated">È un errore per richiamare i metodi che modificano l'implementazione di un tipo dopo <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> è stato chiamato.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>For example, the common language runtime throws an exception if the caller tries to add new members to a type.</source>
          <target state="translated">Ad esempio, common language runtime genera un'eccezione se il chiamante tenta di aggiungere nuovi membri a un tipo.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A class initializer is created by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Un inizializzatore di classi viene creato utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> returns a <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> restituisce un <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Nested types are defined by calling one of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">I tipi annidati definiti chiamando uno del <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Attributes</source>
          <target state="translated">Attributi</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class uses the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration to further specify the characteristics of the type to be created:</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> classe Usa il <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumerazione per specificare ulteriormente le caratteristiche del tipo da creare:</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Interfaces are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attributes.</source>
          <target state="translated">Le interfacce vengono specificate utilizzando il <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph> gli attributi.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Concrete classes (classes that cannot be extended) are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Classi concrete (che non può essere esteso) vengono specificate utilizzando il <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph> attributo.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Several attributes determine type visibility.</source>
          <target state="translated">Visibilità del tipo è determinata da vari attributi.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration.</source>
          <target state="translated">Vedere la descrizione del <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumerazione.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>If <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is specified, the class loader lays out fields in the order they are read from metadata.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> viene specificato, il caricatore di classe dispone i campi nell'ordine in cui vengono letti dai metadati.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The class loader considers the specified packing size but ignores any specified field offsets.</source>
          <target state="translated">Il caricatore di classe prende in considerazione la dimensione di compressione specificato, ma ignora qualsiasi offset di campo specificato.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The metadata preserves the order in which the field definitions are emitted.</source>
          <target state="translated">I metadati mantengono l'ordine in cui vengono generate le definizioni di campo.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Even across a merge, the metadata will not reorder the field definitions.</source>
          <target state="translated">Anche in un'unione, i metadati non verranno riordinate le definizioni di campo.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The loader will honor the specified field offsets only if <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is specified.</source>
          <target state="translated">Il caricatore rispetterà l'offset di campo specificato solo se <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> è specificato.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Known Issues</source>
          <target state="translated">Problemi noti</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</source>
          <target state="translated">La reflection emit non verifica se tutti i metodi dichiarati nell'interfaccia è implementata da una classe non astratta che implementa un'interfaccia.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</source>
          <target state="translated">Tuttavia, se la classe non implementa tutti i metodi dichiarati in un'interfaccia, il runtime non carica la classe.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Type&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Type&gt;</ph> class are not fully implemented in the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class.</source>
          <target state="translated">Sebbene <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> è derivato da <ph id="ph2">&lt;xref:System.Type&gt;</ph>, alcuni dei metodi astratti definiti nel <ph id="ph3">&lt;xref:System.Type&gt;</ph> non sono implementati completamente nel <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Calls to these <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> methods throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">Chiamate a queste <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> metodi generano un <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> eccezione.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The desired functionality can be obtained by retrieving the created type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and reflecting on the retrieved type.</source>
          <target state="translated">La funzionalità desiderata, è possibile ottenere recuperando il tipo creato mediante il <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>This section contains two code examples.</source>
          <target state="translated">In questa sezione contiene due esempi di codice.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The first example shows how to create a dynamic type with a field, constructor, property, and method.</source>
          <target state="translated">Nel primo esempio viene illustrato come creare un tipo dinamico con un campo, un costruttore, una proprietà e un metodo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The second example builds a method dynamically from user input.</source>
          <target state="translated">Nel secondo esempio compila un metodo in modo dinamico dall'input dell'utente.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example one<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Esempio n. 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code example shows how to define a dynamic assembly with one module.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come definire un assembly dinamico con un modulo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The module in the example assembly contains one type, <ph id="ph1">`MyDynamicType`</ph>, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</source>
          <target state="translated">Il modulo nell'assembly di esempio contiene un solo tipo, <ph id="ph1">`MyDynamicType`</ph>, che dispone di un campo privato, una proprietà che ottiene e imposta il campo privato, costruttori che inizializzano il campo privato e un metodo che moltiplica un numero fornito dall'utente per il campo privato il valore e restituisce il risultato.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> field is specified when the assembly is created.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> campo viene specificato al momento della creazione dell'assembly.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> or used in another program.</source>
          <target state="translated">Il codice assembly viene utilizzato immediatamente e l'assembly viene salvato anche su disco in modo che possono essere esaminata con <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> o utilizzata in un altro programma.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example two<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Esempio 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code sample demonstrates how to build a dynamic type by using <ph id="ph1">`TypeBuilder`</ph>.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come creare un tipo dinamico tramite <ph id="ph1">`TypeBuilder`</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken such as Demand, Assert, and so on.</source>
          <target state="translated">Azione di sicurezza da eseguire, ad esempio Demand, Assert e così via.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">Set di autorizzazioni a cui viene applicata l'azione.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this type.</source>
          <target state="translated">Aggiunge sicurezza dichiarativa a questo tipo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">`AddDeclarativeSecurity`</ph> may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</source>
          <target state="translated"><ph id="ph1">`AddDeclarativeSecurity`</ph> può essere chiamato più volte specificando un'azione di sicurezza (ad esempio Demand, Assert o Deny) e un set di autorizzazioni che si applicano all'azione a ogni chiamata.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</source>
          <target state="translated">Nelle versioni di .NET Framework 1.0, 1.1 e 2.0, gli attributi di sicurezza dichiarativa applicati a un tipo con questo metodo vengono archiviati nel formato di metadati XML precedente.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The following example demonstrates the use of the <ph id="ph1">`AddDeclarativeSecurity`</ph> method to add a security demand for <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag to a dynamic type named <ph id="ph4">`MyDynamicClass`</ph>, in an assembly named EmittedExample.dll.</source>
          <target state="translated">Nell'esempio seguente viene illustrato l'utilizzo del <ph id="ph1">`AddDeclarativeSecurity`</ph> metodo per aggiungere una richiesta di sicurezza per <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag per un tipo dinamico denominato <ph id="ph4">`MyDynamicClass`</ph>, in un assembly denominato EmittedExample.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The example produces no console output; after you run it, you can use <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine EmittedExample.dll.</source>
          <target state="translated">Questo esempio viene non generato alcun output di console. Dopo l'esecuzione, è possibile utilizzare <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare EmittedExample.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In <ph id="ph1">`MyDynamicClass`</ph>, open the <ph id="ph2">`.class public auto ansi`</ph> statement to see the declarative permission.</source>
          <target state="translated">In <ph id="ph1">`MyDynamicClass`</ph>, aprire il <ph id="ph2">`.class public auto ansi`</ph> istruzione per visualizzare l'autorizzazione dichiarativa.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>, and <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> are invalid).</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="action" /&gt;</ph> non è valido (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph> e <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> non sono validi).</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph>.</source>
          <target state="translated">Il set di autorizzazioni <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contiene un'azione aggiunta in precedenza mediante <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The interface that this type implements.</source>
          <target state="translated">Interfaccia implementata da questo tipo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>Adds an interface that this type implements.</source>
          <target state="translated">Aggiunge un'interfaccia implementata da questo tipo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The following code sample demonstrates the implementation of an interface on a dynamically created type using <ph id="ph1">`AddInterfaceImplementation`</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrata l'implementazione di un'interfaccia su un tipo creato dinamicamente utilizzando <ph id="ph1">`AddInterfaceImplementation`</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">Recupera l'assembly dinamico che contiene la definizione di tipo.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">Recupera l'assembly dinamico che contiene la definizione di tipo.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Returns the full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">Restituisce il nome completo di questo tipo qualificato dal nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">Nome completo di questo tipo qualificato dal nome visualizzato dell'assembly.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The format of the returned string is the concatenation of the full name of the type (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) and the display name of the assembly (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>), separated by a comma and a space.</source>
          <target state="translated">Il formato della stringa restituita è la concatenazione del nome completo del tipo (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) e il nome visualizzato dell'assembly (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>), separati da una virgola e uno spazio.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> per una descrizione del formato del nome visualizzato di un assembly.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Version Information</source>
          <target state="translated">Informazioni sulla versione</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</source>
          <target state="translated">Nelle versioni di .NET Framework 1.0 e 1.1, il valore di questa proprietà non include le impostazioni cultura o una chiave pubblica.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">Recupera il tipo di base del tipo.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">Recupera il tipo di base del tipo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for the class.</source>
          <target state="translated">Crea un oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> per la classe.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>After defining fields and methods on the class, <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> is called in order to load its <ph id="ph2">&lt;see langword="Type" /&gt;</ph> object.</source>
          <target state="translated">Dopo aver definito i campi e metodi della classe <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> viene chiamato per caricare il relativo oggetto <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Returns the new <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for this class.</source>
          <target state="translated">Restituisce il nuovo oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> per questa classe.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If this type is a nested type, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method must be called on the enclosing type before it is called on the nested type.</source>
          <target state="translated">Se questo tipo è un tipo annidato, il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo deve essere chiamato sul tipo di inclusione prima che venga chiamato sul tipo annidato.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the current type derives from an incomplete type or implements incomplete interfaces, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the parent type and the interface types before calling it on the current type.</source>
          <target state="translated">Se il tipo corrente deriva da un tipo incompleto o implementa interfacce incomplete, chiamare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo nel tipo di elemento padre e i tipi di interfaccia prima di eseguire la chiamata del tipo corrente.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the enclosing type will generate a <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Se il tipo di inclusione contiene un campo che è un tipo di valore definito come un tipo annidato (ad esempio, un campo che rappresenta un'enumerazione definita come un tipo annidato), la chiamata di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo sul tipo di inclusione genererà un <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> evento.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</source>
          <target state="translated">Questo avviene perché il caricatore non è possibile determinare le dimensioni del tipo di inclusione fino a quando il tipo annidato è stato completato.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The caller should define a handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event to complete the definition of the nested type by calling <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the nested type.</source>
          <target state="translated">Il chiamante deve definire un gestore per il <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> evento per completare la definizione del tipo annidato chiamando <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> sul <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto che rappresenta il tipo annidato.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The code example for this topic shows how to define such an event handler.</source>
          <target state="translated">Nell'esempio di codice riportato in questo argomento viene illustrato come definire un gestore di evento.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>A type is created only once, no matter how many times the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">Viene creato un tipo in una sola volta, indipendentemente da come numero di volte il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo viene chiamato.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>All calls return the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Tutte le chiamate restituiscono lo stesso <ph id="ph1">&lt;xref:System.Type&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The following code example shows how to define an event handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event, in order to call the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on a nested type during a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> call on the enclosing type.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come definire un gestore eventi per il <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> evento, per poter chiamare il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo su un tipo annidato durante un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> chiamare sul tipo di inclusione.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The enclosing type has not been created.</source>
          <target state="translated">Il tipo di inclusione non è stato creato.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is non-abstract and contains an abstract method.</source>
          <target state="translated">Questo tipo è non astratto e contiene un metodo astratto.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is not an abstract class or an interface and has a method without a method body.</source>
          <target state="translated">Questo tipo è una classe o un'interfaccia non astratta e ha un metodo senza corpo.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type contains invalid Microsoft intermediate language (MSIL) code.</source>
          <target state="translated">Il tipo contiene codice MSIL (Microsoft Intermediate Language) non valido.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</source>
          <target state="translated">La destinazione branch viene specificata usando un offset di 1 byte, ma la destinazione si trova a una distanza maggiore di 127 byte dal branch.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type cannot be loaded.</source>
          <target state="translated">Non è possibile caricare il tipo.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>For example, it contains a <ph id="ph1">&lt;see langword="static" /&gt;</ph> method that has the calling convention <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph>.</source>
          <target state="translated">Ad esempio, contiene un metodo <ph id="ph1">&lt;see langword="static" /&gt;</ph> con la convenzione di chiamata <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object that represents this type.</source>
          <target state="translated">Ottiene un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> che rappresenta il tipo.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>An object that represents this type.</source>
          <target state="translated">Oggetto che rappresenta il tipo.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>Gets the method that declared the current generic type parameter.</source>
          <target state="translated">Ottiene il metodo che ha dichiarato il parametro di tipo generico corrente.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto<ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> che rappresenta il metodo che ha dichiarato il tipo corrente, se il tipo corrente è un parametro di tipo generico; in caso contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Quando si genera codice, un parametro di tipo generico è rappresentato da un <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> oggetto anziché da un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Returns the type that declared this type.</source>
          <target state="translated">Restituisce il tipo con cui è stato dichiarato questo tipo.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>The type that declared this type.</source>
          <target state="translated">Tipo con cui è stato dichiarato questo tipo.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new constructor to the dynamic type.</source>
          <target state="translated">Aggiunge un nuovo costruttore al tipo dinamico.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The attributes of the constructor.</source>
          <target state="translated">Attributi del costruttore.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">Convenzione di chiamata del costruttore.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">Tipi di parametro del costruttore.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Adds a new constructor to the type, with the given attributes and signature.</source>
          <target state="translated">Aggiunge un nuovo costruttore al tipo, con la firma e gli attributi specificati.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The defined constructor.</source>
          <target state="translated">Costruttore definito.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</source>
          <target state="translated">Se si definisce un costruttore per il tipo dinamico, viene fornito automaticamente un costruttore predefinito e chiama il costruttore predefinito della classe di base.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you define a constructor for your dynamic type, a default constructor is not provided.</source>
          <target state="translated">Se si definisce un costruttore per il tipo dinamico, non viene fornito un costruttore predefinito.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>You have the following options for providing a default constructor in addition to the constructor you defined:</source>
          <target state="translated">Sono disponibili le opzioni seguenti per fornire un costruttore predefinito oltre il costruttore che è definito:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that simply calls the default constructor of the base class, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> method to create one (and optionally restrict access to it).</source>
          <target state="translated">Se si desidera un costruttore predefinito che chiama semplicemente il costruttore predefinito della classe di base, è possibile utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> per creare uno (e, facoltativamente, limitare l'accesso a esso).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Do not provide an implementation for this default constructor.</source>
          <target state="translated">Fornisce un'implementazione per il costruttore predefinito.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do, an exception is thrown when you try to use the constructor.</source>
          <target state="translated">In caso contrario, viene generata un'eccezione quando si tenta di utilizzare il costruttore.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>No exception is thrown when the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">Viene generata alcuna eccezione quando il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo viene chiamato.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> method to create one, and provide your own implementation.</source>
          <target state="translated">Se si desidera un costruttore predefinito che esegue un'operazione più semplicemente chiamando il costruttore predefinito della classe di base o che chiama un altro costruttore della classe di base o che effettua altre operazioni, è necessario utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> per crearne uno, (metodo) e fornire la propria implementazione.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato l'utilizzo di <ph id="ph1">`DefineConstructor`</ph> per impostare un costruttore di una determinata firma e gli attributi su un tipo dinamico e restituire un corrispondente <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> per dati MSIL.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the constructor.</source>
          <target state="translated">Attributi del costruttore.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">Convenzione di chiamata del costruttore.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">Tipi di parametro del costruttore.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</source>
          <target state="translated">Aggiunge un nuovo costruttore al tipo, con gli attributi specificati, la firma e i modificatori personalizzati.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The defined constructor.</source>
          <target state="translated">Costruttore definito.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Questo overload viene fornito per i progettisti di compilatori gestiti.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Per ulteriori informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II Metadata.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentazione è disponibile online; vedere <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (ECMA C# e standard di Common Language Infrastructure) in MSDN e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> nel sito Web internazionale Ecma.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">La dimensione di <ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> o <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> non è uguale a quella di <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> object representing the attributes to be applied to the constructor.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> che rappresenta gli attributi da applicare al costruttore.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Defines the default constructor.</source>
          <target state="translated">Definisce il costruttore predefinito.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The constructor defined here will simply call the default constructor of the parent.</source>
          <target state="translated">Il costruttore definito qui chiamerà semplicemente il costruttore predefinito dell'elemento padre.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Returns the constructor.</source>
          <target state="translated">Restituisce il costruttore.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</source>
          <target state="translated">Poiché il costruttore predefinito viene definito automaticamente, è necessario chiamare questo metodo solo nelle situazioni seguenti:</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</source>
          <target state="translated">È stato definito un altro costruttore e si desidera anche un costruttore predefinito che chiama semplicemente il costruttore di classe di base.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You want to set the attributes on the default constructor to something other than <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, and <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</source>
          <target state="translated">Si desidera impostare gli attributi del costruttore predefinito su un valore diverso da <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, e <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato l'utilizzo di <ph id="ph1">`DefineConstructor`</ph> per impostare un costruttore di una determinata firma e gli attributi su un tipo dinamico e restituire un corrispondente <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> per dati MSIL.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The parent type (base type) does not have a default constructor.</source>
          <target state="translated">Il tipo padre (tipo di base) non ha un costruttore predefinito.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The name of the event.</source>
          <target state="translated">Nome dell'evento.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The attributes of the event.</source>
          <target state="translated">Attributi dell'evento.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type of the event.</source>
          <target state="translated">Tipo di evento.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>Adds a new event to the type, with the given name, attributes and event type.</source>
          <target state="translated">Aggiunge un nuovo evento al tipo, con il nome, gli attributi e il tipo di evento specificati.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The defined event.</source>
          <target state="translated">Evento definito.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new field to the dynamic type.</source>
          <target state="translated">Aggiunge un nuovo campo al tipo dinamico.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">Nome del campo.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">Tipo di campo.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">Attributi del campo.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, and field type.</source>
          <target state="translated">Aggiunge un nuovo campo al tipo, con il nome, gli attributi e il tipo di campo specificati.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">Campo definito.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> è System.Void.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">È stata specificata una dimensione totale per la classe padre di questo campo.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">Nome del campo.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">Tipo di campo.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the required custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated">Matrice di tipi che rappresentano i modificatori personalizzati obbligatori per il campo, come <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the optional custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated">Matrice di tipi che rappresentano i modificatori personalizzati opzionali per il campo, come <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">Attributi del campo.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</source>
          <target state="translated">Aggiunge un nuovo campo al tipo, con il nome, gli attributi, il tipo di campo e i modificatori personalizzati specificati.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">Campo definito.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Questo overload viene fornito per i progettisti di compilatori gestiti.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> è System.Void.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">È stata specificata una dimensione totale per la classe padre di questo campo.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of names for the generic type parameters.</source>
          <target state="translated">Matrice di nomi per i parametri di tipo generico.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to set their constraints.</source>
          <target state="translated">Definisce parametri di tipo generico per il tipo corrente, specificandone il numero e i nomi e restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> che possono essere usati per impostare i vincoli.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to define the constraints of the generic type parameters for the current type.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> che può essere usata per definire i vincoli dei parametri di tipo generico per il tipo corrente.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Calling this method makes the current type a generic type.</source>
          <target state="translated">Chiamare questo metodo rende il tipo corrente di un tipo generico.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>If the method is called again on the same type, an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Se il metodo viene chiamato nuovamente sullo stesso tipo, un <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</source>
          <target state="translated">Esempio di codice seguente crea un tipo generico con due parametri di tipo e li salva nell'assembly Genericemitexample1.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to view the generated types.</source>
          <target state="translated">È possibile utilizzare il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per visualizzare i tipi generati.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>For a more detailed explanation of the steps involved in defining a dynamic generic type, see <bpt id="p1">[</bpt>How to: Define a Generic Type with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>.</source>
          <target state="translated">Per una spiegazione più dettagliata dei passaggi coinvolti nella definizione di un tipo generico dinamico, vedere <bpt id="p1">[</bpt>procedura: definire un tipo generico tramite Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Generic type parameters have already been defined for this type.</source>
          <target state="translated">Parametri di tipo generico sono già stati definiti per questo tipo.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An element of <ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un elemento di <ph id="ph1">&lt;paramref name="names" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> è una matrice vuota.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Nome usato per fare riferimento ai dati.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The blob of data.</source>
          <target state="translated">BLOB di dati.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Attributi per il campo.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Defines initialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">Definisce il campo di dati inizializzati nella sezione .sdata del file eseguibile di tipo PE.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Campo di riferimento ai dati.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">Il campo creato con questo metodo sarà <ph id="ph1">`static`</ph>, anche se non si include <ph id="ph2">`FieldAttributes.Static`</ph> nel <ph id="ph3">`attributes`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</source>
          <target state="translated">La dimensione dei dati è minore o uguale a zero oppure maggiore o uguale a 0x3f0000.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="data" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> o <ph id="ph2">&lt;paramref name="data" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> has been previously called.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> è stato chiamato in precedenza.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a method to the type.</source>
          <target state="translated">Aggiunge un metodo al tipo.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The name of the method.</source>
          <target state="translated">Nome del metodo.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The attributes of the method.</source>
          <target state="translated">Attributi del metodo.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Adds a new method to the type, with the specified name and method attributes.</source>
          <target state="translated">Aggiunge un nuovo metodo al tipo, con il nome e gli attributi del metodo specificati.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> che rappresenta il metodo appena definito.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">Utilizzare questo overload del metodo quando non si conosce la firma del metodo al momento che si definisce il metodo.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">Tipi di parametro e tipo restituito di un metodo generico, ad esempio, può essere specificati dai parametri di tipo generico del metodo, che devono essere definiti dopo il metodo è stato aggiunto al tipo.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">I parametri e tipo restituito del metodo può essere impostati in un secondo momento utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This method overload defines a method with <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo overload del metodo definisce un metodo con <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>If you need to define a method without a signature, with a different calling convention, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overload.</source>
          <target state="translated">Se è necessario definire un metodo senza firma, con una convenzione di chiamata diversa, utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The following code example defines a generic method named <ph id="ph1">`DemoMethod`</ph> whose parameter type and return type are specified by its generic type parameters.</source>
          <target state="translated">Esempio di codice seguente definisce un metodo generico denominato <ph id="ph1">`DemoMethod`</ph> il cui tipo di parametro e il tipo restituito specificati dai relativi parametri di tipo generico.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The method is defined without a signature, using the standard calling convention.</source>
          <target state="translated">Il metodo viene definito senza firma, utilizzando la convenzione di chiamata standard.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method is used to make <ph id="ph2">`DemoMethod`</ph> a generic method, and the newly defined type parameters are then used for the signature and return type.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> consente di rendere <ph id="ph2">`DemoMethod`</ph> un metodo generico, i parametri di tipo appena definito vengono quindi utilizzati per la firma e il tipo restituito.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">Questo esempio di codice fa parte di un esempio più esaustivo disponibile per il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The name of the method.</source>
          <target state="translated">Nome del metodo.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The attributes of the method.</source>
          <target state="translated">Attributi del metodo.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The calling convention of the method.</source>
          <target state="translated">Convenzione di chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Adds a new method to the type, with the specified name, method attributes, and calling convention.</source>
          <target state="translated">Aggiunge un nuovo metodo al tipo, con il nome e gli attributi del metodo e la convenzione di chiamata specificati.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> che rappresenta il metodo appena definito.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">Utilizzare questo overload del metodo quando non si conosce la firma del metodo al momento che si definisce il metodo.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">Tipi di parametro e tipo restituito di un metodo generico, ad esempio, può essere specificati dai parametri di tipo generico del metodo, che devono essere definiti dopo il metodo è stato aggiunto al tipo.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">I parametri e tipo restituito del metodo può essere impostati in un secondo momento utilizzando il <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type of the parent of this method is an interface and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Nome del metodo.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Attributi del metodo.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Tipi dei parametri del metodo.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, and method signature.</source>
          <target state="translated">Aggiunge un nuovo metodo al tipo, con il nome, gli attributi e la firma del metodo specificati.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The defined method.</source>
          <target state="translated">Metodo definito.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato l'utilizzo di <ph id="ph1">`DefineMethod`</ph> per impostare un costruttore di una determinata firma e gli attributi su un tipo dinamico e per restituire un oggetto corrispondente <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> per dati MSIL.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">Nome del metodo.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">Attributi del metodo.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the method.</source>
          <target state="translated">Convenzione di chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">Tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Tipi dei parametri del metodo.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</source>
          <target state="translated">Aggiunge un nuovo metodo al tipo, con il nome, gli attributi del metodo, la convenzione di chiamata e la firma del metodo specificati.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> che rappresenta il metodo appena definito.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato l'utilizzo di <ph id="ph1">`DefineMethod`</ph> per impostare un costruttore di una determinata firma e gli attributi su un tipo dinamico e per restituire un oggetto corrispondente <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> per dati MSIL.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the method.</source>
          <target state="translated">Nome del metodo.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the method.</source>
          <target state="translated">Attributi del metodo.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the method.</source>
          <target state="translated">Convenzione di chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">Tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">Tipi dei parametri del metodo.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</source>
          <target state="translated">Aggiunge un nuovo metodo al tipo, con il nome, gli attributi del metodo, la convenzione di chiamata, la firma del metodo e i modificatori personalizzati specificati.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object representing the newly added method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> che rappresenta il metodo appena aggiunto.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Use this overload if you need to specify custom modifiers.</source>
          <target state="translated">Utilizzare questo overload se è necessario specificare i modificatori personalizzati specificati.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overloads to define the method and then use the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method to define the parameter and return types with custom modifiers.</source>
          <target state="translated">Se è necessario specificare i modificatori personalizzati specificati dopo il metodo è stato creato, come avviene, ad esempio, con un metodo generico, i cui tipi di parametro specificati dai relativi parametri di tipo generico, è possibile utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> overload del metodo per definire il metodo e utilizzare quindi la <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> per definire il parametro e restituire i tipi con i modificatori personalizzati specificati.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Per ulteriori informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II Metadata.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentazione è disponibile online; vedere <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (ECMA C# e standard di Common Language Infrastructure) in MSDN e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> nel sito Web internazionale Ecma.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">La dimensione di <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> o <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> non è uguale a quella di <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method body to be used.</source>
          <target state="translated">Corpo del metodo da usare.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>This should be a <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> object.</source>
          <target state="translated">Deve essere un oggetto <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method whose declaration is to be used.</source>
          <target state="translated">Metodo di cui usare la dichiarazione.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Specifies a given method body that implements a given method declaration, potentially with a different name.</source>
          <target state="translated">Specifica un corpo del metodo che implementa una data dichiarazione di metodo, potenzialmente con un nome diverso.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Do not use this method to emit method overrides or interface implementations.</source>
          <target state="translated">Non utilizzare questo metodo per generare l'override del metodo o implementazioni di interfaccia.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</source>
          <target state="translated">Per eseguire l'override di un metodo di una classe base o implementare un metodo di un'interfaccia, è sufficiente generare un metodo con lo stesso nome e la stessa firma del metodo di essere sottoposto a override o implementati, come illustrato nell'esempio di codice.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is used when a method body and a method declaration have different names.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> metodo viene utilizzato quando un corpo del metodo e una dichiarazione di metodo hanno nomi diversi.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</source>
          <target state="translated">Ad esempio, una classe potrebbe eseguire l'override di un metodo della classe base e inoltre fornire un'implementazione separata da un membro di interfaccia con lo stesso nome, come illustrato nell'esempio di codice.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`DefineMethodOverride`</ph> defines a <ph id="ph2">`methodimpl`</ph>, which consists of a pair of metadata tokens.</source>
          <target state="translated"><ph id="ph1">`DefineMethodOverride`</ph> definisce un <ph id="ph2">`methodimpl`</ph>, che è costituito da una coppia di token di metadati.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>One token points to an implementation, and the other token points to a declaration that the body implements.</source>
          <target state="translated">Un token punta a un'implementazione e gli altri punti di token a una dichiarazione che implementa il corpo.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The body must be defined on the type the method impl is defined on, and the body must be virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
          <target state="translated">Il corpo deve essere definito nel tipo di implementazione del metodo è definito in e il corpo deve essere virtuale (<ph id="ph1">`Overridable`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</source>
          <target state="translated">La dichiarazione può essere effettuata a un metodo definito in un'interfaccia implementata da un metodo definito nel tipo di, il tipo o un metodo in una classe derivata.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is on an interface only, the slot defined for the interface is altered.</source>
          <target state="translated">Se la dichiarazione è solo su un'interfaccia, viene modificato lo slot definito per l'interfaccia.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</source>
          <target state="translated">Se la dichiarazione viene effettuata a un metodo su un tipo di base, viene eseguito l'override del metodo slot ed eventuali duplicati per il metodo sottoposto a override verranno sostituiti.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The overridden method cannot be the actual method that is declared.</source>
          <target state="translated">Il metodo sottoposto a override non può essere il metodo effettivo che è dichiarato.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</source>
          <target state="translated">Se il metodo è sullo stesso tipo, lo slot verrà sostituito e vengono sottoposte a override di eventuali duplicati per i metodi di sostituzione.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For more information about method impls, see <ph id="ph1">`MethodImpl`</ph> in the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Per ulteriori informazioni sulle implementazioni di metodo, vedere <ph id="ph1">`MethodImpl`</ph> nella documentazione di ECMA Partition II Metadata.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentazione è disponibile online; vedere <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (ECMA C# e standard di Common Language Infrastructure) in MSDN e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> nel sito Web internazionale Ecma.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is called, some features of <ph id="ph2">`methodInfoBody`</ph> cannot be changed.</source>
          <target state="translated">Dopo il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> metodo viene chiamato, alcune funzionalità di <ph id="ph2">`methodInfoBody`</ph> non può essere modificato.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, you cannot apply an attribute to a generic type parameter of <ph id="ph1">`methodInfoBody`</ph> by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> method.</source>
          <target state="translated">È ad esempio, non è possibile applicare un attributo a un parametro di tipo generico di <ph id="ph1">`methodInfoBody`</ph> utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method, do so after all characteristics of <ph id="ph2">`methodInfoBody`</ph> have been defined.</source>
          <target state="translated">Se è necessario utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> (metodo), eseguire questa operazione dopo tutte le caratteristiche di <ph id="ph2">`methodInfoBody`</ph> sono state definite.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The following code example contains an interface <ph id="ph1">`I`</ph> with a method <ph id="ph2">`M()`</ph>, a base class <ph id="ph3">`A`</ph> that implements the interface, and a derived class <ph id="ph4">`C`</ph> that overrides the base class implementation of <ph id="ph5">`M()`</ph> and also provides a separate explicit implementation of <ph id="ph6">`I.M()`</ph>.</source>
          <target state="translated">Esempio di codice seguente contiene un'interfaccia <ph id="ph1">`I`</ph> con un metodo <ph id="ph2">`M()`</ph>, una classe di base <ph id="ph3">`A`</ph> che implementa l'interfaccia e una classe derivata <ph id="ph4">`C`</ph> che esegue l'override dell'implementazione della classe base <ph id="ph5">`M()`</ph> e inoltre fornisce un'implementazione esplicita distinta di <ph id="ph6">`I.M()`</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`main()`</ph> method of the code example shows how to emit the derived class <ph id="ph2">`C`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`main()`</ph> metodo dell'esempio di codice viene illustrato come generare la classe derivata <ph id="ph2">`C`</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The override of <ph id="ph1">`A.M()`</ph> is accomplished simply by emitting a method <ph id="ph2">`M()`</ph> with the same signature.</source>
          <target state="translated">L'override di <ph id="ph1">`A.M()`</ph> avviene semplicemente mediante la creazione di un metodo <ph id="ph2">`M()`</ph> con la stessa firma.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>However, to provide a separate implementation of <ph id="ph1">`I.M()`</ph>, you must define a method body and then use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method to associate that method body with a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing <ph id="ph4">`I.M()`</ph>.</source>
          <target state="translated">Tuttavia, per fornire un'implementazione separata di <ph id="ph1">`I.M()`</ph>, è necessario definire un corpo del metodo e quindi utilizzare il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> metodo per associare il corpo del metodo con un <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> che rappresenta <ph id="ph4">`I.M()`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The name of the method body does not matter.</source>
          <target state="translated">Il nome del corpo del metodo non è rilevante.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The code example creates an instance of the emitted class.</source>
          <target state="translated">L'esempio di codice crea un'istanza della classe generata.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`I.M()`</ph>, and uses it to invoke the emitted class's explicit interface implementation.</source>
          <target state="translated">Ottiene un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto <ph id="ph2">`I.M()`</ph>, e l'implementazione dell'interfaccia viene utilizzata per richiamare la classe generata 's esplicita.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It then obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`A.M()`</ph>, and uses it to invoke the emitted class's override of that method.</source>
          <target state="translated">Viene quindi ottenuto un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto <ph id="ph2">`A.M()`</ph>che viene utilizzato per richiamare l'override della classe generata di tale metodo.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> does not belong to this class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> non appartiene a questa classe.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> o <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> is not the type represented by this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Il tipo dichiarante di <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> non è il tipo rappresentato da questo oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a nested type.</source>
          <target state="translated">Definisce un tipo annidato.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The short name of the type.</source>
          <target state="translated">Nome breve del tipo.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Defines a nested type, given its name.</source>
          <target state="translated">Definisce un tipo annidato, dato il relativo nome.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The defined nested type.</source>
          <target state="translated">Tipo annidato definito.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Questo metodo può essere utilizzato per creare nidificata tipi anche dopo il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo è stato chiamato sul tipo di inclusione.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Il tipo annidato deve essere completata prima che riflette su di esso utilizzando <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vedere la descrizione di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> per l'ordine in cui devono essere completati i tipi annidati e i tipi di annidamento.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Un nome duplicato non viene necessariamente creato se <ph id="ph1">`name`</ph> è identico al nome di un tipo definito in precedenza o un tipo annidato.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Per essere duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di nidificazione.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero o maggiore di 1023.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Questa operazione creerebbe un tipo con un oggetto <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicato nell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The short name of the type.</source>
          <target state="translated">Nome breve del tipo.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The attributes of the type.</source>
          <target state="translated">Attributi del tipo.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>Defines a nested type, given its name and attributes.</source>
          <target state="translated">Definisce un tipo annidato, dato il relativo nome e attributi.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The defined nested type.</source>
          <target state="translated">Tipo annidato definito.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Questo metodo può essere utilizzato per creare nidificata tipi anche dopo il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo è stato chiamato sul tipo di inclusione.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Il tipo annidato deve essere completata prima che riflette su di esso utilizzando <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vedere la descrizione di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> per l'ordine in cui devono essere completati i tipi annidati e i tipi di annidamento.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Un nome duplicato non viene necessariamente creato se <ph id="ph1">`name`</ph> è identico al nome di un tipo definito in precedenza o un tipo annidato.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Per essere duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di nidificazione.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">L'attributo annidato non è specificato.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is sealed.</source>
          <target state="translated">Questo tipo è sealed.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an array.</source>
          <target state="translated">Questo tipo è una matrice.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero o maggiore di 1023.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Questa operazione creerebbe un tipo con un oggetto <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicato nell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The short name of the type.</source>
          <target state="translated">Nome breve del tipo.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attributes of the type.</source>
          <target state="translated">Attributi del tipo.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Tipo esteso dal tipo annidato.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Defines a nested type, given its name, attributes, and the type that it extends.</source>
          <target state="translated">Definisce un tipo annidato a partire dal nome, dagli attributi e dal tipo che estende.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined nested type.</source>
          <target state="translated">Tipo annidato definito.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Questo metodo può essere utilizzato per creare nidificata tipi anche dopo il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo è stato chiamato sul tipo di inclusione.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Il tipo annidato deve essere completata prima che riflette su di esso utilizzando <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vedere la descrizione di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> per l'ordine in cui devono essere completati i tipi annidati e i tipi di annidamento.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Un nome duplicato non viene necessariamente creato se <ph id="ph1">`name`</ph> è identico al nome di un tipo definito in precedenza o un tipo annidato.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Per essere duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di nidificazione.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">L'attributo annidato non è specificato.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is sealed.</source>
          <target state="translated">Questo tipo è sealed.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an array.</source>
          <target state="translated">Questo tipo è una matrice.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero o maggiore di 1023.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Questa operazione creerebbe un tipo con un oggetto <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicato nell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">Nome breve del tipo.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">Attributi del tipo.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Tipo esteso dal tipo annidato.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Dimensione totale del tipo.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</source>
          <target state="translated">Definisce un tipo annidato a partire dal nome, dagli attributi, dalla dimensione totale del tipo e dal tipo che estende.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">Tipo annidato definito.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Questo metodo può essere utilizzato per creare nidificata tipi anche dopo il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo è stato chiamato sul tipo di inclusione.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Il tipo annidato deve essere completata prima che riflette su di esso utilizzando <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vedere la descrizione di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> per l'ordine in cui devono essere completati i tipi annidati e i tipi di annidamento.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Un nome duplicato non viene necessariamente creato se <ph id="ph1">`name`</ph> è identico al nome di un tipo definito in precedenza o un tipo annidato.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Per essere duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di nidificazione.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">L'attributo annidato non è specificato.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is sealed.</source>
          <target state="translated">Questo tipo è sealed.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an array.</source>
          <target state="translated">Questo tipo è una matrice.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero o maggiore di 1023.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Questa operazione creerebbe un tipo con un oggetto <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicato nell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The short name of the type.</source>
          <target state="translated">Nome breve del tipo.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The attributes of the type.</source>
          <target state="translated">Attributi del tipo.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Tipo esteso dal tipo annidato.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The packing size of the type.</source>
          <target state="translated">Dimensione di compressione del tipo.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</source>
          <target state="translated">Definisce un tipo annidato a partire dal nome, dagli attributi, dal tipo che estende e dalla dimensione di compressione.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The defined nested type.</source>
          <target state="translated">Tipo annidato definito.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Questo metodo può essere utilizzato per creare nidificata tipi anche dopo il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo è stato chiamato sul tipo di inclusione.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Il tipo annidato deve essere completata prima che riflette su di esso utilizzando <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vedere la descrizione di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> per l'ordine in cui devono essere completati i tipi annidati e i tipi di annidamento.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Un nome duplicato non viene necessariamente creato se <ph id="ph1">`name`</ph> è identico al nome di un tipo definito in precedenza o un tipo annidato.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Per essere duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di nidificazione.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">L'attributo annidato non è specificato.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is sealed.</source>
          <target state="translated">Questo tipo è sealed.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an array.</source>
          <target state="translated">Questo tipo è una matrice.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero o maggiore di 1023.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Questa operazione creerebbe un tipo con un oggetto <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicato nell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The short name of the type.</source>
          <target state="translated">Nome breve del tipo.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The attributes of the type.</source>
          <target state="translated">Attributi del tipo.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The type that the nested type extends.</source>
          <target state="translated">Tipo esteso dal tipo annidato.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The interfaces that the nested type implements.</source>
          <target state="translated">Interfacce implementate dal tipo annidato.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</source>
          <target state="translated">Definisce un tipo annidato a partire dal nome, dagli attributi, dal tipo che estende e dalle interfacce che implementa.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The defined nested type.</source>
          <target state="translated">Tipo annidato definito.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">Questo metodo può essere utilizzato per creare nidificata tipi anche dopo il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo è stato chiamato sul tipo di inclusione.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">Il tipo annidato deve essere completata prima che riflette su di esso utilizzando <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">Vedere la descrizione di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> per l'ordine in cui devono essere completati i tipi annidati e i tipi di annidamento.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">Un nome duplicato non viene necessariamente creato se <ph id="ph1">`name`</ph> è identico al nome di un tipo definito in precedenza o un tipo annidato.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">Per essere duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di nidificazione.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested attribute is not specified.</source>
          <target state="translated">L'attributo annidato non è specificato.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is sealed.</source>
          <target state="translated">Questo tipo è sealed.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an array.</source>
          <target state="translated">Questo tipo è una matrice.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero o maggiore di 1023.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">Questa operazione creerebbe un tipo con un oggetto <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> duplicato nell'assembly corrente.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>An element of the <ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Un elemento della matrice <ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">Nome breve del tipo.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded null values.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">Attributi del tipo.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">Tipo esteso dal tipo annidato.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The packing size of the type.</source>
          <target state="translated">Dimensione di compressione del tipo.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">Dimensione totale del tipo.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Defines a nested type, given its name, attributes, size, and the type that it extends.</source>
          <target state="translated">Definisce un tipo annidato a partire dal nome, dagli attributi, dalla dimensione e dal tipo che estende.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">Tipo annidato definito.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Definisce un metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Nome del metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Nome della DLL in cui è definito il metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Attributi del metodo.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Convenzione di chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Tipi dei parametri del metodo.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Convenzione di chiamata nativa.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Set di caratteri nativo del metodo.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Definisce un metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> in base al nome, al nome della DLL in cui è definito il metodo, agli attributi del metodo, alla convenzione di chiamata del metodo, al tipo restituito del metodo, ai tipi di parametri del metodo e ai flag <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> definito.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Gli attributi di importazione di alcune DLL (vedere la descrizione di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) non può essere specificata come argomenti a questo metodo.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Attributo di importazione DLL, ad esempio, <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> deve essere aggiunto dopo il <ph id="ph2">`PInvoke`</ph> (metodo) viene creato, se il metodo restituisce un valore.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">Nell'esempio viene illustrato come eseguire questa operazione.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> metodo per creare un <ph id="ph2">`PInvoke`</ph> (metodo) e come aggiungere il <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag ai flag di implementazione del metodo dopo aver creato il <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, utilizzando il <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>metodi.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Per ottenere un valore restituito diverso da zero, è necessario aggiungere il <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">Nell'esempio viene creato un assembly dinamico con un modulo dinamico e un solo tipo, <ph id="ph1">`MyType`</ph>, che contiene il <ph id="ph2">`PInvoke`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated">Il <ph id="ph1">`PInvoke`</ph> metodo rappresenta Win32 <ph id="ph2">`GetTickCount`</ph> (funzione).</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">Quando si esegue l'esempio, viene eseguito il <ph id="ph1">`PInvoke`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">Inoltre, Salva l'assembly dinamico come PInvokeTest.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">È possibile utilizzare il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il <ph id="ph1">`MyType`</ph> classe e <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> metodo contiene.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">È possibile compilare un programma Visual Basic o c# che utilizza il metodo statico <ph id="ph1">`MyType.GetTickCount`</ph> metodo includendo un riferimento alla DLL quando si esegue csc.exe o vbc.exe; ad esempio, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Il metodo non è statico.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">Il tipo padre è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Il metodo è di tipo abstract.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Il metodo è stato definito in precedenza.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> o <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> o <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato in precedenza con <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Nome del metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Nome della DLL in cui è definito il metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">Nome del punto di ingresso nella DLL.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Attributi del metodo.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Convenzione di chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Tipi dei parametri del metodo.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Convenzione di chiamata nativa.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Set di caratteri nativo del metodo.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated">Definisce un metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> in base al nome, al nome della DLL in cui è definito il metodo, al nome del punto di ingresso, agli attributi del metodo, alla convenzione di chiamata del metodo, al tipo restituito del metodo, ai tipi di parametri del metodo e ai flag <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> definito.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Gli attributi di importazione di alcune DLL (vedere la descrizione di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) non può essere specificata come argomenti a questo metodo.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Attributo di importazione DLL, ad esempio, <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> deve essere aggiunto dopo il <ph id="ph2">`PInvoke`</ph> (metodo) viene creato, se il metodo restituisce un valore.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">Nell'esempio viene illustrato come eseguire questa operazione.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> metodo per creare un <ph id="ph2">`PInvoke`</ph> (metodo) e come aggiungere il <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag ai flag di implementazione del metodo dopo aver creato il <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, utilizzando il <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Per ottenere un valore restituito diverso da zero, è necessario aggiungere il <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">Nell'esempio viene creato un assembly dinamico con un modulo dinamico e un solo tipo, <ph id="ph1">`MyType`</ph>, che contiene il <ph id="ph2">`PInvoke`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated">Il <ph id="ph1">`PInvoke`</ph> metodo rappresenta Win32 <ph id="ph2">`GetTickCount`</ph> (funzione).</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">Quando si esegue l'esempio, viene eseguito il <ph id="ph1">`PInvoke`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">Inoltre, Salva l'assembly dinamico come PInvokeTest.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">È possibile utilizzare il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il <ph id="ph1">`MyType`</ph> classe e <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> metodo contiene.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">È possibile compilare un programma Visual Basic o c# che utilizza il metodo statico <ph id="ph1">`MyType.GetTickCount`</ph> metodo includendo un riferimento alla DLL quando si esegue csc.exe o vbc.exe; ad esempio, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Il metodo non è statico.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">Il tipo padre è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Il metodo è di tipo abstract.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Il metodo è stato definito in precedenza.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> o <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> o <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> è <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato in precedenza con <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Nome del metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated">Nome della DLL in cui è definito il metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">Nome del punto di ingresso nella DLL.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">Attributi del metodo.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">Convenzione di chiamata del metodo.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">Tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito del metodo.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">Tipi dei parametri del metodo.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">Convenzione di chiamata nativa.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">Set di caratteri nativo del metodo.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags, and custom modifiers for the parameters and return type.</source>
          <target state="translated">Definisce un metodo <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> in base al nome, al nome della DLL in cui è definito il metodo, al nome del punto di ingresso, agli attributi del metodo, alla convenzione di chiamata del metodo, al tipo restituito del metodo, ai tipi di parametri del metodo, ai flag <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> e ai modificatori personalizzati relativi ai parametri e al tipo restituito.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the defined <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> che rappresenta il metodo <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> definito.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">Gli attributi di importazione di alcune DLL (vedere la descrizione di <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) non può essere specificata come argomenti a questo metodo.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">Attributo di importazione DLL, ad esempio, <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> deve essere aggiunto dopo il <ph id="ph2">`PInvoke`</ph> (metodo) viene creato, se il metodo restituisce un valore.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">Nell'esempio viene illustrato come eseguire questa operazione.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Per ulteriori informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II Metadata.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentazione è disponibile online; vedere <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (ECMA C# e standard di Common Language Infrastructure) in MSDN e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> nel sito Web internazionale Ecma.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the [<ph id="ph1">\]</ph>, Type<ph id="ph2">\[</ph><ph id="ph3">\]</ph>, Type<ph id="ph4">\[</ph><ph id="ph5">\]</ph>, Type<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>, Type<ph id="ph10">\[</ph><ph id="ph11">\]</ph><ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt; method to create a <ph id="ph13">`PInvoke`</ph> method, and how to add the <ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come usare il [<ph id="ph1">\]</ph>, tipo<ph id="ph2">\[</ph><ph id="ph3">\]</ph>, tipo<ph id="ph4">\[</ph><ph id="ph5">\]</ph>, tipo<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>, tipo<ph id="ph10">\[</ph> <ph id="ph11">\]</ph> <ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A &gt; per creare un <ph id="ph13">`PInvoke`</ph> (metodo) e come aggiungere il <ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag ai flag di implementazione del metodo dopo aver creato il <ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, utilizzando il <ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">Nell'esempio viene creato un assembly dinamico con un modulo dinamico e un solo tipo, <ph id="ph1">`MyType`</ph>, che contiene il <ph id="ph2">`PInvoke`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated">Il <ph id="ph1">`PInvoke`</ph> metodo rappresenta Win32 <ph id="ph2">`GetTickCount`</ph> (funzione).</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">Per ottenere un valore restituito diverso da zero, è necessario aggiungere il <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example uses an overload that does not specify custom modifiers.</source>
          <target state="translated">Nell'esempio viene usato un overload che non specifica i modificatori personalizzati specificati.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To specify custom modifiers, change the example code to use this method overload instead.</source>
          <target state="translated">Per specificare i modificatori personalizzati, modificare il codice di esempio per utilizzare invece l'overload di questo metodo.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">Quando si esegue l'esempio, viene eseguito il <ph id="ph1">`PInvoke`</ph> metodo.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">Inoltre, Salva l'assembly dinamico come PInvokeTest.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">È possibile utilizzare il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per esaminare il <ph id="ph1">`MyType`</ph> classe e <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> metodo contiene.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">È possibile compilare un programma Visual Basic o c# che utilizza il metodo statico <ph id="ph1">`MyType.GetTickCount`</ph> metodo includendo un riferimento alla DLL quando si esegue csc.exe o vbc.exe; ad esempio, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">Il metodo non è statico.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">Il tipo padre è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">Il metodo è di tipo abstract.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">Il metodo è stato definito in precedenza.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> o <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated">La dimensione di <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> o <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> non è uguale a quella di <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> o <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> è <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new property to the type.</source>
          <target state="translated">Aggiunge una nuova proprietà al tipo.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">Nome della proprietà.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">Attributi della proprietà.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">Tipo restituito della proprietà.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Tipi dei parametri della proprietà.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name and property signature.</source>
          <target state="translated">Aggiunge una nuova proprietà al tipo, con il nome e la firma della proprietà specificati.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">Proprietà definita.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates how to define a dynamic property and obtain a <ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph> for specification.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come definire una proprietà dinamica e ottenere un <ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph> specifica.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Note that a <ph id="ph1">`PropertyBuilder`</ph> must also have a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, which will house the IL logic for the property.</source>
          <target state="translated">Si noti che un <ph id="ph1">`PropertyBuilder`</ph> deve avere anche una corrispondente <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, che conterrà la logica di IL per la proprietà.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno degli elementi della matrice <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">Nome della proprietà.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">Attributi della proprietà.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">Convenzione di chiamata delle funzioni di accesso della proprietà.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">Tipo restituito della proprietà.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Tipi dei parametri della proprietà.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</source>
          <target state="translated">Aggiunge una nuova proprietà al tipo, con il nome, gli attributi, la convenzione di chiamata e la firma della proprietà specificati.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">Proprietà definita.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno degli elementi della matrice <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">Nome della proprietà.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">Attributi della proprietà.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">Tipo restituito della proprietà.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito della proprietà.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito della proprietà.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Tipi dei parametri della proprietà.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, property signature, and custom modifiers.</source>
          <target state="translated">Aggiunge una nuova proprietà al tipo, con il nome, la firma della proprietà e i modificatori personalizzati specificati.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">Proprietà definita.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Questo overload viene fornito per i progettisti di compilatori gestiti.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Per ulteriori informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II Metadata.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentazione è disponibile online; vedere <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (ECMA C# e standard di Common Language Infrastructure) in MSDN e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> nel sito Web internazionale Ecma.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated">Uno degli elementi della matrice <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">Nome della proprietà.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">Attributi della proprietà.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">Convenzione di chiamata delle funzioni di accesso della proprietà.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">Tipo restituito della proprietà.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito della proprietà.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, per il tipo restituito della proprietà.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">Tipi dei parametri della proprietà.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">Matrice di matrici di tipi.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di tipi.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <ph id="ph1">&lt;see langword="null" /&gt;</ph> invece di una matrice di matrici.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</source>
          <target state="translated">Aggiunge una nuova proprietà al tipo, con il nome, la convenzione di chiamata, la firma e i modificatori personalizzati specificati.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">Proprietà definita.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">Questo overload viene fornito per i progettisti di compilatori gestiti.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">Per ulteriori informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II Metadata.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentazione è disponibile online; vedere <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (ECMA C# e standard di Common Language Infrastructure) in MSDN e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> nel sito Web internazionale Ecma.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Questo overload del metodo è stato introdotto nel <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Uno degli elementi della matrice <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Defines the initializer for this type.</source>
          <target state="translated">Definisce l'inizializzatore per questo tipo.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Returns a type initializer.</source>
          <target state="translated">Restituisce un inizializzatore di tipo.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The initializer created is always public.</source>
          <target state="translated">L'inizializzatore creato è sempre pubblica.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The following code sample demonstrates how to create an initialization constructor using <ph id="ph1">`DefineTypeInitializer`</ph>.</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato come creare un costruttore di inizializzazione utilizzando <ph id="ph1">`DefineTypeInitializer`</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo contenitore è stato creato in precedenza con <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">Nome usato per fare riferimento ai dati.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> non può contenere valori Null incorporati.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The size of the data field.</source>
          <target state="translated">Dimensione del campo dati.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">Attributi per il campo.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Defines an uninitialized data field in the <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph> section of the portable executable (PE) file.</source>
          <target state="translated">Definisce un campo di dati non inizializzati nella sezione <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph> del file eseguibile di tipo PE.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">Campo di riferimento ai dati.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">Il campo creato con questo metodo sarà <ph id="ph1">`static`</ph>, anche se non si include <ph id="ph2">`FieldAttributes.Static`</ph> nel <ph id="ph3">`attributes`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineUninitializedData`</ph> to create an uninitialized data field in a dynamic type:</source>
          <target state="translated">Esempio di codice riportato di seguito viene illustrato l'utilizzo di <ph id="ph1">`DefineUninitializedData`</ph> per creare un campo dati non inizializzati in un tipo dinamico:</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è zero.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than or equal to zero, or greater than or equal to 0x003f0000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> è minore di o uguale a zero oppure maggiore di o uguale a 0x003f0000.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">Recupera il percorso completo di questo tipo.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">Recupera il percorso completo di questo tipo.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</source>
          <target state="translated">Il formato restituito è "NomeCompletoTipoInclusione + NomeTipoNidificato" per i tipi annidati e "NomeTipo" per i tipi non annidati.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>Gets a value that indicates the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Ottiene un valore che indica la covarianza e i vincoli speciali del parametro di tipo generico corrente.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Combinazione bit per bit di valori <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> che descrive la covariante e i vincoli speciali del parametro di tipo generico corrente.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Quando si genera codice, un parametro di tipo generico è rappresentato da un <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> oggetto anziché da un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</source>
          <target state="translated">Ottiene la posizione di un parametro di tipo nell'elenco dei parametri di tipo del tipo generico che ha dichiarato il parametro.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</source>
          <target state="translated">Se l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> corrente rappresenta un parametro di tipo generico, la posizione del parametro di tipo nell'elenco di parametri di tipo del tipo generico che ha dichiarato il parametro; in caso contrario, non definito.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Quando si genera codice, un parametro di tipo generico è rappresentato da un <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> oggetto anziché da un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent a generic type parameter, the value of this property is undefined.</source>
          <target state="translated">Se l'oggetto corrente <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> non rappresenta un parametro di tipo generico, il valore di questa proprietà non è definito.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents a generic type parameter.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> proprietà per determinare se l'oggetto corrente <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> rappresenta un parametro di tipo generico.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The constructed generic type whose constructor is returned.</source>
          <target state="translated">Tipo generico creato di cui viene restituito il costruttore.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A constructor on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which constructor of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Costruttore sulla definizione di tipo generico di <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, che specifica il costruttore di <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> da restituire.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</source>
          <target state="translated">Restituisce il costruttore del tipo generico costruito specificato che corrisponde al costruttore specificato della definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object that represents the constructor of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="constructor" /&gt;</ph>, which specifies a constructor belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> che rappresenta il costruttore di <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corrispondente a <ph id="ph3">&lt;paramref name="constructor" /&gt;</ph>, che specifica un costruttore appartenente alla definizione di tipo generico di <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> metodo fornisce un modo per ottenere un <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> oggetto che rappresenta un costruttore di un tipo generico costruito la cui definizione di tipo generico è rappresentato da un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents a constructor of <ph id="ph6">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Si supponga, ad esempio, un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto che rappresenta il tipo <ph id="ph2">`G&lt;T&gt;`</ph> nella sintassi di c# (<ph id="ph3">`G(Of T)`</ph> in Visual Basic <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) e un <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> oggetto che rappresenta un costruttore di <ph id="ph6">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">Si supponga che <ph id="ph1">`G&lt;T&gt;`</ph> ha un metodo generico con il parametro di tipo <ph id="ph2">`U`</ph> che crea un'istanza del tipo costruito <ph id="ph3">`G&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In order to emit the code to create an instance of the constructed type, you need a <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents the constructor of this constructed type — in other words, that creates an instance of <ph id="ph2">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">Per generare il codice per creare un'istanza del tipo costruito, è necessario un <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> oggetto che rappresenta il costruttore di questo tipo costruito, in altre parole, che crea un'istanza di <ph id="ph2">`G&lt;U&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">A tale scopo, chiamare innanzitutto il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dell'oggetto, che specifica il <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> oggetto che rappresenta <ph id="ph4">`U`</ph> come argomento di tipo.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents the constructor of <ph id="ph5">`G&lt;U&gt;`</ph> as parameter <ph id="ph6">`constructor`</ph>.</source>
          <target state="translated">Quindi chiamare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> metodo con il valore restituito del <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> metodo come parametro <ph id="ph3">`type`</ph> e <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> oggetto che rappresenta il costruttore di <ph id="ph5">`G&lt;U&gt;`</ph> come parametro <ph id="ph6">`constructor`</ph>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">Il valore restituito è il <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> è necessario creare la chiamata di funzione.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">L'esempio di codice viene illustrato questo scenario.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">Esempio di codice seguente contiene il codice sorgente per una classe generica denominata <ph id="ph1">`Sample`</ph> che include un parametro di tipo denominato <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">La classe dispone di un campo denominato <ph id="ph1">`Field`</ph>, di tipo <ph id="ph2">`T`</ph>e un metodo generico denominato <ph id="ph3">`GM`</ph> con un parametro di tipo denominato <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Metodo <ph id="ph1">`GM`</ph> crea un'istanza di <ph id="ph2">`Sample`</ph>, sostituendo il parametro di tipo <ph id="ph3">`U`</ph> per il parametro di tipo <ph id="ph4">`Sample`</ph>e archivia il relativo parametro di input in <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Questo codice sorgente viene compilato ma non è utilizzato; è possibile visualizzare con il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> e confrontarla con il codice generato dalla classe <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">Il codice nella classe <ph id="ph1">`Example`</ph> viene illustrato come utilizzare il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> metodo per generare il codice generico.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`Main`</ph> metodo della classe <ph id="ph2">`Example`</ph> crea un assembly dinamico che contiene una classe denominata <ph id="ph3">`Sample`</ph> e utilizza il <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> metodo per renderlo generico aggiungendo un parametro di tipo denominato <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Un costruttore predefinito e un campo denominato <ph id="ph1">`Field`</ph>, di tipo <ph id="ph2">`T`</ph>, vengono aggiunti alla classe <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Un metodo <ph id="ph1">`GM`</ph> viene aggiunto e trasformato in un metodo generico utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Il parametro di tipo <ph id="ph1">`GM`</ph> denominato <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Dopo aver definito il parametro di tipo, la firma di <ph id="ph1">`GM`</ph> viene aggiunto tramite il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">Vi è alcun tipo restituito e non necessari o modificatori personalizzati, pertanto tutti i parametri di questo metodo sono <ph id="ph1">`null`</ph> tranne <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> imposta il tipo di parametro solo del metodo per <ph id="ph4">`U`</ph>, il parametro di tipo generico del metodo.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Il corpo del metodo crea un'istanza del tipo costruito <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assegna il parametro del metodo per <ph id="ph3">`Field`</ph>e quindi stampato il valore di <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents the default constructor of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph> instruction that creates the instance.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> metodo viene utilizzato per creare un <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> che rappresenta il costruttore predefinito del tipo generico costruito <ph id="ph3">`Sample&lt;U&gt;`</ph> nel <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph> istruzione che crea l'istanza.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Viene definito un tipo fittizio per contenere il metodo del punto di ingresso <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">Nel corpo di <ph id="ph1">`Main`</ph>, statica <ph id="ph2">`GM`</ph> metodo viene richiamato nel tipo generico costruito <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), con il tipo <ph id="ph5">&lt;xref:System.String&gt;</ph> sostituito con <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Quando si esegue l'esempio di codice, come TypeBuilderGetFieldExample.exe salva l'assembly generato.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">È possibile eseguire TypeBuilderGetFieldExample.exe ed è possibile utilizzare il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per confrontare il codice generato con il codice per la <ph id="ph1">`Sample`</ph> classe che viene compilato nell'esempio di codice.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> non rappresenta un tipo generico.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> non è di tipo <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">Il tipo dichiarante di <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> non è una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Il tipo dichiarante di <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> non è la definizione di tipo generico di <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">È necessario che si tratti di un flag di bit da <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, come in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e così via.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the public and non-public constructors defined for this class, as specified.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> che rappresentano i costruttori pubblici e non pubblici definiti per questa classe, come specificato.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the specified constructors defined for this class.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> che rappresentano i costruttori specificati definiti per questa classe.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>If no constructors are defined, an empty array is returned.</source>
          <target state="translated">Se non è stato definito alcun costruttore, verrà restituita una matrice vuota.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the custom attributes defined for this type.</source>
          <target state="translated">Restituisce gli attributi personalizzati definiti per questo tipo.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Specifica se trovare gli attributi cercandoli nella catena di ereditarietà del membro.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this type.</source>
          <target state="translated">Restituisce tutti gli attributi personalizzati definiti per questo tipo.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of this type.</source>
          <target state="translated">Restituisce una matrice di oggetti che rappresentano tutti gli attributi personalizzati di questo tipo.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Questo metodo non è attualmente supportato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> e chiamare <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> sul <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> restituito.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">Tipo di attributo da cercare.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">Vengono restituiti solo gli attributi assegnabili a questo tipo.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Specifica se trovare gli attributi cercandoli nella catena di ereditarietà del membro.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns all the custom attributes of the current type that are assignable to a specified type.</source>
          <target state="translated">Restituisce tutti gli attributi personalizzati del tipo corrente che è possibile assegnare a un tipo specificato.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of custom attributes defined on the current type.</source>
          <target state="translated">Matrice di attributi personalizzati definiti per il tipo corrente.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Questo metodo non è attualmente supportato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> e chiamare <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> sul <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> restituito.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type must be a type provided by the underlying runtime system.</source>
          <target state="translated">Il tipo deve essere uno di quelli forniti dal sistema di runtime sottostante.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Calling this method always throws <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</source>
          <target state="translated">La chiamata di questo metodo genera sempre un'eccezione <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">Questo metodo non è supportato.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>No value is returned.</source>
          <target state="translated">Non vengono restituiti valori.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">Questo metodo non è supportato.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The name of the event to search for.</source>
          <target state="translated">Nome dell'evento di cui eseguire la ricerca.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">Combinazione bit per bit di valori <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> che limitano la ricerca.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Returns the event with the specified name.</source>
          <target state="translated">Restituisce l'evento con il nome specificato.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the event declared or inherited by this type with the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if there are no matches.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> che rappresenta l'evento dichiarato o ereditato da questo tipo con il nome specificato o <ph id="ph2">&lt;see langword="null" /&gt;</ph> in assenza di corrispondenze.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the events defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Restituisce gli eventi definiti dalla classe <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns the public events declared or inherited by this type.</source>
          <target state="translated">Restituisce gli eventi pubblici dichiarati o ereditati da questo tipo.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the public events declared or inherited by this type.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> che rappresentano tutti gli eventi pubblici dichiarati o ereditati dal tipo.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>An empty array is returned if there are no public events.</source>
          <target state="translated">In assenza di eventi pubblici, viene restituita una matrice vuota.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">Combinazione bit per bit di valori <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> che limitano la ricerca.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public events that are declared by this type.</source>
          <target state="translated">Restituisce gli eventi pubblici e non pubblici dichiarati da questo tipo.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the events declared or inherited by this type that match the specified binding flags.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> che rappresentano gli eventi dichiarati o ereditati da questo tipo e corrispondono a flag di associazione specificati.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching events.</source>
          <target state="translated">In assenza di eventi corrispondenti, viene restituita una matrice vuota.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a field defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Restituisce un campo definito dalla classe <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The name of the field to get.</source>
          <target state="translated">Nome del campo da ottenere.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">È necessario che si tratti di un flag di bit da <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, come in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e così via.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the field specified by the given name.</source>
          <target state="translated">Restituisce il campo specificato con il nome specificato.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</source>
          <target state="translated">Restituisce l'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> che rappresenta il campo dichiarato o ereditato da questo tipo con il nome e il modificatore pubblico o non pubblico specificati.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If there are no matches then <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Se non ci sono corrispondenze, verrà restituito <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The constructed generic type whose field is returned.</source>
          <target state="translated">Il tipo generico creato di cui viene restituito il campo.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A field on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which field of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Campo sulla definizione di tipo generico di <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, che specifica il campo di <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> da restituire.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</source>
          <target state="translated">Restituisce il campo del tipo generico specificato che corrisponde al campo specificato della definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object that represents the field of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="field" /&gt;</ph>, which specifies a field belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> che rappresenta il campo di <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corrispondente a <ph id="ph3">&lt;paramref name="field" /&gt;</ph>, che specifica un campo appartenente alla definizione di tipo generico di <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents a field of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> metodo fornisce un modo per ottenere un <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> oggetto che rappresenta un campo di un tipo generico costruito la cui definizione di tipo generico è rappresentato da un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents a field <ph id="ph6">`public T F`</ph> in C# syntax (<ph id="ph7">`Public F As T`</ph> in Visual Basic, <ph id="ph8">`public: T F`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Si supponga, ad esempio, un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto che rappresenta il tipo <ph id="ph2">`G&lt;T&gt;`</ph> nella sintassi di c# (<ph id="ph3">`G(Of T)`</ph> in Visual Basic <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) e un <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> oggetto che rappresenta un campo <ph id="ph6">`public T F`</ph> nella sintassi di c# (<ph id="ph7">`Public F As T`</ph>in Visual Basic <ph id="ph8">`public: T F`</ph> in C++) definito da <ph id="ph9">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls field <ph id="ph4">`F`</ph> on that instance.</source>
          <target state="translated">Si supponga che <ph id="ph1">`G&lt;T&gt;`</ph> ha un metodo generico con il parametro di tipo <ph id="ph2">`U`</ph> che crea un'istanza del tipo costruito <ph id="ph3">`G&lt;U&gt;`</ph> e chiami il campo <ph id="ph4">`F`</ph> su quell'istanza.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents <ph id="ph2">`F`</ph> on the constructed type — in other words, that is of type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Per creare la chiamata di funzione, è necessario un <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> oggetto che rappresenta <ph id="ph2">`F`</ph> sul tipo costruito, in altre parole, che è di tipo <ph id="ph3">`U`</ph> anziché tipo <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">A tale scopo, chiamare innanzitutto il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dell'oggetto, che specifica il <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> oggetto che rappresenta <ph id="ph4">`U`</ph> come argomento di tipo.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents <ph id="ph5">`F`</ph> as parameter <ph id="ph6">`field`</ph>.</source>
          <target state="translated">Chiamare quindi il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> metodo con il valore restituito del <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> metodo come parametro <ph id="ph3">`type`</ph> e <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> oggetto che rappresenta <ph id="ph5">`F`</ph> come parametro <ph id="ph6">`field`</ph>.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">Il valore restituito è il <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> è necessario creare la chiamata di funzione.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">L'esempio di codice viene illustrato questo scenario.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The following code example contains source code for a generic class named Sample that has a type parameter named <ph id="ph1">`T`</ph>.</source>
          <target state="translated">Esempio di codice seguente contiene il codice sorgente per una classe generica denominata Sample che dispone di un parametro di tipo denominato <ph id="ph1">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">La classe dispone di un campo denominato <ph id="ph1">`Field`</ph>, di tipo <ph id="ph2">`T`</ph>e un metodo generico denominato <ph id="ph3">`GM`</ph> con un parametro di tipo denominato <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Metodo <ph id="ph1">`GM`</ph> crea un'istanza di <ph id="ph2">`Sample`</ph>, sostituendo il parametro di tipo <ph id="ph3">`U`</ph> per il parametro di tipo <ph id="ph4">`Sample`</ph>e archivia il relativo parametro di input in <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Questo codice sorgente viene compilato ma non è utilizzato; è possibile visualizzare con il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> e confrontarla con il codice generato dalla classe <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">Il codice nella classe <ph id="ph1">`Example`</ph> viene illustrato come utilizzare il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> metodo per generare il codice generico.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph>, and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`Main`</ph> metodo della classe <ph id="ph2">`Example`</ph> crea un assembly dinamico che contiene una classe denominata <ph id="ph3">`Sample`</ph>e utilizza il <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> metodo per renderlo generico aggiungendo un parametro di tipo denominato <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Un costruttore predefinito e un campo denominato <ph id="ph1">`Field`</ph>, di tipo <ph id="ph2">`T`</ph>, vengono aggiunti alla classe <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Un metodo <ph id="ph1">`GM`</ph> viene aggiunto e trasformato in un metodo generico utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Il parametro di tipo <ph id="ph1">`GM`</ph> denominato <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Dopo aver definito il parametro di tipo, la firma di <ph id="ph1">`GM`</ph> viene aggiunto tramite il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">Vi è alcun tipo restituito e non necessari o modificatori personalizzati, pertanto tutti i parametri di questo metodo sono <ph id="ph1">`null`</ph> tranne <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> imposta il tipo di parametro solo del metodo per <ph id="ph4">`U`</ph>, il parametro di tipo generico del metodo.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Il corpo del metodo crea un'istanza del tipo costruito <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assegna il parametro del metodo per <ph id="ph3">`Field`</ph>e quindi stampato il valore di <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> that represents the field of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph> instructions.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> metodo viene utilizzato per creare un <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> che rappresenta il campo del tipo generico costruito <ph id="ph3">`Sample&lt;U&gt;`</ph> nel <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph> e <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph> istruzioni.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Viene definito un tipo fittizio per contenere il metodo del punto di ingresso <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">Nel corpo di <ph id="ph1">`Main`</ph>, statica <ph id="ph2">`GM`</ph> metodo viene richiamato nel tipo generico costruito <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), con il tipo <ph id="ph5">&lt;xref:System.String&gt;</ph> sostituito con <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Quando si esegue l'esempio di codice, come TypeBuilderGetFieldExample.exe salva l'assembly generato.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">È possibile eseguire TypeBuilderGetFieldExample.exe ed è possibile utilizzare il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per confrontare il codice generato con il codice per la <ph id="ph1">`Sample`</ph> classe che viene compilato nell'esempio di codice.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> non rappresenta un tipo generico.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> non è di tipo <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">Il tipo dichiarante di <ph id="ph1">&lt;paramref name="field" /&gt;</ph> non è una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Il tipo dichiarante di <ph id="ph1">&lt;paramref name="field" /&gt;</ph> non è la definizione di tipo generico di <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">È necessario che si tratti di un flag di bit richiamato dall'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, ad esempio <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e così via.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public fields that are declared by this type.</source>
          <target state="translated">Restituisce i campi pubblici e non pubblici dichiarati da questo tipo.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the public and non-public fields declared or inherited by this type.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> che rappresentano i campi pubblici e non pubblici dichiarati o ereditati da questo tipo.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no fields, as specified.</source>
          <target state="translated">In assenza di campi, viene restituita una matrice vuota, come specificato.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> metodo non restituisce i campi in un ordine specifico, ad esempio in ordine alfabetico o ordine di dichiarazione.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">Il codice non deve dipendere l'ordine in cui vengono restituiti i campi, poiché tale ordine può variare.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresentano gli argomenti di tipo di un tipo generico o i parametri di tipo di una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Gli elementi della matrice rappresentano gli argomenti tipo di un tipo generico o i parametri di tipo di una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</source>
          <target state="translated">Gli elementi della matrice restituita sono nell'ordine in cui compaiono nell'elenco dei parametri di tipo per la definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto rappresenta una definizione di tipo generico, se il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> metodo è stato utilizzato per fornire parametri di tipo generico.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>This method retrieves the <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objects that represent the generic type parameters.</source>
          <target state="translated">Questo metodo recupera il <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> gli oggetti che rappresentano i parametri di tipo generico.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per ulteriori informazioni sui tipi generici nella reflection e un elenco di condizioni invarianti per i termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current type can be obtained.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta una definizione di tipo generico da cui è possibile ottenere il tipo generico.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type definition from which the current type can be obtained.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta una definizione di tipo generico da cui è possibile ottenere il tipo generico.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object for which the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> property returns the current instance.</source>
          <target state="translated">Se si chiama il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> metodo su un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto per cui il <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> restituisce proprietà <ph id="ph4">`true`</ph>, <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> proprietà restituisce l'istanza corrente.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type is always a generic type definition.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> che rappresenta un tipo generico è sempre una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you used the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method to construct a generic type from a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents a generic type definition, using the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> method on the constructed type gets back the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the generic type definition.</source>
          <target state="translated">Se è stata utilizzata la <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> metodo per creare un tipo generico da un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto che rappresenta una definizione di tipo generico, utilizzando il <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> metodo sul tipo costruito consente di ottenere il <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto che rappresenta il tipo generico definizione.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>The current type is not generic.</source>
          <target state="translated">Il tipo corrente non è generico.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ciò significa che <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>The name of the interface.</source>
          <target state="translated">Nome dell'interfaccia.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated">Se <ph id="ph1">&lt;see langword="true" /&gt;</ph>, per la ricerca non verrà applicata la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated">Se <ph id="ph1">&lt;see langword="false" /&gt;</ph>, per la ricerca verrà applicata la distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</source>
          <target state="translated">Restituisce l'interfaccia implementata (direttamente o indirettamente) da questa classe, con il nome completo corrispondente al nome di interfaccia specificato.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the implemented interface.</source>
          <target state="translated">Restituisce un tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta l'interfaccia implementata.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns null if no interface matching name is found.</source>
          <target state="translated">Restituisce Null se non viene trovato alcun nome di interfaccia corrispondente.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the interface for which the mapping is to be retrieved.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> dell'interfaccia per il quale recuperare il mapping.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the requested interface.</source>
          <target state="translated">Restituisce un mapping di interfaccia per l'interfaccia richiesta.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns the requested interface mapping.</source>
          <target state="translated">Restituisce il mapping dell'interfaccia richiesto.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of all the interfaces implemented on this type and its base types.</source>
          <target state="translated">Restituisce una matrice di tutte le interfacce implementate nel tipo e nei relativi tipi di base.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the implemented interfaces.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresentano le interfacce implementate.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>If none are defined, an empty array is returned.</source>
          <target state="translated">Se non è stata definita alcuna interfaccia, viene restituita una matrice vuota.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The name of the member.</source>
          <target state="translated">Nome del membro.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The type of the member to return.</source>
          <target state="translated">Tipo del membro da restituire.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">È necessario che si tratti di un flag di bit da <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, come in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e così via.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public members declared or inherited by this type, as specified.</source>
          <target state="translated">Restituisce tutti i membri pubblici e non pubblici dichiarati o ereditati da questo tipo, come specificato.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public members are returned.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> che rappresentano i membri pubblici e non pubblici definiti sul tipo se <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> viene utilizzato; in caso contrario, vengono restituiti solo i membri pubblici.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, such as <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">È necessario che si tratti di un flag di bit da <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, come <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e così via.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns the members for the public and non-public members declared or inherited by this type.</source>
          <target state="translated">Restituisce i membri per i membri pubblici e non pubblici dichiarati o ereditati da questo tipo.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members declared or inherited by this type.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> che rappresentano i campi pubblici e non pubblici dichiarati o ereditati da questo tipo.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching members.</source>
          <target state="translated">In assenza di membri corrispondenti, viene restituita una matrice vuota.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The constructed generic type whose method is returned.</source>
          <target state="translated">Tipo generico costruito di cui viene restituito il metodo.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which method of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">Metodo sulla definizione di tipo generico di <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, che specifica il metodo di <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> da restituire.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</source>
          <target state="translated">Restituisce il metodo del tipo generico costruito specificato che corrisponde al metodo specificato della definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents the method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="method" /&gt;</ph>, which specifies a method belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> che rappresenta il metodo di <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corrispondente a <ph id="ph3">&lt;paramref name="method" /&gt;</ph>, che specifica un metodo appartenente alla definizione di tipo generico di <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a method of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> metodo fornisce un modo per ottenere un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta un metodo di un tipo generico costruito la cui definizione di tipo generico è rappresentato da un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents a method <ph id="ph6">`T M()`</ph> in C# syntax (<ph id="ph7">`Function M() As T`</ph> in Visual Basic, <ph id="ph8">`T M()`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">Si supponga, ad esempio, un <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto che rappresenta il tipo <ph id="ph2">`G&lt;T&gt;`</ph> nella sintassi di c# (<ph id="ph3">`G(Of T)`</ph> in Visual Basic <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) e un <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> oggetto che rappresenta un metodo <ph id="ph6">`T M()`</ph> nella sintassi di c# (<ph id="ph7">`Function M() As T`</ph>in Visual Basic <ph id="ph8">`T M()`</ph> in C++) definito da <ph id="ph9">`G&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls method <ph id="ph4">`M`</ph> on that instance.</source>
          <target state="translated">Si supponga che <ph id="ph1">`G&lt;T&gt;`</ph> ha un metodo generico con il parametro di tipo <ph id="ph2">`U`</ph> che crea un'istanza del tipo costruito <ph id="ph3">`G&lt;U&gt;`</ph> e chiama metodo <ph id="ph4">`M`</ph> su quell'istanza.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph2">`M`</ph> on the constructed type — in other words, that returns type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">Per creare la chiamata di funzione, è necessario un <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> oggetto che rappresenta <ph id="ph2">`M`</ph> sul tipo costruito, in altre parole, che restituisce tipo <ph id="ph3">`U`</ph> anziché tipo <ph id="ph4">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">A tale scopo, chiamare innanzitutto il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> metodo il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> dell'oggetto, che specifica il <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> oggetto che rappresenta <ph id="ph4">`U`</ph> come argomento di tipo.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents <ph id="ph5">`T M()`</ph> as parameter <ph id="ph6">`method`</ph>.</source>
          <target state="translated">Chiamare quindi il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> metodo con il valore restituito del <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> metodo come parametro <ph id="ph3">`type`</ph> e <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> oggetto che rappresenta <ph id="ph5">`T M()`</ph> come parametro <ph id="ph6">`method`</ph>.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">Il valore restituito è il <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> è necessario creare la chiamata di funzione.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code example demonstrates a scenario similar to this.</source>
          <target state="translated">L'esempio di codice viene illustrato uno scenario simile al seguente.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">Esempio di codice seguente contiene il codice sorgente per una classe generica denominata <ph id="ph1">`Sample`</ph> che include un parametro di tipo denominato <ph id="ph2">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">La classe dispone di un campo denominato <ph id="ph1">`Field`</ph>, di tipo <ph id="ph2">`T`</ph>e un metodo generico denominato <ph id="ph3">`GM`</ph> con un parametro di tipo denominato <ph id="ph4">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">Metodo <ph id="ph1">`GM`</ph> crea un'istanza di <ph id="ph2">`Sample`</ph>, sostituendo il parametro di tipo <ph id="ph3">`U`</ph> per il parametro di tipo <ph id="ph4">`Sample`</ph>e archivia il relativo parametro di input in <ph id="ph5">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">Questo codice sorgente viene compilato ma non è utilizzato; è possibile visualizzare con il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> e confrontarla con il codice generato dalla classe <ph id="ph1">`Example`</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">Il codice nella classe <ph id="ph1">`Example`</ph> viene illustrato come utilizzare il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> metodo per generare il codice generico.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated">Il <ph id="ph1">`Main`</ph> metodo della classe <ph id="ph2">`Example`</ph> crea un assembly dinamico che contiene una classe denominata <ph id="ph3">`Sample`</ph> e utilizza il <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> metodo per renderlo generico aggiungendo un parametro di tipo denominato <ph id="ph5">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">Un costruttore predefinito e un campo denominato <ph id="ph1">`Field`</ph>, di tipo <ph id="ph2">`T`</ph>, vengono aggiunti alla classe <ph id="ph3">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Un metodo <ph id="ph1">`GM`</ph> viene aggiunto e trasformato in un metodo generico utilizzando il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">Il parametro di tipo <ph id="ph1">`GM`</ph> denominato <ph id="ph2">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Dopo aver definito il parametro di tipo, la firma di <ph id="ph1">`GM`</ph> viene aggiunto tramite il <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">Vi è alcun tipo restituito e non necessari o modificatori personalizzati, pertanto tutti i parametri di questo metodo sono <ph id="ph1">`null`</ph> tranne <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> imposta il tipo di parametro solo del metodo per <ph id="ph4">`U`</ph>, il parametro di tipo generico del metodo.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">Il corpo del metodo crea un'istanza del tipo costruito <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assegna il parametro del metodo per <ph id="ph3">`Field`</ph>e quindi stampato il valore di <ph id="ph4">`Field`</ph>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">Viene definito un tipo fittizio per contenere il metodo del punto di ingresso <ph id="ph1">`Main`</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">Nel corpo di <ph id="ph1">`Main`</ph>, statica <ph id="ph2">`GM`</ph> metodo viene richiamato nel tipo generico costruito <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), con il tipo <ph id="ph5">&lt;xref:System.String&gt;</ph> sostituito con <ph id="ph6">`U`</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the static <ph id="ph3">`GM`</ph> method of the constructed generic type <ph id="ph4">`Sample&lt;U&gt;`</ph>, and the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method is then used to create a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can emitted in a method call.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> metodo viene utilizzato per creare un <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> per statica <ph id="ph3">`GM`</ph> metodo del tipo generico costruito <ph id="ph4">`Sample&lt;U&gt;`</ph>e <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> metodo viene quindi utilizzato per creare un <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> che possono emessi in una chiamata al metodo.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">Quando si esegue l'esempio di codice, come TypeBuilderGetFieldExample.exe salva l'assembly generato.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">È possibile eseguire TypeBuilderGetFieldExample.exe ed è possibile utilizzare il <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> per confrontare il codice generato con il codice per la <ph id="ph1">`Sample`</ph> classe che viene compilato nell'esempio di codice.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is a generic method that is not a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> è un metodo generico che non è una definizione di metodo generico.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> non rappresenta un tipo generico.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> non è di tipo <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated">Il tipo dichiarante di <ph id="ph1">&lt;paramref name="method" /&gt;</ph> non è una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated">Il tipo dichiarante di <ph id="ph1">&lt;paramref name="method" /&gt;</ph> non è la definizione di tipo generico di <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">È necessario che si tratti di un flag di bit da <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, come in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e così via.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public methods declared or inherited by this type, as specified.</source>
          <target state="translated">Restituisce tutti i metodi pubblici e non pubblici dichiarati o ereditati da questo tipo, come specificato.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing the public and non-public methods defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public methods are returned.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> che rappresentano i metodi pubblici e non pubblici definiti sul tipo se il parametro <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> viene utilizzato; in caso contrario, vengono restituiti solo i metodi pubblici.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the name of the nested type to get.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> contenente il nome del tipo annidato da ottenere.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Maschera di bit costituita da uno o più <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> che consente di specificare le modalità di esecuzione della ricerca.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to conduct a case-sensitive search for public methods.</source>
          <target state="translated">Zero, per eseguire una ricerca di metodi pubblici con distinzione tra maiuscole e minuscole.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared by this type.</source>
          <target state="translated">Restituisce i tipi annidati pubblici e non pubblici dichiarati da questo tipo.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo annidato corrispondente ai requisiti specificati, se è stato trovato. In caso contrario, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">Se il tipo è completo, ad esempio, se <ph id="ph1">`CreateType`</ph> è stato chiamato su questo tipo, ma sono presenti tipi nidificati che non sono completi, quindi <ph id="ph2">`GetNestedTypes`</ph> restituirà solo i tipi annidati per cui <ph id="ph3">`CreateType`</ph> è stato chiamato.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">È necessario che si tratti di un flag di bit da <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, come in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e così via.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared or inherited by this type.</source>
          <target state="translated">Restituisce i tipi annidati pubblici e non pubblici dichiarati o ereditati da questo tipo.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Matrice di oggetti <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresentano tutti i tipi annidati all'interno del <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> corrente, che corrisponde ai vincoli di associazione specificati.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no types are nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the nested types match the binding constraints.</source>
          <target state="translated">Matrice vuota di tipo <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, se non è presente alcun tipo annidato all'interno del <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> corrente oppure se nessuno dei tipi annidati corrisponde ai vincoli di associazione.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">Se il tipo è completo, ad esempio, se <ph id="ph1">`CreateType`</ph> è stato chiamato su questo tipo, ma sono presenti tipi nidificati che non sono completi, quindi <ph id="ph2">`GetNestedTypes`</ph> restituirà solo i tipi annidati per cui <ph id="ph3">`CreateType`</ph> è stato chiamato.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This invocation attribute.</source>
          <target state="translated">Attributo di chiamata.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">È necessario che si tratti di un flag di bit richiamato dall'oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, ad esempio <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> e così via.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public properties declared or inherited by this type, as specified.</source>
          <target state="translated">Restituisce tutte le proprietà pubbliche e non pubbliche dichiarate o ereditate da questo tipo, come specificato.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> objects representing the public and non-public properties defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public properties are returned.</source>
          <target state="translated">Restituisce una matrice di oggetti <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> che rappresentano le proprietà pubbliche e non pubbliche definite su questo tipo se <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> viene utilizzato; in caso contrario, vengono restituite solo le proprietà pubbliche.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">Questo metodo non viene implementato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type.</source>
          <target state="translated">Recupera il GUID di questo tipo.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type</source>
          <target state="translated">Recupera il GUID di questo tipo</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Questo metodo non è attualmente supportato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The name of the member to invoke.</source>
          <target state="translated">Nome del membro da richiamare.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This can be a constructor, method, property, or field.</source>
          <target state="translated">Può essere un costruttore, un metodo, una proprietà o un campo.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A suitable invocation attribute must be specified.</source>
          <target state="translated">È necessario specificare un attributo di chiamata appropriato.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</source>
          <target state="translated">Si noti che è possibile richiamare il membro predefinito di una classe passando una stringa vuota come nome del membro.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The invocation attribute.</source>
          <target state="translated">Attributo di chiamata.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This must be a bit flag from <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">il quale deve essere un flag di bit da <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> tramite reflection.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Se il gestore di associazione è <ph id="ph1">&lt;see langword="null" /&gt;</ph>, verrà utilizzato il gestore di associazione predefinito.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">Vedere <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Oggetto su cui richiamare il membro specificato.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the member is static, this parameter is ignored.</source>
          <target state="translated">Se il membro è statico, il parametro viene ignorato.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An argument list.</source>
          <target state="translated">Elenco di argomenti.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</source>
          <target state="translated">Matrice di oggetti che contiene il numero, l'ordine e il tipo dei parametri del membro da richiamare.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If there are no parameters this should be null.</source>
          <target state="translated">In assenza di parametri, deve essere Null.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of the same length as <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> with elements that represent the attributes associated with the arguments of the member to be invoked.</source>
          <target state="translated">Matrice della stessa lunghezza di <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> con elementi che rappresentano gli attributi associati agli argomenti del membro da richiamare.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter has attributes associated with it in the metadata.</source>
          <target state="translated">A un parametro sono associati attributi nei metadati.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>They are used by various interoperability services.</source>
          <target state="translated">Vengono usati da vari servizi di interoperabilità.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See the metadata specs for more details.</source>
          <target state="translated">Per informazioni dettagliate, vedere le specifiche dei metadati. </target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Istanza di <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> usata per regolare la coercizione dei tipi.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If this is null, the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se è null, verrà utilizzato l'oggetto <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> per il thread corrente.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">Ciò è necessario, ad esempio, per convertire una stringa che rappresenta 1000 in un valore double, perché 1000 è rappresentato in modo diverso nelle diverse impostazioni cultura.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept> array gets the value in the corresponding element in the <bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Tutti i parametri nella matrice <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept> ottengono il valore nell'elemento corrispondente della matrice <bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> is greater than the length of <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept>, the remaining argument values are passed in order.</source>
          <target state="translated">Se la lunghezza di <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> è superiore a quella di <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept>, i valori degli argomenti rimanenti vengono passati in ordine.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invokes the specified member.</source>
          <target state="translated">Richiama il membro specificato.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</source>
          <target state="translated">Il metodo da richiamare deve essere accessibile e fornire massima corrispondenza con l'elenco di argomenti specificato, in conformità ai vincoli del binder e degli attributi di chiamata specificati.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Returns the return value of the invoked member.</source>
          <target state="translated">Restituisce il valore restituito del membro richiamato.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Se il numero di parametri della dichiarazione del metodo è uguale al numero di argomenti nell'elenco di argomenti specificato e il tipo di ciascun argomento può essere convertito dal gestore di associazione per il tipo del parametro, verrà richiamato un metodo.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">Lo strumento di associazione troverà tutti i metodi di corrispondenza.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</source>
          <target state="translated">Questi metodi vengono individuati in base al tipo di associazione richiesta (BindingFlags. InvokeMethod, BindingFlags. GetProperties e così via.).</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Il set di metodi verrà filtrato per il nome, numero di argomenti e un set di modificatori di ricerca definiti nel gestore di associazione.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it will be invoked.</source>
          <target state="translated">Dopo aver selezionato il metodo, verrà richiamato.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">A questo punto viene controllato l'accesso facilitato.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">La ricerca è possibile controllare quale set di metodi vengono ricercati in base all'attributo di accessibilità associato al metodo.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`IBinder.BindToMethod`</ph> method is responsible for selecting the method to be invoked.</source>
          <target state="translated">Il <ph id="ph1">`IBinder.BindToMethod`</ph> metodo è responsabile della selezione del metodo da richiamare.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Il binder predefinito consente di selezionare la corrispondenza più specifica.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Le restrizioni di accesso vengono ignorate per il codice completamente attendibile.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</source>
          <target state="translated">Vale a dire, proprietà, metodi, campi e costruttori privati accessibili e richiamato tramite Reflection, ogni volta che il codice è completamente attendibile.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported.</source>
          <target state="translated">Questo metodo non è attualmente supportato.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">È possibile recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Questo metodo non è attualmente supportato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Determines whether a specified type can be assigned to this object.</source>
          <target state="translated">Determina se un tipo specificato può essere assegnato a questo oggetto.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>The object to test.</source>
          <target state="translated">Oggetto da testare.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object can be assigned to this object.</source>
          <target state="translated">Ottiene un valore che indica se a questo oggetto è possibile assegnare un oggetto <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> specificato.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> can be assigned to this object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> può essere assegnato a questo oggetto; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>The object to test.</source>
          <target state="translated">Oggetto da testare.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be assigned to this object.</source>
          <target state="translated">Ottiene un valore che indica se è possibile assegnare un oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> specificato a questo oggetto.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="c" /&gt;</ph> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <ph id="ph3">&lt;paramref name="c" /&gt;</ph>, or if the current type is an interface that <ph id="ph4">&lt;paramref name="c" /&gt;</ph> supports.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il parametro e il tipo corrente <ph id="ph2">&lt;paramref name="c" /&gt;</ph> rappresentano lo stesso tipo o se il tipo corrente è nella gerarchia di ereditarietà di <ph id="ph3">&lt;paramref name="c" /&gt;</ph>, oppure se il tipo corrente è un'interfaccia supportata da <ph id="ph4">&lt;paramref name="c" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are valid, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> se non viene soddisfatta nessuna di queste condizioni oppure se <ph id="ph2">&lt;paramref name="c" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">Ottiene un valore che indica se l'oggetto rappresenta un tipo generico costruito.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se questo oggetto rappresenta una definizione di tipo generico; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Returns a value that indicates whether the current dynamic type has been created.</source>
          <target state="translated">Restituisce un valore che indica se è stato creato il tipo dinamico corrente.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has been called; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il metodo <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> è stato chiamato; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called, the type represented by the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object is complete.</source>
          <target state="translated">Dopo il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo è stato chiamato, il tipo rappresentato dal <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto è stato completato.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</source>
          <target state="translated">Le eccezioni generate in ulteriori tentativi di aggiungere membri o modificare altre caratteristiche del tipo.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">Tipo di attributo da cercare.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">Vengono restituiti solo gli attributi assegnabili a questo tipo.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">Specifica se trovare gli attributi cercandoli nella catena di ereditarietà del membro.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Determines whether a custom attribute is applied to the current type.</source>
          <target state="translated">Determina se un attributo personalizzato viene applicato al tipo corrente.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>, or an attribute derived from <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph>, is defined on this type; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se una o più istanze di <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> o di un attributo derivato da <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph> sono definite su questo tipo. In caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not supported for incomplete generic type parameters.</source>
          <target state="translated">Questo metodo non è supportato per i parametri di tipo generico incompleti.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">Questo metodo non è attualmente supportato per i tipi incompleti.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> e chiamare <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> sul <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> restituito.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not defined.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> non è definito.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>Gets a value indicating whether the current type is a generic type parameter.</source>
          <target state="translated">Ottiene un valore che indica se il tipo corrente è un parametro di tipo generico.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> corrente rappresenta un parametro di tipo generico; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">Quando si genera codice, un parametro di tipo generico è rappresentato da un <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> oggetto anziché da un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">Ottiene un valore che indica se il tipo corrente è un tipo generico.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object is generic; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il tipo rappresentato dall'oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> corrente è generico; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto rappresenta una definizione di tipo generico, se il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> metodo è stato utilizzato per fornire parametri di tipo generico.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">Un'istanza di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> classe generica è sempre una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per ulteriori informazioni sui tipi generici nella reflection e un elenco di condizioni invarianti per i termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> represents a generic type definition from which other generic types can be constructed.</source>
          <target state="translated">Ottiene un valore che indica se la classe <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> corrente rappresenta una definizione di tipo generico, da cui è possibile costruire altri tipi generici.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se questo oggetto <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> rappresenta una definizione di tipo generico; in caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> oggetto rappresenta una definizione di tipo generico, se il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> metodo è stato utilizzato per fornire parametri di tipo generico.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">Un'istanza di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> classe generica è sempre una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be used to build generic type definitions, but not constructed generic types.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> può essere usato per creare definizioni di tipo generico, ma non i tipi generici costruiti.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>To get a constructed generic type, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">Per ottenere un tipo generico costruito, chiamano il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> metodo su un <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> che rappresenta una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Per ulteriori informazioni sui tipi generici nella reflection e un elenco di condizioni invarianti per i termini utilizzati nella reflection generica, vedere il <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> proprietà.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</source>
          <target state="translated">Ottiene un valore che indica se il tipo corrente è critico per la sicurezza o critico per la sicurezza e richiamabile da codice trasparente e può pertanto eseguire operazioni critiche.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il tipo corrente è critico per la sicurezza o security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se è trasparente.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> riportano il livello di trasparenza del tipo, come determinato da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Livello di sicurezza</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Safe-critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">Il runtime avvia la valutazione di livelli di trasparenza all'assembly.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Ad esempio, se l'assembly dinamico è critico per la sicurezza, le annotazioni sui tipi vengono ignorate e tutti i tipi sono critici per la sicurezza.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">Per impostazione predefinita, un assembly dinamico eredita la trasparenza dell'assembly che lo genera.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">È possibile eseguire l'override di questa impostazione predefinita tramite il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> overload del metodo e specificando gli attributi di sicurezza.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">Non è possibile elevare i livelli di sicurezza in questo modo; ovvero, il codice trasparente non è possibile creare codice SecurityCritical o sicurezza SecuritySafeCritical.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Quando viene creato l'assembly dinamico o non hanno effetto fino a quando l'assembly è stato salvato su disco e ricaricato, è necessario specificare gli attributi.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Ereditarietà predefinita è limitato alla valutazione del runtime di trasparenza.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">Attributi non vengono applicati all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Se si desidera aggiungere gli attributi di sicurezza, è necessario applicarli manualmente.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla reflection emit e la trasparenza, vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Per informazioni su trasparenza, vedere <bpt id="p1">[</bpt>modifiche della sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Il tipo dinamico corrente non è stato creato tramite la chiamata del metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Ottiene un valore che indica se il tipo corrente è critico per la sicurezza, vale a dire se può eseguire operazioni critiche e se è possibile accedervi tramite codice trasparente.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il tipo corrente è security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se è critico per la sicurezza o trasparente.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> riportano il livello di trasparenza del tipo, come determinato da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Livello di sicurezza</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Safe-critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">Il runtime avvia la valutazione di livelli di trasparenza all'assembly.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Ad esempio, se l'assembly dinamico è critico per la sicurezza, le annotazioni sui tipi vengono ignorate e tutti i tipi sono critici per la sicurezza.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">Per impostazione predefinita, un assembly dinamico eredita la trasparenza dell'assembly che lo genera.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">È possibile eseguire l'override di questa impostazione predefinita tramite il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> overload del metodo e specificando gli attributi di sicurezza.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">Non è possibile elevare i livelli di sicurezza in questo modo; ovvero, il codice trasparente non è possibile creare codice SecurityCritical o sicurezza SecuritySafeCritical.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Quando viene creato l'assembly dinamico o non hanno effetto fino a quando l'assembly è stato salvato su disco e ricaricato, è necessario specificare gli attributi.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Ereditarietà predefinita è limitato alla valutazione del runtime di trasparenza.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">Attributi non vengono applicati all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Se si desidera aggiungere gli attributi di sicurezza, è necessario applicarli manualmente.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla reflection emit e la trasparenza, vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Per informazioni su trasparenza, vedere <bpt id="p1">[</bpt>modifiche della sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Il tipo dinamico corrente non è stato creato tramite la chiamata del metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</source>
          <target state="translated">Ottiene un valore che indica se il tipo corrente è trasparente e pertanto non può eseguire operazioni critiche.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il tipo è SecurityTransparent. In caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> riportano il livello di trasparenza del tipo, come determinato da common language runtime (CLR).</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Security level</source>
          <target state="translated">Livello di sicurezza</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">Critico</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Safe-critical</source>
          <target state="translated">Critico per la sicurezza</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">Trasparente</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">Il runtime avvia la valutazione di livelli di trasparenza all'assembly.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">Ad esempio, se l'assembly dinamico è critico per la sicurezza, le annotazioni sui tipi vengono ignorate e tutti i tipi sono critici per la sicurezza.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">Per impostazione predefinita, un assembly dinamico eredita la trasparenza dell'assembly che lo genera.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">È possibile eseguire l'override di questa impostazione predefinita tramite il <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, o <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> overload del metodo e specificando gli attributi di sicurezza.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">Non è possibile elevare i livelli di sicurezza in questo modo; ovvero, il codice trasparente non è possibile creare codice SecurityCritical o sicurezza SecuritySafeCritical.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">Quando viene creato l'assembly dinamico o non hanno effetto fino a quando l'assembly è stato salvato su disco e ricaricato, è necessario specificare gli attributi.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">Ereditarietà predefinita è limitato alla valutazione del runtime di trasparenza.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">Attributi non vengono applicati all'assembly dinamico.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">Se si desidera aggiungere gli attributi di sicurezza, è necessario applicarli manualmente.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni sulla reflection emit e la trasparenza, vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Per informazioni su trasparenza, vedere <bpt id="p1">[</bpt>modifiche della sicurezza<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">Il tipo dinamico corrente non è stato creato tramite la chiamata del metodo <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that is to be checked.</source>
          <target state="translated">Classe <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> da verificare.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Determines whether this type is derived from a specified type.</source>
          <target state="translated">Determina se questo tipo è derivato da un tipo specificato.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if this type is the same as the type <ph id="ph2">&lt;paramref name="c" /&gt;</ph>, or is a subtype of type <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Restituisce <ph id="ph1">&lt;see langword="true" /&gt;</ph> se questo tipo è lo stesso del tipo <ph id="ph2">&lt;paramref name="c" /&gt;</ph> oppure è un sottotipo del tipo <ph id="ph3">&lt;paramref name="c" /&gt;</ph>. In caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta una matrice del tipo corrente.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta una matrice unidimensionale del tipo corrente con un limite inferiore a zero.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta un tipo di matrice unidimensionale, il cui tipo di elemento è di tipo corrente con limite inferiore zero.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> metodo fornisce un modo per generare un tipo di matrice con qualsiasi tipo di elemento, inclusi i tipi generici.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">L'esempio di codice seguente crea un modulo dinamico, un tipo astratto denominato <ph id="ph1">`Sample`</ph>e un metodo astratto denominato <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> accetta un <ph id="ph2">`ref`</ph> parametro (<ph id="ph3">`ByRef`</ph> in Visual Basic) di tipo <ph id="ph4">`Sample`</ph>, un puntatore al tipo <ph id="ph5">`Sample`</ph>e una matrice di tipo <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Restituisce una matrice bidimensionale di tipo <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">L'esempio di codice salva il modulo dinamico su disco, è possibile esaminarlo mediante la <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">Numero di dimensioni della matrice.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta una matrice del tipo corrente, con il numero specificato di dimensioni.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta una matrice unidimensionale del tipo corrente.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> metodo fornisce un modo per generare un tipo di matrice con qualsiasi tipo di elemento, inclusi i tipi generici.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">L'esempio di codice seguente crea un modulo dinamico, un tipo astratto denominato <ph id="ph1">`Sample`</ph>e un metodo astratto denominato <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> accetta un <ph id="ph2">`ref`</ph> parametro (<ph id="ph3">`ByRef`</ph> in Visual Basic) di tipo <ph id="ph4">`Sample`</ph>, un puntatore al tipo <ph id="ph5">`Sample`</ph>e una matrice di tipo <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Restituisce una matrice bidimensionale di tipo <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">L'esempio di codice salva il modulo dinamico su disco, è possibile esaminarlo mediante la <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is not a valid array dimension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> non è una dimensione di matrice valida.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo corrente quando viene passato come parametro <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo corrente quando viene passato come parametro <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> metodo fornisce un modo per generare <ph id="ph2">`ref`</ph> tipi (<ph id="ph3">`ByRef`</ph> in Visual Basic) per elenchi di parametri.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType&amp;`</ph>.</source>
          <target state="translated">Utilizzando la sintassi di Microsoft intermediate language (MSIL), se l'oggetto corrente <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> rappresenta <ph id="ph2">`MyType`</ph>, il tipo restituito da questo metodo sarà <ph id="ph3">`MyType&amp;`</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">L'esempio di codice seguente crea un modulo dinamico, un tipo astratto denominato <ph id="ph1">`Sample`</ph>e un metodo astratto denominato <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> accetta un <ph id="ph2">`ref`</ph> parametro (<ph id="ph3">`ByRef`</ph> in Visual Basic) di tipo <ph id="ph4">`Sample`</ph>, un puntatore al tipo <ph id="ph5">`Sample`</ph>e una matrice di tipo <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Restituisce una matrice bidimensionale di tipo <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">L'esempio di codice salva il modulo dinamico su disco, è possibile esaminarlo mediante la <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type definition.</source>
          <target state="translated">Matrice di tipi con cui sostituire i parametri di tipo della definizione di tipo generico corrente.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</source>
          <target state="translated">Sostituisce gli elementi di una matrice di tipi ai parametri di tipo della definizione di tipo generico corrente e restituisce il tipo costruito risultante.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo costruito ottenuto sostituendo i parametri di tipo del tipo generico corrente con gli elementi di <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Use this method when your emitted code requires a type constructed from the current generic type definition.</source>
          <target state="translated">Utilizzare questo metodo quando il codice generato richiede un tipo costruito dalla definizione di tipo generico corrente.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is not necessary to call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method before calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">Non è necessario chiamare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo prima di chiamare il <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> metodo su un <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> che rappresenta una definizione di tipo generico.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent the definition of a generic type, an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Se l'oggetto corrente <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> rappresenta la definizione di un tipo generico, un <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</source>
          <target state="translated">L'oggetto restituito da questo metodo funziona come segnaposto per un tipo generico costruito nel codice generato.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is an instance of a class derived from <ph id="ph1">&lt;xref:System.Type&gt;</ph> that has limited capabilities.</source>
          <target state="translated">È un'istanza di una classe derivata da <ph id="ph1">&lt;xref:System.Type&gt;</ph> che dispone di funzionalità limitate.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>In particular:</source>
          <target state="translated">In particolare:</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>To get methods, fields, and constructors for these constructed generic types, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> method overloads.</source>
          <target state="translated">Per ottenere i costruttori, campi e metodi per questi tipi generici costruiti, utilizzare il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Two instances that represent the same constructed type do not compare as equal.</source>
          <target state="translated">Due istanze che rappresentano lo stesso tipo costruito non vengono considerati uguali.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>For example, in the following code <ph id="ph1">`t1.Equals(t2)`</ph> returns <ph id="ph2">`false`</ph>:</source>
          <target state="translated">Ad esempio, nel codice seguente <ph id="ph1">`t1.Equals(t2)`</ph> restituisce <ph id="ph2">`false`</ph>:</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The current type does not represent the definition of a generic type.</source>
          <target state="translated">Il tipo corrente non rappresenta la definizione di un tipo generico.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ciò significa che <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> restituisce <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Qualsiasi elemento di <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph> property of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph> di qualsiasi elemento di <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph> property of the module of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph> del modulo di qualsiasi elemento di <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">Restituisce un oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo di un puntatore non gestito al tipo corrente.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> che rappresenta il tipo di un puntatore non gestito al tipo corrente.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> metodo fornisce un modo per generare i tipi di puntatore per elenchi di parametri.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType*`</ph>.</source>
          <target state="translated">Utilizzando la sintassi di Microsoft intermediate language (MSIL), se l'oggetto corrente <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> rappresenta <ph id="ph2">`MyType`</ph>, il tipo restituito da questo metodo sarà <ph id="ph3">`MyType*`</ph>.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">L'esempio di codice seguente crea un modulo dinamico, un tipo astratto denominato <ph id="ph1">`Sample`</ph>e un metodo astratto denominato <ph id="ph2">`TestMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> accetta un <ph id="ph2">`ref`</ph> parametro (<ph id="ph3">`ByRef`</ph> in Visual Basic) di tipo <ph id="ph4">`Sample`</ph>, un puntatore al tipo <ph id="ph5">`Sample`</ph>e una matrice di tipo <ph id="ph6">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">Restituisce una matrice bidimensionale di tipo <ph id="ph1">`Sample`</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">L'esempio di codice salva il modulo dinamico su disco, è possibile esaminarlo mediante la <bpt id="p1">[</bpt>Ildasm.exe (Disassembler IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">Recupera il modulo dinamico che contiene la definizione di tipo.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">Recupera il modulo dinamico che contiene la definizione di tipo.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the name of this type.</source>
          <target state="translated">Recupera il nome di questo tipo.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> name of this type.</source>
          <target state="translated">Recupera il nome dell'oggetto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> di questo tipo.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">Recupera lo spazio dei nomi in cui è definito <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">Recupera lo spazio dei nomi in cui è definito <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">Recupera la dimensione di compressione di questo tipo.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">Recupera la dimensione di compressione di questo tipo.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Returns the type that was used to obtain this type.</source>
          <target state="translated">Restituisce il tipo usato per ottenere questo tipo.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>The type that was used to obtain this type.</source>
          <target state="translated">Tipo usato per ottenere questo tipo.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">Imposta un attributo personalizzato.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to define the custom attribute.</source>
          <target state="translated">Un'istanza di una classe helper per definire l'attributo personalizzato.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Set a custom attribute using a custom attribute builder.</source>
          <target state="translated">Impostare un attributo personalizzato usando un generatore di attributi personalizzati.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo membro non è più necessario <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">Costruttore dell'attributo personalizzato.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">BLOB di byte che rappresenta gli attributi.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">Imposta un attributo personalizzato usando un BLOB di attributi personalizzati specificato.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For more information on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Per ulteriori informazioni sulla modalità di formattazione <ph id="ph1">`binaryAttribute`</ph>, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "partizione II: metadati definizione e la semantica".</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">La documentazione è disponibile online; vedere <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> (ECMA C# e standard di Common Language Infrastructure) in MSDN e <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> nel sito Web internazionale Ecma.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">A partire dal <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, questo membro non è più necessario <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> con il <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(Vedere <bpt id="p1">[</bpt>problemi di sicurezza nella Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) Per usare questa funzionalità, l'applicazione deve essere destinata a <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> o versione successiva.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> o <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> è <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The new base type.</source>
          <target state="translated">Nuovo tipo di base.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>Sets the base type of the type currently under construction.</source>
          <target state="translated">Imposta il tipo di base del tipo che si sta creando.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>If <ph id="ph1">`parent`</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> is used as the base type.</source>
          <target state="translated">Se <ph id="ph1">`parent`</ph> è <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> viene utilizzato come tipo di base.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In the .NET Framework versions 1.0 and 1.1, no exception is thrown if <ph id="ph1">`parent`</ph> is an interface type, but a <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> is thrown when the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">Nelle versioni di .NET Framework 1.0 e 1.1, viene generata alcuna eccezione se <ph id="ph1">`parent`</ph> è un tipo di interfaccia, ma un <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> viene generata quando il <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo viene chiamato.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> method does not check for most invalid parent types.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> metodo non verifica la maggior parte dei tipi di elemento padre non valido.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> type.</source>
          <target state="translated">Ad esempio, non rifiuta un tipo padre che include alcun costruttore predefinito, quando il tipo corrente ha un costruttore predefinito, non vengono rifiutati i tipi sealed e non viene rifiutato il <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In all these cases, exceptions are thrown by the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method.</source>
          <target state="translated">In questi casi, vengono generate eccezioni di <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the current instance represents an interface whose attributes do not include <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> e l'istanza corrente rappresenta un'interfaccia i cui attributi non includono <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Per il tipo dinamico corrente, la proprietà <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> è <ph id="ph2">&lt;see langword="true" /&gt;</ph> ma la proprietà <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> è <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> è un'interfaccia.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>This exception condition is new in the .NET Framework version 2.0.</source>
          <target state="translated">Questa condizione di eccezione è stata introdotta in .NET Framework versione 2.0.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves the total size of a type.</source>
          <target state="translated">Recupera la dimensione totale di un tipo.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves this type’s total size.</source>
          <target state="translated">Recupera la dimensione totale del tipo.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matrice di nomi passata di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Conteggio dei nomi di cui eseguire il mapping.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Contesto delle impostazioni locali in cui interpretare i nomi.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Informazioni sul tipo da restituire.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Identificatore delle impostazioni locali per le informazioni sul tipo.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica il membro.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Riservato per utilizzi futuri.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve essere IID_NULL.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flag che descrivono il contesto della chiamata.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Puntatore alla posizione in cui deve essere archiviato il risultato.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Puntatore a una struttura contenente informazioni sull'eccezione.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Indice del primo argomento che contiene un errore.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`IDispatch::Invoke`</ph>, vedere MSDN Library.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">L'accesso ad associazione tardiva usando l'interfaccia COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> non è supportato.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Returns the name of the type excluding the namespace.</source>
          <target state="translated">Restituisce il nome del tipo escluso lo spazio dei nomi.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>The name of the type excluding the namespace.</source>
          <target state="translated">Nome del tipo escluso lo spazio dei nomi.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">Non supportato in moduli dinamici.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">Recuperare il tipo utilizzando <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> e usare la reflection sul tipo recuperato.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">Non supportato in moduli dinamici.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the type token of this type.</source>
          <target state="translated">Restituisce il token di tipo per questo tipo.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> of this type.</source>
          <target state="translated">Restituisce il <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> di questo tipo.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">Il tipo è stato creato in precedenza usando <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type for this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">Restituisce il tipo di sistema sottostante per questo <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Read-only.</source>
          <target state="translated">Sola lettura.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type.</source>
          <target state="translated">Restituisce il tipo di sistema sottostante.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>This type is an enumeration, but there is no underlying system type.</source>
          <target state="translated">Questo tipo è un'enumerazione, ma non esiste alcun tipo di sistema sottostante.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
          <source>Represents that total size for the type is not specified.</source>
          <target state="translated">Indica che le dimensioni totali per il tipo non sono specificate.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>