<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b136d33672d3676473ad75c5fba7be56988a9a86" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="it-IT" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53229922" /></Metadata><TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeBuilder&#xA;Inherits TypeInfo&#xA;Implements _TypeBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeBuilder sealed : System::Reflection::TypeInfo, System::Runtime::InteropServices::_TypeBuilder" />
  <TypeSignature Language="F#" Value="type TypeBuilder = class&#xA;    inherit TypeInfo&#xA;    interface _TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="04e9c-101">Definisce e crea nuove istanze delle classi in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-101">Defines and creates new instances of classes during run time.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-102"><xref:System.Reflection.Emit.TypeBuilder> la classe radice viene utilizzata per controllare la creazione di classi dinamiche in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-102"><xref:System.Reflection.Emit.TypeBuilder> is the root class used to control the creation of dynamic classes in the runtime.</span></span> <span data-ttu-id="04e9c-103">Fornisce un set di routine che consentono di definire le classi, aggiungere i metodi e campi e creare la classe all'interno di un modulo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-103">It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</span></span> <span data-ttu-id="04e9c-104">Una nuova <xref:System.Reflection.Emit.TypeBuilder> può essere creato da un modulo dinamico chiamando il <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> metodo, che restituisce un <xref:System.Reflection.Emit.TypeBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-104">A new <xref:System.Reflection.Emit.TypeBuilder> can be created from a dynamic module by calling the <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> method, which returns a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="04e9c-105">La reflection emit offre le opzioni per la definizione dei tipi seguenti:</span><span class="sxs-lookup"><span data-stu-id="04e9c-105">Reflection emit provides the following options for defining types:</span></span>  
  
-   <span data-ttu-id="04e9c-106">Definire una classe o interfaccia con il nome specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-106">Define a class or interface with the given name.</span></span>  
  
-   <span data-ttu-id="04e9c-107">Definire una classe o interfaccia con il nome specificato e attributi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-107">Define a class or interface with the given name and attributes.</span></span>  
  
-   <span data-ttu-id="04e9c-108">Definire una classe con il nome specificato, attributi e classe di base.</span><span class="sxs-lookup"><span data-stu-id="04e9c-108">Define a class with the given name, attributes, and base class.</span></span>  
  
-   <span data-ttu-id="04e9c-109">Definire una classe con il nome specificato, attributi, classe di base e il set di interfacce che implementa la classe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-109">Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</span></span>  
  
-   <span data-ttu-id="04e9c-110">Definire una classe con il nome specificato, attributi, classe di base e la dimensione di compressione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-110">Define a class with the given name, attributes, base class, and packing size.</span></span>  
  
-   <span data-ttu-id="04e9c-111">Definire una classe con il nome specificato, attributi, classe di base e le dimensioni di classe nel suo complesso.</span><span class="sxs-lookup"><span data-stu-id="04e9c-111">Define a class with the given name, attributes, base class, and the class size as a whole.</span></span>  
  
-   <span data-ttu-id="04e9c-112">Definire una classe con il nome specificato, attributi, classe di base, la dimensione di compressione e la dimensione di classe nel suo complesso.</span><span class="sxs-lookup"><span data-stu-id="04e9c-112">Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</span></span>  
  
 <span data-ttu-id="04e9c-113">Per creare un tipo di matrice, il tipo di puntatore o byref tipo per un tipo incompleto che è rappresentato da un <xref:System.Reflection.Emit.TypeBuilder> oggetto, usare il <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> metodo <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> metodo, o <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> metodo, rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-113">To create an array type, pointer type, or byref type for an incomplete type that is represented by a <xref:System.Reflection.Emit.TypeBuilder> object, use the <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method, or <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method, respectively.</span></span>  
  
 <span data-ttu-id="04e9c-114">Prima che venga utilizzato un tipo, il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> necessario chiamare il metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-114">Before a type is used, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> method must be called.</span></span> <span data-ttu-id="04e9c-115">**CreateType** completa la creazione del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-115">**CreateType** completes the creation of the type.</span></span> <span data-ttu-id="04e9c-116">Dopo la chiamata a **CreateType**, il chiamante può creare istanze del tipo tramite il <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> metodo e richiamare i membri del tipo usando il <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-116">Following the call to **CreateType**, the caller can instantiate the type by using the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and invoke members of the type by using the <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="04e9c-117">È un errore per richiamare i metodi che modificano l'implementazione di un tipo dopo **CreateType** è stato chiamato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-117">It is an error to invoke methods that change the implementation of a type after **CreateType** has been called.</span></span> <span data-ttu-id="04e9c-118">Ad esempio, common language runtime genera un'eccezione se il chiamante tenta di aggiungere nuovi membri a un tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-118">For example, the common language runtime throws an exception if the caller tries to add new members to a type.</span></span>  
  
 <span data-ttu-id="04e9c-119">Un inizializzatore di classi viene creato usando il <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-119">A class initializer is created by using the <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="04e9c-120">**DefineTypeInitializer** restituisce un <xref:System.Reflection.Emit.ConstructorBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-120">**DefineTypeInitializer** returns a <xref:System.Reflection.Emit.ConstructorBuilder> object.</span></span>  
  
 <span data-ttu-id="04e9c-121">I tipi annidati definiti chiamando uno del <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-121">Nested types are defined by calling one of the <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> methods.</span></span>  
  
## <a name="attributes"></a><span data-ttu-id="04e9c-122">Attributi</span><span class="sxs-lookup"><span data-stu-id="04e9c-122">Attributes</span></span>  
 <span data-ttu-id="04e9c-123">Il <xref:System.Reflection.Emit.TypeBuilder> classe Usa il <xref:System.Reflection.TypeAttributes> enumerazione per specificare ulteriormente le caratteristiche del tipo da creare:</span><span class="sxs-lookup"><span data-stu-id="04e9c-123">The <xref:System.Reflection.Emit.TypeBuilder> class uses the <xref:System.Reflection.TypeAttributes> enumeration to further specify the characteristics of the type to be created:</span></span>  
  
-   <span data-ttu-id="04e9c-124">Le interfacce vengono specificate utilizzando il <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> e <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-124">Interfaces are specified using the <xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType> and <xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType> attributes.</span></span>  
  
-   <span data-ttu-id="04e9c-125">Classi concrete (ovvero non possono essere estesi) vengono specificate utilizzando il <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attributo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-125">Concrete classes (classes that cannot be extended) are specified using the <xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType> attribute.</span></span>  
  
-   <span data-ttu-id="04e9c-126">Diversi attributi determinano visibilità del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-126">Several attributes determine type visibility.</span></span> <span data-ttu-id="04e9c-127">Vedere la descrizione del <xref:System.Reflection.TypeAttributes> enumerazione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-127">See the description of the <xref:System.Reflection.TypeAttributes> enumeration.</span></span>  
  
-   <span data-ttu-id="04e9c-128">Se <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> viene specificato, il caricatore di classe viene disposto campi nell'ordine in cui vengono letti dai metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-128">If <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is specified, the class loader lays out fields in the order they are read from metadata.</span></span> <span data-ttu-id="04e9c-129">Il caricatore di classe prende in considerazione la dimensione di compressione specificato, ma ignora qualsiasi offset di campo specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-129">The class loader considers the specified packing size but ignores any specified field offsets.</span></span> <span data-ttu-id="04e9c-130">I metadati mantengono l'ordine in cui vengono generate le definizioni di campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-130">The metadata preserves the order in which the field definitions are emitted.</span></span> <span data-ttu-id="04e9c-131">Anche in un'unione nell'indice, i metadati non riordinerà le definizioni di campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-131">Even across a merge, the metadata will not reorder the field definitions.</span></span> <span data-ttu-id="04e9c-132">Il caricatore rispetteranno l'offset di campo specificato solo se <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> è specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-132">The loader will honor the specified field offsets only if <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is specified.</span></span>  
  
## <a name="known-issues"></a><span data-ttu-id="04e9c-133">Problemi noti</span><span class="sxs-lookup"><span data-stu-id="04e9c-133">Known Issues</span></span>  
  
-   <span data-ttu-id="04e9c-134">La reflection emit non verifica se tutti i metodi dichiarati nell'interfaccia è implementata da una classe non astratta che implementa un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-134">Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</span></span> <span data-ttu-id="04e9c-135">Tuttavia, se la classe non implementa tutti i metodi dichiarati in un'interfaccia, il runtime non carica la classe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-135">However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</span></span>  
  
-   <span data-ttu-id="04e9c-136">Sebbene <xref:System.Reflection.Emit.TypeBuilder> è derivato da <xref:System.Type>, alcuni dei metodi astratti definiti nel <xref:System.Type> classe non sono completamente implementate nel <xref:System.Reflection.Emit.TypeBuilder> classe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-136">Although <xref:System.Reflection.Emit.TypeBuilder> is derived from <xref:System.Type>, some of the abstract methods defined in the <xref:System.Type> class are not fully implemented in the <xref:System.Reflection.Emit.TypeBuilder> class.</span></span> <span data-ttu-id="04e9c-137">Chiamate a queste <xref:System.Reflection.Emit.TypeBuilder> metodi generano un <xref:System.NotSupportedException> eccezione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-137">Calls to these <xref:System.Reflection.Emit.TypeBuilder> methods throw a <xref:System.NotSupportedException> exception.</span></span> <span data-ttu-id="04e9c-138">La funzionalità desiderata può essere ottenuta tramite il recupero del tipo creato usando il <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-138">The desired functionality can be obtained by retrieving the created type using the <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and reflecting on the retrieved type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-139">In questa sezione sono riportati due esempi di codice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-139">This section contains two code examples.</span></span> <span data-ttu-id="04e9c-140">Nel primo esempio viene illustrato come creare un tipo dinamico con un campo, costruttore, proprietà e metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-140">The first example shows how to create a dynamic type with a field, constructor, property, and method.</span></span> <span data-ttu-id="04e9c-141">Nel secondo esempio compila un metodo in modo dinamico dall'input dell'utente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-141">The second example builds a method dynamically from user input.</span></span>  
  
 <span data-ttu-id="04e9c-142">**Esempio n. 1**</span><span class="sxs-lookup"><span data-stu-id="04e9c-142">**Example one**</span></span>  
  
 <span data-ttu-id="04e9c-143">Esempio di codice seguente viene illustrato come definire un assembly dinamico con un modulo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-143">The following code example shows how to define a dynamic assembly with one module.</span></span> <span data-ttu-id="04e9c-144">Il modulo nell'assembly di esempio contiene un solo tipo, `MyDynamicType`, che ha un campo privato, una proprietà che ottiene e imposta il campo privato, i costruttori che inizializzano il campo privato e un metodo che moltiplica un numero fornito dall'utente per il campo privato il valore e restituisce il risultato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-144">The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</span></span>  
  
 <span data-ttu-id="04e9c-145">Il <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> campo è specificato al momento della creazione dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="04e9c-145">The <xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType> field is specified when the assembly is created.</span></span> <span data-ttu-id="04e9c-146">Il codice dell'assembly viene utilizzato immediatamente e l'assembly viene anche salvato su disco in modo che possono essere esaminati con [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) o usato in un altro programma.</span><span class="sxs-lookup"><span data-stu-id="04e9c-146">The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) or used in another program.</span></span>  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 <span data-ttu-id="04e9c-147">**Esempio 2**</span><span class="sxs-lookup"><span data-stu-id="04e9c-147">**Example two**</span></span>  
  
 <span data-ttu-id="04e9c-148">Esempio di codice seguente viene illustrato come compilare un tipo dinamico usando `TypeBuilder`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-148">The following code sample demonstrates how to build a dynamic type by using `TypeBuilder`.</span></span>  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07d5f01a-7b5b-40ea-9b15-f21561098fe4"><span data-ttu-id="04e9c-149">Procedura: definire un tipo generico tramite reflection emit</span><span class="sxs-lookup"><span data-stu-id="04e9c-149">How to: Define a Generic Type with Reflection Emit</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TypeBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddDeclarativeSecurity (action As SecurityAction, pset As PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddDeclarativeSecurity(System::Security::Permissions::SecurityAction action, System::Security::PermissionSet ^ pset);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurity : System.Security.Permissions.SecurityAction * System.Security.PermissionSet -&gt; unit" Usage="typeBuilder.AddDeclarativeSecurity (action, pset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="04e9c-150">Azione di sicurezza da eseguire, ad esempio Demand, Assert e così via.</span><span class="sxs-lookup"><span data-stu-id="04e9c-150">The security action to be taken such as Demand, Assert, and so on.</span></span></param>
        <param name="pset"><span data-ttu-id="04e9c-151">Set di autorizzazioni a cui viene applicata l'azione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-151">The set of permissions the action applies to.</span></span></param>
        <summary><span data-ttu-id="04e9c-152">Aggiunge sicurezza dichiarativa a questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-152">Adds declarative security to this type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-153">`AddDeclarativeSecurity` può essere chiamato più volte specificando un'azione di sicurezza (ad esempio Demand, Assert o Deny) e un set di autorizzazioni valide per l'azione a ogni chiamata.</span><span class="sxs-lookup"><span data-stu-id="04e9c-153">`AddDeclarativeSecurity` may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-154">Nelle versioni 1.0, 1.1 e 2.0 di .NET Framework, gli attributi di sicurezza dichiarativa applicati a un tipo con questo metodo vengono archiviati nel vecchio formato XML dei metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-154">In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-155">Nell'esempio seguente viene illustrato l'utilizzo dei `AddDeclarativeSecurity` metodo per aggiungere una richiesta di sicurezza per <xref:System.Security.Permissions.SecurityPermission> con il <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag per un tipo dinamico denominato `MyDynamicClass`, in un assembly denominato EmittedExample.</span><span class="sxs-lookup"><span data-stu-id="04e9c-155">The following example demonstrates the use of the `AddDeclarativeSecurity` method to add a security demand for <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag to a dynamic type named `MyDynamicClass`, in an assembly named EmittedExample.dll.</span></span> <span data-ttu-id="04e9c-156">Nell'esempio viene non generato alcun output di console. Dopo l'esecuzione, è possibile usare [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) esaminare EmittedExample.</span><span class="sxs-lookup"><span data-stu-id="04e9c-156">The example produces no console output; after you run it, you can use [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine EmittedExample.dll.</span></span> <span data-ttu-id="04e9c-157">Nelle `MyDynamicClass`, aprire il `.class public auto ansi` istruzione per visualizzare l'autorizzazione dichiarativa.</span><span class="sxs-lookup"><span data-stu-id="04e9c-157">In `MyDynamicClass`, open the `.class public auto ansi` statement to see the declarative permission.</span></span>  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="04e9c-158"><paramref name="action" /> non è valido (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, e <see langword="RequestRefuse" /> non sono validi).</span><span class="sxs-lookup"><span data-stu-id="04e9c-158">The <paramref name="action" /> is invalid (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, and <see langword="RequestRefuse" /> are invalid).</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-159">Il tipo contenitore è stato creato usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-159">The containing type has been created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-160">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-160">-or-</span></span> 
<span data-ttu-id="04e9c-161">Il set di autorizzazioni <paramref name="pset" /> contiene un'azione che è stata aggiunta in precedenza da <see langword="AddDeclarativeSecurity" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-161">The permission set <paramref name="pset" /> contains an action that was added earlier by <see langword="AddDeclarativeSecurity" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-162"><paramref name="pset" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-162"><paramref name="pset" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInterfaceImplementation (interfaceType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInterfaceImplementation(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="member this.AddInterfaceImplementation : Type -&gt; unit" Usage="typeBuilder.AddInterfaceImplementation interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="04e9c-163">Interfaccia implementata da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-163">The interface that this type implements.</span></span></param>
        <summary><span data-ttu-id="04e9c-164">Aggiunge un'interfaccia implementata da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-164">Adds an interface that this type implements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04e9c-165">Esempio di codice seguente illustra l'implementazione di un'interfaccia su un tipo in modo dinamico creato con `AddInterfaceImplementation`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-165">The following code sample demonstrates the implementation of an interface on a dynamically created type using `AddInterfaceImplementation`.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-166"><paramref name="interfaceType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-166"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-167">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-167">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-168">Recupera l'assembly dinamico che contiene la definizione di tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-168">Retrieves the dynamic assembly that contains this type definition.</span></span></summary>
        <value><span data-ttu-id="04e9c-169">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-169">Read-only.</span></span> <span data-ttu-id="04e9c-170">Recupera l'assembly dinamico che contiene la definizione di tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-170">Retrieves the dynamic assembly that contains this type definition.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-171">Restituisce il nome completo di questo tipo qualificato dal nome visualizzato dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="04e9c-171">Returns the full name of this type qualified by the display name of the assembly.</span></span></summary>
        <value><span data-ttu-id="04e9c-172">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-172">Read-only.</span></span> <span data-ttu-id="04e9c-173">Nome completo di questo tipo qualificato dal nome visualizzato dell'assembly.</span><span class="sxs-lookup"><span data-stu-id="04e9c-173">The full name of this type qualified by the display name of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-174">Il formato della stringa restituita è la concatenazione del nome completo del tipo (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) e il nome visualizzato dell'assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separati da una virgola e uno spazio.</span><span class="sxs-lookup"><span data-stu-id="04e9c-174">The format of the returned string is the concatenation of the full name of the type (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) and the display name of the assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separated by a comma and a space.</span></span>  
  
 <span data-ttu-id="04e9c-175">Vedere <xref:System.Reflection.AssemblyName> per una descrizione del formato del nome visualizzato di un assembly.</span><span class="sxs-lookup"><span data-stu-id="04e9c-175">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="04e9c-176">Informazioni sulla versione</span><span class="sxs-lookup"><span data-stu-id="04e9c-176">Version Information</span></span>  
 <span data-ttu-id="04e9c-177">Nelle versioni 1.0 e 1.1 di .NET Framework, il valore di questa proprietà non include la lingua o chiave pubblica.</span><span class="sxs-lookup"><span data-stu-id="04e9c-177">In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-178">Recupera il tipo di base del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-178">Retrieves the base type of this type.</span></span></summary>
        <value><span data-ttu-id="04e9c-179">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-179">Read-only.</span></span> <span data-ttu-id="04e9c-180">Recupera il tipo di base del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-180">Retrieves the base type of this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ CreateType();" />
      <MemberSignature Language="F#" Value="member this.CreateType : unit -&gt; Type" Usage="typeBuilder.CreateType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-181">Crea un oggetto <see cref="T:System.Type" /> per la classe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-181">Creates a <see cref="T:System.Type" /> object for the class.</span></span> <span data-ttu-id="04e9c-182">Dopo aver definito i campi e metodi della classe <see langword="CreateType" /> viene chiamato per caricare il relativo oggetto <see langword="Type" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-182">After defining fields and methods on the class, <see langword="CreateType" /> is called in order to load its <see langword="Type" /> object.</span></span></summary>
        <returns><span data-ttu-id="04e9c-183">Restituisce il nuovo oggetto <see cref="T:System.Type" /> per questa classe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-183">Returns the new <see cref="T:System.Type" /> object for this class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-184">Se questo tipo è un tipo annidato, il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo deve essere chiamato sul tipo di inclusione prima che venga chiamato sul tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-184">If this type is a nested type, the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method must be called on the enclosing type before it is called on the nested type.</span></span>  
  
 <span data-ttu-id="04e9c-185">Se il tipo corrente deriva da un tipo incompleto o implementa le interfacce incomplete, chiamare il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo nel tipo di elemento padre e i tipi di interfaccia prima di eseguire la chiamata per il tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-185">If the current type derives from an incomplete type or implements incomplete interfaces, call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the parent type and the interface types before calling it on the current type.</span></span>  
  
 <span data-ttu-id="04e9c-186">Se il tipo di inclusione contiene un campo che rappresenta un tipo di valore definito come un tipo annidato (ad esempio, un campo che rappresenta un'enumerazione definita come un tipo annidato), chiama il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo sul tipo di inclusione, verrà generato un <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-186">If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on the enclosing type will generate a <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="04e9c-187">Questo avviene perché il caricatore non è possibile determinare le dimensioni del tipo di inclusione fino a quando il tipo annidato è stato completato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-187">This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</span></span> <span data-ttu-id="04e9c-188">Il chiamante deve definire un gestore per il <xref:System.AppDomain.TypeResolve> eventi per completare la definizione del tipo annidato chiamando <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> nel <xref:System.Reflection.Emit.TypeBuilder> oggetto che rappresenta il tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-188">The caller should define a handler for the <xref:System.AppDomain.TypeResolve> event to complete the definition of the nested type by calling <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> on the <xref:System.Reflection.Emit.TypeBuilder> object that represents the nested type.</span></span> <span data-ttu-id="04e9c-189">L'esempio di codice in questo argomento viene illustrato come definire il gestore eventi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-189">The code example for this topic shows how to define such an event handler.</span></span>  
  
 <span data-ttu-id="04e9c-190">Viene creato un tipo in una sola volta, indipendentemente da come numero di volte il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-190">A type is created only once, no matter how many times the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span> <span data-ttu-id="04e9c-191">Tutte le chiamate restituiscono lo stesso <xref:System.Type> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-191">All calls return the same <xref:System.Type> object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-192">Esempio di codice seguente viene illustrato come definire un gestore eventi per il <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> evento, per poter chiamare il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo su un tipo annidato durante un <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> chiama sul tipo di inclusione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-192">The following code example shows how to define an event handler for the <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> event, in order to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method on a nested type during a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> call on the enclosing type.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-193">Il tipo di inclusione non è stato creato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-193">The enclosing type has not been created.</span></span>  
  
<span data-ttu-id="04e9c-194">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-194">-or-</span></span> 
<span data-ttu-id="04e9c-195">Questo tipo è non astratto e contiene un metodo astratto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-195">This type is non-abstract and contains an abstract method.</span></span>  
  
<span data-ttu-id="04e9c-196">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-196">-or-</span></span> 
<span data-ttu-id="04e9c-197">Questo tipo è una classe o un'interfaccia non astratta e ha un metodo senza corpo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-197">This type is not an abstract class or an interface and has a method without a method body.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-198">Il tipo contiene codice MSIL (Microsoft Intermediate Language) non valido.</span><span class="sxs-lookup"><span data-stu-id="04e9c-198">The type contains invalid Microsoft intermediate language (MSIL) code.</span></span>  
  
<span data-ttu-id="04e9c-199">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-199">-or-</span></span> 
<span data-ttu-id="04e9c-200">La destinazione branch viene specificata usando un offset di 1 byte, ma la destinazione si trova a una distanza maggiore di 127 byte dal branch.</span><span class="sxs-lookup"><span data-stu-id="04e9c-200">The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="04e9c-201">Non è possibile caricare il tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-201">The type cannot be loaded.</span></span> <span data-ttu-id="04e9c-202">Ad esempio, contiene un metodo <see langword="static" /> con la convenzione di chiamata <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-202">For example, it contains a <see langword="static" /> method that has the calling convention <see cref="F:System.Reflection.CallingConventions.HasThis" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateTypeInfo () As TypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::TypeInfo ^ CreateTypeInfo();" />
      <MemberSignature Language="F#" Value="member this.CreateTypeInfo : unit -&gt; System.Reflection.TypeInfo" Usage="typeBuilder.CreateTypeInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-203">Ottiene un oggetto <see cref="T:System.Reflection.TypeInfo" /> che rappresenta il tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-203">Gets a <see cref="T:System.Reflection.TypeInfo" /> object that represents this type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-204">Oggetto che rappresenta il tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-204">An object that represents this type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-205">Ottiene il metodo che ha dichiarato il parametro di tipo generico corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-205">Gets the method that declared the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="04e9c-206">Oggetto<see cref="T:System.Reflection.MethodBase" /> che rappresenta il metodo che ha dichiarato il tipo corrente, se il tipo corrente è un parametro di tipo generico; in caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-206">A <see cref="T:System.Reflection.MethodBase" /> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-207">Quando si crea il codice, un parametro di tipo generico è rappresentato da un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> oggetto anziché da un <xref:System.Reflection.Emit.TypeBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-207">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-208">Restituisce il tipo con cui è stato dichiarato questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-208">Returns the type that declared this type.</span></span></summary>
        <value><span data-ttu-id="04e9c-209">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-209">Read-only.</span></span> <span data-ttu-id="04e9c-210">Tipo con cui è stato dichiarato questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-210">The type that declared this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineConstructor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-211">Aggiunge un nuovo costruttore al tipo dinamico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-211">Adds a new constructor to the dynamic type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="04e9c-212">Attributi del costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-212">The attributes of the constructor.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-213">Convenzione di chiamata del costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-213">The calling convention of the constructor.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-214">Tipi di parametro del costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-214">The parameter types of the constructor.</span></span></param>
        <summary><span data-ttu-id="04e9c-215">Aggiunge un nuovo costruttore al tipo, con la firma e gli attributi specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-215">Adds a new constructor to the type, with the given attributes and signature.</span></span></summary>
        <returns><span data-ttu-id="04e9c-216">Costruttore definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-216">The defined constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-217">Se si definisce un costruttore per il tipo dinamico, viene fornito automaticamente un costruttore predefinito e chiama il costruttore predefinito della classe di base.</span><span class="sxs-lookup"><span data-stu-id="04e9c-217">If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</span></span>  
  
 <span data-ttu-id="04e9c-218">Se si definisce un costruttore per il tipo dinamico, non viene fornito un costruttore predefinito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-218">If you define a constructor for your dynamic type, a default constructor is not provided.</span></span> <span data-ttu-id="04e9c-219">Sono disponibili le opzioni seguenti per fornire un costruttore predefinito oltre al costruttore che è definito:</span><span class="sxs-lookup"><span data-stu-id="04e9c-219">You have the following options for providing a default constructor in addition to the constructor you defined:</span></span>  
  
-   <span data-ttu-id="04e9c-220">Se si desidera un costruttore predefinito che consente di chiamare semplicemente il costruttore predefinito della classe di base, è possibile usare il <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> metodo per crearne uno (e, facoltativamente, limitare l'accesso a esso).</span><span class="sxs-lookup"><span data-stu-id="04e9c-220">If you want a default constructor that simply calls the default constructor of the base class, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> method to create one (and optionally restrict access to it).</span></span> <span data-ttu-id="04e9c-221">Si fornisce un'implementazione per il costruttore predefinito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-221">Do not provide an implementation for this default constructor.</span></span> <span data-ttu-id="04e9c-222">In caso contrario viene generata un'eccezione quando si prova a usare il costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-222">If you do, an exception is thrown when you try to use the constructor.</span></span> <span data-ttu-id="04e9c-223">Viene generata alcuna eccezione quando il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-223">No exception is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
-   <span data-ttu-id="04e9c-224">Se si desidera che un costruttore predefinito che esegue un'operazione più semplicemente chiamare il costruttore predefinito della classe di base o che chiama un altro costruttore della classe di base o che esegue un'altra operazione completamente, è necessario utilizzare il <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> per crearne uno, metodo e fornire la propria implementazione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-224">If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> method to create one, and provide your own implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-225">L'esempio di codice seguente illustra l'uso del `DefineConstructor` per impostare un costruttore specifico firma e gli attributi su un tipo dinamico e restituire un corrispondente <xref:System.Reflection.Emit.ConstructorBuilder> popolazione MSIL.</span><span class="sxs-lookup"><span data-stu-id="04e9c-225">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-226">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-226">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineConstructor (attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineConstructor(System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineConstructor : System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineConstructor (attributes, callingConvention, parameterTypes, requiredCustomModifiers, optionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="04e9c-227">Attributi del costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-227">The attributes of the constructor.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-228">Convenzione di chiamata del costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-228">The calling convention of the constructor.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-229">Tipi di parametro del costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-229">The parameter types of the constructor.</span></span></param>
        <param name="requiredCustomModifiers"><span data-ttu-id="04e9c-230">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-230">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-231">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-231">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-232">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-232">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-233">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-233">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="optionalCustomModifiers"><span data-ttu-id="04e9c-234">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-234">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-235">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-235">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-236">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-236">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-237">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-237">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="04e9c-238">Aggiunge un nuovo costruttore al tipo, con gli attributi specificati, la firma e i modificatori personalizzati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-238">Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="04e9c-239">Costruttore definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-239">The defined constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-240">Questo overload è disponibile per i progettisti di compilatori gestiti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-240">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-241">Per altre informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-241">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="04e9c-242">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="04e9c-242">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-243">La dimensione di <paramref name="requiredCustomModifiers" /> o <paramref name="optionalCustomModifiers" /> non è uguale a quella di <paramref name="parameterTypes" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-243">The size of <paramref name="requiredCustomModifiers" /> or <paramref name="optionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-244">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-244">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-245">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-245">-or-</span></span> 
<span data-ttu-id="04e9c-246">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-246">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDefaultConstructor (attributes As MethodAttributes) As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineDefaultConstructor(System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDefaultConstructor : System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineDefaultConstructor attributes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes"><span data-ttu-id="04e9c-247">Oggetto <see langword="MethodAttributes" /> che rappresenta gli attributi da applicare al costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-247">A <see langword="MethodAttributes" /> object representing the attributes to be applied to the constructor.</span></span></param>
        <summary><span data-ttu-id="04e9c-248">Definisce il costruttore predefinito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-248">Defines the default constructor.</span></span> <span data-ttu-id="04e9c-249">Il costruttore definito qui chiamerà semplicemente il costruttore predefinito dell'elemento padre.</span><span class="sxs-lookup"><span data-stu-id="04e9c-249">The constructor defined here will simply call the default constructor of the parent.</span></span></summary>
        <returns><span data-ttu-id="04e9c-250">Restituisce il costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-250">Returns the constructor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-251">Poiché il costruttore predefinito viene definito automaticamente, è necessario chiamare questo metodo solo nelle situazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="04e9c-251">Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</span></span>  
  
-   <span data-ttu-id="04e9c-252">È stato definito un altro costruttore e si desidera anche un costruttore predefinito che consente di chiamare semplicemente il costruttore di classe di base.</span><span class="sxs-lookup"><span data-stu-id="04e9c-252">You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</span></span>  
  
-   <span data-ttu-id="04e9c-253">Si desidera impostare gli attributi del costruttore predefinito su un valore diverso da <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, e <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span><span class="sxs-lookup"><span data-stu-id="04e9c-253">You want to set the attributes on the default constructor to something other than <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, and <xref:System.Reflection.MethodAttributes.RTSpecialName>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-254">L'esempio di codice seguente illustra l'uso del `DefineConstructor` per impostare un costruttore specifico firma e gli attributi su un tipo dinamico e restituire un corrispondente <xref:System.Reflection.Emit.ConstructorBuilder> popolazione MSIL.</span><span class="sxs-lookup"><span data-stu-id="04e9c-254">The following code sample demonstrates the use of `DefineConstructor` to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref:System.Reflection.Emit.ConstructorBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-255">Il tipo padre (tipo di base) non ha un costruttore predefinito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-255">The parent type (base type) does not have a default constructor.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-256">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-256">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-257">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-257">-or-</span></span> 
<span data-ttu-id="04e9c-258">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-258">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEvent (name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EventBuilder ^ DefineEvent(System::String ^ name, System::Reflection::EventAttributes attributes, Type ^ eventtype);" />
      <MemberSignature Language="F#" Value="member this.DefineEvent : string * System.Reflection.EventAttributes * Type -&gt; System.Reflection.Emit.EventBuilder" Usage="typeBuilder.DefineEvent (name, attributes, eventtype)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-259">Nome dell'evento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-259">The name of the event.</span></span> <span data-ttu-id="04e9c-260"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-260"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-261">Attributi dell'evento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-261">The attributes of the event.</span></span></param>
        <param name="eventtype"><span data-ttu-id="04e9c-262">Tipo di evento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-262">The type of the event.</span></span></param>
        <summary><span data-ttu-id="04e9c-263">Aggiunge un nuovo evento al tipo, con il nome, gli attributi e il tipo di evento specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-263">Adds a new event to the type, with the given name, attributes and event type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-264">Evento definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-264">The defined event.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-265">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-265">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-266"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-266"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="04e9c-267">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-267">-or-</span></span> 
 <span data-ttu-id="04e9c-268"><paramref name="eventtype" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-268"><paramref name="eventtype" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-269">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-269">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-270">Aggiunge un nuovo campo al tipo dinamico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-270">Adds a new field to the dynamic type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName"><span data-ttu-id="04e9c-271">Nome del campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-271">The name of the field.</span></span> <span data-ttu-id="04e9c-272"><paramref name="fieldName" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-272"><paramref name="fieldName" /> cannot contain embedded nulls.</span></span></param>
        <param name="type"><span data-ttu-id="04e9c-273">Tipo di campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-273">The type of the field</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-274">Attributi del campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-274">The attributes of the field.</span></span></param>
        <summary><span data-ttu-id="04e9c-275">Aggiunge un nuovo campo al tipo, con il nome, gli attributi e il tipo di campo specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-275">Adds a new field to the type, with the given name, attributes, and field type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-276">Campo definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-276">The defined field.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-277">La lunghezza di <paramref name="fieldName" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-277">The length of <paramref name="fieldName" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-278">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-278">-or-</span></span> 
 <span data-ttu-id="04e9c-279"><paramref name="type" /> è System.Void.</span><span class="sxs-lookup"><span data-stu-id="04e9c-279"><paramref name="type" /> is System.Void.</span></span>  
  
<span data-ttu-id="04e9c-280">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-280">-or-</span></span> 
<span data-ttu-id="04e9c-281">È stata specificata una dimensione totale per la classe padre di questo campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-281">A total size was specified for the parent class of this field.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-282"><paramref name="fieldName" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-282"><paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-283">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-283">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineField(System::String ^ fieldName, Type ^ type, cli::array &lt;Type ^&gt; ^ requiredCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalCustomModifiers, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineField : string * Type * Type[] * Type[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineField (fieldName, type, requiredCustomModifiers, optionalCustomModifiers, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName"><span data-ttu-id="04e9c-284">Nome del campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-284">The name of the field.</span></span> <span data-ttu-id="04e9c-285"><paramref name="fieldName" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-285"><paramref name="fieldName" /> cannot contain embedded nulls.</span></span></param>
        <param name="type"><span data-ttu-id="04e9c-286">Tipo di campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-286">The type of the field</span></span></param>
        <param name="requiredCustomModifiers"><span data-ttu-id="04e9c-287">Matrice di tipi che rappresentano i modificatori personalizzati obbligatori per il campo, come <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-287">An array of types representing the required custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span></span></param>
        <param name="optionalCustomModifiers"><span data-ttu-id="04e9c-288">Matrice di tipi che rappresentano i modificatori personalizzati opzionali per il campo, come <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-288">An array of types representing the optional custom modifiers for the field, such as <see cref="T:Microsoft.VisualC.IsConstModifier" />.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-289">Attributi del campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-289">The attributes of the field.</span></span></param>
        <summary><span data-ttu-id="04e9c-290">Aggiunge un nuovo campo al tipo, con il nome, gli attributi, il tipo di campo e i modificatori personalizzati specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-290">Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="04e9c-291">Campo definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-291">The defined field.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-292">Questo overload è disponibile per i progettisti di compilatori gestiti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-292">This overload is provided for designers of managed compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-293">La lunghezza di <paramref name="fieldName" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-293">The length of <paramref name="fieldName" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-294">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-294">-or-</span></span> 
 <span data-ttu-id="04e9c-295"><paramref name="type" /> è System.Void.</span><span class="sxs-lookup"><span data-stu-id="04e9c-295"><paramref name="type" /> is System.Void.</span></span>  
  
<span data-ttu-id="04e9c-296">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-296">-or-</span></span> 
<span data-ttu-id="04e9c-297">È stata specificata una dimensione totale per la classe padre di questo campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-297">A total size was specified for the parent class of this field.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-298"><paramref name="fieldName" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-298"><paramref name="fieldName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-299">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-299">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGenericParameters (ParamArray names As String()) As GenericTypeParameterBuilder()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Emit::GenericTypeParameterBuilder ^&gt; ^ DefineGenericParameters(... cli::array &lt;System::String ^&gt; ^ names);" />
      <MemberSignature Language="F#" Value="member this.DefineGenericParameters : string[] -&gt; System.Reflection.Emit.GenericTypeParameterBuilder[]" Usage="typeBuilder.DefineGenericParameters names" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names"><span data-ttu-id="04e9c-300">Matrice di nomi per i parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-300">An array of names for the generic type parameters.</span></span></param>
        <summary><span data-ttu-id="04e9c-301">Definisce parametri di tipo generico per il tipo corrente, specificandone il numero e i nomi e restituisce una matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che possono essere usati per impostare i vincoli.</span><span class="sxs-lookup"><span data-stu-id="04e9c-301">Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to set their constraints.</span></span></summary>
        <returns><span data-ttu-id="04e9c-302">Matrice di oggetti <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> che può essere usata per definire i vincoli dei parametri di tipo generico per il tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-302">An array of <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objects that can be used to define the constraints of the generic type parameters for the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-303">Chiamare questo metodo rende il tipo corrente di un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-303">Calling this method makes the current type a generic type.</span></span> <span data-ttu-id="04e9c-304">Se il metodo viene chiamato nuovamente sullo stesso tipo, un <xref:System.InvalidOperationException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-304">If the method is called again on the same type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-305">Esempio di codice seguente crea un tipo generico con due parametri di tipo e salvarli nell'assembly Genericemitexample1.</span><span class="sxs-lookup"><span data-stu-id="04e9c-305">The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</span></span> <span data-ttu-id="04e9c-306">È possibile usare la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per visualizzare i tipi generati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-306">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to view the generated types.</span></span> <span data-ttu-id="04e9c-307">Per una spiegazione più dettagliata dei passaggi coinvolti nella definizione di un tipo generico dinamico, vedere [come: Definire un tipo generico tramite Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-307">For a more detailed explanation of the steps involved in defining a dynamic generic type, see [How to: Define a Generic Type with Reflection Emit](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).</span></span>  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-308">Parametri di tipo generico sono già stati definiti per questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-308">Generic type parameters have already been defined for this type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-309"><paramref name="names" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-309"><paramref name="names" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="04e9c-310">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-310">-or-</span></span> 
<span data-ttu-id="04e9c-311">Un elemento di <paramref name="names" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-311">An element of <paramref name="names" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-312"><paramref name="names" /> è una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="04e9c-312"><paramref name="names" /> is an empty array.</span></span></exception>
        <altmember cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <related type="Article" href="https://msdn.microsoft.com/library/07d5f01a-7b5b-40ea-9b15-f21561098fe4"><span data-ttu-id="04e9c-313">Procedura: definire un tipo generico tramite reflection emit</span><span class="sxs-lookup"><span data-stu-id="04e9c-313">How to: Define a Generic Type with Reflection Emit</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-314">Nome usato per fare riferimento ai dati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-314">The name used to refer to the data.</span></span> <span data-ttu-id="04e9c-315"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-315"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="data"><span data-ttu-id="04e9c-316">BLOB di dati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-316">The blob of data.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-317">Attributi per il campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-317">The attributes for the field.</span></span></param>
        <summary><span data-ttu-id="04e9c-318">Definisce il campo di dati inizializzati nella sezione .sdata del file eseguibile di tipo PE.</span><span class="sxs-lookup"><span data-stu-id="04e9c-318">Defines initialized data field in the .sdata section of the portable executable (PE) file.</span></span></summary>
        <returns><span data-ttu-id="04e9c-319">Campo di riferimento ai dati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-319">A field to reference the data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-320">Il campo creati con questo metodo sarà `static`, anche se non si include `FieldAttributes.Static` nel `attributes` parametro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-320">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-321">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-321">Length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-322">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-322">-or-</span></span> 
<span data-ttu-id="04e9c-323">La dimensione dei dati è minore o uguale a zero oppure maggiore o uguale a 0x3f0000.</span><span class="sxs-lookup"><span data-stu-id="04e9c-323">The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-324"><paramref name="name" /> o <paramref name="data" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-324"><paramref name="name" /> or <paramref name="data" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-325">L'oggetto <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> è stato chiamato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-325"><see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> has been previously called.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-326">Aggiunge un metodo al tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-326">Adds a method to the type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-327">Nome del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-327">The name of the method.</span></span> <span data-ttu-id="04e9c-328"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-328"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-329">Attributi del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-329">The attributes of the method.</span></span></param>
        <summary><span data-ttu-id="04e9c-330">Aggiunge un nuovo metodo al tipo, con il nome e gli attributi del metodo specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-330">Adds a new method to the type, with the specified name and method attributes.</span></span></summary>
        <returns><span data-ttu-id="04e9c-331">Oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" /> che rappresenta il metodo appena definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-331">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-332">Utilizzare questo overload del metodo quando non si conosce la firma del metodo al momento che si definisce il metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-332">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="04e9c-333">I tipi di parametro e tipo restituito di un metodo generico, ad esempio, può essere specificati dai parametri di tipo generico del metodo, che devono essere definiti dopo il metodo è stato aggiunto al tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-333">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="04e9c-334">I parametri e il tipo restituito del metodo può essere impostate in un secondo momento usando il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-334">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="04e9c-335">Questo overload del metodo definisce un metodo con <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="04e9c-335">This method overload defines a method with <xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>.</span></span> <span data-ttu-id="04e9c-336">Se è necessario definire un metodo senza una firma, con una convenzione di chiamata diversa, usare il <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-336">If you need to define a method without a signature, with a different calling convention, use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-337">Esempio di codice seguente definisce un metodo generico denominato `DemoMethod` il cui tipo di parametro e il tipo restituito specificati dai relativi parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-337">The following code example defines a generic method named `DemoMethod` whose parameter type and return type are specified by its generic type parameters.</span></span> <span data-ttu-id="04e9c-338">Il metodo viene definito senza una firma, usando la convenzione di chiamata standard.</span><span class="sxs-lookup"><span data-stu-id="04e9c-338">The method is defined without a signature, using the standard calling convention.</span></span> <span data-ttu-id="04e9c-339">Il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> metodo viene utilizzato per rendere `DemoMethod` un metodo generico e i parametri appena definiti vengono quindi usate per la firma e il tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-339">The <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method is used to make `DemoMethod` a generic method, and the newly defined type parameters are then used for the signature and return type.</span></span>  
  
 <span data-ttu-id="04e9c-340">Questo esempio di codice è parte di un esempio più esaustivo disponibile per il <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-340">This code example is part of a larger example provided for the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> method.</span></span>  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-341">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-341">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-342">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-342">-or-</span></span> 
<span data-ttu-id="04e9c-343">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<see langword="Overridable" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04e9c-343">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-344"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-344"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-345">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-345">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-346">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-346">-or-</span></span> 
<span data-ttu-id="04e9c-347">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-347">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-348">Nome del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-348">The name of the method.</span></span> <span data-ttu-id="04e9c-349"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-349"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-350">Attributi del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-350">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-351">Convenzione di chiamata del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-351">The calling convention of the method.</span></span></param>
        <summary><span data-ttu-id="04e9c-352">Aggiunge un nuovo metodo al tipo, con il nome e gli attributi del metodo e la convenzione di chiamata specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-352">Adds a new method to the type, with the specified name, method attributes, and calling convention.</span></span></summary>
        <returns><span data-ttu-id="04e9c-353">Oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" /> che rappresenta il metodo appena definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-353">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-354">Utilizzare questo overload del metodo quando non si conosce la firma del metodo al momento che si definisce il metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-354">Use this method overload when you do not know the method signature at the time you define the method.</span></span> <span data-ttu-id="04e9c-355">I tipi di parametro e tipo restituito di un metodo generico, ad esempio, può essere specificati dai parametri di tipo generico del metodo, che devono essere definiti dopo il metodo è stato aggiunto al tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-355">For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</span></span> <span data-ttu-id="04e9c-356">I parametri e il tipo restituito del metodo può essere impostate in un secondo momento usando il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-356">The parameters and return type of the method can be set later using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-357">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-357">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-358">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-358">-or-</span></span> 
<span data-ttu-id="04e9c-359">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<see langword="Overridable" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04e9c-359">The type of the parent of this method is an interface and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-360"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-360"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-361">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-361">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-362">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-362">-or-</span></span> 
<span data-ttu-id="04e9c-363">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-363">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-364">Nome del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-364">The name of the method.</span></span> <span data-ttu-id="04e9c-365"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-365"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-366">Attributi del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-366">The attributes of the method.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-367">Tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-367">The return type of the method.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-368">Tipi dei parametri del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-368">The types of the parameters of the method.</span></span></param>
        <summary><span data-ttu-id="04e9c-369">Aggiunge un nuovo metodo al tipo, con il nome, gli attributi e la firma del metodo specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-369">Adds a new method to the type, with the specified name, method attributes, and method signature.</span></span></summary>
        <returns><span data-ttu-id="04e9c-370">Metodo definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-370">The defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04e9c-371">Esempio di codice seguente viene illustrato l'utilizzo di `DefineMethod` per impostare un costruttore specifico firma e gli attributi su un tipo dinamico e per restituire un oggetto corrispondente <xref:System.Reflection.Emit.MethodBuilder> popolazione MSIL.</span><span class="sxs-lookup"><span data-stu-id="04e9c-371">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-372">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-372">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-373">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-373">-or-</span></span> 
<span data-ttu-id="04e9c-374">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<see langword="Overridable" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04e9c-374">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-375"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-375"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-376">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-376">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-377">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-377">-or-</span></span> 
<span data-ttu-id="04e9c-378">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-378">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-379">Nome del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-379">The name of the method.</span></span> <span data-ttu-id="04e9c-380"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-380"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-381">Attributi del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-381">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-382">Convenzione di chiamata del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-382">The calling convention of the method.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-383">Tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-383">The return type of the method.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-384">Tipi dei parametri del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-384">The types of the parameters of the method.</span></span></param>
        <summary><span data-ttu-id="04e9c-385">Aggiunge un nuovo metodo al tipo, con il nome, gli attributi del metodo, la convenzione di chiamata e la firma del metodo specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-385">Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</span></span></summary>
        <returns><span data-ttu-id="04e9c-386">Oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" /> che rappresenta il metodo appena definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-386">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the newly defined method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04e9c-387">Esempio di codice seguente viene illustrato l'utilizzo di `DefineMethod` per impostare un costruttore specifico firma e gli attributi su un tipo dinamico e per restituire un oggetto corrispondente <xref:System.Reflection.Emit.MethodBuilder> popolazione MSIL.</span><span class="sxs-lookup"><span data-stu-id="04e9c-387">The following code sample demonstrates the use of `DefineMethod` to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref:System.Reflection.Emit.MethodBuilder> for MSIL population.</span></span>  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-388">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-388">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-389">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-389">-or-</span></span> 
<span data-ttu-id="04e9c-390">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<see langword="Overridable" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04e9c-390">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-391"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-391"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-392">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-392">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-393">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-393">-or-</span></span> 
<span data-ttu-id="04e9c-394">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-394">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefineMethod (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-395">Nome del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-395">The name of the method.</span></span> <span data-ttu-id="04e9c-396"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-396"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-397">Attributi del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-397">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-398">Convenzione di chiamata del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-398">The calling convention of the method.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-399">Tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-399">The return type of the method.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="04e9c-400">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-400">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="04e9c-401">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-401">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="04e9c-402">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-402">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="04e9c-403">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-403">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-404">Tipi dei parametri del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-404">The types of the parameters of the method.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="04e9c-405">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-405">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-406">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-406">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-407">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-407">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-408">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-408">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="04e9c-409">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-409">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-410">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-410">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-411">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-411">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-412">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-412">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="04e9c-413">Aggiunge un nuovo metodo al tipo, con il nome, gli attributi del metodo, la convenzione di chiamata, la firma del metodo e i modificatori personalizzati specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-413">Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="04e9c-414">Oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" /> che rappresenta il metodo appena aggiunto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-414">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> object representing the newly added method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-415">Utilizzare questo overload se è necessario specificare i modificatori personalizzati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-415">Use this overload if you need to specify custom modifiers.</span></span> <span data-ttu-id="04e9c-416">Se è necessario specificare i modificatori personalizzati dopo aver creato il metodo, come si farebbe, ad esempio, con un metodo generico con tipi di parametro specificati dai relativi parametri di tipo generico, è possibile usare la <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> o <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> overload del metodo per definire il metodo e quindi usare il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> per definire il parametro e restituire i tipi con i modificatori personalizzati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-416">If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> or <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> method overloads to define the method and then use the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method to define the parameter and return types with custom modifiers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-417">Per altre informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-417">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="04e9c-418">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="04e9c-418">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-419">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-419">The length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-420">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-420">-or-</span></span> 
<span data-ttu-id="04e9c-421">Il tipo dell'elemento padre di questo metodo è un'interfaccia e il metodo non è virtuale (<see langword="Overridable" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04e9c-421">The type of the parent of this method is an interface, and this method is not virtual (<see langword="Overridable" /> in Visual Basic).</span></span>  
  
<span data-ttu-id="04e9c-422">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-422">-or-</span></span> 
<span data-ttu-id="04e9c-423">La dimensione di <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> non è uguale a quella di <paramref name="parameterTypes" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-423">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-424"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-424"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-425">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-425">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-426">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-426">-or-</span></span> 
<span data-ttu-id="04e9c-427">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-427">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineMethodOverride (methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineMethodOverride(System::Reflection::MethodInfo ^ methodInfoBody, System::Reflection::MethodInfo ^ methodInfoDeclaration);" />
      <MemberSignature Language="F#" Value="member this.DefineMethodOverride : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; unit" Usage="typeBuilder.DefineMethodOverride (methodInfoBody, methodInfoDeclaration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody"><span data-ttu-id="04e9c-428">Corpo del metodo da usare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-428">The method body to be used.</span></span> <span data-ttu-id="04e9c-429">Deve essere un oggetto <see langword="MethodBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-429">This should be a <see langword="MethodBuilder" /> object.</span></span></param>
        <param name="methodInfoDeclaration"><span data-ttu-id="04e9c-430">Metodo di cui usare la dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-430">The method whose declaration is to be used.</span></span></param>
        <summary><span data-ttu-id="04e9c-431">Specifica un corpo del metodo che implementa una data dichiarazione di metodo, potenzialmente con un nome diverso.</span><span class="sxs-lookup"><span data-stu-id="04e9c-431">Specifies a given method body that implements a given method declaration, potentially with a different name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-432">Non utilizzare questo metodo per generare override dei metodi o le implementazioni dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-432">Do not use this method to emit method overrides or interface implementations.</span></span> <span data-ttu-id="04e9c-433">Per eseguire l'override di un metodo di una classe base o implementare un metodo di un'interfaccia, creare semplicemente un metodo con lo stesso nome e firma del metodo deve essere sottoposto a override o implementati, come illustrato nell'esempio di codice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-433">To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="04e9c-434">Il <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> metodo viene usato quando un corpo del metodo e una dichiarazione di metodo hanno nomi diversi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-434">The <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is used when a method body and a method declaration have different names.</span></span> <span data-ttu-id="04e9c-435">Ad esempio, una classe potrebbe eseguire l'override di un metodo della classe base e anche fornire un'implementazione separata per un membro di interfaccia con lo stesso nome, come illustrato nell'esempio di codice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-435">For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</span></span>  
  
 <span data-ttu-id="04e9c-436">`DefineMethodOverride` definisce un `methodimpl`, che è costituito da una coppia di token di metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-436">`DefineMethodOverride` defines a `methodimpl`, which consists of a pair of metadata tokens.</span></span> <span data-ttu-id="04e9c-437">Un token punta a un'implementazione e gli altri punti a una dichiarazione che implementa il corpo del token.</span><span class="sxs-lookup"><span data-stu-id="04e9c-437">One token points to an implementation, and the other token points to a declaration that the body implements.</span></span> <span data-ttu-id="04e9c-438">Il corpo deve essere definito nel tipo di implementazione del metodo è definito in e il corpo deve essere virtuale (`Overridable` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04e9c-438">The body must be defined on the type the method impl is defined on, and the body must be virtual (`Overridable` in Visual Basic).</span></span> <span data-ttu-id="04e9c-439">La dichiarazione può essere effettuata a un metodo definito in un'interfaccia implementata da un metodo in una classe derivata, il tipo o un metodo definito nel tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-439">The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</span></span> <span data-ttu-id="04e9c-440">Se la dichiarazione è solo su un'interfaccia, lo slot definito per l'interfaccia viene modificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-440">If the declaration is on an interface only, the slot defined for the interface is altered.</span></span> <span data-ttu-id="04e9c-441">Se la dichiarazione viene effettuata a un metodo su un tipo di base, eventuali duplicati per il metodo sottoposto a override vengono sostituiti anche lo slot per il metodo viene sottoposto a override.</span><span class="sxs-lookup"><span data-stu-id="04e9c-441">If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</span></span> <span data-ttu-id="04e9c-442">Il metodo sottoposto a override non può essere il metodo effettivo che viene dichiarato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-442">The overridden method cannot be the actual method that is declared.</span></span> <span data-ttu-id="04e9c-443">Se il metodo è sullo stesso tipo, lo slot viene sostituito e vengono sottoposte a override eventuali duplicati per il metodo sostituito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-443">If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-444">Per altre informazioni sulle implementazioni di metodo, vedere `MethodImpl` nella documentazione di ECMA Partition II metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-444">For more information about method impls, see `MethodImpl` in the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="04e9c-445">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="04e9c-445">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="04e9c-446">Dopo il <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> metodo viene chiamato, alcune funzionalità di `methodInfoBody` non può essere modificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-446">After the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method is called, some features of `methodInfoBody` cannot be changed.</span></span> <span data-ttu-id="04e9c-447">È ad esempio, non è possibile applicare un attributo a un parametro di tipo generico di `methodInfoBody` utilizzando il <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-447">For example, you cannot apply an attribute to a generic type parameter of `methodInfoBody` by using the <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> method.</span></span> <span data-ttu-id="04e9c-448">Se è necessario usare il <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> metodo, eseguire questa operazione dopo tutte le caratteristiche di `methodInfoBody` sono state definite.</span><span class="sxs-lookup"><span data-stu-id="04e9c-448">If you must use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method, do so after all characteristics of `methodInfoBody` have been defined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-449">Esempio di codice seguente contiene un'interfaccia `I` con un metodo `M()`, una classe di base `A` che implementa l'interfaccia e una classe derivata `C` che esegue l'override dell'implementazione della classe di base di `M()` nonché fornisce un'implementazione esplicita separata di `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-449">The following code example contains an interface `I` with a method `M()`, a base class `A` that implements the interface, and a derived class `C` that overrides the base class implementation of `M()` and also provides a separate explicit implementation of `I.M()`.</span></span>  
  
 <span data-ttu-id="04e9c-450">Il `main()` metodo di esempio di codice illustra come generare la classe derivata `C`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-450">The `main()` method of the code example shows how to emit the derived class `C`.</span></span> <span data-ttu-id="04e9c-451">L'override del `A.M()` avviene semplicemente con la creazione di un metodo `M()` con la stessa firma.</span><span class="sxs-lookup"><span data-stu-id="04e9c-451">The override of `A.M()` is accomplished simply by emitting a method `M()` with the same signature.</span></span> <span data-ttu-id="04e9c-452">Tuttavia, per fornire un'implementazione separata di `I.M()`, è necessario definire un corpo del metodo e quindi usare il <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> metodo per associare tale corpo del metodo con un <xref:System.Reflection.MethodInfo> che rappresentano `I.M()`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-452">However, to provide a separate implementation of `I.M()`, you must define a method body and then use the <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> method to associate that method body with a <xref:System.Reflection.MethodInfo> representing `I.M()`.</span></span> <span data-ttu-id="04e9c-453">Il nome del corpo del metodo non è rilevante.</span><span class="sxs-lookup"><span data-stu-id="04e9c-453">The name of the method body does not matter.</span></span>  
  
 <span data-ttu-id="04e9c-454">L'esempio di codice crea un'istanza della classe generata.</span><span class="sxs-lookup"><span data-stu-id="04e9c-454">The code example creates an instance of the emitted class.</span></span> <span data-ttu-id="04e9c-455">Ottiene un <xref:System.Reflection.MethodInfo> dell'oggetto per `I.M()`, e l'implementazione dell'interfaccia viene utilizzata per richiamare la classe generata relativo esplicita.</span><span class="sxs-lookup"><span data-stu-id="04e9c-455">It obtains a <xref:System.Reflection.MethodInfo> object for `I.M()`, and uses it to invoke the emitted class's explicit interface implementation.</span></span> <span data-ttu-id="04e9c-456">Ottiene quindi un <xref:System.Reflection.MethodInfo> dell'oggetto per `A.M()`e lo usa per richiamare l'override del metodo della classe generato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-456">It then obtains a <xref:System.Reflection.MethodInfo> object for `A.M()`, and uses it to invoke the emitted class's override of that method.</span></span>  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-457"><paramref name="methodInfoBody" /> non appartiene a questa classe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-457"><paramref name="methodInfoBody" /> does not belong to this class.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-458"><paramref name="methodInfoBody" /> o <paramref name="methodInfoDeclaration" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-458"><paramref name="methodInfoBody" /> or <paramref name="methodInfoDeclaration" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-459">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-459">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-460">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-460">-or-</span></span> 
<span data-ttu-id="04e9c-461">Il tipo dichiarante di <paramref name="methodInfoBody" /> non è il tipo rappresentato da questo oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-461">The declaring type of <paramref name="methodInfoBody" /> is not the type represented by this <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineNestedType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-462">Definisce un tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-462">Defines a nested type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-463">Nome breve del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-463">The short name of the type.</span></span> <span data-ttu-id="04e9c-464"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-464"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <summary><span data-ttu-id="04e9c-465">Definisce un tipo annidato, dato il relativo nome.</span><span class="sxs-lookup"><span data-stu-id="04e9c-465">Defines a nested type, given its name.</span></span></summary>
        <returns><span data-ttu-id="04e9c-466">Tipo annidato definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-466">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-467">Questo metodo è utilizzabile per creare nidificata tipi anche dopo il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo è stato chiamato sul tipo di inclusione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-467">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="04e9c-468">Deve essere completata prima che possano rispecchiare su di esso con il tipo annidato <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="04e9c-468">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="04e9c-469">Vedere la descrizione della <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> per l'ordine in cui devono essere completati i tipi annidati e tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-469">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="04e9c-470">Un nome duplicato non è necessariamente creato se `name` è identico al nome di un tipo definito in precedenza o un tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-470">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="04e9c-471">Per essere dei duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-471">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-472">La lunghezza di <paramref name="name" /> è zero o maggiore di 1023.</span><span class="sxs-lookup"><span data-stu-id="04e9c-472">Length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="04e9c-473">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-473">-or-</span></span> 
<span data-ttu-id="04e9c-474">Questa operazione creerebbe un tipo con un oggetto <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicato nell'assembly corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-474">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-475"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-475"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-476">Nome breve del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-476">The short name of the type.</span></span> <span data-ttu-id="04e9c-477"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-477"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="04e9c-478">Attributi del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-478">The attributes of the type.</span></span></param>
        <summary><span data-ttu-id="04e9c-479">Definisce un tipo annidato, dato il relativo nome e attributi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-479">Defines a nested type, given its name and attributes.</span></span></summary>
        <returns><span data-ttu-id="04e9c-480">Tipo annidato definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-480">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-481">Questo metodo è utilizzabile per creare nidificata tipi anche dopo il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo è stato chiamato sul tipo di inclusione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-481">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="04e9c-482">Deve essere completata prima che possano rispecchiare su di esso con il tipo annidato <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="04e9c-482">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="04e9c-483">Vedere la descrizione della <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> per l'ordine in cui devono essere completati i tipi annidati e tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-483">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="04e9c-484">Un nome duplicato non è necessariamente creato se `name` è identico al nome di un tipo definito in precedenza o un tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-484">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="04e9c-485">Per essere dei duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-485">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-486">L'attributo annidato non è specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-486">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="04e9c-487">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-487">-or-</span></span> 
<span data-ttu-id="04e9c-488">Questo tipo è sealed.</span><span class="sxs-lookup"><span data-stu-id="04e9c-488">This type is sealed.</span></span>  
  
<span data-ttu-id="04e9c-489">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-489">-or-</span></span> 
<span data-ttu-id="04e9c-490">Questo tipo è una matrice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-490">This type is an array.</span></span>  
  
<span data-ttu-id="04e9c-491">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-491">-or-</span></span> 
<span data-ttu-id="04e9c-492">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-492">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="04e9c-493">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-493">-or-</span></span> 
<span data-ttu-id="04e9c-494">La lunghezza di <paramref name="name" /> è zero o maggiore di 1023.</span><span class="sxs-lookup"><span data-stu-id="04e9c-494">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="04e9c-495">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-495">-or-</span></span> 
<span data-ttu-id="04e9c-496">Questa operazione creerebbe un tipo con un oggetto <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicato nell'assembly corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-496">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-497"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-497"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-498">Nome breve del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-498">The short name of the type.</span></span> <span data-ttu-id="04e9c-499"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-499"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="04e9c-500">Attributi del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-500">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="04e9c-501">Tipo esteso dal tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-501">The type that the nested type extends.</span></span></param>
        <summary><span data-ttu-id="04e9c-502">Definisce un tipo annidato a partire dal nome, dagli attributi e dal tipo che estende.</span><span class="sxs-lookup"><span data-stu-id="04e9c-502">Defines a nested type, given its name, attributes, and the type that it extends.</span></span></summary>
        <returns><span data-ttu-id="04e9c-503">Tipo annidato definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-503">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-504">Questo metodo è utilizzabile per creare nidificata tipi anche dopo il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo è stato chiamato sul tipo di inclusione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-504">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="04e9c-505">Deve essere completata prima che possano rispecchiare su di esso con il tipo annidato <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="04e9c-505">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="04e9c-506">Vedere la descrizione della <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> per l'ordine in cui devono essere completati i tipi annidati e tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-506">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="04e9c-507">Un nome duplicato non è necessariamente creato se `name` è identico al nome di un tipo definito in precedenza o un tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-507">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="04e9c-508">Per essere dei duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-508">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-509">L'attributo annidato non è specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-509">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="04e9c-510">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-510">-or-</span></span> 
<span data-ttu-id="04e9c-511">Questo tipo è sealed.</span><span class="sxs-lookup"><span data-stu-id="04e9c-511">This type is sealed.</span></span>  
  
<span data-ttu-id="04e9c-512">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-512">-or-</span></span> 
<span data-ttu-id="04e9c-513">Questo tipo è una matrice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-513">This type is an array.</span></span>  
  
<span data-ttu-id="04e9c-514">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-514">-or-</span></span> 
<span data-ttu-id="04e9c-515">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-515">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="04e9c-516">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-516">-or-</span></span> 
<span data-ttu-id="04e9c-517">La lunghezza di <paramref name="name" /> è zero o maggiore di 1023.</span><span class="sxs-lookup"><span data-stu-id="04e9c-517">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="04e9c-518">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-518">-or-</span></span> 
<span data-ttu-id="04e9c-519">Questa operazione creerebbe un tipo con un oggetto <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicato nell'assembly corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-519">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-520"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-520"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-521">Nome breve del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-521">The short name of the type.</span></span> <span data-ttu-id="04e9c-522"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-522"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="04e9c-523">Attributi del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-523">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="04e9c-524">Tipo esteso dal tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-524">The type that the nested type extends.</span></span></param>
        <param name="typeSize"><span data-ttu-id="04e9c-525">Dimensione totale del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-525">The total size of the type.</span></span></param>
        <summary><span data-ttu-id="04e9c-526">Definisce un tipo annidato a partire dal nome, dagli attributi, dalla dimensione totale del tipo e dal tipo che estende.</span><span class="sxs-lookup"><span data-stu-id="04e9c-526">Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</span></span></summary>
        <returns><span data-ttu-id="04e9c-527">Tipo annidato definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-527">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-528">Questo metodo è utilizzabile per creare nidificata tipi anche dopo il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo è stato chiamato sul tipo di inclusione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-528">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="04e9c-529">Deve essere completata prima che possano rispecchiare su di esso con il tipo annidato <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="04e9c-529">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="04e9c-530">Vedere la descrizione della <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> per l'ordine in cui devono essere completati i tipi annidati e tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-530">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="04e9c-531">Un nome duplicato non è necessariamente creato se `name` è identico al nome di un tipo definito in precedenza o un tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-531">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="04e9c-532">Per essere dei duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-532">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-533">L'attributo annidato non è specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-533">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="04e9c-534">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-534">-or-</span></span> 
<span data-ttu-id="04e9c-535">Questo tipo è sealed.</span><span class="sxs-lookup"><span data-stu-id="04e9c-535">This type is sealed.</span></span>  
  
<span data-ttu-id="04e9c-536">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-536">-or-</span></span> 
<span data-ttu-id="04e9c-537">Questo tipo è una matrice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-537">This type is an array.</span></span>  
  
<span data-ttu-id="04e9c-538">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-538">-or-</span></span> 
<span data-ttu-id="04e9c-539">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-539">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="04e9c-540">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-540">-or-</span></span> 
<span data-ttu-id="04e9c-541">La lunghezza di <paramref name="name" /> è zero o maggiore di 1023.</span><span class="sxs-lookup"><span data-stu-id="04e9c-541">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="04e9c-542">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-542">-or-</span></span> 
<span data-ttu-id="04e9c-543">Questa operazione creerebbe un tipo con un oggetto <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicato nell'assembly corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-543">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-544"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-544"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-545">Nome breve del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-545">The short name of the type.</span></span> <span data-ttu-id="04e9c-546"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-546"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="04e9c-547">Attributi del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-547">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="04e9c-548">Tipo esteso dal tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-548">The type that the nested type extends.</span></span></param>
        <param name="packSize"><span data-ttu-id="04e9c-549">Dimensione di compressione del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-549">The packing size of the type.</span></span></param>
        <summary><span data-ttu-id="04e9c-550">Definisce un tipo annidato a partire dal nome, dagli attributi, dal tipo che estende e dalla dimensione di compressione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-550">Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</span></span></summary>
        <returns><span data-ttu-id="04e9c-551">Tipo annidato definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-551">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-552">Questo metodo è utilizzabile per creare nidificata tipi anche dopo il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo è stato chiamato sul tipo di inclusione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-552">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="04e9c-553">Deve essere completata prima che possano rispecchiare su di esso con il tipo annidato <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="04e9c-553">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="04e9c-554">Vedere la descrizione della <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> per l'ordine in cui devono essere completati i tipi annidati e tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-554">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="04e9c-555">Un nome duplicato non è necessariamente creato se `name` è identico al nome di un tipo definito in precedenza o un tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-555">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="04e9c-556">Per essere dei duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-556">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-557">L'attributo annidato non è specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-557">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="04e9c-558">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-558">-or-</span></span> 
<span data-ttu-id="04e9c-559">Questo tipo è sealed.</span><span class="sxs-lookup"><span data-stu-id="04e9c-559">This type is sealed.</span></span>  
  
<span data-ttu-id="04e9c-560">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-560">-or-</span></span> 
<span data-ttu-id="04e9c-561">Questo tipo è una matrice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-561">This type is an array.</span></span>  
  
<span data-ttu-id="04e9c-562">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-562">-or-</span></span> 
<span data-ttu-id="04e9c-563">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-563">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="04e9c-564">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-564">-or-</span></span> 
<span data-ttu-id="04e9c-565">La lunghezza di <paramref name="name" /> è zero o maggiore di 1023.</span><span class="sxs-lookup"><span data-stu-id="04e9c-565">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="04e9c-566">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-566">-or-</span></span> 
<span data-ttu-id="04e9c-567">Questa operazione creerebbe un tipo con un oggetto <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicato nell'assembly corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-567">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-568"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-568"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-569">Nome breve del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-569">The short name of the type.</span></span> <span data-ttu-id="04e9c-570"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-570"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attr"><span data-ttu-id="04e9c-571">Attributi del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-571">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="04e9c-572">Tipo esteso dal tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-572">The type that the nested type extends.</span></span></param>
        <param name="interfaces"><span data-ttu-id="04e9c-573">Interfacce implementate dal tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-573">The interfaces that the nested type implements.</span></span></param>
        <summary><span data-ttu-id="04e9c-574">Definisce un tipo annidato a partire dal nome, dagli attributi, dal tipo che estende e dalle interfacce che implementa.</span><span class="sxs-lookup"><span data-stu-id="04e9c-574">Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</span></span></summary>
        <returns><span data-ttu-id="04e9c-575">Tipo annidato definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-575">The defined nested type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-576">Questo metodo è utilizzabile per creare nidificata tipi anche dopo il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo è stato chiamato sul tipo di inclusione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-576">This method can be used to create nested types even after the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called on the enclosing type.</span></span>  
  
 <span data-ttu-id="04e9c-577">Deve essere completata prima che possano rispecchiare su di esso con il tipo annidato <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, o <xref:System.Type.GetNestedTypes%2A>.</span><span class="sxs-lookup"><span data-stu-id="04e9c-577">The nested type needs to be complete before you can reflect on it using <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, or <xref:System.Type.GetNestedTypes%2A>.</span></span>  
  
 <span data-ttu-id="04e9c-578">Vedere la descrizione della <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> per l'ordine in cui devono essere completati i tipi annidati e tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-578">See the description of <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> for the order in which nested types and nesting types should be completed.</span></span>  
  
 <span data-ttu-id="04e9c-579">Un nome duplicato non è necessariamente creato se `name` è identico al nome di un tipo definito in precedenza o un tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-579">A duplicate name is not necessarily created if `name` is identical to the name of a previously defined type or nested type.</span></span> <span data-ttu-id="04e9c-580">Per essere dei duplicati, i nomi completi devono essere lo stesso, tra cui lo spazio dei nomi e tutti i tipi di annidamento.</span><span class="sxs-lookup"><span data-stu-id="04e9c-580">To be duplicates, the full names must be the same, including the namespace and all nesting types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-581">L'attributo annidato non è specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-581">The nested attribute is not specified.</span></span>  
  
<span data-ttu-id="04e9c-582">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-582">-or-</span></span> 
<span data-ttu-id="04e9c-583">Questo tipo è sealed.</span><span class="sxs-lookup"><span data-stu-id="04e9c-583">This type is sealed.</span></span>  
  
<span data-ttu-id="04e9c-584">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-584">-or-</span></span> 
<span data-ttu-id="04e9c-585">Questo tipo è una matrice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-585">This type is an array.</span></span>  
  
<span data-ttu-id="04e9c-586">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-586">-or-</span></span> 
<span data-ttu-id="04e9c-587">Questo tipo è un'interfaccia, ma il tipo annidato non è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-587">This type is an interface, but the nested type is not an interface.</span></span>  
  
<span data-ttu-id="04e9c-588">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-588">-or-</span></span> 
<span data-ttu-id="04e9c-589">La lunghezza di <paramref name="name" /> è zero o maggiore di 1023.</span><span class="sxs-lookup"><span data-stu-id="04e9c-589">The length of <paramref name="name" /> is zero or greater than 1023.</span></span>  
  
<span data-ttu-id="04e9c-590">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-590">-or-</span></span> 
<span data-ttu-id="04e9c-591">Questa operazione creerebbe un tipo con un oggetto <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> duplicato nell'assembly corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-591">This operation would create a type with a duplicate <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> in the current assembly.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-592"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-592"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="04e9c-593">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-593">-or-</span></span> 
<span data-ttu-id="04e9c-594">Un elemento della matrice <paramref name="interfaces" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-594">An element of the <paramref name="interfaces" /> array is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineNestedType (name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineNestedType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packSize, int typeSize);" />
      <MemberSignature Language="F#" Value="member this.DefineNestedType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="typeBuilder.DefineNestedType (name, attr, parent, packSize, typeSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-595">Nome breve del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-595">The short name of the type.</span></span> <span data-ttu-id="04e9c-596">L'oggetto <paramref name="name" /> non può contenere valori null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-596"><paramref name="name" /> cannot contain embedded null values.</span></span></param>
        <param name="attr"><span data-ttu-id="04e9c-597">Attributi del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-597">The attributes of the type.</span></span></param>
        <param name="parent"><span data-ttu-id="04e9c-598">Tipo esteso dal tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-598">The type that the nested type extends.</span></span></param>
        <param name="packSize"><span data-ttu-id="04e9c-599">Dimensione di compressione del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-599">The packing size of the type.</span></span></param>
        <param name="typeSize"><span data-ttu-id="04e9c-600">Dimensione totale del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-600">The total size of the type.</span></span></param>
        <summary><span data-ttu-id="04e9c-601">Definisce un tipo annidato a partire dal nome, dagli attributi, dalla dimensione e dal tipo che estende.</span><span class="sxs-lookup"><span data-stu-id="04e9c-601">Defines a nested type, given its name, attributes, size, and the type that it extends.</span></span></summary>
        <returns><span data-ttu-id="04e9c-602">Tipo annidato definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-602">The defined nested type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-603">Definisce un metodo <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-603">Defines a <see langword="PInvoke" /> method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-604">Nome del metodo <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-604">The name of the <see langword="PInvoke" /> method.</span></span> <span data-ttu-id="04e9c-605"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-605"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="dllName"><span data-ttu-id="04e9c-606">Nome della DLL in cui è definito il metodo <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-606">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-607">Attributi del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-607">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-608">Convenzione di chiamata del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-608">The method's calling convention.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-609">Tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-609">The method's return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-610">Tipi dei parametri del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-610">The types of the method's parameters.</span></span></param>
        <param name="nativeCallConv"><span data-ttu-id="04e9c-611">Convenzione di chiamata nativa.</span><span class="sxs-lookup"><span data-stu-id="04e9c-611">The native calling convention.</span></span></param>
        <param name="nativeCharSet"><span data-ttu-id="04e9c-612">Set di caratteri nativo del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-612">The method's native character set.</span></span></param>
        <summary><span data-ttu-id="04e9c-613">Definisce un metodo <see langword="PInvoke" /> in base al nome, al nome della DLL in cui è definito il metodo, agli attributi del metodo, alla convenzione di chiamata del metodo, al tipo restituito del metodo, ai tipi di parametri del metodo e ai flag <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-613">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span></span></summary>
        <returns><span data-ttu-id="04e9c-614">Metodo <see langword="PInvoke" /> definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-614">The defined <see langword="PInvoke" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-615">Gli attributi di importazione alcune DLL (vedere la descrizione della <xref:System.Runtime.InteropServices.DllImportAttribute>) non possono essere specificate come argomenti al metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-615">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="04e9c-616">Import (attributo), ad esempio, la DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> deve essere aggiunto dopo il `PInvoke` metodo viene creato, se il metodo restituisce un valore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-616">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="04e9c-617">Nell'esempio viene illustrato come eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-617">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-618">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> metodo per creare un `PInvoke` (metodo) e su come aggiungere il <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag ai flag di implementazione del metodo dopo aver creato il <xref:System.Reflection.Emit.MethodBuilder>, utilizzando il <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>metodi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-618">The following example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="04e9c-619">Per ottenere un valore restituito diverso da zero, è necessario aggiungere il <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="04e9c-619">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="04e9c-620">L'esempio crea un assembly dinamico con un unico tipo e un modulo dinamico `MyType`, che contiene il `PInvoke` (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-620">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="04e9c-621">Il `PInvoke` metodo rappresenta Win32 `GetTickCount` (funzione).</span><span class="sxs-lookup"><span data-stu-id="04e9c-621">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="04e9c-622">Quando viene eseguito l'esempio, esegue il `PInvoke` (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-622">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="04e9c-623">Salva inoltre l'assembly dinamico come PInvokeTest.</span><span class="sxs-lookup"><span data-stu-id="04e9c-623">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="04e9c-624">È possibile usare il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare le `MyType` classe e il `static` (`Shared` in Visual Basic) `PInvoke` contiene (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-624">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="04e9c-625">È possibile compilare un programma Visual Basic o c# che usa il metodo statico `MyType.GetTickCount` metodo includendo un riferimento alla DLL quando si esegue csc.exe o vbc.exe; ad esempio, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-625">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-626">Il metodo non è statico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-626">The method is not static.</span></span>  
  
<span data-ttu-id="04e9c-627">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-627">-or-</span></span> 
<span data-ttu-id="04e9c-628">Il tipo padre è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-628">The parent type is an interface.</span></span>  
  
<span data-ttu-id="04e9c-629">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-629">-or-</span></span> 
<span data-ttu-id="04e9c-630">Il metodo è di tipo abstract.</span><span class="sxs-lookup"><span data-stu-id="04e9c-630">The method is abstract.</span></span>  
  
<span data-ttu-id="04e9c-631">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-631">-or-</span></span> 
<span data-ttu-id="04e9c-632">Il metodo è stato definito in precedenza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-632">The method was previously defined.</span></span>  
  
<span data-ttu-id="04e9c-633">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-633">-or-</span></span> 
<span data-ttu-id="04e9c-634">La lunghezza di <paramref name="name" /> o <paramref name="dllName" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-634">The length of <paramref name="name" /> or <paramref name="dllName" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-635"><paramref name="name" /> o <paramref name="dllName" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-635"><paramref name="name" /> or <paramref name="dllName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-636">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-636">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-637">Nome del metodo <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-637">The name of the <see langword="PInvoke" /> method.</span></span> <span data-ttu-id="04e9c-638"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-638"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="dllName"><span data-ttu-id="04e9c-639">Nome della DLL in cui è definito il metodo <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-639">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span></span></param>
        <param name="entryName"><span data-ttu-id="04e9c-640">Nome del punto di ingresso nella DLL.</span><span class="sxs-lookup"><span data-stu-id="04e9c-640">The name of the entry point in the DLL.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-641">Attributi del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-641">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-642">Convenzione di chiamata del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-642">The method's calling convention.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-643">Tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-643">The method's return type.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-644">Tipi dei parametri del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-644">The types of the method's parameters.</span></span></param>
        <param name="nativeCallConv"><span data-ttu-id="04e9c-645">Convenzione di chiamata nativa.</span><span class="sxs-lookup"><span data-stu-id="04e9c-645">The native calling convention.</span></span></param>
        <param name="nativeCharSet"><span data-ttu-id="04e9c-646">Set di caratteri nativo del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-646">The method's native character set.</span></span></param>
        <summary><span data-ttu-id="04e9c-647">Definisce un metodo <see langword="PInvoke" /> in base al nome, al nome della DLL in cui è definito il metodo, al nome del punto di ingresso, agli attributi del metodo, alla convenzione di chiamata del metodo, al tipo restituito del metodo, ai tipi di parametri del metodo e ai flag <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-647">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</span></span></summary>
        <returns><span data-ttu-id="04e9c-648">Metodo <see langword="PInvoke" /> definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-648">The defined <see langword="PInvoke" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-649">Gli attributi di importazione alcune DLL (vedere la descrizione della <xref:System.Runtime.InteropServices.DllImportAttribute>) non possono essere specificate come argomenti al metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-649">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="04e9c-650">Import (attributo), ad esempio, la DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> deve essere aggiunto dopo il `PInvoke` metodo viene creato, se il metodo restituisce un valore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-650">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="04e9c-651">Nell'esempio viene illustrato come eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-651">The example shows how to do this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-652">Il codice seguente viene illustrato come utilizzare il <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> metodo per creare un `PInvoke` (metodo) e su come aggiungere il <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag ai flag di implementazione del metodo dopo aver creato il <xref:System.Reflection.Emit.MethodBuilder>, utilizzando il <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-652">The following code example demonstrates how to use the <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="04e9c-653">Per ottenere un valore restituito diverso da zero, è necessario aggiungere il <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="04e9c-653">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="04e9c-654">L'esempio crea un assembly dinamico con un unico tipo e un modulo dinamico `MyType`, che contiene il `PInvoke` (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-654">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="04e9c-655">Il `PInvoke` metodo rappresenta Win32 `GetTickCount` (funzione).</span><span class="sxs-lookup"><span data-stu-id="04e9c-655">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
 <span data-ttu-id="04e9c-656">Quando viene eseguito l'esempio, esegue il `PInvoke` (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-656">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="04e9c-657">Salva inoltre l'assembly dinamico come PInvokeTest.</span><span class="sxs-lookup"><span data-stu-id="04e9c-657">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="04e9c-658">È possibile usare il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare le `MyType` classe e il `static` (`Shared` in Visual Basic) `PInvoke` contiene (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-658">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="04e9c-659">È possibile compilare un programma Visual Basic o c# che usa il metodo statico `MyType.GetTickCount` metodo includendo un riferimento alla DLL quando si esegue csc.exe o vbc.exe; ad esempio, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-659">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-660">Il metodo non è statico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-660">The method is not static.</span></span>  
  
<span data-ttu-id="04e9c-661">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-661">-or-</span></span> 
<span data-ttu-id="04e9c-662">Il tipo padre è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-662">The parent type is an interface.</span></span>  
  
<span data-ttu-id="04e9c-663">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-663">-or-</span></span> 
<span data-ttu-id="04e9c-664">Il metodo è di tipo abstract.</span><span class="sxs-lookup"><span data-stu-id="04e9c-664">The method is abstract.</span></span>  
  
<span data-ttu-id="04e9c-665">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-665">-or-</span></span> 
<span data-ttu-id="04e9c-666">Il metodo è stato definito in precedenza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-666">The method was previously defined.</span></span>  
  
<span data-ttu-id="04e9c-667">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-667">-or-</span></span> 
<span data-ttu-id="04e9c-668">La lunghezza di <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-668">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-669"><paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-669"><paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-670">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-670">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="typeBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-671">Nome del metodo <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-671">The name of the <see langword="PInvoke" /> method.</span></span> <span data-ttu-id="04e9c-672"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-672"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="dllName"><span data-ttu-id="04e9c-673">Nome della DLL in cui è definito il metodo <see langword="PInvoke" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-673">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</span></span></param>
        <param name="entryName"><span data-ttu-id="04e9c-674">Nome del punto di ingresso nella DLL.</span><span class="sxs-lookup"><span data-stu-id="04e9c-674">The name of the entry point in the DLL.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-675">Attributi del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-675">The attributes of the method.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-676">Convenzione di chiamata del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-676">The method's calling convention.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-677">Tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-677">The method's return type.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="04e9c-678">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-678">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="04e9c-679">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-679">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="04e9c-680">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-680">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the method.</span></span> <span data-ttu-id="04e9c-681">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-681">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-682">Tipi dei parametri del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-682">The types of the method's parameters.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="04e9c-683">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-683">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-684">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-684">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-685">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-685">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-686">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-686">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="04e9c-687">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-687">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-688">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-688">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-689">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-689">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-690">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-690">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="nativeCallConv"><span data-ttu-id="04e9c-691">Convenzione di chiamata nativa.</span><span class="sxs-lookup"><span data-stu-id="04e9c-691">The native calling convention.</span></span></param>
        <param name="nativeCharSet"><span data-ttu-id="04e9c-692">Set di caratteri nativo del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-692">The method's native character set.</span></span></param>
        <summary><span data-ttu-id="04e9c-693">Definisce un metodo <see langword="PInvoke" /> in base al nome, al nome della DLL in cui è definito il metodo, al nome del punto di ingresso, agli attributi del metodo, alla convenzione di chiamata del metodo, al tipo restituito del metodo, ai tipi di parametri del metodo, ai flag <see langword="PInvoke" /> e ai modificatori personalizzati relativi ai parametri e al tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-693">Defines a <see langword="PInvoke" /> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <see langword="PInvoke" /> flags, and custom modifiers for the parameters and return type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-694">Oggetto <see cref="T:System.Reflection.Emit.MethodBuilder" /> che rappresenta il metodo <see langword="PInvoke" /> definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-694">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> representing the defined <see langword="PInvoke" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-695">Gli attributi di importazione alcune DLL (vedere la descrizione della <xref:System.Runtime.InteropServices.DllImportAttribute>) non possono essere specificate come argomenti al metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-695">Some DLL import attributes (see the description of <xref:System.Runtime.InteropServices.DllImportAttribute>) cannot be specified as arguments to this method.</span></span> <span data-ttu-id="04e9c-696">Import (attributo), ad esempio, la DLL <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> deve essere aggiunto dopo il `PInvoke` metodo viene creato, se il metodo restituisce un valore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-696">For example, the DLL import attribute <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> must be added after the `PInvoke` method is created, if the method returns a value.</span></span> <span data-ttu-id="04e9c-697">Nell'esempio viene illustrato come eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-697">The example shows how to do this.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-698">Per altre informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-698">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="04e9c-699">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="04e9c-699">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-700">Esempio di codice seguente viene illustrato come usare il [\], tipo\[\], digitare\[\], tipo\[\]\[\], tipo\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > per creare un `PInvoke` (metodo) e su come aggiungere il <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag ai flag di implementazione del metodo dopo aver creato il <xref:System.Reflection.Emit.MethodBuilder>, usando il <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-700">The following code example demonstrates how to use the [\], Type\[\], Type\[\], Type\[\]\[\], Type\[\]\<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> method to create a `PInvoke` method, and how to add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag to the method implementation flags after you create the <xref:System.Reflection.Emit.MethodBuilder>, by using the <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> and <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="04e9c-701">L'esempio crea un assembly dinamico con un unico tipo e un modulo dinamico `MyType`, che contiene il `PInvoke` (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-701">The example creates a dynamic assembly with one dynamic module and a single type, `MyType`, that contains the `PInvoke` method.</span></span> <span data-ttu-id="04e9c-702">Il `PInvoke` metodo rappresenta Win32 `GetTickCount` (funzione).</span><span class="sxs-lookup"><span data-stu-id="04e9c-702">The `PInvoke` method represents the Win32 `GetTickCount` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="04e9c-703">Per ottenere un valore restituito diverso da zero, è necessario aggiungere il <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="04e9c-703">To get a non-zero return value, you must add the <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> flag.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-704">L'esempio Usa un overload che non specifica i modificatori personalizzati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-704">The example uses an overload that does not specify custom modifiers.</span></span> <span data-ttu-id="04e9c-705">Per specificare i modificatori personalizzati, modificare il codice di esempio per usare invece questo overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-705">To specify custom modifiers, change the example code to use this method overload instead.</span></span>  
  
 <span data-ttu-id="04e9c-706">Quando viene eseguito l'esempio, esegue il `PInvoke` (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-706">When the example is run, it executes the `PInvoke` method.</span></span> <span data-ttu-id="04e9c-707">Salva inoltre l'assembly dinamico come PInvokeTest.</span><span class="sxs-lookup"><span data-stu-id="04e9c-707">It also saves the dynamic assembly as PInvokeTest.dll.</span></span> <span data-ttu-id="04e9c-708">È possibile usare il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminare le `MyType` classe e il `static` (`Shared` in Visual Basic) `PInvoke` contiene (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-708">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the `MyType` class and the `static` (`Shared` in Visual Basic) `PInvoke` method it contains.</span></span> <span data-ttu-id="04e9c-709">È possibile compilare un programma Visual Basic o c# che usa il metodo statico `MyType.GetTickCount` metodo includendo un riferimento alla DLL quando si esegue csc.exe o vbc.exe; ad esempio, `/r:PInvokeTest.dll`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-709">You can compile a Visual Basic or C# program that uses the static `MyType.GetTickCount` method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, `/r:PInvokeTest.dll`.</span></span>  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-710">Il metodo non è statico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-710">The method is not static.</span></span>  
  
<span data-ttu-id="04e9c-711">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-711">-or-</span></span> 
<span data-ttu-id="04e9c-712">Il tipo padre è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-712">The parent type is an interface.</span></span>  
  
<span data-ttu-id="04e9c-713">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-713">-or-</span></span> 
<span data-ttu-id="04e9c-714">Il metodo è di tipo abstract.</span><span class="sxs-lookup"><span data-stu-id="04e9c-714">The method is abstract.</span></span>  
  
<span data-ttu-id="04e9c-715">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-715">-or-</span></span> 
<span data-ttu-id="04e9c-716">Il metodo è stato definito in precedenza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-716">The method was previously defined.</span></span>  
  
<span data-ttu-id="04e9c-717">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-717">-or-</span></span> 
<span data-ttu-id="04e9c-718">La lunghezza di <paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-718">The length of <paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-719">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-719">-or-</span></span> 
<span data-ttu-id="04e9c-720">La dimensione di <paramref name="parameterTypeRequiredCustomModifiers" /> o <paramref name="parameterTypeOptionalCustomModifiers" /> non è uguale a quella di <paramref name="parameterTypes" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-720">The size of <paramref name="parameterTypeRequiredCustomModifiers" /> or <paramref name="parameterTypeOptionalCustomModifiers" /> does not equal the size of <paramref name="parameterTypes" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-721"><paramref name="name" />, <paramref name="dllName" /> o <paramref name="entryName" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-721"><paramref name="name" />, <paramref name="dllName" />, or <paramref name="entryName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-722">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-722">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-723">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-723">-or-</span></span> 
<span data-ttu-id="04e9c-724">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-724">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineProperty">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-725">Aggiunge una nuova proprietà al tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-725">Adds a new property to the type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-726">Nome della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-726">The name of the property.</span></span> <span data-ttu-id="04e9c-727"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-727"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-728">Attributi della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-728">The attributes of the property.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-729">Tipo restituito della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-729">The return type of the property.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-730">Tipi dei parametri della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-730">The types of the parameters of the property.</span></span></param>
        <summary><span data-ttu-id="04e9c-731">Aggiunge una nuova proprietà al tipo, con il nome e la firma della proprietà specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-731">Adds a new property to the type, with the given name and property signature.</span></span></summary>
        <returns><span data-ttu-id="04e9c-732">Proprietà definita.</span><span class="sxs-lookup"><span data-stu-id="04e9c-732">The defined property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="04e9c-733">Esempio di codice seguente viene illustrato come definire una proprietà dinamica e ottenere un <xref:System.Reflection.Emit.PropertyBuilder> specifica.</span><span class="sxs-lookup"><span data-stu-id="04e9c-733">The following code sample demonstrates how to define a dynamic property and obtain a <xref:System.Reflection.Emit.PropertyBuilder> for specification.</span></span> <span data-ttu-id="04e9c-734">Si noti che un `PropertyBuilder` deve anche corrispondere un <xref:System.Reflection.Emit.MethodBuilder>, che dovrà contenere la logica di IL per la proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-734">Note that a `PropertyBuilder` must also have a corresponding <xref:System.Reflection.Emit.MethodBuilder>, which will house the IL logic for the property.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-735">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-735">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-736"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-736"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="04e9c-737">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-737">-or-</span></span> 
<span data-ttu-id="04e9c-738">Uno degli elementi della matrice <paramref name="parameterTypes" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-738">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-739">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-739">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-740">Nome della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-740">The name of the property.</span></span> <span data-ttu-id="04e9c-741"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-741"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-742">Attributi della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-742">The attributes of the property.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-743">Convenzione di chiamata delle funzioni di accesso della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-743">The calling convention of the property accessors.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-744">Tipo restituito della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-744">The return type of the property.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-745">Tipi dei parametri della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-745">The types of the parameters of the property.</span></span></param>
        <summary><span data-ttu-id="04e9c-746">Aggiunge una nuova proprietà al tipo, con il nome, gli attributi, la convenzione di chiamata e la firma della proprietà specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-746">Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</span></span></summary>
        <returns><span data-ttu-id="04e9c-747">Proprietà definita.</span><span class="sxs-lookup"><span data-stu-id="04e9c-747">The defined property.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-748">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-748">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-749"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-749"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="04e9c-750">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-750">-or-</span></span> 
<span data-ttu-id="04e9c-751">Uno degli elementi della matrice <paramref name="parameterTypes" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-751">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-752">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-752">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-753">Nome della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-753">The name of the property.</span></span> <span data-ttu-id="04e9c-754"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-754"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-755">Attributi della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-755">The attributes of the property.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-756">Tipo restituito della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-756">The return type of the property.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="04e9c-757">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-757">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="04e9c-758">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-758">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="04e9c-759">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-759">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="04e9c-760">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-760">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-761">Tipi dei parametri della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-761">The types of the parameters of the property.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="04e9c-762">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-762">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-763">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-763">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-764">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-764">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-765">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-765">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="04e9c-766">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-766">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-767">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-767">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-768">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-768">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-769">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-769">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="04e9c-770">Aggiunge una nuova proprietà al tipo, con il nome, la firma della proprietà e i modificatori personalizzati specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-770">Adds a new property to the type, with the given name, property signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="04e9c-771">Proprietà definita.</span><span class="sxs-lookup"><span data-stu-id="04e9c-771">The defined property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-772">Questo overload è disponibile per i progettisti di compilatori gestiti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-772">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-773">Per altre informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-773">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="04e9c-774">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="04e9c-774">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-775">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-775">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-776"><paramref name="name" /> è <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="04e9c-776"><paramref name="name" /> is <see langword="null" /></span></span>  
  
<span data-ttu-id="04e9c-777">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-777">-or-</span></span> 
<span data-ttu-id="04e9c-778">Uno degli elementi della matrice <paramref name="parameterTypes" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-778">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" /></span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-779">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-779">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineProperty (name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::PropertyBuilder ^ DefineProperty(System::String ^ name, System::Reflection::PropertyAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ returnTypeRequiredCustomModifiers, cli::array &lt;Type ^&gt; ^ returnTypeOptionalCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeRequiredCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineProperty : string * System.Reflection.PropertyAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.PropertyBuilder" Usage="typeBuilder.DefineProperty (name, attributes, callingConvention, returnType, returnTypeRequiredCustomModifiers, returnTypeOptionalCustomModifiers, parameterTypes, parameterTypeRequiredCustomModifiers, parameterTypeOptionalCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-780">Nome della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-780">The name of the property.</span></span> <span data-ttu-id="04e9c-781"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-781"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-782">Attributi della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-782">The attributes of the property.</span></span></param>
        <param name="callingConvention"><span data-ttu-id="04e9c-783">Convenzione di chiamata delle funzioni di accesso della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-783">The calling convention of the property accessors.</span></span></param>
        <param name="returnType"><span data-ttu-id="04e9c-784">Tipo restituito della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-784">The return type of the property.</span></span></param>
        <param name="returnTypeRequiredCustomModifiers"><span data-ttu-id="04e9c-785">Matrice di tipi che rappresenta i modificatori personalizzati obbligatori, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-785">An array of types representing the required custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="04e9c-786">Se il tipo restituito non ha modificatori personalizzati obbligatori, specificare <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-786">If the return type has no required custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="returnTypeOptionalCustomModifiers"><span data-ttu-id="04e9c-787">Matrice di tipi che rappresenta i modificatori personalizzati facoltativi, come <see cref="T:System.Runtime.CompilerServices.IsConst" />, per il tipo restituito della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-787">An array of types representing the optional custom modifiers, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />, for the return type of the property.</span></span> <span data-ttu-id="04e9c-788">Se il tipo restituito non ha modificatori personalizzati facoltativi, specificare <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-788">If the return type has no optional custom modifiers, specify <see langword="null" />.</span></span></param>
        <param name="parameterTypes"><span data-ttu-id="04e9c-789">Tipi dei parametri della proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-789">The types of the parameters of the property.</span></span></param>
        <param name="parameterTypeRequiredCustomModifiers"><span data-ttu-id="04e9c-790">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-790">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-791">Ogni matrice di tipi rappresenta i modificatori personalizzati obbligatori per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-791">Each array of types represents the required custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-792">Se un parametro particolare non ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-792">If a particular parameter has no required custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-793">Se nessun parametro ha modificatori personalizzati obbligatori, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-793">If none of the parameters have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <param name="parameterTypeOptionalCustomModifiers"><span data-ttu-id="04e9c-794">Matrice di matrici di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-794">An array of arrays of types.</span></span> <span data-ttu-id="04e9c-795">Ogni matrice di tipi rappresenta i modificatori personalizzati facoltativi per il parametro corrispondente, come <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-795">Each array of types represents the optional custom modifiers for the corresponding parameter, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span> <span data-ttu-id="04e9c-796">Se un parametro particolare non ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-796">If a particular parameter has no optional custom modifiers, specify <see langword="null" /> instead of an array of types.</span></span> <span data-ttu-id="04e9c-797">Se nessun parametro ha modificatori personalizzati facoltativi, specificare <see langword="null" /> invece di una matrice di matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-797">If none of the parameters have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</span></span></param>
        <summary><span data-ttu-id="04e9c-798">Aggiunge una nuova proprietà al tipo, con il nome, la convenzione di chiamata, la firma e i modificatori personalizzati specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-798">Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</span></span></summary>
        <returns><span data-ttu-id="04e9c-799">Proprietà definita.</span><span class="sxs-lookup"><span data-stu-id="04e9c-799">The defined property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-800">Questo overload è disponibile per i progettisti di compilatori gestiti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-800">This overload is provided for designers of managed compilers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-801">Per altre informazioni sui modificatori personalizzati, vedere la documentazione ECMA Partition II metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-801">For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</span></span> <span data-ttu-id="04e9c-802">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="04e9c-802">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="04e9c-803">Questo overload del metodo è stato introdotto nel [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="04e9c-803">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-804">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-804">The length of <paramref name="name" /> is zero.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-805"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-805"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="04e9c-806">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-806">-or-</span></span> 
<span data-ttu-id="04e9c-807">Uno degli elementi della matrice <paramref name="parameterTypes" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-807">Any of the elements of the <paramref name="parameterTypes" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-808">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-808">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineTypeInitializer () As ConstructorBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ConstructorBuilder ^ DefineTypeInitializer();" />
      <MemberSignature Language="F#" Value="member this.DefineTypeInitializer : unit -&gt; System.Reflection.Emit.ConstructorBuilder" Usage="typeBuilder.DefineTypeInitializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-809">Definisce l'inizializzatore per questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-809">Defines the initializer for this type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-810">Restituisce un inizializzatore di tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-810">Returns a type initializer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-811">L'inizializzatore creato sempre è pubblico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-811">The initializer created is always public.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-812">Esempio di codice seguente viene illustrato come creare un costruttore di inizializzazione utilizzando `DefineTypeInitializer`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-812">The following code sample demonstrates how to create an initialization constructor using `DefineTypeInitializer`.</span></span>  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-813">Il tipo contenitore è stato creato in precedenza con <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-813">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="typeBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-814">Nome usato per fare riferimento ai dati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-814">The name used to refer to the data.</span></span> <span data-ttu-id="04e9c-815"><paramref name="name" /> non può contenere valori Null incorporati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-815"><paramref name="name" /> cannot contain embedded nulls.</span></span></param>
        <param name="size"><span data-ttu-id="04e9c-816">Dimensione del campo dati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-816">The size of the data field.</span></span></param>
        <param name="attributes"><span data-ttu-id="04e9c-817">Attributi per il campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-817">The attributes for the field.</span></span></param>
        <summary><span data-ttu-id="04e9c-818">Definisce un campo di dati non inizializzati nella sezione <see langword=".sdata" /> del file eseguibile di tipo PE.</span><span class="sxs-lookup"><span data-stu-id="04e9c-818">Defines an uninitialized data field in the <see langword=".sdata" /> section of the portable executable (PE) file.</span></span></summary>
        <returns><span data-ttu-id="04e9c-819">Campo di riferimento ai dati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-819">A field to reference the data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-820">Il campo creati con questo metodo sarà `static`, anche se non si include `FieldAttributes.Static` nel `attributes` parametro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-820">The field that you create with this method will be `static`, even if you do not include `FieldAttributes.Static` in the `attributes` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-821">Esempio di codice seguente viene illustrato l'utilizzo di `DefineUninitializedData` per creare un campo dati non inizializzati in un tipo dinamico:</span><span class="sxs-lookup"><span data-stu-id="04e9c-821">The following code sample demonstrates the use of `DefineUninitializedData` to create an uninitialized data field in a dynamic type:</span></span>  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-822">La lunghezza di <paramref name="name" /> è zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-822">Length of <paramref name="name" /> is zero.</span></span>  
  
<span data-ttu-id="04e9c-823">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-823">-or-</span></span> 
 <span data-ttu-id="04e9c-824"><paramref name="size" /> è minore di o uguale a zero oppure maggiore di o uguale a 0x003f0000.</span><span class="sxs-lookup"><span data-stu-id="04e9c-824"><paramref name="size" /> is less than or equal to zero, or greater than or equal to 0x003f0000.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-825"><paramref name="name" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-825"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-826">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-826">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-827">Recupera il percorso completo di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-827">Retrieves the full path of this type.</span></span></summary>
        <value><span data-ttu-id="04e9c-828">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-828">Read-only.</span></span> <span data-ttu-id="04e9c-829">Recupera il percorso completo di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-829">Retrieves the full path of this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-830">Il formato restituito è "NomeCompletoTipoInclusione + NomeTipoNidificato" per i tipi annidati e "typeName" per i tipi non annidata.</span><span class="sxs-lookup"><span data-stu-id="04e9c-830">The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-831">Ottiene un valore che indica la covarianza e i vincoli speciali del parametro di tipo generico corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-831">Gets a value that indicates the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="04e9c-832">Combinazione bit per bit di valori <see cref="T:System.Reflection.GenericParameterAttributes" /> che descrive la covariante e i vincoli speciali del parametro di tipo generico corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-832">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-833">Quando si crea il codice, un parametro di tipo generico è rappresentato da un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> oggetto anziché da un <xref:System.Reflection.Emit.TypeBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-833">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-834">Ottiene la posizione di un parametro di tipo nell'elenco dei parametri di tipo del tipo generico che ha dichiarato il parametro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-834">Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</span></span></summary>
        <value><span data-ttu-id="04e9c-835">Se l'oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> corrente rappresenta un parametro di tipo generico, la posizione del parametro di tipo nell'elenco di parametri di tipo del tipo generico che ha dichiarato il parametro; in caso contrario, non definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-835">If the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-836">Quando si crea il codice, un parametro di tipo generico è rappresentato da un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> oggetto anziché da un <xref:System.Reflection.Emit.TypeBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-836">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="04e9c-837">Se l'oggetto corrente <xref:System.Reflection.Emit.TypeBuilder> non rappresenta un parametro di tipo generico, il valore di questa proprietà è non definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-837">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent a generic type parameter, the value of this property is undefined.</span></span> <span data-ttu-id="04e9c-838">Usare la <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> proprietà per determinare se l'oggetto corrente <xref:System.Reflection.Emit.TypeBuilder> rappresenta un parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-838">Use the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property to determine whether the current <xref:System.Reflection.Emit.TypeBuilder> represents a generic type parameter.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetArrayRank();" />
      <MemberSignature Language="F#" Value="override this.GetArrayRank : unit -&gt; int" Usage="typeBuilder.GetArrayRank " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="override this.GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="typeBuilder.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::ConstructorInfo ^ GetConstructor(Type ^ type, System::Reflection::ConstructorInfo ^ constructor);" />
      <MemberSignature Language="F#" Value="static member GetConstructor : Type * System.Reflection.ConstructorInfo -&gt; System.Reflection.ConstructorInfo" Usage="System.Reflection.Emit.TypeBuilder.GetConstructor (type, constructor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="04e9c-839">Tipo generico creato di cui viene restituito il costruttore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-839">The constructed generic type whose constructor is returned.</span></span></param>
        <param name="constructor"><span data-ttu-id="04e9c-840">Costruttore sulla definizione di tipo generico dell'oggetto <paramref name="type" />, che specifica il costruttore di <paramref name="type" /> da restituire.</span><span class="sxs-lookup"><span data-stu-id="04e9c-840">A constructor on the generic type definition of <paramref name="type" />, which specifies which constructor of <paramref name="type" /> to return.</span></span></param>
        <summary><span data-ttu-id="04e9c-841">Restituisce il costruttore del tipo generico costruito specificato che corrisponde al costruttore specificato della definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-841">Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</span></span></summary>
        <returns><span data-ttu-id="04e9c-842">Oggetto <see cref="T:System.Reflection.ConstructorInfo" /> che rappresenta il costruttore di <paramref name="type" /> corrispondente a <paramref name="constructor" />, che specifica un costruttore appartenente alla definizione di tipo generico di <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-842">A <see cref="T:System.Reflection.ConstructorInfo" /> object that represents the constructor of <paramref name="type" /> corresponding to <paramref name="constructor" />, which specifies a constructor belonging to the generic type definition of <paramref name="type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-843">Il <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> metodo fornisce un modo per ottenere un <xref:System.Reflection.ConstructorInfo> che rappresenta un costruttore di un tipo generico costruito, la cui definizione di tipo generico è rappresentato da un <xref:System.Reflection.Emit.TypeBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-843">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method provides a way to get a <xref:System.Reflection.ConstructorInfo> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="04e9c-844">Ad esempio, si supponga di avere un <xref:System.Reflection.Emit.TypeBuilder> oggetto che rappresenta il tipo `G<T>` nella sintassi di c# (`G(Of T)` in Visual Basic `generic <T> ref class G` in C++) e un <xref:System.Reflection.Emit.ConstructorBuilder> oggetto che rappresenta un costruttore di `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-844">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.ConstructorBuilder> object that represents a constructor of `G<T>`.</span></span> <span data-ttu-id="04e9c-845">Si supponga che `G<T>` dispone di un metodo generico con parametro di tipo `U` che crea un'istanza del tipo costruito `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-845">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>`.</span></span> <span data-ttu-id="04e9c-846">Per emettere il codice per creare un'istanza del tipo costruito, è necessario un <xref:System.Reflection.ConstructorInfo> oggetto che rappresenta il costruttore di questo tipo costruito - in altre parole, che crea un'istanza di `G<U>`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-846">In order to emit the code to create an instance of the constructed type, you need a <xref:System.Reflection.ConstructorInfo> object that represents the constructor of this constructed type - in other words, that creates an instance of `G<U>`.</span></span> <span data-ttu-id="04e9c-847">A tale scopo, chiamare prima il <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metodo sul <xref:System.Reflection.Emit.TypeBuilder> dell'oggetto, che specifica il <xref:System.Reflection.Emit.GenericTypeParameterBuilder> che rappresenta `U` come argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-847">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="04e9c-848">Quindi chiamare il <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> con il valore restituito del metodo di <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metodo come parametro `type` e il <xref:System.Reflection.Emit.ConstructorBuilder> oggetto che rappresenta il costruttore di `G<U>` come parametro `constructor`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-848">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.ConstructorBuilder> object that represents the constructor of `G<U>` as parameter `constructor`.</span></span> <span data-ttu-id="04e9c-849">Il valore restituito è il <xref:System.Reflection.ConstructorInfo> oggetto necessario per creare la chiamata di funzione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-849">The return value is the <xref:System.Reflection.ConstructorInfo> object you need to emit the function call.</span></span> <span data-ttu-id="04e9c-850">L'esempio di codice illustra questo scenario.</span><span class="sxs-lookup"><span data-stu-id="04e9c-850">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-851">Esempio di codice seguente contiene il codice sorgente per una classe generica denominata `Sample` che include un parametro di tipo denominato `T`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-851">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="04e9c-852">La classe dispone di un campo denominato `Field`, di tipo `T`e un metodo generico denominato `GM` con il proprio parametro di tipo denominato `U`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-852">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="04e9c-853">Metodo `GM` crea un'istanza di `Sample`, sostituendo il parametro di tipo `U` per il parametro di tipo `Sample`e archivia il parametro di input in `Field`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-853">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="04e9c-854">Questo codice sorgente viene compilato ma non usato; è possibile visualizzarla con il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) e confrontarlo con il codice generato dalla classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-854">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="04e9c-855">Il codice nella classe `Example` viene illustrato come utilizzare il <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> metodo per generare codice generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-855">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method to emit generic code.</span></span> <span data-ttu-id="04e9c-856">Il `Main` metodo della classe `Example` crea un assembly dinamico che contiene una classe denominata `Sample` e viene utilizzato il <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> metodo per renderla generico aggiungendo un parametro di tipo denominato `T`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-856">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="04e9c-857">Un costruttore predefinito e un campo denominato `Field`, di tipo `T`, vengono aggiunti alla classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-857">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="04e9c-858">Un metodo `GM` viene aggiunto e trasformato in un metodo generico tramite le <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-858">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="04e9c-859">Il parametro di tipo `GM` denominato `U`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-859">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="04e9c-860">Dopo aver definito il parametro di tipo, la firma dei `GM` viene aggiunto tramite il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-860">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="04e9c-861">I modificatori personalizzati, pertanto, tutti i parametri di questo metodo sono o non disponibile alcun tipo restituito e nessun necessaria `null` eccetto `parameterTypes`; `parameterTypes` imposta il tipo del parametro unica del metodo da `U`, parametro di tipo generico del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-861">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="04e9c-862">Il corpo del metodo crea un'istanza del tipo costruito `Sample<U>` (`Sample(Of U)` in Visual Basic), assegna il parametro del metodo per `Field`e quindi stampato il valore di `Field`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-862">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="04e9c-863">Il <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> metodo viene utilizzato per creare un <xref:System.Reflection.ConstructorInfo> che rappresenta il costruttore predefinito del tipo generico costruito `Sample<U>` nel <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> istruzione che crea l'istanza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-863">The <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> method is used to create a <xref:System.Reflection.ConstructorInfo> that represents the default constructor of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instruction that creates the instance.</span></span>  
  
 <span data-ttu-id="04e9c-864">Viene definito un tipo fittizio che contenga il metodo del punto di ingresso `Main`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-864">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="04e9c-865">Nel corpo della `Main`, il metodo statico `GM` metodo viene richiamato sul tipo generico costruito `Sample<int>` (`Sample(Of Integer)` in Visual Basic), con il tipo <xref:System.String> sostituito `U`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-865">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="04e9c-866">Quando viene eseguito l'esempio di codice, Salva l'assembly generato come TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-866">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="04e9c-867">È possibile eseguire TypeBuilderGetFieldExample.exe ed è possibile usare la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per confrontare il codice generato con il codice per il `Sample` classe che viene compilato nell'esempio di codice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-867">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-868"><paramref name="type" /> non rappresenta un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-868"><paramref name="type" /> does not represent a generic type.</span></span>  
  
<span data-ttu-id="04e9c-869">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-869">-or-</span></span> 
 <span data-ttu-id="04e9c-870"><paramref name="type" /> non è di tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-870"><paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span>  
  
<span data-ttu-id="04e9c-871">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-871">-or-</span></span> 
<span data-ttu-id="04e9c-872">Il tipo dichiarante di <paramref name="constructor" /> non è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-872">The declaring type of <paramref name="constructor" /> is not a generic type definition.</span></span>  
  
<span data-ttu-id="04e9c-873">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-873">-or-</span></span> 
<span data-ttu-id="04e9c-874">Il tipo dichiarante di <paramref name="constructor" /> non è la definizione di tipo generico di <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-874">The declaring type of <paramref name="constructor" /> is not the generic type definition of <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="typeBuilder.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="typeBuilder.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="04e9c-875">Deve essere un flag di bit di <see cref="T:System.Reflection.BindingFlags" />, come in <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</span><span class="sxs-lookup"><span data-stu-id="04e9c-875">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="04e9c-876">Restituisce una matrice di oggetti <see cref="T:System.Reflection.ConstructorInfo" /> che rappresentano i costruttori pubblici e non pubblici definiti per questa classe, come specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-876">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the public and non-public constructors defined for this class, as specified.</span></span></summary>
        <returns><span data-ttu-id="04e9c-877">Restituisce una matrice di oggetti <see cref="T:System.Reflection.ConstructorInfo" /> che rappresentano i costruttori specificati definiti per questa classe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-877">Returns an array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing the specified constructors defined for this class.</span></span> <span data-ttu-id="04e9c-878">Se non è stato definito alcun costruttore, verrà restituita una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="04e9c-878">If no constructors are defined, an empty array is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-879">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-879">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-880">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-880">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-881">Restituisce gli attributi personalizzati definiti per questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-881">Returns the custom attributes defined for this type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="04e9c-882">Specifica se trovare gli attributi cercandoli nella catena di ereditarietà del membro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-882">Specifies whether to search this member's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="04e9c-883">Restituisce tutti gli attributi personalizzati definiti per questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-883">Returns all the custom attributes defined for this type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-884">Restituisce una matrice di oggetti che rappresentano tutti gli attributi personalizzati di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-884">Returns an array of objects representing all the custom attributes of this type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-885">Questo metodo non è attualmente supportato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-885">This method is not currently supported for incomplete types.</span></span> <span data-ttu-id="04e9c-886">Recuperare il tipo usando <see cref="M:System.Type.GetType" /> e chiamare <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> nell'oggetto <see cref="T:System.Type" /> restituito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-886">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="typeBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="04e9c-887">Tipo di attributo da cercare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-887">The type of attribute to search for.</span></span> <span data-ttu-id="04e9c-888">Vengono restituiti solo gli attributi assegnabili a questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-888">Only attributes that are assignable to this type are returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="04e9c-889">Specifica se trovare gli attributi cercandoli nella catena di ereditarietà del membro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-889">Specifies whether to search this member's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="04e9c-890">Restituisce tutti gli attributi personalizzati del tipo corrente che è possibile assegnare a un tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-890">Returns all the custom attributes of the current type that are assignable to a specified type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-891">Matrice di attributi personalizzati definiti per il tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-891">An array of custom attributes defined on the current type.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-892">Questo metodo non è attualmente supportato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-892">This method is not currently supported for incomplete types.</span></span> <span data-ttu-id="04e9c-893">Recuperare il tipo usando <see cref="M:System.Type.GetType" /> e chiamare <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> nell'oggetto <see cref="T:System.Type" /> restituito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-893">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-894"><paramref name="attributeType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-894"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-895">Il tipo deve essere uno di quelli forniti dal sistema di runtime sottostante.</span><span class="sxs-lookup"><span data-stu-id="04e9c-895">The type must be a type provided by the underlying runtime system.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="override this.GetElementType : unit -&gt; Type" Usage="typeBuilder.GetElementType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-896">La chiamata di questo metodo genera sempre un'eccezione <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-896">Calling this method always throws <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="04e9c-897">Questo metodo non è supportato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-897">This method is not supported.</span></span> <span data-ttu-id="04e9c-898">Non vengono restituiti valori.</span><span class="sxs-lookup"><span data-stu-id="04e9c-898">No value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-899">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-899">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-900">Questo metodo non è supportato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-900">This method is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="typeBuilder.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-901">Nome dell'evento di cui eseguire la ricerca.</span><span class="sxs-lookup"><span data-stu-id="04e9c-901">The name of the event to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="04e9c-902">Combinazione bit per bit dei valori <see cref="T:System.Reflection.BindingFlags" /> che limita la ricerca.</span><span class="sxs-lookup"><span data-stu-id="04e9c-902">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span></span></param>
        <summary><span data-ttu-id="04e9c-903">Restituisce l'evento con il nome specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-903">Returns the event with the specified name.</span></span></summary>
        <returns><span data-ttu-id="04e9c-904">Oggetto <see cref="T:System.Reflection.EventInfo" /> che rappresenta l'evento dichiarato o ereditato da questo tipo con il nome specificato o <see langword="null" /> in assenza di corrispondenze.</span><span class="sxs-lookup"><span data-stu-id="04e9c-904">An <see cref="T:System.Reflection.EventInfo" /> object representing the event declared or inherited by this type with the specified name, or <see langword="null" /> if there are no matches.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-905">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-905">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-906">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-906">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-907">Restituisce gli eventi definiti dal <see cref="T:System.Reflection.Emit.TypeBuilder" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-907">Returns the events defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-908">Restituisce gli eventi pubblici dichiarati o ereditati da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-908">Returns the public events declared or inherited by this type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-909">Restituisce una matrice di oggetti <see cref="T:System.Reflection.EventInfo" /> che rappresentano gli eventi pubblici dichiarati o ereditati da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-909">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the public events declared or inherited by this type.</span></span> <span data-ttu-id="04e9c-910">In assenza di eventi pubblici, viene restituita una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="04e9c-910">An empty array is returned if there are no public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-911">Recuperare il tipo usando <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetType%2A> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-911">Retrieve the type using <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetType%2A> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-912">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-912">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="typeBuilder.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="04e9c-913">Combinazione bit per bit dei valori <see cref="T:System.Reflection.BindingFlags" /> che limita la ricerca.</span><span class="sxs-lookup"><span data-stu-id="04e9c-913">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values that limits the search.</span></span></param>
        <summary><span data-ttu-id="04e9c-914">Restituisce gli eventi pubblici e non pubblici dichiarati da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-914">Returns the public and non-public events that are declared by this type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-915">Restituisce una matrice di oggetti <see cref="T:System.Reflection.EventInfo" /> che rappresentano gli eventi dichiarati o ereditati da questo tipo che corrispondono ai flag di associazione specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-915">Returns an array of <see cref="T:System.Reflection.EventInfo" /> objects representing the events declared or inherited by this type that match the specified binding flags.</span></span> <span data-ttu-id="04e9c-916">In assenza di eventi corrispondenti, viene restituita una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="04e9c-916">An empty array is returned if there are no matching events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-917">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-917">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-918">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-918">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-919">Restituisce un campo definito dall'oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-919">Returns a field defined by the current <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="typeBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-920">Nome del campo da ottenere.</span><span class="sxs-lookup"><span data-stu-id="04e9c-920">The name of the field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="04e9c-921">Deve essere un flag di bit di <see cref="T:System.Reflection.BindingFlags" />, come in <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</span><span class="sxs-lookup"><span data-stu-id="04e9c-921">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="04e9c-922">Restituisce il campo specificato con il nome specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-922">Returns the field specified by the given name.</span></span></summary>
        <returns><span data-ttu-id="04e9c-923">Restituisce l'oggetto <see cref="T:System.Reflection.FieldInfo" /> che rappresenta il campo dichiarato o ereditato da questo tipo con il nome specificato e il modificatore pubblico o non pubblico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-923">Returns the <see cref="T:System.Reflection.FieldInfo" /> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</span></span> <span data-ttu-id="04e9c-924">Se non sono presenti corrispondenze, verrà restituito <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-924">If there are no matches then <see langword="null" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-925">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-925">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-926">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-926">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetField(Type ^ type, System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="static member GetField : Type * System.Reflection.FieldInfo -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.Emit.TypeBuilder.GetField (type, field)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="04e9c-927">Il tipo generico creato di cui viene restituito il campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-927">The constructed generic type whose field is returned.</span></span></param>
        <param name="field"><span data-ttu-id="04e9c-928">Campo sulla definizione di tipo generico dell'oggetto <paramref name="type" />, che specifica il campo di <paramref name="type" /> da restituire.</span><span class="sxs-lookup"><span data-stu-id="04e9c-928">A field on the generic type definition of <paramref name="type" />, which specifies which field of <paramref name="type" /> to return.</span></span></param>
        <summary><span data-ttu-id="04e9c-929">Restituisce il campo del tipo generico specificato che corrisponde al campo specificato della definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-929">Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</span></span></summary>
        <returns><span data-ttu-id="04e9c-930">Oggetto <see cref="T:System.Reflection.FieldInfo" /> che rappresenta il campo di <paramref name="type" /> corrispondente a <paramref name="field" />, che specifica un campo appartenente alla definizione di tipo generico di <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-930">A <see cref="T:System.Reflection.FieldInfo" /> object that represents the field of <paramref name="type" /> corresponding to <paramref name="field" />, which specifies a field belonging to the generic type definition of <paramref name="type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-931">Il <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> metodo fornisce un modo per ottenere un <xref:System.Reflection.FieldInfo> che rappresenta un campo di un tipo generico costruito, la cui definizione di tipo generico è rappresentato da un <xref:System.Reflection.Emit.TypeBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-931">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method provides a way to get a <xref:System.Reflection.FieldInfo> object that represents a field of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="04e9c-932">Ad esempio, si supponga di disporre un <xref:System.Reflection.Emit.TypeBuilder> oggetto che rappresenta il tipo `G<T>` nella sintassi di c# (`G(Of T)` in Visual Basic `generic <T> ref class G` in C++) e un <xref:System.Reflection.Emit.FieldBuilder> oggetto che rappresenta un campo `public T F` nella sintassi di c# (`Public F As T`in Visual Basic `public: T F` in C++) che è definito da `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-932">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.FieldBuilder> object that represents a field `public T F` in C# syntax (`Public F As T` in Visual Basic, `public: T F` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="04e9c-933">Si supponga che `G<T>` dispone di un metodo generico con parametro di tipo `U` che crea un'istanza del tipo costruito `G<U>` e il campo chiamate `F` su quell'istanza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-933">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls field `F` on that instance.</span></span> <span data-ttu-id="04e9c-934">Per emettere la chiamata di funzione, è necessario un <xref:System.Reflection.FieldInfo> oggetto che rappresenta `F` nel tipo costruito - in altre parole, che è di tipo `U` invece di tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-934">In order to emit the function call, you need a <xref:System.Reflection.FieldInfo> object that represents `F` on the constructed type - in other words, that is of type `U` rather than type `T`.</span></span> <span data-ttu-id="04e9c-935">A tale scopo, chiamare prima il <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metodo sul <xref:System.Reflection.Emit.TypeBuilder> dell'oggetto, che specifica il <xref:System.Reflection.Emit.GenericTypeParameterBuilder> che rappresenta `U` come argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-935">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="04e9c-936">Quindi chiamare il <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> con il valore restituito del metodo di <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metodo come parametro `type` e il <xref:System.Reflection.Emit.FieldBuilder> oggetto che rappresenta `F` come parametro `field`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-936">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.FieldBuilder> object that represents `F` as parameter `field`.</span></span> <span data-ttu-id="04e9c-937">Il valore restituito è il <xref:System.Reflection.FieldInfo> oggetto necessario per creare la chiamata di funzione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-937">The return value is the <xref:System.Reflection.FieldInfo> object you need to emit the function call.</span></span> <span data-ttu-id="04e9c-938">L'esempio di codice illustra questo scenario.</span><span class="sxs-lookup"><span data-stu-id="04e9c-938">The code example demonstrates this scenario.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-939">Esempio di codice seguente contiene il codice sorgente per una classe generica denominato Sample con un parametro di tipo denominato `T`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-939">The following code example contains source code for a generic class named Sample that has a type parameter named `T`.</span></span> <span data-ttu-id="04e9c-940">La classe dispone di un campo denominato `Field`, di tipo `T`e un metodo generico denominato `GM` con il proprio parametro di tipo denominato `U`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-940">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="04e9c-941">Metodo `GM` crea un'istanza di `Sample`, sostituendo il parametro di tipo `U` per il parametro di tipo `Sample`e archivia il parametro di input in `Field`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-941">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="04e9c-942">Questo codice sorgente viene compilato ma non usato; è possibile visualizzarla con il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) e confrontarlo con il codice generato dalla classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-942">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="04e9c-943">Il codice nella classe `Example` viene illustrato come utilizzare il <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> metodo per generare codice generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-943">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method to emit generic code.</span></span> <span data-ttu-id="04e9c-944">Il `Main` metodo della classe `Example` crea un assembly dinamico che contiene una classe denominata `Sample`e Usa le <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> metodo per renderla generico aggiungendo un parametro di tipo denominato `T`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-944">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample`, and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="04e9c-945">Un costruttore predefinito e un campo denominato `Field`, di tipo `T`, vengono aggiunti alla classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-945">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="04e9c-946">Un metodo `GM` viene aggiunto e trasformato in un metodo generico tramite le <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-946">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="04e9c-947">Il parametro di tipo `GM` denominato `U`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-947">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="04e9c-948">Dopo aver definito il parametro di tipo, la firma dei `GM` viene aggiunto tramite il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-948">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="04e9c-949">I modificatori personalizzati, pertanto, tutti i parametri di questo metodo sono o non disponibile alcun tipo restituito e nessun necessaria `null` eccetto `parameterTypes`; `parameterTypes` imposta il tipo del parametro unica del metodo da `U`, parametro di tipo generico del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-949">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="04e9c-950">Il corpo del metodo crea un'istanza del tipo costruito `Sample<U>` (`Sample(Of U)` in Visual Basic), assegna il parametro del metodo per `Field`e quindi stampato il valore di `Field`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-950">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="04e9c-951">Il <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> metodo viene utilizzato per creare un <xref:System.Reflection.FieldInfo> che rappresenta il campo del tipo generico costruito `Sample<U>` nel <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> e <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> istruzioni.</span><span class="sxs-lookup"><span data-stu-id="04e9c-951">The <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> method is used to create a <xref:System.Reflection.FieldInfo> that represents the field of the constructed generic type `Sample<U>` in the <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> and <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instructions.</span></span>  
  
 <span data-ttu-id="04e9c-952">Viene definito un tipo fittizio che contenga il metodo del punto di ingresso `Main`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-952">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="04e9c-953">Nel corpo della `Main`, il metodo statico `GM` metodo viene richiamato sul tipo generico costruito `Sample<int>` (`Sample(Of Integer)` in Visual Basic), con il tipo <xref:System.String> sostituito `U`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-953">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span>  
  
 <span data-ttu-id="04e9c-954">Quando viene eseguito l'esempio di codice, Salva l'assembly generato come TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-954">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="04e9c-955">È possibile eseguire TypeBuilderGetFieldExample.exe ed è possibile usare la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per confrontare il codice generato con il codice per il `Sample` classe che viene compilato nell'esempio di codice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-955">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-956"><paramref name="type" /> non rappresenta un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-956"><paramref name="type" /> does not represent a generic type.</span></span>  
  
<span data-ttu-id="04e9c-957">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-957">-or-</span></span> 
 <span data-ttu-id="04e9c-958"><paramref name="type" /> non è di tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-958"><paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span>  
  
<span data-ttu-id="04e9c-959">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-959">-or-</span></span> 
<span data-ttu-id="04e9c-960">Il tipo dichiarante di <paramref name="field" /> non è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-960">The declaring type of <paramref name="field" /> is not a generic type definition.</span></span>  
  
<span data-ttu-id="04e9c-961">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-961">-or-</span></span> 
<span data-ttu-id="04e9c-962">Il tipo dichiarante di <paramref name="field" /> non è la definizione di tipo generico di <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-962">The declaring type of <paramref name="field" /> is not the generic type definition of <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="typeBuilder.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="04e9c-963">Deve essere un flag di bit di <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</span><span class="sxs-lookup"><span data-stu-id="04e9c-963">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="04e9c-964">Restituisce i campi pubblici e non pubblici dichiarati da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-964">Returns the public and non-public fields that are declared by this type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-965">Restituisce una matrice di oggetti <see cref="T:System.Reflection.FieldInfo" /> che rappresentano i campi pubblici e non pubblici dichiarati o ereditati da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-965">Returns an array of <see cref="T:System.Reflection.FieldInfo" /> objects representing the public and non-public fields declared or inherited by this type.</span></span> <span data-ttu-id="04e9c-966">In assenza di campi, viene restituita una matrice vuota, come specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-966">An empty array is returned if there are no fields, as specified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-967">Il <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> metodo non restituisce i campi in un ordine specifico, ad esempio in ordine alfabetico o un ordine di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-967">The <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="04e9c-968">Il codice non deve dipendere l'ordine in cui vengono restituiti i campi, dal momento che quest'ordine può variare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-968">Your code must not depend on the order in which fields are returned, because that order can vary.</span></span>  
  
 <span data-ttu-id="04e9c-969">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-969">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-970">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-970">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="typeBuilder.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-971">Restituisce una matrice di oggetti <see cref="T:System.Type" /> che rappresentano gli argomenti tipo di un tipo generico o i parametri di tipo di una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-971">Returns an array of <see cref="T:System.Type" /> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="04e9c-972">Matrice di oggetti <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-972">An array of <see cref="T:System.Type" /> objects.</span></span> <span data-ttu-id="04e9c-973">Gli elementi della matrice rappresentano gli argomenti tipo di un tipo generico o i parametri di tipo di una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-973">The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-974">Gli elementi della matrice restituita sono nell'ordine in cui vengono visualizzati nell'elenco dei parametri di tipo per la definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-974">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</span></span>  
  
 <span data-ttu-id="04e9c-975">Oggetto <xref:System.Reflection.Emit.TypeBuilder> oggetto rappresenta una definizione di tipo generico, se il <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> metodo è stato usato per fornire parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-975">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="04e9c-976">Questo metodo recupera il <xref:System.Reflection.Emit.GenericTypeParameterBuilder> gli oggetti che rappresentano i parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-976">This method retrieves the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objects that represent the generic type parameters.</span></span>  
  
 <span data-ttu-id="04e9c-977">Per altre informazioni sui tipi generici nella reflection e un elenco delle condizioni invariabili relative ai termini usati nel processo di reflection generico, vedere il <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-977">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericArguments" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="typeBuilder.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="typeBuilder.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-978">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una definizione di tipo generico da cui è possibile ottenere il tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-978">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current type can be obtained.</span></span></summary>
        <returns><span data-ttu-id="04e9c-979">Oggetto <see cref="T:System.Type" /> che rappresenta una definizione di tipo generico da cui è possibile ottenere il tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-979">A <see cref="T:System.Type" /> object representing a generic type definition from which the current type can be obtained.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-980">Se si chiama il <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> metodo su un <xref:System.Reflection.Emit.TypeBuilder> oggetto per il quale il <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> restituisce proprietà `true`, il <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> proprietà restituisce l'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-980">If you call the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> object for which the <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> property returns `true`, the <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> property returns the current instance.</span></span> <span data-ttu-id="04e9c-981">Oggetto <xref:System.Reflection.Emit.TypeBuilder> che rappresenta un tipo generico è sempre una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-981">A <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type is always a generic type definition.</span></span>  
  
 <span data-ttu-id="04e9c-982">Se è stata usata la <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metodo per costruire un tipo generico da una <xref:System.Reflection.Emit.TypeBuilder> oggetto che rappresenta una definizione di tipo generico, usando la <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> metodo nel tipo costruito ottiene nuovamente il <xref:System.Reflection.Emit.TypeBuilder> oggetto che rappresenta il tipo generico definizione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-982">If you used the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method to construct a generic type from a <xref:System.Reflection.Emit.TypeBuilder> object that represents a generic type definition, using the <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> method on the constructed type gets back the <xref:System.Reflection.Emit.TypeBuilder> object that represents the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-983">Il tipo corrente non è generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-983">The current type is not generic.</span></span> <span data-ttu-id="04e9c-984">Ciò significa che <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> restituisce <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-984">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetInterface : string * bool -&gt; Type" Usage="typeBuilder.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-985">Nome dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-985">The name of the interface.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="04e9c-986">Se <see langword="true" />, la ricerca non fa distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="04e9c-986">If <see langword="true" />, the search is case-insensitive.</span></span> <span data-ttu-id="04e9c-987">Se <see langword="false" />, la ricerca fa distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="04e9c-987">If <see langword="false" />, the search is case-sensitive.</span></span></param>
        <summary><span data-ttu-id="04e9c-988">Restituisce l'interfaccia implementata (direttamente o indirettamente) da questa classe, con il nome completo corrispondente al nome di interfaccia specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-988">Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</span></span></summary>
        <returns><span data-ttu-id="04e9c-989">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta l'interfaccia implementata.</span><span class="sxs-lookup"><span data-stu-id="04e9c-989">Returns a <see cref="T:System.Type" /> object representing the implemented interface.</span></span> <span data-ttu-id="04e9c-990">Restituisce Null se non viene trovato alcun nome di interfaccia corrispondente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-990">Returns null if no interface matching name is found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-991">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-991">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-992">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-992">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="typeBuilder.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="04e9c-993">Oggetto <see cref="T:System.Type" /> dell'interfaccia per cui recuperare il mapping.</span><span class="sxs-lookup"><span data-stu-id="04e9c-993">The <see cref="T:System.Type" /> of the interface for which the mapping is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="04e9c-994">Restituisce un mapping di interfaccia per l'interfaccia richiesta.</span><span class="sxs-lookup"><span data-stu-id="04e9c-994">Returns an interface mapping for the requested interface.</span></span></summary>
        <returns><span data-ttu-id="04e9c-995">Restituisce il mapping dell'interfaccia richiesto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-995">Returns the requested interface mapping.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-996">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-996">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-997">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-997">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="override this.GetInterfaces : unit -&gt; Type[]" Usage="typeBuilder.GetInterfaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-998">Restituisce una matrice di tutte le interfacce implementate nel tipo e nei relativi tipi di base.</span><span class="sxs-lookup"><span data-stu-id="04e9c-998">Returns an array of all the interfaces implemented on this type and its base types.</span></span></summary>
        <returns><span data-ttu-id="04e9c-999">Restituisce una matrice di oggetti <see cref="T:System.Type" /> che rappresentano le interfacce implementate.</span><span class="sxs-lookup"><span data-stu-id="04e9c-999">Returns an array of <see cref="T:System.Type" /> objects representing the implemented interfaces.</span></span> <span data-ttu-id="04e9c-1000">Se non è stata definita alcuna interfaccia, viene restituita una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1000">If none are defined, an empty array is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-1001">Nome del membro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1001">The name of the member.</span></span></param>
        <param name="type"><span data-ttu-id="04e9c-1002">Tipo del membro da restituire.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1002">The type of the member to return.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="04e9c-1003">Deve essere un flag di bit di <see cref="T:System.Reflection.BindingFlags" />, come in <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1003">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="04e9c-1004">Restituisce tutti i membri pubblici e non pubblici dichiarati o ereditati da questo tipo, come specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1004">Returns all the public and non-public members declared or inherited by this type, as specified.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1005">Restituisce una matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri pubblici e non pubblici definiti sul tipo se è usato il parametro <paramref name="nonPublic" />; in caso contrario, vengono restituiti solo i membri pubblici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1005">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public members are returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1006">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1006">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1007">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1007">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="typeBuilder.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="04e9c-1008">Deve essere un flag di bit di <see cref="T:System.Reflection.BindingFlags" />, ad esempio <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1008">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, such as <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="04e9c-1009">Restituisce i membri per i membri pubblici e non pubblici dichiarati o ereditati da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1009">Returns the members for the public and non-public members declared or inherited by this type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1010">Restituisce una matrice di oggetti <see cref="T:System.Reflection.MemberInfo" /> che rappresentano i membri pubblici o non pubblici dichiarati o ereditati da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1010">Returns an array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public and non-public members declared or inherited by this type.</span></span> <span data-ttu-id="04e9c-1011">In assenza di membri corrispondenti, viene restituita una matrice vuota.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1011">An empty array is returned if there are no matching members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1012">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1012">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1013">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1013">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodInfo ^ GetMethod(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member GetMethod : Type * System.Reflection.MethodInfo -&gt; System.Reflection.MethodInfo" Usage="System.Reflection.Emit.TypeBuilder.GetMethod (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="04e9c-1014">Tipo generico costruito di cui viene restituito il metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1014">The constructed generic type whose method is returned.</span></span></param>
        <param name="method"><span data-ttu-id="04e9c-1015">Metodo sulla definizione di tipo generico dell'oggetto <paramref name="type" />, che specifica quale metodo di <paramref name="type" /> restituire.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1015">A method on the generic type definition of <paramref name="type" />, which specifies which method of <paramref name="type" /> to return.</span></span></param>
        <summary><span data-ttu-id="04e9c-1016">Restituisce il metodo del tipo generico costruito specificato che corrisponde al metodo specificato della definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1016">Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1017">Un oggetto <see cref="T:System.Reflection.MethodInfo" /> che rappresenta il metodo di <paramref name="type" /> corrispondente a <paramref name="method" />, che specifica un metodo appartenente alla definizione di tipo generico di <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1017">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the method of <paramref name="type" /> corresponding to <paramref name="method" />, which specifies a method belonging to the generic type definition of <paramref name="type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1018">Il <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> metodo fornisce un modo per ottenere un <xref:System.Reflection.MethodInfo> che rappresenta un metodo di un tipo generico costruito, la cui definizione di tipo generico è rappresentato da un <xref:System.Reflection.Emit.TypeBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1018">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method provides a way to get a <xref:System.Reflection.MethodInfo> object that represents a method of a constructed generic type whose generic type definition is represented by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 <span data-ttu-id="04e9c-1019">Ad esempio, si supponga di disporre un <xref:System.Reflection.Emit.TypeBuilder> oggetto che rappresenta il tipo `G<T>` nella sintassi di c# (`G(Of T)` in Visual Basic `generic <T> ref class G` in C++) e un <xref:System.Reflection.Emit.MethodBuilder> oggetto che rappresenta un metodo `T M()` nella sintassi di c# (`Function M() As T`in Visual Basic `T M()` in C++) che è definito da `G<T>`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1019">For example, suppose you have a <xref:System.Reflection.Emit.TypeBuilder> object that represents the type `G<T>` in C# syntax (`G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) and a <xref:System.Reflection.Emit.MethodBuilder> object that represents a method `T M()` in C# syntax (`Function M() As T` in Visual Basic, `T M()` in C++) that is defined by `G<T>`.</span></span> <span data-ttu-id="04e9c-1020">Si supponga che `G<T>` dispone di un metodo generico con parametro di tipo `U` che crea un'istanza del tipo costruito `G<U>` e chiama il metodo `M` su quell'istanza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1020">Suppose that `G<T>` has a generic method with type parameter `U` that creates an instance of the constructed type `G<U>` and calls method `M` on that instance.</span></span> <span data-ttu-id="04e9c-1021">Per emettere la chiamata di funzione, è necessario un <xref:System.Reflection.MethodInfo> oggetto che rappresenta `M` nel tipo costruito - in altre parole, che restituirà il tipo `U` invece di tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1021">In order to emit the function call, you need a <xref:System.Reflection.MethodInfo> object that represents `M` on the constructed type - in other words, that returns type `U` rather than type `T`.</span></span> <span data-ttu-id="04e9c-1022">A tale scopo, chiamare prima il <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metodo sul <xref:System.Reflection.Emit.TypeBuilder> dell'oggetto, che specifica il <xref:System.Reflection.Emit.GenericTypeParameterBuilder> che rappresenta `U` come argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1022">To do this, first call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on the <xref:System.Reflection.Emit.TypeBuilder> object, specifying the <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object that represents `U` as the type argument.</span></span> <span data-ttu-id="04e9c-1023">Quindi chiamare il <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> con il valore restituito del metodo di <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metodo come parametro `type` e il <xref:System.Reflection.Emit.MethodBuilder> oggetto che rappresenta `T M()` come parametro `method`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1023">Then call the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method with the return value of the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method as parameter `type` and the <xref:System.Reflection.Emit.MethodBuilder> object that represents `T M()` as parameter `method`.</span></span> <span data-ttu-id="04e9c-1024">Il valore restituito è il <xref:System.Reflection.MethodInfo> oggetto necessario per creare la chiamata di funzione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1024">The return value is the <xref:System.Reflection.MethodInfo> object you need to emit the function call.</span></span> <span data-ttu-id="04e9c-1025">L'esempio di codice viene illustrato uno scenario simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1025">The code example demonstrates a scenario similar to this.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-1026">Esempio di codice seguente contiene il codice sorgente per una classe generica denominata `Sample` che include un parametro di tipo denominato `T`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1026">The following code example contains source code for a generic class named `Sample` that has a type parameter named `T`.</span></span> <span data-ttu-id="04e9c-1027">La classe dispone di un campo denominato `Field`, di tipo `T`e un metodo generico denominato `GM` con il proprio parametro di tipo denominato `U`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1027">The class has a field named `Field`, of type `T`, and a generic method named `GM` with its own type parameter, named `U`.</span></span> <span data-ttu-id="04e9c-1028">Metodo `GM` crea un'istanza di `Sample`, sostituendo il parametro di tipo `U` per il parametro di tipo `Sample`e archivia il parametro di input in `Field`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1028">Method `GM` creates an instance of `Sample`, substituting its own type parameter `U` for the type parameter of `Sample`, and stores its input parameter in `Field`.</span></span> <span data-ttu-id="04e9c-1029">Questo codice sorgente viene compilato ma non usato; è possibile visualizzarla con il [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) e confrontarlo con il codice generato dalla classe `Example`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1029">This source code is compiled but not used; you can view it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) and compare it to the code emitted by class `Example`.</span></span>  
  
 <span data-ttu-id="04e9c-1030">Il codice nella classe `Example` viene illustrato come utilizzare il <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> metodo per generare codice generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1030">The code in class `Example` demonstrates the use of the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method to emit generic code.</span></span> <span data-ttu-id="04e9c-1031">Il `Main` metodo della classe `Example` crea un assembly dinamico che contiene una classe denominata `Sample` e viene utilizzato il <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> metodo per renderla generico aggiungendo un parametro di tipo denominato `T`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1031">The `Main` method of class `Example` creates a dynamic assembly containing a class named `Sample` and uses the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method to make it generic by adding a type parameter named `T`.</span></span> <span data-ttu-id="04e9c-1032">Un costruttore predefinito e un campo denominato `Field`, di tipo `T`, vengono aggiunti alla classe `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1032">A default constructor and a field named `Field`, of type `T`, are added to class `Sample`.</span></span> <span data-ttu-id="04e9c-1033">Un metodo `GM` viene aggiunto e trasformato in un metodo generico tramite le <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1033">A method `GM` is added and turned into a generic method by using the <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="04e9c-1034">Il parametro di tipo `GM` denominato `U`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1034">The type parameter of `GM` is named `U`.</span></span> <span data-ttu-id="04e9c-1035">Dopo aver definito il parametro di tipo, la firma dei `GM` viene aggiunto tramite il <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1035">After the type parameter is defined, the signature of `GM` is added by using the <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="04e9c-1036">I modificatori personalizzati, pertanto, tutti i parametri di questo metodo sono o non disponibile alcun tipo restituito e nessun necessaria `null` eccetto `parameterTypes`; `parameterTypes` imposta il tipo del parametro unica del metodo da `U`, parametro di tipo generico del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1036">There is no return type and no required or custom modifiers, so all the parameters of this method are `null` except `parameterTypes`; `parameterTypes` sets the type of the method's only parameter to `U`, the method's generic type parameter.</span></span> <span data-ttu-id="04e9c-1037">Il corpo del metodo crea un'istanza del tipo costruito `Sample<U>` (`Sample(Of U)` in Visual Basic), assegna il parametro del metodo per `Field`e quindi stampato il valore di `Field`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1037">The body of the method creates an instance of the constructed type `Sample<U>` (`Sample(Of U)` in Visual Basic), assigns the method's parameter to `Field`, and then prints the value of `Field`.</span></span> <span data-ttu-id="04e9c-1038">Viene definito un tipo fittizio che contenga il metodo del punto di ingresso `Main`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1038">A dummy type is defined to hold the entry-point method `Main`.</span></span> <span data-ttu-id="04e9c-1039">Nel corpo della `Main`, il metodo statico `GM` metodo viene richiamato sul tipo generico costruito `Sample<int>` (`Sample(Of Integer)` in Visual Basic), con il tipo <xref:System.String> sostituito `U`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1039">In the body of `Main`, the static `GM` method is invoked on the constructed generic type `Sample<int>` (`Sample(Of Integer)` in Visual Basic), with type <xref:System.String> substituted for `U`.</span></span> <span data-ttu-id="04e9c-1040">Il <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> metodo viene utilizzato per creare un <xref:System.Reflection.MethodInfo> per il metodo statico `GM` metodo del tipo generico costruito `Sample<U>`e il <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> metodo viene quindi utilizzato per creare un <xref:System.Reflection.MethodInfo> che possono emessi in una chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1040">The <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> method is used to create a <xref:System.Reflection.MethodInfo> for the static `GM` method of the constructed generic type `Sample<U>`, and the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method is then used to create a <xref:System.Reflection.MethodInfo> that can emitted in a method call.</span></span>  
  
 <span data-ttu-id="04e9c-1041">Quando viene eseguito l'esempio di codice, Salva l'assembly generato come TypeBuilderGetFieldExample.exe.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1041">When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</span></span> <span data-ttu-id="04e9c-1042">È possibile eseguire TypeBuilderGetFieldExample.exe ed è possibile usare la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per confrontare il codice generato con il codice per il `Sample` classe che viene compilato nell'esempio di codice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1042">You can run TypeBuilderGetFieldExample.exe, and you can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to compare the emitted code with the code for the `Sample` class that is compiled into the code example itself.</span></span>  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-1043"><paramref name="method" /> è un metodo generico che non è una definizione di metodo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1043"><paramref name="method" /> is a generic method that is not a generic method definition.</span></span>  
  
<span data-ttu-id="04e9c-1044">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-1044">-or-</span></span> 
 <span data-ttu-id="04e9c-1045"><paramref name="type" /> non rappresenta un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1045"><paramref name="type" /> does not represent a generic type.</span></span>  
  
<span data-ttu-id="04e9c-1046">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-1046">-or-</span></span> 
 <span data-ttu-id="04e9c-1047"><paramref name="type" /> non è di tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1047"><paramref name="type" /> is not of type <see cref="T:System.Reflection.Emit.TypeBuilder" />.</span></span>  
  
<span data-ttu-id="04e9c-1048">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-1048">-or-</span></span> 
<span data-ttu-id="04e9c-1049">Il tipo dichiarante di <paramref name="method" /> non è una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1049">The declaring type of <paramref name="method" /> is not a generic type definition.</span></span>  
  
<span data-ttu-id="04e9c-1050">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-1050">-or-</span></span> 
<span data-ttu-id="04e9c-1051">Il tipo dichiarante di <paramref name="method" /> non è la definizione di tipo generico di <paramref name="type" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1051">The declaring type of <paramref name="method" /> is not the generic type definition of <paramref name="type" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="typeBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="typeBuilder.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="04e9c-1052">Deve essere un flag di bit di <see cref="T:System.Reflection.BindingFlags" />, come in <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1052">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="04e9c-1053">Restituisce tutti i metodi pubblici e non pubblici dichiarati o ereditati da questo tipo, come specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1053">Returns all the public and non-public methods declared or inherited by this type, as specified.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1054">Restituisce una matrice di oggetti <see cref="T:System.Reflection.MethodInfo" /> che rappresentano i metodi pubblici e non pubblici definiti sul tipo se è usato il parametro <paramref name="nonPublic" />; in caso contrario, vengono restituiti solo i metodi pubblici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1054">Returns an array of <see cref="T:System.Reflection.MethodInfo" /> objects representing the public and non-public methods defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public methods are returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1055">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1055">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1056">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1056">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="typeBuilder.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-1057">Oggetto <see cref="T:System.String" /> che contiene il nome del tipo annidato da ottenere.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1057">The <see cref="T:System.String" /> containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="04e9c-1058">Maschera di bit costituita da uno o più <see cref="T:System.Reflection.BindingFlags" /> che consente di specificare le modalità di esecuzione della ricerca.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1058">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="04e9c-1059">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-1059">-or-</span></span> 
<span data-ttu-id="04e9c-1060">Zero, per eseguire una ricerca di metodi pubblici con distinzione tra maiuscole e minuscole.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1060">Zero, to conduct a case-sensitive search for public methods.</span></span></param>
        <summary><span data-ttu-id="04e9c-1061">Restituisce i tipi annidati pubblici e non pubblici dichiarati da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1061">Returns the public and non-public nested types that are declared by this type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1062">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo annidato corrispondente ai requisiti specificati, se presente; in caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1062">A <see cref="T:System.Type" /> object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1063">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1063">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="04e9c-1064">Se il tipo è completo, ad esempio, se `CreateType` è stato chiamato su questo tipo, ma sono presenti tipi nidificati che non sono complete, quindi `GetNestedTypes` restituirà solo i tipi annidati per la quale `CreateType` è stato chiamato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1064">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1065">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1065">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="typeBuilder.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="04e9c-1066">Deve essere un flag di bit di <see cref="T:System.Reflection.BindingFlags" />, come in <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1066">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" />, as in <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="04e9c-1067">Restituisce i tipi annidati pubblici e non pubblici dichiarati o ereditati da questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1067">Returns the public and non-public nested types that are declared or inherited by this type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1068">Matrice di oggetti <see cref="T:System.Type" /> che rappresentano tutti i tipi annidati nell'oggetto <see cref="T:System.Type" /> corrente che corrispondono ai vincoli di associazione specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1068">An array of <see cref="T:System.Type" /> objects representing all the types nested within the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="04e9c-1069">Matrice vuota di tipo <see cref="T:System.Type" />, se l'oggetto <see cref="T:System.Type" /> corrente non contiene tipi annidati o se nessuno dei tipi annidati corrisponde ai vincoli di associazione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1069">An empty array of type <see cref="T:System.Type" />, if no types are nested within the current <see cref="T:System.Type" />, or if none of the nested types match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1070">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1070">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 <span data-ttu-id="04e9c-1071">Se il tipo è completo, ad esempio, se `CreateType` è stato chiamato su questo tipo, ma sono presenti tipi nidificati che non sono complete, quindi `GetNestedTypes` restituirà solo i tipi annidati per la quale `CreateType` è stato chiamato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1071">If this type is complete, for example, if `CreateType` has been called on this type, but there are nested types that are not complete, then `GetNestedTypes` will only return those nested types for which `CreateType` has been called.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1072">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1072">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="typeBuilder.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="04e9c-1073">Attributo di chiamata.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1073">This invocation attribute.</span></span> <span data-ttu-id="04e9c-1074">Deve essere un flag di bit di <see cref="T:System.Reflection.BindingFlags" />: <see langword="InvokeMethod" />, <see langword="NonPublic" /> e così via.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1074">This must be a bit flag from <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />, and so on.</span></span></param>
        <summary><span data-ttu-id="04e9c-1075">Restituisce tutte le proprietà pubbliche e non pubbliche dichiarate o ereditate da questo tipo, come specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1075">Returns all the public and non-public properties declared or inherited by this type, as specified.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1076">Restituisce una matrice di oggetti <see langword="PropertyInfo" /> che rappresentano le proprietà pubbliche e non pubbliche definite per questo tipo se viene usato il parametro <paramref name="nonPublic" />; in caso contrario, vengono restituite solo le proprietà pubbliche.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1076">Returns an array of <see langword="PropertyInfo" /> objects representing the public and non-public properties defined on this type if <paramref name="nonPublic" /> is used; otherwise, only the public properties are returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1077">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1077">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1078">Questo metodo non viene implementato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1078">This method is not implemented for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="typeBuilder.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1079">Recupera il GUID di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1079">Retrieves the GUID of this type.</span></span></summary>
        <value><span data-ttu-id="04e9c-1080">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1080">Read-only.</span></span> <span data-ttu-id="04e9c-1081">Recupera il GUID di questo tipo</span><span class="sxs-lookup"><span data-stu-id="04e9c-1081">Retrieves the GUID of this type</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1082">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1082">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1083">Questo metodo non è attualmente supportato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1083">This method is not currently supported for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.HasElementTypeImpl : unit -&gt; bool" Usage="typeBuilder.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="typeBuilder.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="04e9c-1084">Nome del membro da richiamare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1084">The name of the member to invoke.</span></span> <span data-ttu-id="04e9c-1085">Può essere un costruttore, un metodo, una proprietà o un campo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1085">This can be a constructor, method, property, or field.</span></span> <span data-ttu-id="04e9c-1086">È necessario specificare un attributo di chiamata appropriato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1086">A suitable invocation attribute must be specified.</span></span> <span data-ttu-id="04e9c-1087">Si noti che è possibile richiamare il membro predefinito di una classe passando una stringa vuota come nome del membro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1087">Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="04e9c-1088">Attributo di chiamata.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1088">The invocation attribute.</span></span> <span data-ttu-id="04e9c-1089">Deve essere un flag di bit di <see langword="BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1089">This must be a bit flag from <see langword="BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="04e9c-1090">Oggetto che consente l'associazione, la coercizione dei tipi di argomento, la chiamata dei membri e il recupero di oggetti <see langword="MemberInfo" /> tramite reflection.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1090">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="04e9c-1091">Se il binder è <see langword="null" />, viene usato quello predefinito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1091">If binder is <see langword="null" />, the default binder is used.</span></span> <span data-ttu-id="04e9c-1092">Vedere <see cref="T:System.Reflection.Binder" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1092">See <see cref="T:System.Reflection.Binder" />.</span></span></param>
        <param name="target"><span data-ttu-id="04e9c-1093">Oggetto su cui richiamare il membro specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1093">The object on which to invoke the specified member.</span></span> <span data-ttu-id="04e9c-1094">Se il membro è statico, il parametro viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1094">If the member is static, this parameter is ignored.</span></span></param>
        <param name="args"><span data-ttu-id="04e9c-1095">Elenco di argomenti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1095">An argument list.</span></span> <span data-ttu-id="04e9c-1096">Matrice di oggetti che contiene il numero, l'ordine e il tipo dei parametri del membro da richiamare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1096">This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</span></span> <span data-ttu-id="04e9c-1097">In assenza di parametri, deve essere Null.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1097">If there are no parameters this should be null.</span></span></param>
        <param name="modifiers"><span data-ttu-id="04e9c-1098">Matrice della stessa lunghezza di <paramref name="args" /> con elementi che rappresentano gli attributi associati agli argomenti del membro da richiamare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1098">An array of the same length as <paramref name="args" /> with elements that represent the attributes associated with the arguments of the member to be invoked.</span></span> <span data-ttu-id="04e9c-1099">A un parametro sono associati attributi nei metadati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1099">A parameter has attributes associated with it in the metadata.</span></span> <span data-ttu-id="04e9c-1100">Vengono usati da vari servizi di interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1100">They are used by various interoperability services.</span></span> <span data-ttu-id="04e9c-1101">Per informazioni dettagliate, vedere le specifiche dei metadati. </span><span class="sxs-lookup"><span data-stu-id="04e9c-1101">See the metadata specs for more details.</span></span></param>
        <param name="culture"><span data-ttu-id="04e9c-1102">Istanza di <see langword="CultureInfo" /> usata per regolare la coercizione dei tipi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1102">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="04e9c-1103">Se tale parametro è Null, verrà usato l'oggetto <see langword="CultureInfo" /> per il thread corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1103">If this is null, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="04e9c-1104">Ciò è necessario, ad esempio, per convertire una stringa che rappresenta 1000 in un valore double, perché 1000 è rappresentato in modo diverso nelle diverse impostazioni cultura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1104">(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</span></span></param>
        <param name="namedParameters"><span data-ttu-id="04e9c-1105">Tutti i parametri nella matrice <paramref name="namedParameters" /> ottengono il valore nell'elemento corrispondente della matrice <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1105">Each parameter in the <paramref name="namedParameters" /> array gets the value in the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="04e9c-1106">Se la lunghezza di <paramref name="args" /> è superiore a quella di <paramref name="namedParameters" />, i valori degli argomenti rimanenti vengono passati in ordine.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1106">If the length of <paramref name="args" /> is greater than the length of <paramref name="namedParameters" />, the remaining argument values are passed in order.</span></span></param>
        <summary><span data-ttu-id="04e9c-1107">Richiama il membro specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1107">Invokes the specified member.</span></span> <span data-ttu-id="04e9c-1108">Il metodo da richiamare deve essere accessibile e fornire massima corrispondenza con l'elenco di argomenti specificato, in conformità ai vincoli del binder e degli attributi di chiamata specificati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1108">The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1109">Restituisce il valore restituito del membro richiamato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1109">Returns the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1110">Verrà richiamato un metodo se il numero di parametri nella dichiarazione del metodo è uguale al numero di argomenti nell'elenco di argomenti specificato e il tipo di ciascun argomento può essere convertito dallo strumento di associazione per il tipo del parametro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1110">A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="04e9c-1111">Lo strumento di associazione disponibili tutti i metodi corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1111">The binder will find all of the matching methods.</span></span> <span data-ttu-id="04e9c-1112">Questi metodi sono disponibili in base al tipo di associazione richiesti (BindingFlags. InvokeMethod, BindingFlags. GetProperties e così via.).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1112">These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</span></span> <span data-ttu-id="04e9c-1113">Il set di metodi verrà filtrato per il nome, numero di argomenti e un set di modificatori di ricerca definita nel gestore di associazione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1113">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span> <span data-ttu-id="04e9c-1114">Dopo aver selezionato il metodo, verrà richiamato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1114">After the method is selected, it will be invoked.</span></span> <span data-ttu-id="04e9c-1115">Accessibilità viene verificata a quel punto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1115">Accessibility is checked at that point.</span></span> <span data-ttu-id="04e9c-1116">La ricerca è possibile controllare quale set di metodi vengono ricercati in base all'attributo di accessibilità associata al metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1116">The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="04e9c-1117">Il `IBinder.BindToMethod` metodo è responsabile della scelta del metodo da richiamare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1117">The `IBinder.BindToMethod` method is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="04e9c-1118">Il binder predefinito consente di selezionare la corrispondenza più specifica.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1118">The default binder selects the most specific match.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-1119">Restrizioni di accesso vengono ignorate per un codice completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1119">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="04e9c-1120">Vale a dire, proprietà, metodi, campi e i costruttori privati sono accessibili e richiamato tramite Reflection, ogni volta che il codice è completamente attendibile.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1120">That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="04e9c-1121">Questo metodo non è attualmente supportato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1121">This method is not currently supported.</span></span> <span data-ttu-id="04e9c-1122">È possibile recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1122">You can retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1123">Questo metodo non è attualmente supportato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1123">This method is not currently supported for incomplete types.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="override this.IsArrayImpl : unit -&gt; bool" Usage="typeBuilder.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAssignableFrom">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-1124">Determina se un tipo specificato può essere assegnato a questo oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1124">Determines whether a specified type can be assigned to this object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(System::Reflection::TypeInfo ^ typeInfo);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : System.Reflection.TypeInfo -&gt; bool" Usage="typeBuilder.IsAssignableFrom typeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo"><span data-ttu-id="04e9c-1125">Oggetto da testare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1125">The object to test.</span></span></param>
        <summary><span data-ttu-id="04e9c-1126">Ottiene un valore che indica se a questo oggetto è possibile assegnare un oggetto <see cref="T:System.Reflection.TypeInfo" /> specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1126">Gets a value that indicates whether a specified <see cref="T:System.Reflection.TypeInfo" /> object can be assigned to this object.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1127"><see langword="true" /> se <paramref name="typeInfo" /> può essere assegnato a questo oggetto; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1127"><see langword="true" /> if <paramref name="typeInfo" /> can be assigned to this object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsAssignableFrom : Type -&gt; bool" Usage="typeBuilder.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="04e9c-1128">Oggetto da testare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1128">The object to test.</span></span></param>
        <summary><span data-ttu-id="04e9c-1129">Ottiene un valore che indica se all'oggetto è possibile assegnare un oggetto <see cref="T:System.Type" /> specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1129">Gets a value that indicates whether a specified <see cref="T:System.Type" /> can be assigned to this object.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1130"><see langword="true" /> se il parametro <paramref name="c" /> e il tipo corrente rappresentano lo stesso tipo oppure se il tipo corrente è nella gerarchia di ereditarietà di <paramref name="c" /> o è un'interfaccia che supporta <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1130"><see langword="true" /> if the <paramref name="c" /> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <paramref name="c" />, or if the current type is an interface that <paramref name="c" /> supports.</span></span> <span data-ttu-id="04e9c-1131"><see langword="false" />se nessuna di queste condizioni è valida oppure se <paramref name="c" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1131"><see langword="false" /> if none of these conditions are valid, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="override this.IsByRefImpl : unit -&gt; bool" Usage="typeBuilder.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public override bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Reflection.Emit.TypeBuilder.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="override this.IsCOMObjectImpl : unit -&gt; bool" Usage="typeBuilder.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1132">Ottiene un valore che indica se l'oggetto rappresenta un tipo generico costruito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1132">Gets a value that indicates whether this object represents a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="04e9c-1133"><see langword="true" /> se questo oggetto rappresenta una definizione di tipo generico; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1133"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCreated () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsCreated();" />
      <MemberSignature Language="F#" Value="member this.IsCreated : unit -&gt; bool" Usage="typeBuilder.IsCreated " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-1134">Restituisce un valore che indica se è stato creato il tipo dinamico corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1134">Returns a value that indicates whether the current dynamic type has been created.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1135"><see langword="true" /> se il metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> è stato chiamato; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1135"><see langword="true" /> if the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has been called; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1136">Dopo il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo è stato chiamato, il tipo rappresentato dal <xref:System.Reflection.Emit.TypeBuilder> oggetto è stato completato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1136">After the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method has been called, the type represented by the <xref:System.Reflection.Emit.TypeBuilder> object is complete.</span></span> <span data-ttu-id="04e9c-1137">Le eccezioni generate in ulteriori tentativi di aggiungere membri o modificare altre caratteristiche del tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1137">Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="typeBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="04e9c-1138">Tipo di attributo da cercare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1138">The type of attribute to search for.</span></span> <span data-ttu-id="04e9c-1139">Vengono restituiti solo gli attributi assegnabili a questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1139">Only attributes that are assignable to this type are returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="04e9c-1140">Specifica se trovare gli attributi cercandoli nella catena di ereditarietà del membro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1140">Specifies whether to search this member's inheritance chain to find the attributes.</span></span></param>
        <summary><span data-ttu-id="04e9c-1141">Determina se un attributo personalizzato viene applicato al tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1141">Determines whether a custom attribute is applied to the current type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1142"><see langword="true" /> se una o più istanze di <paramref name="attributeType" />, o un attributo derivato da <paramref name="attributeType" />, sono definite in questo tipo; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1142"><see langword="true" /> if one or more instances of <paramref name="attributeType" />, or an attribute derived from <paramref name="attributeType" />, is defined on this type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1143">Questo metodo non è supportato per i parametri di tipo generico incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1143">This method is not supported for incomplete generic type parameters.</span></span> <span data-ttu-id="04e9c-1144">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1144">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1145">Questo metodo non è attualmente supportato per i tipi incompleti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1145">This method is not currently supported for incomplete types.</span></span> <span data-ttu-id="04e9c-1146">Recuperare il tipo usando <see cref="M:System.Type.GetType" /> e chiamare <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> nell'oggetto <see cref="T:System.Type" /> restituito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1146">Retrieve the type using <see cref="M:System.Type.GetType" /> and call <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> on the returned <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-1147"><paramref name="attributeType" /> non è definito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1147"><paramref name="attributeType" /> is not defined.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-1148"><paramref name="attributeType" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1148"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1149">Ottiene un valore che indica se il tipo corrente è un parametro di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1149">Gets a value indicating whether the current type is a generic type parameter.</span></span></summary>
        <value><span data-ttu-id="04e9c-1150"><see langword="true" /> se l'oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> corrente rappresenta un parametro di tipo generico; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1150"><see langword="true" /> if the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type parameter; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-1151">Quando si crea il codice, un parametro di tipo generico è rappresentato da un <xref:System.Reflection.Emit.GenericTypeParameterBuilder> oggetto anziché da un <xref:System.Reflection.Emit.TypeBuilder> oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1151">When emitting code, a generic type parameter is represented by a <xref:System.Reflection.Emit.GenericTypeParameterBuilder> object rather than by a <xref:System.Reflection.Emit.TypeBuilder> object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1152">Ottiene un valore che indica se il tipo corrente è un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1152">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="04e9c-1153"><see langword="true" /> se il tipo rappresentato dall'oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> corrente è generico; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1153"><see langword="true" /> if the type represented by the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> object is generic; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1154">Oggetto <xref:System.Reflection.Emit.TypeBuilder> oggetto rappresenta una definizione di tipo generico, se il <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> metodo è stato usato per fornire parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1154">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="04e9c-1155">Un'istanza di <xref:System.Reflection.Emit.TypeBuilder> classe generica è sempre una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1155">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="04e9c-1156">Per altre informazioni sui tipi generici nella reflection e un elenco delle condizioni invariabili relative ai termini usati nel processo di reflection generico, vedere il <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1156">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1157">Ottiene un valore che indica se la classe <see cref="T:System.Reflection.Emit.TypeBuilder" /> corrente rappresenta una definizione di tipo generico, da cui è possibile costruire altri tipi generici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1157">Gets a value indicating whether the current <see cref="T:System.Reflection.Emit.TypeBuilder" /> represents a generic type definition from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="04e9c-1158"><see langword="true" /> se questo oggetto <see cref="T:System.Reflection.Emit.TypeBuilder" /> rappresenta una definizione di tipo generico; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1158"><see langword="true" /> if this <see cref="T:System.Reflection.Emit.TypeBuilder" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1159">Oggetto <xref:System.Reflection.Emit.TypeBuilder> oggetto rappresenta una definizione di tipo generico, se il <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> metodo è stato usato per fornire parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1159">A <xref:System.Reflection.Emit.TypeBuilder> object represents a generic type definition if the <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> method has been used to give it generic type parameters.</span></span> <span data-ttu-id="04e9c-1160">Un'istanza di <xref:System.Reflection.Emit.TypeBuilder> classe generica è sempre una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1160">An instance of the <xref:System.Reflection.Emit.TypeBuilder> class that is generic is always a generic type definition.</span></span>  
  
 <span data-ttu-id="04e9c-1161">Oggetto <xref:System.Reflection.Emit.TypeBuilder> può essere utilizzato per creare definizioni di tipo generico, ma non tipi generici costruiti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1161">A <xref:System.Reflection.Emit.TypeBuilder> can be used to build generic type definitions, but not constructed generic types.</span></span> <span data-ttu-id="04e9c-1162">Per ottenere un tipo generico costruito, chiamare il <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metodo su un <xref:System.Reflection.Emit.TypeBuilder> che rappresenta una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1162">To get a constructed generic type, call the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span>  
  
 <span data-ttu-id="04e9c-1163">Per altre informazioni sui tipi generici nella reflection e un elenco delle condizioni invariabili relative ai termini usati nel processo di reflection generico, vedere il <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1163">For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
        <altmember cref="P:System.Type.IsGenericType" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPointerImpl : unit -&gt; bool" Usage="typeBuilder.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="override this.IsPrimitiveImpl : unit -&gt; bool" Usage="typeBuilder.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1164">Ottiene un valore che indica se il tipo corrente è critico per la sicurezza o critico per la sicurezza e richiamabile da codice trasparente e può pertanto eseguire operazioni critiche.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1164">Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="04e9c-1165"><see langword="true" /> se il tipo corrente è critico per la sicurezza o critico per la sicurezza e richiamabile da codice trasparente; <see langword="false" /> se è trasparente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1165"><see langword="true" /> if the current type is security-critical or security-safe-critical; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1166">Il <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> riportano il livello di trasparenza del tipo, come determinato da common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1166">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="04e9c-1167">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="04e9c-1167">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="04e9c-1168">Livello di sicurezza</span><span class="sxs-lookup"><span data-stu-id="04e9c-1168">Security level</span></span>|<span data-ttu-id="04e9c-1169">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="04e9c-1169">IsSecurityCritical</span></span>|<span data-ttu-id="04e9c-1170">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="04e9c-1170">IsSecuritySafeCritical</span></span>|<span data-ttu-id="04e9c-1171">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="04e9c-1171">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="04e9c-1172">Critico</span><span class="sxs-lookup"><span data-stu-id="04e9c-1172">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="04e9c-1173">Critico per la sicurezza</span><span class="sxs-lookup"><span data-stu-id="04e9c-1173">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="04e9c-1174">Trasparente</span><span class="sxs-lookup"><span data-stu-id="04e9c-1174">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="04e9c-1175">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1175">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="04e9c-1176">Il runtime avvia la valutazione di livelli di trasparenza all'assembly.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1176">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="04e9c-1177">Ad esempio, se l'assembly dinamico è critico per la sicurezza, le annotazioni sui tipi vengono ignorate e tutti i tipi sono critici per la sicurezza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1177">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="04e9c-1178">Per impostazione predefinita, un assembly dinamico eredita la trasparenza dell'assembly che lo genera.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1178">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="04e9c-1179">È possibile eseguire l'override di questa impostazione predefinita tramite il <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> overload del metodo e specificando gli attributi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1179">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="04e9c-1180">Non è possibile elevare i livelli di sicurezza in questo modo; vale a dire, il codice trasparente non è possibile creare codice critico per la sicurezza o security-safe-critical.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1180">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="04e9c-1181">Quando viene creato l'assembly dinamico o non hanno effetto fino a quando non è stato salvato su disco e ricaricata l'assembly, è necessario specificare gli attributi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1181">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-1182">Ereditarietà predefinita è limitato alla valutazione del runtime di trasparenza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1182">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="04e9c-1183">Non sono presenti attributi vengono applicati all'assembly dinamico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1183">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="04e9c-1184">Se si desidera aggiungere gli attributi di sicurezza, è necessario applicarle personalmente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1184">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="04e9c-1185">Per altre informazioni sulla reflection emit e trasparenza, vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1185">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="04e9c-1186">Per informazioni sulla trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1186">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1187">Il tipo dinamico corrente non è stato creato chiamando il metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1187">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="04e9c-1188">Problemi di sicurezza nella reflection emit</span><span class="sxs-lookup"><span data-stu-id="04e9c-1188">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="04e9c-1189">Considerazioni sulla sicurezza in relazione alla reflection</span><span class="sxs-lookup"><span data-stu-id="04e9c-1189">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="04e9c-1190">Modifiche della sicurezza in .NET Framework 4.0</span><span class="sxs-lookup"><span data-stu-id="04e9c-1190">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="04e9c-1191">Codice SecurityTransparent, livello 1</span><span class="sxs-lookup"><span data-stu-id="04e9c-1191">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="04e9c-1192">Codice SecurityTransparent, livello 2</span><span class="sxs-lookup"><span data-stu-id="04e9c-1192">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1193">Ottiene un valore che indica se il tipo corrente è critico per la sicurezza, vale a dire se può eseguire operazioni critiche e se è possibile accedervi tramite codice trasparente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1193">Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="04e9c-1194"><see langword="true" /> se il tipo corrente è critico per la sicurezza, <see langword="false" /> se è critico per la sicurezza o trasparente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1194"><see langword="true" /> if the current type is security-safe-critical; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1195">Il <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> riportano il livello di trasparenza del tipo, come determinato da common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1195">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="04e9c-1196">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="04e9c-1196">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="04e9c-1197">Livello di sicurezza</span><span class="sxs-lookup"><span data-stu-id="04e9c-1197">Security level</span></span>|<span data-ttu-id="04e9c-1198">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="04e9c-1198">IsSecurityCritical</span></span>|<span data-ttu-id="04e9c-1199">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="04e9c-1199">IsSecuritySafeCritical</span></span>|<span data-ttu-id="04e9c-1200">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="04e9c-1200">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="04e9c-1201">Critico</span><span class="sxs-lookup"><span data-stu-id="04e9c-1201">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="04e9c-1202">Critico per la sicurezza</span><span class="sxs-lookup"><span data-stu-id="04e9c-1202">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="04e9c-1203">Trasparente</span><span class="sxs-lookup"><span data-stu-id="04e9c-1203">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="04e9c-1204">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1204">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="04e9c-1205">Il runtime avvia la valutazione di livelli di trasparenza all'assembly.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1205">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="04e9c-1206">Ad esempio, se l'assembly dinamico è critico per la sicurezza, le annotazioni sui tipi vengono ignorate e tutti i tipi sono critici per la sicurezza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1206">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="04e9c-1207">Per impostazione predefinita, un assembly dinamico eredita la trasparenza dell'assembly che lo genera.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1207">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="04e9c-1208">È possibile eseguire l'override di questa impostazione predefinita tramite il <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> overload del metodo e specificando gli attributi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1208">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="04e9c-1209">Non è possibile elevare i livelli di sicurezza in questo modo; vale a dire, il codice trasparente non è possibile creare codice critico per la sicurezza o security-safe-critical.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1209">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="04e9c-1210">Quando viene creato l'assembly dinamico o non hanno effetto fino a quando non è stato salvato su disco e ricaricata l'assembly, è necessario specificare gli attributi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1210">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-1211">Ereditarietà predefinita è limitato alla valutazione del runtime di trasparenza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1211">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="04e9c-1212">Non sono presenti attributi vengono applicati all'assembly dinamico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1212">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="04e9c-1213">Se si desidera aggiungere gli attributi di sicurezza, è necessario applicarle personalmente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1213">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="04e9c-1214">Per altre informazioni sulla reflection emit e trasparenza, vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1214">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="04e9c-1215">Per informazioni sulla trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1215">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1216">Il tipo dinamico corrente non è stato creato chiamando il metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1216">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="04e9c-1217">Problemi di sicurezza nella reflection emit</span><span class="sxs-lookup"><span data-stu-id="04e9c-1217">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="04e9c-1218">Considerazioni sulla sicurezza in relazione alla reflection</span><span class="sxs-lookup"><span data-stu-id="04e9c-1218">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="04e9c-1219">Modifiche della sicurezza in .NET Framework 4.0</span><span class="sxs-lookup"><span data-stu-id="04e9c-1219">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="04e9c-1220">Codice SecurityTransparent, livello 1</span><span class="sxs-lookup"><span data-stu-id="04e9c-1220">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="04e9c-1221">Codice SecurityTransparent, livello 2</span><span class="sxs-lookup"><span data-stu-id="04e9c-1221">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1222">Ottiene un valore che indica se il tipo corrente è trasparente e pertanto non può eseguire operazioni critiche.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1222">Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="04e9c-1223"><see langword="true" /> se il tipo è trasparente per la sicurezza; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1223"><see langword="true" /> if the type is security-transparent; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1224">Il <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> riportano il livello di trasparenza del tipo, come determinato da common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1224">The <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> properties report the transparency level of the type, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="04e9c-1225">Le combinazioni di queste proprietà vengono visualizzate nella tabella seguente:</span><span class="sxs-lookup"><span data-stu-id="04e9c-1225">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="04e9c-1226">Livello di sicurezza</span><span class="sxs-lookup"><span data-stu-id="04e9c-1226">Security level</span></span>|<span data-ttu-id="04e9c-1227">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="04e9c-1227">IsSecurityCritical</span></span>|<span data-ttu-id="04e9c-1228">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="04e9c-1228">IsSecuritySafeCritical</span></span>|<span data-ttu-id="04e9c-1229">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="04e9c-1229">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="04e9c-1230">Critico</span><span class="sxs-lookup"><span data-stu-id="04e9c-1230">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="04e9c-1231">Critico per la sicurezza</span><span class="sxs-lookup"><span data-stu-id="04e9c-1231">Safe-critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="04e9c-1232">Trasparente</span><span class="sxs-lookup"><span data-stu-id="04e9c-1232">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="04e9c-1233">Usare queste proprietà è molto più semplice che non esaminare le annotazioni di sicurezza di un assembly e dei suoi tipi, controllare il livello di attendibilità corrente e tentare di duplicare le regole del runtime.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1233">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
 <span data-ttu-id="04e9c-1234">Il runtime avvia la valutazione di livelli di trasparenza all'assembly.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1234">The runtime begins evaluating transparency levels at the assembly.</span></span> <span data-ttu-id="04e9c-1235">Ad esempio, se l'assembly dinamico è critico per la sicurezza, le annotazioni sui tipi vengono ignorate e tutti i tipi sono critici per la sicurezza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1235">For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</span></span>  
  
 <span data-ttu-id="04e9c-1236">Per impostazione predefinita, un assembly dinamico eredita la trasparenza dell'assembly che lo genera.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1236">By default, a dynamic assembly inherits the transparency of the assembly that emits it.</span></span> <span data-ttu-id="04e9c-1237">È possibile eseguire l'override di questa impostazione predefinita tramite il <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> overload del metodo e specificando gli attributi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1237">You can override this default by using the <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, or <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> method overload and specifying security attributes.</span></span> <span data-ttu-id="04e9c-1238">Non è possibile elevare i livelli di sicurezza in questo modo; vale a dire, il codice trasparente non è possibile creare codice critico per la sicurezza o security-safe-critical.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1238">You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</span></span> <span data-ttu-id="04e9c-1239">Quando viene creato l'assembly dinamico o non hanno effetto fino a quando non è stato salvato su disco e ricaricata l'assembly, è necessario specificare gli attributi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1239">Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-1240">Ereditarietà predefinita è limitato alla valutazione del runtime di trasparenza.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1240">Default inheritance is limited to the runtime's evaluation of transparency.</span></span> <span data-ttu-id="04e9c-1241">Non sono presenti attributi vengono applicati all'assembly dinamico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1241">No attributes are applied to the dynamic assembly.</span></span> <span data-ttu-id="04e9c-1242">Se si desidera aggiungere gli attributi di sicurezza, è necessario applicarle personalmente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1242">If you want to add security attributes, you must apply them yourself.</span></span>  
  
 <span data-ttu-id="04e9c-1243">Per altre informazioni sulla reflection emit e trasparenza, vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1243">For more information about reflection emit and transparency, see [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).</span></span> <span data-ttu-id="04e9c-1244">Per informazioni sulla trasparenza, vedere [modifiche della sicurezza](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1244">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1245">Il tipo dinamico corrente non è stato creato chiamando il metodo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1245">The current dynamic type has not been created by calling the <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method.</span></span></exception>
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md"><span data-ttu-id="04e9c-1246">Problemi di sicurezza nella reflection emit</span><span class="sxs-lookup"><span data-stu-id="04e9c-1246">Security Issues in Reflection Emit</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="04e9c-1247">Considerazioni sulla sicurezza in relazione alla reflection</span><span class="sxs-lookup"><span data-stu-id="04e9c-1247">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="04e9c-1248">Modifiche della sicurezza in .NET Framework 4.0</span><span class="sxs-lookup"><span data-stu-id="04e9c-1248">Security Changes in the .NET Framework Version 4.0</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf"><span data-ttu-id="04e9c-1249">Codice SecurityTransparent, livello 1</span><span class="sxs-lookup"><span data-stu-id="04e9c-1249">Security-Transparent Code, Level 1</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0"><span data-ttu-id="04e9c-1250">Codice SecurityTransparent, livello 2</span><span class="sxs-lookup"><span data-stu-id="04e9c-1250">Security-Transparent Code, Level 2</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="override this.IsSubclassOf : Type -&gt; bool" Usage="typeBuilder.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="04e9c-1251">Oggetto <see cref="T:System.Type" /> da verificare.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1251">A <see cref="T:System.Type" /> that is to be checked.</span></span></param>
        <summary><span data-ttu-id="04e9c-1252">Determina se questo tipo è derivato da un tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1252">Determines whether this type is derived from a specified type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1253">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1253">Read-only.</span></span> <span data-ttu-id="04e9c-1254">Restituisce <see langword="true" /> se questo tipo è lo stesso del tipo <paramref name="c" /> oppure è un sottotipo del tipo <paramref name="c" />; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1254">Returns <see langword="true" /> if this type is the same as the type <paramref name="c" />, or is a subtype of type <paramref name="c" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="override this.IsValueTypeImpl : unit -&gt; bool" Usage="typeBuilder.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-1255">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una matrice del tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1255">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : unit -&gt; Type" Usage="typeBuilder.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-1256">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una matrice unidimensionale del tipo corrente con un limite inferiore a zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1256">Returns a <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1257">Oggetto <see cref="T:System.Type" /> che rappresenta un tipo di matrice unidimensionale, il cui tipo di elemento è di tipo corrente con limite inferiore zero.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1257">A <see cref="T:System.Type" /> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1258">Il <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> metodo fornisce un modo per generare un tipo di matrice con qualsiasi tipo di elemento, inclusi i tipi generici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1258">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-1259">L'esempio di codice seguente crea un modulo dinamico, un tipo astratto denominato `Sample`e un metodo astratto denominato `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1259">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="04e9c-1260">`TestMethod` accetta una `ref` parametro (`ByRef` in Visual Basic) di tipo `Sample`, un puntatore al tipo `Sample`e una matrice di tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1260">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="04e9c-1261">Restituisce una matrice bidimensionale di tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1261">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="04e9c-1262">L'esempio di codice salva il modulo dinamico su disco, è possibile esaminarlo mediante la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1262">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="override this.MakeArrayType : int -&gt; Type" Usage="typeBuilder.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="04e9c-1263">Numero di dimensioni della matrice.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1263">The number of dimensions for the array.</span></span></param>
        <summary><span data-ttu-id="04e9c-1264">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta una matrice del tipo corrente, con il numero specificato di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1264">Returns a <see cref="T:System.Type" /> object that represents an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1265">Oggetto <see cref="T:System.Type" /> che rappresenta una matrice unidimensionale del tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1265">A <see cref="T:System.Type" /> object that represents a one-dimensional array of the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1266">Il <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> metodo fornisce un modo per generare un tipo di matrice con qualsiasi tipo di elemento, inclusi i tipi generici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1266">The <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> method provides a way to generate an array type with any possible element type, including generic types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-1267">L'esempio di codice seguente crea un modulo dinamico, un tipo astratto denominato `Sample`e un metodo astratto denominato `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1267">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="04e9c-1268">`TestMethod` accetta una `ref` parametro (`ByRef` in Visual Basic) di tipo `Sample`, un puntatore al tipo `Sample`e una matrice di tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1268">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="04e9c-1269">Restituisce una matrice bidimensionale di tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1269">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="04e9c-1270">L'esempio di codice salva il modulo dinamico su disco, è possibile esaminarlo mediante la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1270">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="04e9c-1271"><paramref name="rank" /> non è una dimensione di matrice valida.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1271"><paramref name="rank" /> is not a valid array dimension.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="override this.MakeByRefType : unit -&gt; Type" Usage="typeBuilder.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-1272">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta il tipo corrente quando viene passato come parametro <see langword="ref" /> (<see langword="ByRef" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1272">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="04e9c-1273">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo corrente quando viene passato come parametro <see langword="ref" /> (<see langword="ByRef" /> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1273">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1274">Il <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> metodo fornisce un modo per generare `ref` tipi (`ByRef` in Visual Basic) per elenchi di parametri.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1274">The <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-1275">Usando la sintassi di Microsoft intermediate language (MSIL), se l'oggetto corrente <xref:System.Reflection.Emit.TypeBuilder> rappresenta `MyType`, quindi il tipo restituito da questo metodo sarebbe `MyType&`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1275">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-1276">L'esempio di codice seguente crea un modulo dinamico, un tipo astratto denominato `Sample`e un metodo astratto denominato `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1276">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="04e9c-1277">`TestMethod` accetta una `ref` parametro (`ByRef` in Visual Basic) di tipo `Sample`, un puntatore al tipo `Sample`e una matrice di tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1277">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="04e9c-1278">Restituisce una matrice bidimensionale di tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1278">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="04e9c-1279">L'esempio di codice salva il modulo dinamico su disco, è possibile esaminarlo mediante la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1279">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="override this.MakeGenericType : Type[] -&gt; Type" Usage="typeBuilder.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="04e9c-1280">Matrice di tipi con cui sostituire i parametri di tipo della definizione di tipo generico corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1280">An array of types to be substituted for the type parameters of the current generic type definition.</span></span></param>
        <summary><span data-ttu-id="04e9c-1281">Sostituisce gli elementi di una matrice di tipi ai parametri di tipo della definizione di tipo generico corrente e restituisce il tipo costruito risultante.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1281">Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1282">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo costruito ottenuto sostituendo i parametri di tipo del tipo generico corrente con gli elementi di <paramref name="typeArguments" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1282">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1283">Utilizzare questo metodo quando il codice generato richiede un tipo costruito dalla definizione di tipo generico corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1283">Use this method when your emitted code requires a type constructed from the current generic type definition.</span></span> <span data-ttu-id="04e9c-1284">Non è necessario chiamare il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> metodo prima di chiamare il <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> metodo su un <xref:System.Reflection.Emit.TypeBuilder> che rappresenta una definizione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1284">It is not necessary to call the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method before calling the <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> method on a <xref:System.Reflection.Emit.TypeBuilder> that represents a generic type definition.</span></span> <span data-ttu-id="04e9c-1285">Se l'oggetto corrente <xref:System.Reflection.Emit.TypeBuilder> non rappresenta la definizione di un tipo generico, un <xref:System.InvalidOperationException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1285">If the current <xref:System.Reflection.Emit.TypeBuilder> does not represent the definition of a generic type, an <xref:System.InvalidOperationException> is thrown.</span></span>  
  
 <span data-ttu-id="04e9c-1286">L'oggetto restituito da questo metodo funziona come segnaposto per un tipo generico costruito nel codice generato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1286">The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</span></span> <span data-ttu-id="04e9c-1287">Si tratta di un'istanza di una classe derivata da <xref:System.Type> con funzionalità limitate.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1287">It is an instance of a class derived from <xref:System.Type> that has limited capabilities.</span></span> <span data-ttu-id="04e9c-1288">In particolare:</span><span class="sxs-lookup"><span data-stu-id="04e9c-1288">In particular:</span></span>  
  
-   <span data-ttu-id="04e9c-1289">Per ottenere i metodi, campi e i costruttori per questi tipi generici costruiti, usare il <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, e <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1289">To get methods, fields, and constructors for these constructed generic types, use the <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, and <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> method overloads.</span></span>  
  
-   <span data-ttu-id="04e9c-1290">Due istanze che rappresentano lo stesso tipo costruito non vengono considerati uguali.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1290">Two instances that represent the same constructed type do not compare as equal.</span></span> <span data-ttu-id="04e9c-1291">Ad esempio, nel codice seguente `t1.Equals(t2)` restituisce `false`:</span><span class="sxs-lookup"><span data-stu-id="04e9c-1291">For example, in the following code `t1.Equals(t2)` returns `false`:</span></span>  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-1292">Il tipo corrente non rappresenta la definizione di un tipo generico.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1292">The current type does not represent the definition of a generic type.</span></span> <span data-ttu-id="04e9c-1293">Ciò significa che <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> restituisce <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1293">That is, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-1294"><paramref name="typeArguments" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1294"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="04e9c-1295">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-1295">-or-</span></span> 
<span data-ttu-id="04e9c-1296">Qualsiasi elemento di <paramref name="typeArguments" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1296">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-1297">La proprietà <see cref="P:System.Type.Module" /> di qualsiasi elemento di <paramref name="typeArguments" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1297">The <see cref="P:System.Type.Module" /> property of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="04e9c-1298">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-1298">-or-</span></span> 
<span data-ttu-id="04e9c-1299">La proprietà <see cref="P:System.Reflection.Module.Assembly" /> del modulo di qualsiasi elemento di <paramref name="typeArguments" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1299">The <see cref="P:System.Reflection.Module.Assembly" /> property of the module of any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="override this.MakePointerType : unit -&gt; Type" Usage="typeBuilder.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-1300">Restituisce un oggetto <see cref="T:System.Type" /> che rappresenta il tipo di un puntatore non gestito al tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1300">Returns a <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1301">Oggetto <see cref="T:System.Type" /> che rappresenta il tipo di un puntatore non gestito al tipo corrente.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1301">A <see cref="T:System.Type" /> object that represents the type of an unmanaged pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1302">Il <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> metodo fornisce un modo per generare i tipi di puntatore per gli elenchi di parametri.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1302">The <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-1303">Usando la sintassi di Microsoft intermediate language (MSIL), se l'oggetto corrente <xref:System.Reflection.Emit.TypeBuilder> rappresenta `MyType`, quindi il tipo restituito da questo metodo sarebbe `MyType*`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1303">Using Microsoft intermediate language (MSIL) syntax, if the current <xref:System.Reflection.Emit.TypeBuilder> represents `MyType`, then the type returned by this method would be `MyType*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="04e9c-1304">L'esempio di codice seguente crea un modulo dinamico, un tipo astratto denominato `Sample`e un metodo astratto denominato `TestMethod`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1304">The following code example creates a dynamic module, an abstract type named `Sample`, and an abstract method named `TestMethod`.</span></span> <span data-ttu-id="04e9c-1305">`TestMethod` accetta una `ref` parametro (`ByRef` in Visual Basic) di tipo `Sample`, un puntatore al tipo `Sample`e una matrice di tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1305">`TestMethod` takes a `ref` parameter (`ByRef` in Visual Basic) of type `Sample`, a pointer to type `Sample`, and an array of type `Sample`.</span></span> <span data-ttu-id="04e9c-1306">Restituisce una matrice bidimensionale di tipo `Sample`.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1306">It returns a two-dimensional array of type `Sample`.</span></span> <span data-ttu-id="04e9c-1307">L'esempio di codice salva il modulo dinamico su disco, è possibile esaminarlo mediante la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1307">The code example saves the dynamic module to disk, so you can examine it with the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span>  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
        <altmember cref="Overload:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.TypeBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1308">Recupera il modulo dinamico che contiene la definizione di tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1308">Retrieves the dynamic module that contains this type definition.</span></span></summary>
        <value><span data-ttu-id="04e9c-1309">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1309">Read-only.</span></span> <span data-ttu-id="04e9c-1310">Recupera il modulo dinamico che contiene la definizione di tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1310">Retrieves the dynamic module that contains this type definition.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.TypeBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1311">Recupera il nome di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1311">Retrieves the name of this type.</span></span></summary>
        <value><span data-ttu-id="04e9c-1312">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1312">Read-only.</span></span> <span data-ttu-id="04e9c-1313">Recupera il nome dell'oggetto <see cref="T:System.String" /> di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1313">Retrieves the <see cref="T:System.String" /> name of this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1314">Recupera lo spazio dei nomi in cui è definito <see langword="TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1314">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span></span></summary>
        <value><span data-ttu-id="04e9c-1315">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1315">Read-only.</span></span> <span data-ttu-id="04e9c-1316">Recupera lo spazio dei nomi in cui è definito <see langword="TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1316">Retrieves the namespace where this <see langword="TypeBuilder" /> is defined.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackingSize As PackingSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::PackingSize PackingSize { System::Reflection::Emit::PackingSize get(); };" />
      <MemberSignature Language="F#" Value="member this.PackingSize : System.Reflection.Emit.PackingSize" Usage="System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1317">Recupera la dimensione di compressione di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1317">Retrieves the packing size of this type.</span></span></summary>
        <value><span data-ttu-id="04e9c-1318">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1318">Read-only.</span></span> <span data-ttu-id="04e9c-1319">Recupera la dimensione di compressione di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1319">Retrieves the packing size of this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1320">Restituisce il tipo usato per ottenere questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1320">Returns the type that was used to obtain this type.</span></span></summary>
        <value><span data-ttu-id="04e9c-1321">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1321">Read-only.</span></span> <span data-ttu-id="04e9c-1322">Tipo usato per ottenere questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1322">The type that was used to obtain this type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="04e9c-1323">Imposta un attributo personalizzato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1323">Sets a custom attribute.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="typeBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder"><span data-ttu-id="04e9c-1324">Un'istanza di una classe helper per definire l'attributo personalizzato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1324">An instance of a helper class to define the custom attribute.</span></span></param>
        <summary><span data-ttu-id="04e9c-1325">Impostare un attributo personalizzato usando un generatore di attributi personalizzati.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1325">Set a custom attribute using a custom attribute builder.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-1326">Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1326">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="04e9c-1327">(Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1327">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-1328"><paramref name="customBuilder" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1328"><paramref name="customBuilder" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-1329">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1329">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="typeBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con"><span data-ttu-id="04e9c-1330">Costruttore dell'attributo personalizzato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1330">The constructor for the custom attribute.</span></span></param>
        <param name="binaryAttribute"><span data-ttu-id="04e9c-1331">BLOB di byte che rappresenta gli attributi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1331">A byte blob representing the attributes.</span></span></param>
        <summary><span data-ttu-id="04e9c-1332">Imposta un attributo personalizzato usando un BLOB di attributi personalizzati specificato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1332">Sets a custom attribute using a specified custom attribute blob.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1333">Per altre informazioni su come formattare `binaryAttribute`, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="04e9c-1333">For more information on how to format `binaryAttribute`, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="04e9c-1334">La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1334">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="04e9c-1335">Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1335">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="04e9c-1336">(Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1336">(See [Security Issues in Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="04e9c-1337"><paramref name="con" /> o <paramref name="binaryAttribute" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1337"><paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-1338">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1338">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetParent (parent As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetParent(Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.SetParent : Type -&gt; unit" Usage="typeBuilder.SetParent parent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent"><span data-ttu-id="04e9c-1339">Nuovo tipo di base.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1339">The new base type.</span></span></param>
        <summary><span data-ttu-id="04e9c-1340">Imposta il tipo di base del tipo che si sta creando.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1340">Sets the base type of the type currently under construction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1341">Se `parent` viene `null`, <xref:System.Object> viene usato come tipo di base.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1341">If `parent` is `null`, <xref:System.Object> is used as the base type.</span></span>  
  
 <span data-ttu-id="04e9c-1342">Nelle versioni 1.0 e 1.1 di .NET Framework, viene generata alcuna eccezione se `parent` è un tipo di interfaccia, ma un <xref:System.TypeLoadException> generata quando il <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1342">In the .NET Framework versions 1.0 and 1.1, no exception is thrown if `parent` is an interface type, but a <xref:System.TypeLoadException> is thrown when the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method is called.</span></span>  
  
 <span data-ttu-id="04e9c-1343">Il <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> metodo non verifica la maggior parte dei tipi di elemento padre non valido.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1343">The <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> method does not check for most invalid parent types.</span></span> <span data-ttu-id="04e9c-1344">Ad esempio, non rifiuta un tipo di elemento padre che non dispone di alcun costruttore predefinito quando il tipo corrente ha un costruttore predefinito, non vengono rifiutati i tipi sealed e non viene rifiutato il <xref:System.Delegate> tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1344">For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <xref:System.Delegate> type.</span></span> <span data-ttu-id="04e9c-1345">In tutti questi casi, vengono generate eccezioni di <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1345">In all these cases, exceptions are thrown by the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-1346">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1346">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span>  
  
<span data-ttu-id="04e9c-1347">-oppure-</span><span class="sxs-lookup"><span data-stu-id="04e9c-1347">-or-</span></span> 
 <span data-ttu-id="04e9c-1348"><paramref name="parent" /> è <see langword="null" /> e l'istanza corrente rappresenta un'interfaccia i cui attributi non includono <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1348"><paramref name="parent" /> is <see langword="null" />, and the current instance represents an interface whose attributes do not include <see cref="F:System.Reflection.TypeAttributes.Abstract" />.</span></span>  
  
<span data-ttu-id="04e9c-1349">oppure</span><span class="sxs-lookup"><span data-stu-id="04e9c-1349">-or-</span></span> 
<span data-ttu-id="04e9c-1350">Per il tipo dinamico corrente, la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> è <see langword="true" /> ma la proprietà <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> è <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1350">For the current dynamic type, the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> property is <see langword="true" />, but the <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> property is <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="04e9c-1351"><paramref name="parent" /> è un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1351"><paramref name="parent" /> is an interface.</span></span> <span data-ttu-id="04e9c-1352">Questa condizione di eccezione è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1352">This exception condition is new in the .NET Framework version 2.0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Size { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : int" Usage="System.Reflection.Emit.TypeBuilder.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1353">Recupera la dimensione totale di un tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1353">Retrieves the total size of a type.</span></span></summary>
        <value><span data-ttu-id="04e9c-1354">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1354">Read-only.</span></span> <span data-ttu-id="04e9c-1355">Recupera la dimensione totale di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1355">Retrieves this type's total size.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _TypeBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_TypeBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="04e9c-1356">Riservato per utilizzi futuri.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1356">Reserved for future use.</span></span> <span data-ttu-id="04e9c-1357">Deve essere IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1357">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="04e9c-1358">Matrice di nomi passata di cui eseguire il mapping.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1358">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="04e9c-1359">Conteggio dei nomi di cui eseguire il mapping.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1359">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="04e9c-1360">Contesto delle impostazioni locali in cui interpretare i nomi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1360">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="04e9c-1361">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1361">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="04e9c-1362">Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1362">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1363">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1363">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04e9c-1364">Per altre informazioni sulle `IDispatch::GetIDsOfNames`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1364">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04e9c-1365">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1365">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _TypeBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="04e9c-1366">Informazioni sul tipo da restituire.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1366">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="04e9c-1367">Identificatore delle impostazioni locali per le informazioni sul tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1367">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="04e9c-1368">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1368">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="04e9c-1369">Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1369">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1370">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1370">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04e9c-1371">Per altre informazioni sulle `IDispatch::GetTypeInfo`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1371">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04e9c-1372">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1372">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _TypeBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_TypeBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="04e9c-1373">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1373">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="04e9c-1374">Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</span><span class="sxs-lookup"><span data-stu-id="04e9c-1374">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1375">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1375">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04e9c-1376">Per altre informazioni sulle `IDispatch::GetTypeInfoCount`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1376">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04e9c-1377">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1377">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _TypeBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._TypeBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_TypeBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._TypeBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="04e9c-1378">Identifica il membro.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1378">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="04e9c-1379">Riservato per utilizzi futuri.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1379">Reserved for future use.</span></span> <span data-ttu-id="04e9c-1380">Deve essere IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1380">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="04e9c-1381">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1381">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="04e9c-1382">Flag che descrivono il contesto della chiamata.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1382">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="04e9c-1383">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1383">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="04e9c-1384">Puntatore alla posizione in cui deve essere archiviato il risultato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1384">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="04e9c-1385">Puntatore a una struttura contenente informazioni sull'eccezione.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1385">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="04e9c-1386">Indice del primo argomento che contiene un errore.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1386">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="04e9c-1387">Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1387">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1388">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1388">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="04e9c-1389">Per altre informazioni sulle `IDispatch::Invoke`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1389">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="04e9c-1390">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1390">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="typeBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04e9c-1391">Restituisce il nome del tipo escluso lo spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1391">Returns the name of the type excluding the namespace.</span></span></summary>
        <returns><span data-ttu-id="04e9c-1392">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1392">Read-only.</span></span> <span data-ttu-id="04e9c-1393">Nome del tipo escluso lo spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1393">The name of the type excluding the namespace.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1394">Non supportato in moduli dinamici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1394">Not supported in dynamic modules.</span></span></summary>
        <value><span data-ttu-id="04e9c-1395">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1395">Read-only.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04e9c-1396">Recuperare il tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usare la reflection sul tipo recuperato.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1396">Retrieve the type using <xref:System.Type.GetType%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> and use reflection on the retrieved type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="04e9c-1397">Non supportato in moduli dinamici.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1397">Not supported in dynamic modules.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeToken As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Emit::TypeToken TypeToken { System::Reflection::Emit::TypeToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeToken : System.Reflection.Emit.TypeToken" Usage="System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1398">Restituisce il token di tipo per questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1398">Returns the type token of this type.</span></span></summary>
        <value><span data-ttu-id="04e9c-1399">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1399">Read-only.</span></span> <span data-ttu-id="04e9c-1400">Restituisce l'oggetto <see langword="TypeToken" /> per questo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1400">Returns the <see langword="TypeToken" /> of this type.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-1401">Il tipo è stato creato in precedenza usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1401">The type was previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1402">Restituisce il tipo di sistema sottostante per l'oggetto <see langword="TypeBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1402">Returns the underlying system type for this <see langword="TypeBuilder" />.</span></span></summary>
        <value><span data-ttu-id="04e9c-1403">Sola lettura.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1403">Read-only.</span></span> <span data-ttu-id="04e9c-1404">Restituisce il tipo di sistema sottostante.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1404">Returns the underlying system type.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="04e9c-1405">Questo tipo è un'enumerazione, ma non esiste alcun tipo di sistema sottostante.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1405">This type is an enumeration, but there is no underlying system type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberSignature Language="VB.NET" Value="Public Const UnspecifiedTypeSize As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="F#" Value="val mutable UnspecifiedTypeSize : int" Usage="System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><span data-ttu-id="04e9c-1406">Indica che le dimensioni totali per il tipo non sono specificate.</span><span class="sxs-lookup"><span data-stu-id="04e9c-1406">Represents that total size for the type is not specified.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>