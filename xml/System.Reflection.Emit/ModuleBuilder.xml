<Type Name="ModuleBuilder" FullName="System.Reflection.Emit.ModuleBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="106806899c95de116223869cfc27485b57f4cf96" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37474787" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ModuleBuilder : System.Reflection.Module, System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ModuleBuilder extends System.Reflection.Module implements class System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ModuleBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class ModuleBuilder&#xA;Inherits Module&#xA;Implements _ModuleBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class ModuleBuilder : System::Reflection::Module, System::Runtime::InteropServices::_ModuleBuilder" />
  <TypeSignature Language="F#" Value="type ModuleBuilder = class&#xA;    inherit Module&#xA;    interface _ModuleBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.Module</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ModuleBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ModuleBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Defines and represents a module in a dynamic assembly.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere un'istanza di <xref:System.Reflection.Emit.ModuleBuilder>, usare il <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di `ModuleBuilder` per creare un modulo dinamico. Si noti che ModuleBuilder viene creato chiamando <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> in <xref:System.Reflection.Emit.AssemblyBuilder>, anziché tramite un costruttore.  
  
 [!code-cpp[ModuleBuilder_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_Class/CPP/modulebuilder.cpp#1)]
 [!code-csharp[ModuleBuilder_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_Class/CS/modulebuilder.cs#1)]
 [!code-vb[ModuleBuilder_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_Class/VB/modulebuilder.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ModuleBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ModuleBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the dynamic assembly that defined this instance of <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
        <value>L'assembly dinamico che è definito il modulo dinamico corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Reflection.Assembly> oggetto restituito è il <xref:System.Reflection.Emit.AssemblyBuilder> che definito questa istanza di <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateGlobalFunctions">
      <MemberSignature Language="C#" Value="public void CreateGlobalFunctions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateGlobalFunctions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateGlobalFunctions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateGlobalFunctions();" />
      <MemberSignature Language="F#" Value="member this.CreateGlobalFunctions : unit -&gt; unit" Usage="moduleBuilder.CreateGlobalFunctions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Completes the global function definitions and global data definitions for this dynamic module.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo deve essere chiamato quando l'utente viene eseguita con la definizione di tutte le funzioni globali all'interno del modulo dinamico. Dopo aver chiamato questa funzione, non più nuove funzioni globali o nuovi dati globali sono consentiti.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente viene illustrato l'utilizzo di `CreateGlobalFunctions` per creare un metodo statico globale da un <xref:System.Reflection.Emit.MethodBuilder> implementata con <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#2)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#2)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This method was called previously.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDocument">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDocument (url As String, language As Guid, languageVendor As Guid, documentType As Guid) As ISymbolDocumentWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ DefineDocument(System::String ^ url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="member this.DefineDocument : string * Guid * Guid * Guid -&gt; System.Diagnostics.SymbolStore.ISymbolDocumentWriter" Usage="moduleBuilder.DefineDocument (url, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolDocumentWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="url">The URL for the document.</param>
        <param name="language">The GUID that identifies the document language. This can be <see cref="F:System.Guid.Empty" />.</param>
        <param name="languageVendor">The GUID that identifies the document language vendor. This can be <see cref="F:System.Guid.Empty" />.</param>
        <param name="documentType">The GUID that identifies the document type. This can be <see cref="F:System.Guid.Empty" />.</param>
        <summary>Defines a document for source.</summary>
        <returns>The defined document.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Le versioni precedenti di .NET Framework generato <xref:System.ArgumentException> invece di <xref:System.ArgumentNullException> quando `url` è `null`.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso di `DefineDocument` per allegare un documento di simbolo esterno (in questo caso, un file non elaborato linguaggio intermedio) a un modulo dinamico.  
  
 [!code-cpp[ModuleBuilder_DefineDocument#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CPP/modulebuilder_definedocument.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineDocument#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CS/modulebuilder_definedocument.cs#1)]
 [!code-vb[ModuleBuilder_DefineDocument#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineDocument/VB/modulebuilder_definedocument.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> is <see langword="null" />. This is a change from earlier versions of the .NET Framework.</exception>
        <exception cref="T:System.InvalidOperationException">This method is called on a dynamic module that is not a debug module.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEnum">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EnumBuilder DefineEnum (string name, System.Reflection.TypeAttributes visibility, Type underlyingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EnumBuilder DefineEnum(string name, valuetype System.Reflection.TypeAttributes visibility, class System.Type underlyingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEnum (name As String, visibility As TypeAttributes, underlyingType As Type) As EnumBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EnumBuilder ^ DefineEnum(System::String ^ name, System::Reflection::TypeAttributes visibility, Type ^ underlyingType);" />
      <MemberSignature Language="F#" Value="member this.DefineEnum : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.EnumBuilder" Usage="moduleBuilder.DefineEnum (name, visibility, underlyingType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EnumBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="visibility" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="underlyingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The full path of the enumeration type. <c>name</c> cannot contain embedded nulls.</param>
        <param name="visibility">The type attributes for the enumeration. The attributes are any bits defined by <see cref="F:System.Reflection.TypeAttributes.VisibilityMask" />.</param>
        <param name="underlyingType">The underlying type for the enumeration. This must be a built-in integer type.</param>
        <summary>Defines an enumeration type that is a value type with a single non-static field called <paramref name="value__" /> of the specified type.</summary>
        <returns>The defined enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'enumerazione definita è una classe derivata di <xref:System.Enum>. Il `value__` campo ha <xref:System.Reflection.FieldAttributes.Private> e <xref:System.Reflection.FieldAttributes.SpecialName> set di attributi.  
  
 Per altre informazioni sui tipi integer predefiniti che possono essere specificati come tipi sottostanti delle enumerazioni, vedere [Cenni preliminari sulla libreria di classi](~/docs/standard/class-library-overview.md).  
  
> [!NOTE]
>  Nelle versioni 1.0 e 1.1 di .NET Framework, è necessario definire le enumerazioni utilizzando <xref:System.Reflection.Emit.TypeBuilder> poiché <xref:System.Reflection.Emit.EnumBuilder> genera le enumerazioni i cui elementi sono di tipo <xref:System.Int32> anziché il tipo di enumerazione. In .NET Framework versione 2.0, <xref:System.Reflection.Emit.EnumBuilder> emette le enumerazioni i cui elementi sono il tipo corretto.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di `DefineEnum` per implementare una classe di enumerazione in un modulo dinamico. L'esempio definisce un enumeratore chiamato `Elevation` che dispone di un tipo sottostante <xref:System.Int32>e crea due elementi: `Low`, con un valore pari a 0, e `High`, con un valore pari a 1. Dopo aver creato il tipo, l'assembly viene salvato con il nome `TempAssembly.dll`. È possibile usare la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per esaminarne il contenuto di questo assembly.  
  
> [!NOTE]
>  Prima di .NET Framework versione 2.0, questo esempio di codice non produce un'enumerazione corretta.  
  
 [!code-cpp[ModuleBuilder_DefineEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CPP/modulebuilder_defineenum.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CS/modulebuilder_defineenum.cs#1)]
 [!code-vb[ModuleBuilder_DefineEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineEnum/VB/modulebuilder_defineenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Attributes other than visibility attributes are provided.  -or-  An enumeration with the given name exists in the parent assembly of this module.  -or-  The visibility attributes do not match the scope of the enumeration. For example, <see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> is specified for <paramref name="visibility" />, but the enumeration is not a nested type.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineGlobalMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Defines a global method.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">The name of the method. <c>name</c> cannot contain embedded nulls.</param>
        <param name="attributes">The attributes of the method. <c>attributes</c> must include <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="returnType">The return type of the method.</param>
        <param name="parameterTypes">The types of the method's parameters.</param>
        <summary>Defines a global method with the specified name, attributes, return type, and parameter types.</summary>
        <returns>The defined global method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo globale che definisce questo metodo non può essere usato finché non si chiama <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di `DefineGlobalMethod` per creare un metodo indipendente dal tipo associato all'oggetto corrente <xref:System.Reflection.Emit.ModuleBuilder>. Dopo aver compilato il metodo globale, <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> deve essere chiamato per completare l'operazione.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The method is not static. That is, <paramref name="attributes" /> does not include <see cref="F:System.Reflection.MethodAttributes.Static" />.  -or-  The length of <paramref name="name" /> is zero  -or-  An element in the <see cref="T:System.Type" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> has been previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">The name of the method. <c>name</c> cannot contain embedded nulls.</param>
        <param name="attributes">The attributes of the method. <c>attributes</c> must include <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">The calling convention for the method.</param>
        <param name="returnType">The return type of the method.</param>
        <param name="parameterTypes">The types of the method's parameters.</param>
        <summary>Defines a global method with the specified name, attributes, calling convention, return type, and parameter types.</summary>
        <returns>The defined global method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare il metodo globale definito dal metodo finché non si chiama <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Esempio di codice seguente illustra l'uso della `DefineGlobalMethod` per creare un metodo indipendente dal tipo associato all'oggetto corrente <xref:System.Reflection.Emit.ModuleBuilder>. Dopo aver compilato il metodo globale, <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> deve essere chiamato per completare l'operazione.  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The method is not static. That is, <paramref name="attributes" /> does not include <see cref="F:System.Reflection.MethodAttributes.Static" />.  -or-  An element in the <see cref="T:System.Type" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> has been previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] requiredReturnTypeCustomModifiers, class System.Type[] optionalReturnTypeCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] requiredParameterTypeCustomModifiers, class System.Type[][] optionalParameterTypeCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, requiredReturnTypeCustomModifiers As Type(), optionalReturnTypeCustomModifiers As Type(), parameterTypes As Type(), requiredParameterTypeCustomModifiers As Type()(), optionalParameterTypeCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ requiredReturnTypeCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalReturnTypeCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredParameterTypeCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, callingConvention, returnType, requiredReturnTypeCustomModifiers, optionalReturnTypeCustomModifiers, parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="requiredReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredParameterTypeCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalParameterTypeCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">The name of the method. <c>name</c> cannot contain embedded null characters.</param>
        <param name="attributes">The attributes of the method. <c>attributes</c> must include <see cref="F:System.Reflection.MethodAttributes.Static" />.</param>
        <param name="callingConvention">The calling convention for the method.</param>
        <param name="returnType">The return type of the method.</param>
        <param name="requiredReturnTypeCustomModifiers">An array of types representing the required custom modifiers for the return type, such as <see cref="T:System.Runtime.CompilerServices.IsConst" /> or <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. If the return type has no required custom modifiers, specify <see langword="null" />.</param>
        <param name="optionalReturnTypeCustomModifiers">An array of types representing the optional custom modifiers for the return type, such as <see cref="T:System.Runtime.CompilerServices.IsConst" /> or <see cref="T:System.Runtime.CompilerServices.IsBoxed" />. If the return type has no optional custom modifiers, specify <see langword="null" />.</param>
        <param name="parameterTypes">The types of the method's parameters.</param>
        <param name="requiredParameterTypeCustomModifiers">An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter of the global method. If a particular argument has no required custom modifiers, specify <see langword="null" /> instead of an array of types. If the global method has no arguments, or if none of the arguments have required custom modifiers, specify <see langword="null" /> instead of an array of arrays.</param>
        <param name="optionalParameterTypeCustomModifiers">An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter. If a particular argument has no optional custom modifiers, specify <see langword="null" /> instead of an array of types. If the global method has no arguments, or if none of the arguments have optional custom modifiers, specify <see langword="null" /> instead of an array of arrays.</param>
        <summary>Defines a global method with the specified name, attributes, calling convention, return type, custom modifiers for the return type, parameter types, and custom modifiers for the parameter types.</summary>
        <returns>The defined global method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo overload è disponibile per i progettisti di compilatori gestiti.  
  
 È possibile utilizzare il metodo globale definito dal metodo finché non si chiama <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The method is not static. That is, <paramref name="attributes" /> does not include <see cref="F:System.Reflection.MethodAttributes.Static" />.  -or-  An element in the <see cref="T:System.Type" /> array is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> method has been previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="moduleBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">The name used to refer to the data. <c>name</c> cannot contain embedded nulls.</param>
        <param name="data">The binary large object (BLOB) of data.</param>
        <param name="attributes">The attributes for the field. The default is <see langword="Static" />.</param>
        <summary>Defines an initialized data field in the .sdata section of the portable executable (PE) file.</summary>
        <returns>A field to reference the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static> viene automaticamente incluso in `attributes`.  
  
 I dati definiti da questo metodo non viene creati finché il <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> viene chiamato il metodo.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> metodo per definire un campo di dati inizializzati nel `.sdata` sezione del file eseguibile portabile (PE).  
  
 [!code-cpp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CPP/modulebuilder_defineinitializeddata.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CS/modulebuilder_defineinitializeddata.cs#1)]
 [!code-vb[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/VB/modulebuilder_defineinitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The length of <paramref name="name" /> is zero.  -or-  The size of <paramref name="data" /> is less than or equal to zero or greater than or equal to 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> or <paramref name="data" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> has been previously called.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineManifestResource">
      <MemberSignature Language="C#" Value="public void DefineManifestResource (string name, System.IO.Stream stream, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineManifestResource(string name, class System.IO.Stream stream, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineManifestResource(System::String ^ name, System::IO::Stream ^ stream, System::Reflection::ResourceAttributes attribute);" />
      <MemberSignature Language="F#" Value="member this.DefineManifestResource : string * System.IO.Stream * System.Reflection.ResourceAttributes -&gt; unit" Usage="moduleBuilder.DefineManifestResource (name, stream, attribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">The case-sensitive name for the resource.</param>
        <param name="stream">A stream that contains the bytes for the resource.</param>
        <param name="attribute">An enumeration value that specifies whether the resource is public or private.</param>
        <summary>Defines a binary large object (BLOB) that represents a manifest resource to be embedded in the dynamic assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le risorse che vengono registrate nel manifesto dell'assembly possono essere risorse gestite o manifesto risorse BLOB, e ognuno di questi può essere incluso nell'assembly mediante il collegamento o incorporamento. Tutti i quattro scenari sono supportati per gli assembly dinamici.  
  
-   Questo metodo consente di incorporare una risorsa di manifesto BLOB in un assembly dinamico.  
  
-   Per incorporare una risorsa gestita nel modulo del manifesto di un assembly dinamico o in un modulo satellite, usare il <xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType> metodo per ottenere un writer di risorse e usare il <xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType> metodo per aggiungere la risorsa.  
  
-   Per collegare una risorsa gestita in un assembly dinamico, usare il <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType> metodo per ottenere un writer di risorse e usare il <xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType> metodo per aggiungere la risorsa collegata.  
  
-   Per collegare una risorsa di manifesto BLOB in un assembly dinamico, usare il <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType> metodo per aggiungere la risorsa collegata.  
  
 Inoltre, una singola risorsa Win32 può essere collegata a un assembly usando il <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType> metodo o il <xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType> (metodo). Questa risorsa non viene visualizzato nel manifesto dell'assembly.  
  
   
  
## Examples  
 Nell'esempio seguente genera l'errore e lo salva un assembly dinamico denominato `EmittedManifestResourceAssembly.exe`, cui è incorporata una risorsa non gestita. Nell'esempio viene creato l'assembly, che è costituito da uno dei moduli e apre un flusso di memoria per contenere la risorsa non gestita. Il codice chiama quindi il <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> metodo per definire la risorsa.  
  
> [!NOTE]
>  È possibile usare qualsiasi tipo di flusso per la risorsa. ad esempio, è possibile leggere i dati binari non gestiti da un file.  
  
 L'esempio definisce un tipo nel modulo dinamico con un `Main` (metodo) e genera il codice MSIL per il corpo del metodo. Il corpo di `Main` metodo è stato generato e il tipo è stato creato, l'esempio di codice scrive cinque byte nel flusso associato alla risorsa di manifesto. Quando viene salvato l'assembly, la risorsa viene aggiunto a esso.  
  
 Dopo aver eseguito l'esempio, è possibile eseguire l'assembly generato. Il codice dell'assembly generato `Main` metodo legge la risorsa del manifesto incorporata e vengono stampati i valori di byte nella console. È possibile usare la [Ildasm.exe (Disassembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) per visualizzare le informazioni nel manifesto dell'assembly.  
  
 [!code-csharp[DefineManifestResource#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineManifestResource/cs/source.cs#1)]
 [!code-vb[DefineManifestResource#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineManifestResource/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  <paramref name="stream" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is a zero-length string.</exception>
        <exception cref="T:System.InvalidOperationException">The dynamic assembly that contains the current module is transient; that is, no file name was specified when <see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /> was called.</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)" />
        <altmember cref="M:System.Resources.ResourceWriter.AddResource(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)" />
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Defines a <see langword="PInvoke" /> method.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">The name of the <see langword="PInvoke" /> method. <c>name</c> cannot contain embedded nulls.</param>
        <param name="dllName">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</param>
        <param name="attributes">The attributes of the method.</param>
        <param name="callingConvention">The method's calling convention.</param>
        <param name="returnType">The method's return type.</param>
        <param name="parameterTypes">The types of the method's parameters.</param>
        <param name="nativeCallConv">The native calling convention.</param>
        <param name="nativeCharSet">The method's native character set.</param>
        <summary>Defines a <see langword="PInvoke" /> method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</summary>
        <returns>The defined <see langword="PInvoke" /> method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni attributi di importazione DLL (vedere la descrizione di InteropServices) non possono essere specificate come argomenti al metodo. Tali attributi devono essere impostati con la creazione di un attributo personalizzato per il metodo. Ad esempio, la DLL import (attributo) `PreserveSig` viene impostato con la creazione di un attributo personalizzato.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei `DefinePInvokeMethod` metodo per creare un <xref:System.Reflection.Emit.MethodBuilder> per un metodo non gestito esterno, `MessageBoxA`, nell'API Win32. L'esempio visualizza una finestra di messaggio con **ripetere** e **Annulla** pulsanti e visualizza il valore restituito dalla finestra di messaggio.  
  
> [!IMPORTANT]
>  Per ottenere un valore restituito diverso da zero, è necessario aggiungere <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> ai flag di implementazione del metodo dopo aver creato il <xref:System.Reflection.Emit.MethodBuilder>, usando la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> metodi.  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The method is not static or if the containing type is an interface.  -or-  The method is abstract.  -or-  The method was previously defined.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> or <paramref name="dllName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">The name of the <see langword="PInvoke" /> method. <c>name</c> cannot contain embedded nulls.</param>
        <param name="dllName">The name of the DLL in which the <see langword="PInvoke" /> method is defined.</param>
        <param name="entryName">The name of the entry point in the DLL.</param>
        <param name="attributes">The attributes of the method.</param>
        <param name="callingConvention">The method's calling convention.</param>
        <param name="returnType">The method's return type.</param>
        <param name="parameterTypes">The types of the method's parameters.</param>
        <param name="nativeCallConv">The native calling convention.</param>
        <param name="nativeCharSet">The method's native character set.</param>
        <summary>Defines a <see langword="PInvoke" /> method with the specified name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <see langword="PInvoke" /> flags.</summary>
        <returns>The defined <see langword="PInvoke" /> method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli attributi di importazione alcune DLL (vedere la descrizione della <xref:System.Runtime.InteropServices.DllImportAttribute>) non possono essere specificate come argomenti al metodo. Tali attributi devono essere impostati con la creazione di un attributo personalizzato per il metodo. Ad esempio, la DLL import (attributo) `PreserveSig` viene impostato con la creazione di un attributo personalizzato.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo dei `DefinePInvokeMethod` metodo per creare un <xref:System.Reflection.Emit.MethodBuilder> per un metodo non gestito esterno, `MessageBoxA`, nell'API Win32. L'esempio visualizza una finestra di messaggio con **ripetere** e **Annulla** pulsanti e visualizza il valore restituito dalla finestra di messaggio.  
  
> [!IMPORTANT]
>  Per ottenere un valore restituito diverso da zero, è necessario aggiungere <xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType> ai flag di implementazione del metodo dopo aver creato il <xref:System.Reflection.Emit.MethodBuilder>, usando la <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> metodi.  
  
 Questo esempio Usa un overload diverso del <xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A> (metodo), ma la tecnica è lo stesso.  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The method is not static or if the containing type is an interface or if the method is abstract of if the method was previously defined.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> or <paramref name="dllName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The containing type has been previously created using <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Defines a managed embedded resource to be stored in this module.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description);" />
      <MemberSignature Language="F#" Value="member this.DefineResource : string * string -&gt; System.Resources.IResourceWriter" Usage="moduleBuilder.DefineResource (name, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the resource. <c>name</c> cannot contain embedded nulls.</param>
        <param name="description">The description of the resource.</param>
        <summary>Defines the named managed embedded resource to be stored in this module.</summary>
        <returns>A resource writer for the defined resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il chiamante non deve chiamare il `ResourceWriter.Generate()` e `ResourceWriter.Close()` metodi, poiché questi metodi vengono chiamati dal `ModuleBuilder.Save` quando viene scritto l'assembly dinamico su disco.  
  
 Usare questo metodo per incorporare una risorsa gestita. Per incorporare un blob di risorsa di manifesto, usare il <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> (metodo). Per un riepilogo di incorporamento e collegare le risorse gestite e risorsa di manifesto BLOB, vedere il <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> (metodo).  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di `DefineResource` per aggiungere una risorsa esterna all'attuale <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 [!code-cpp[ModuleBuilder_DefineResource1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CPP/modulebuilder_defineresource1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CS/modulebuilder_defineresource1.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource1/VB/modulebuilder_defineresource1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="name" /> is zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null.</exception>
        <exception cref="T:System.InvalidOperationException">This module is transient.  -or-  The containing assembly is not persistable.</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String, attribute As ResourceAttributes) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description, System::Reflection::ResourceAttributes attribute);" />
      <MemberSignature Language="F#" Value="member this.DefineResource : string * string * System.Reflection.ResourceAttributes -&gt; System.Resources.IResourceWriter" Usage="moduleBuilder.DefineResource (name, description, attribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">The name of the resource. <c>name</c> cannot contain embedded nulls.</param>
        <param name="description">The description of the resource.</param>
        <param name="attribute">The resource attributes.</param>
        <summary>Defines the named managed embedded resource with the given attributes that is to be stored in this module.</summary>
        <returns>A resource writer for the defined resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il chiamante non deve chiamare il `ResourceWriter.Generate()` e `ResourceWriter.Close()` metodi, poiché questi metodi vengono chiamati dal `ModuleBuilder.Save` quando viene scritto l'assembly dinamico su disco.  
  
 Usare questo metodo per incorporare una risorsa gestita. Per incorporare un blob di risorsa di manifesto, usare il <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> (metodo). Per un riepilogo di incorporamento e collegare le risorse gestite e risorsa di manifesto BLOB, vedere il <xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A> (metodo).  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo di DefineResource per aggiungere una risorsa esterna all'attuale <xref:System.Reflection.Emit.ModuleBuilder>.  
  
 [!code-cpp[ModuleBuilder_DefineResource2#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CPP/modulebuilder_defineresource2.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CS/modulebuilder_defineresource2.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource2/VB/modulebuilder_defineresource2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="name" /> is zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is null.</exception>
        <exception cref="T:System.InvalidOperationException">This module is transient.  -or-  The containing assembly is not persistable.</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Constructs a <see langword="TypeBuilder" />. To define a value type, define a type that derives from <see cref="T:System.ValueType" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The full path of the type, including the namespace. <c>name</c> cannot contain embedded nulls.</param>
        <summary>Constructs a <see langword="TypeBuilder" /> for a private type with the specified name in this module.</summary>
        <returns>A private type with the specified name.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi dei tipi deve essere univoci all'interno di un assembly. È possibile avere due tipi con lo stesso nome in due moduli diversi di un assembly.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Reflection.Emit.TypeBuilder> nel modulo dinamico corrente usando `CreateType`, compilazioni e completa il tipo e Salva l'assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A type with the given name exists in the parent assembly of this module.  -or-  Nested type attributes are set on a type that is not nested.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">The full path of the type. <c>name</c> cannot contain embedded nulls.</param>
        <param name="attr">The attributes of the defined type.</param>
        <summary>Constructs a <see langword="TypeBuilder" /> given the type name and the type attributes.</summary>
        <returns>A <see langword="TypeBuilder" /> created with all of the requested attributes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi dei tipi deve essere univoci all'interno di un assembly. È possibile avere due tipi con lo stesso nome in due moduli diversi di un assembly.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Reflection.Emit.TypeBuilder> nel modulo dinamico corrente usando `CreateType`, compilazioni e completa il tipo e Salva l'assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A type with the given name exists in the parent assembly of this module.  -or-  Nested type attributes are set on a type that is not nested.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The full path of the type. <c>name</c> cannot contain embedded nulls.</param>
        <param name="attr">The attribute to be associated with the type.</param>
        <param name="parent">The type that the defined type extends.</param>
        <summary>Constructs a <see langword="TypeBuilder" /> given type name, its attributes, and the type that the defined type extends.</summary>
        <returns>A <see langword="TypeBuilder" /> created with all of the requested attributes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi dei tipi deve essere univoci all'interno di un assembly. È possibile avere due tipi con lo stesso nome in due moduli diversi di un assembly.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Reflection.Emit.TypeBuilder> nel modulo dinamico corrente usando `CreateType`, compilazioni e completa il tipo e Salva l'assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A type with the given name exists in the parent assembly of this module.  -or-  Nested type attributes are set on a type that is not nested.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, typesize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typesize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, typesize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">The full path of the type. <c>name</c> cannot contain embedded nulls.</param>
        <param name="attr">The attributes of the defined type.</param>
        <param name="parent">The type that the defined type extends.</param>
        <param name="typesize">The total size of the type.</param>
        <summary>Constructs a <see langword="TypeBuilder" /> given the type name, the attributes, the type that the defined type extends, and the total size of the type.</summary>
        <returns>A <see langword="TypeBuilder" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi dei tipi deve essere univoci all'interno di un assembly. Non è consentito avere due tipi con lo stesso nome in due moduli diversi di un assembly.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Reflection.Emit.TypeBuilder> nel modulo dinamico corrente usando `CreateType`, compilazioni e completa il tipo e Salva l'assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A type with the given name exists in the parent assembly of this module.  -or-  Nested type attributes are set on a type that is not nested.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packsize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packsize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, packsize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packsize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, packsize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packsize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">The full path of the type. <c>name</c> cannot contain embedded nulls.</param>
        <param name="attr">The attributes of the defined type.</param>
        <param name="parent">The type that the defined type extends.</param>
        <param name="packsize">The packing size of the type.</param>
        <summary>Constructs a <see langword="TypeBuilder" /> given the type name, the attributes, the type that the defined type extends, and the packing size of the type.</summary>
        <returns>A <see langword="TypeBuilder" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi dei tipi deve essere univoci all'interno di un assembly. È possibile avere due tipi con lo stesso nome in due moduli diversi di un assembly.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Reflection.Emit.TypeBuilder> nel modulo dinamico corrente usando `CreateType`, compilazioni e completa il tipo e Salva l'assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A type with the given name exists in the parent assembly of this module.  -or-  Nested type attributes are set on a type that is not nested.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">The full path of the type. <c>name</c> cannot contain embedded nulls.</param>
        <param name="attr">The attributes to be associated with the type.</param>
        <param name="parent">The type that the defined type extends.</param>
        <param name="interfaces">The list of interfaces that the type implements.</param>
        <summary>Constructs a <see langword="TypeBuilder" /> given the type name, attributes, the type that the defined type extends, and the interfaces that the defined type implements.</summary>
        <returns>A <see langword="TypeBuilder" /> created with all of the requested attributes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi dei tipi deve essere univoci all'interno di un assembly. È possibile avere due tipi con lo stesso nome in due moduli diversi di un assembly.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Reflection.Emit.TypeBuilder> nel modulo dinamico corrente usando `CreateType`, compilazioni e completa il tipo e Salva l'assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A type with the given name exists in the parent assembly of this module.  -or-  Nested type attributes are set on a type that is not nested.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packingSize, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packingSize, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packingSize, int typesize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, packingSize, typesize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packingSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">The full path of the type. <c>name</c> cannot contain embedded nulls.</param>
        <param name="attr">The attributes of the defined type.</param>
        <param name="parent">The type that the defined type extends.</param>
        <param name="packingSize">The packing size of the type.</param>
        <param name="typesize">The total size of the type.</param>
        <summary>Constructs a <see langword="TypeBuilder" /> given the type name, attributes, the type that the defined type extends, the packing size of the defined type, and the total size of the defined type.</summary>
        <returns>A <see langword="TypeBuilder" /> created with all of the requested attributes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I nomi dei tipi deve essere univoci all'interno di un assembly. È possibile avere due tipi con lo stesso nome in due moduli diversi di un assembly.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
   
  
## Examples  
 L'esempio seguente crea una <xref:System.Reflection.Emit.TypeBuilder> nel modulo dinamico corrente usando `CreateType`, compilazioni e completa il tipo e Salva l'assembly.  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A type with the given name exists in the parent assembly of this module.  -or-  Nested type attributes are set on a type that is not nested.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="moduleBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">The name used to refer to the data. <c>name</c> cannot contain embedded nulls.</param>
        <param name="size">The size of the data field.</param>
        <param name="attributes">The attributes for the field.</param>
        <summary>Defines an uninitialized data field in the .sdata section of the portable executable (PE) file.</summary>
        <returns>A field to reference the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static> viene automaticamente incluso in `attributes`.  
  
 I dati definiti da questo metodo non viene creati finché il <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> viene chiamato il metodo.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The length of <paramref name="name" /> is zero.  -or-  <paramref name="size" /> is less than or equal to zero, or greater than or equal to 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> has been previously called.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineUnmanagedResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Defines an unmanaged resource in this module. The binary large object (BLOB) must have the right format for a Win32 resource.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (byte[] resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(unsigned int8[] resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resource As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(cli::array &lt;System::Byte&gt; ^ resource);" />
      <MemberSignature Language="F#" Value="member this.DefineUnmanagedResource : byte[] -&gt; unit" Usage="moduleBuilder.DefineUnmanagedResource resource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="resource">An opaque BLOB that represents an unmanaged resource</param>
        <summary>Defines an unmanaged embedded resource given an opaque binary large object (BLOB) of bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un assembly può essere associato a una sola risorsa non gestita. Ciò significa che la chiamata `DefineVersionInfoResource` oppure `DefineUnmanagedResource` dopo che uno dei metodi è stato chiamato in precedenza genera <xref:System.ArgumentException>. Più risorse non gestite devono essere unite tramite uno strumento, ad esempio l'utilità ResMerge Microsoft (non fornita con common language runtime).  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An unmanaged resource has already been defined in the module's assembly.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resource" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (string resourceFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(string resourceFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resourceFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(System::String ^ resourceFileName);" />
      <MemberSignature Language="F#" Value="member this.DefineUnmanagedResource : string -&gt; unit" Usage="moduleBuilder.DefineUnmanagedResource resourceFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceFileName">The name of the unmanaged resource file.</param>
        <summary>Defines an unmanaged resource given the name of Win32 resource file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un assembly può essere associato a una sola risorsa non gestita. Ciò significa che la chiamata `DefineVersionInfoResource` oppure `DefineUnmanagedResource` dopo che uno dei metodi è stato chiamato in precedenza genera <xref:System.ArgumentException>. Più risorse non gestite devono essere unite tramite uno strumento, ad esempio l'utilità ResMerge Microsoft (non fornita con common language runtime).  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An unmanaged resource has already been defined in the module's assembly.  -or-  <paramref name="resourceFileName" /> is the empty string ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="resourceFileName" /> is not found.  -or-  <paramref name="resourceFileName" /> is a directory.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="moduleBuilder.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">An object to compare with this instance, or <see langword="null" />.</param>
        <summary>Returns a value that indicates whether this instance is equal to the specified object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public override string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifiedName : string" Usage="System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see langword="String" /> representing the fully qualified name and path to this module.</summary>
        <value>Il nome completo del modulo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere il nome senza il percorso, usare `Name`.  
  
> [!NOTE]
>  Nel caso di un nome di modulo è dipendente dalla piattaforma.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Si accede alle informazioni del percorso. Enumerazione associata: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetArrayMethod (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetArrayMethod(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayMethod (arrayClass As Type, methodName As String, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetArrayMethod(Type ^ arrayClass, System::String ^ methodName, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetArrayMethod : Type * string * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.MethodInfo" Usage="moduleBuilder.GetArrayMethod (arrayClass, methodName, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">An array class.</param>
        <param name="methodName">The name of a method on the array class.</param>
        <param name="callingConvention">The method's calling convention.</param>
        <param name="returnType">The return type of the method.</param>
        <param name="parameterTypes">The types of the method's parameters.</param>
        <summary>Returns the named method on an array class.</summary>
        <returns>The named method on an array class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetArrayMethod` è utile quando si dispone di una matrice di un tipo la cui definizione non è stata completata e si desidera accedere ai metodi definiti nel <xref:System.Array>. Ad esempio, si potrebbe definire un tipo e per definire un metodo che accetta una matrice del tipo come parametro. Per accedere agli elementi della matrice, è necessario chiamare i metodi del <xref:System.Array> classe.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A> per ottenere il <xref:System.Reflection.MethodInfo> corrispondente a un metodo che restituisce un valore di matrice.  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#1)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#1)]
 [!code-vb[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" /> is not an array.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> or <paramref name="methodName" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetArrayMethodToken (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetArrayMethodToken(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayMethodToken (arrayClass As Type, methodName As String, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetArrayMethodToken(Type ^ arrayClass, System::String ^ methodName, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetArrayMethodToken : Type * string * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetArrayMethodToken (arrayClass, methodName, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">The object for the array.</param>
        <param name="methodName">A string that contains the name of the method.</param>
        <param name="callingConvention">The calling convention for the method.</param>
        <param name="returnType">The return type of the method.</param>
        <param name="parameterTypes">The types of the parameters of the method.</param>
        <summary>Returns the token for the named method on an array class.</summary>
        <returns>The token for the named method on an array class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è simile a <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>, ad eccezione del fatto che restituisce il token del metodo matrice anziché il metodo di stesso.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare <xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A> per ottenere il <xref:System.Reflection.Emit.MethodToken> corrispondente a un metodo che restituisce un valore di matrice.  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#2)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#2)]
 [!code-vb[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" /> is not an array.  -or-  The length of <paramref name="methodName" /> is zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> or <paramref name="methodName" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructorToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the token used to identify the specified constructor within this module.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructorToken (con As ConstructorInfo) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetConstructorToken(System::Reflection::ConstructorInfo ^ con);" />
      <MemberSignature Language="F#" Value="member this.GetConstructorToken : System.Reflection.ConstructorInfo -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetConstructorToken con" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="con">The constructor to get a token for.</param>
        <summary>Returns the token used to identify the specified constructor within this module.</summary>
        <returns>The token used to identify the specified constructor within this module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructorToken (constructor As ConstructorInfo, optionalParameterTypes As IEnumerable(Of Type)) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetConstructorToken(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetConstructorToken : System.Reflection.ConstructorInfo * seq&lt;Type&gt; -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetConstructorToken (constructor, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">The constructor to get a token for.</param>
        <param name="optionalParameterTypes">A collection of the types of the optional parameters to the constructor.</param>
        <summary>Returns the token used to identify the constructor that has the specified attributes and parameter types within this module.</summary>
        <returns>The token used to identify the specified constructor within this module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the custom attributes that are applied to the current <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="moduleBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">This argument is ignored for objects of this type.</param>
        <summary>Returns all the custom attributes that have been applied to the current <see cref="T:System.Reflection.Emit.ModuleBuilder" />.</summary>
        <returns>An array that contains the custom attributes; the array is empty if there are no attributes.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="moduleBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">The base type from which attributes derive.</param>
        <param name="inherit">This argument is ignored for objects of this type.</param>
        <summary>Returns all the custom attributes that have been applied to the current <see cref="T:System.Reflection.Emit.ModuleBuilder" />, and that derive from a specified attribute type.</summary>
        <returns>An array that contains the custom attributes that are derived, at any level, from <paramref name="attributeType" />; the array is empty if there are no such attributes.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime. For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="moduleBuilder.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns information about the attributes that have been applied to the current <see cref="T:System.Reflection.Emit.ModuleBuilder" />, expressed as <see cref="T:System.Reflection.CustomAttributeData" /> objects.</summary>
        <returns>A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare questo metodo per esaminare gli attributi personalizzati del codice nel contesto reflection-only, nei casi in cui gli attributi personalizzati sono definiti nel codice che viene caricato nel contesto reflection-only. Metodi come <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> e <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> non può essere utilizzato in questi casi, poiché creano istanze degli attributi. Impossibile eseguire codice nel contesto reflection-only. Per altre informazioni e, ad esempio di codice, vedere il <xref:System.Reflection.CustomAttributeData> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="moduleBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">The field name.</param>
        <param name="bindingAttr">A combination of the <see langword="BindingFlags" /> bit flags used to control the search.</param>
        <summary>Returns a module-level field, defined in the .sdata region of the portable executable (PE) file, that has the specified name and binding attributes.</summary>
        <returns>A field that has the specified name and binding attributes, or <see langword="null" /> if the field does not exist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si generano assembly dinamici, i campi nell'area. sdata del file eseguibile portabile (PE) sono definiti tramite il <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> o <xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A> metodi.  
  
> [!IMPORTANT]
>  Non è possibile recuperare i campi a livello di modulo fino a dopo il <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metodo è stato chiamato per il modulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="name" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="moduleBuilder.GetFields bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">A combination of the <see langword="BindingFlags" /> bit flags used to control the search.</param>
        <summary>Returns all fields defined in the .sdata region of the portable executable (PE) file that match the specified binding flags.</summary>
        <returns>An array of fields that match the specified flags; the array is empty if no such fields exist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si generano assembly dinamici, i campi nell'area. sdata del file eseguibile portabile (PE) sono definiti tramite il <xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A> o <xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A> metodi.  
  
> [!IMPORTANT]
>  Non è possibile recuperare i campi a livello di modulo fino a dopo il <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metodo è stato chiamato per il modulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="name" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldToken GetFieldToken (System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.FieldToken GetFieldToken(class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFieldToken (field As FieldInfo) As FieldToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldToken GetFieldToken(System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="member this.GetFieldToken : System.Reflection.FieldInfo -&gt; System.Reflection.Emit.FieldToken" Usage="moduleBuilder.GetFieldToken field" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="field">The field to get a token for.</param>
        <summary>Returns the token used to identify the specified field within this module.</summary>
        <returns>The token used to identify the specified field within this module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="moduleBuilder.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="moduleBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">The method name.</param>
        <param name="bindingAttr">A combination of <see langword="BindingFlags" /> bit flags used to control the search.</param>
        <param name="binder">An object that implements <see langword="Binder" />, containing properties related to this method.</param>
        <param name="callConvention">The calling convention for the method.</param>
        <param name="types">The parameter types of the method.</param>
        <param name="modifiers">An array of parameter modifiers used to make binding work with parameter signatures in which the types have been modified.</param>
        <summary>Returns the module-level method that matches the specified criteria.</summary>
        <returns>A method that is defined at the module level, and matches the specified criteria; or <see langword="null" /> if such a method does not exist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo fornisce l'implementazione per tutti gli overload del ereditato <xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType> (metodo). Usare ereditato <xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType> metodo per ottenere i metodi che sono stati dichiarati a livello di modulo. I metodi a livello di modulo sono definiti nel codice generato utilizzando la <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A> (metodo).  
  
> [!IMPORTANT]
>  I metodi a livello di modulo non è possibile recuperare fino a dopo il <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metodo è stato chiamato per il modulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />, <paramref name="types" /> is <see langword="null" />, or an element of <paramref name="types" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="moduleBuilder.GetMethods bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">A combination of <see langword="BindingFlags" /> bit flags used to control the search.</param>
        <summary>Returns all the methods that have been defined at the module level for the current <see cref="T:System.Reflection.Emit.ModuleBuilder" />, and that match the specified binding flags.</summary>
        <returns>An array that contains all the module-level methods that match <paramref name="bindingFlags" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I metodi a livello di modulo sono definiti nel codice generato utilizzando la <xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A> (metodo).  
  
> [!IMPORTANT]
>  I metodi a livello di modulo non è possibile recuperare fino a dopo il <xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A> metodo è stato chiamato per il modulo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the token used to identify the specified method within this module.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethodToken (method As MethodInfo) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetMethodToken(System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="member this.GetMethodToken : System.Reflection.MethodInfo -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetMethodToken method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="method">The method to get a token for.</param>
        <summary>Returns the token used to identify the specified method within this module.</summary>
        <returns>The token used to identify the specified method within this module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The declaring type for the method is not in this module.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethodToken (method As MethodInfo, optionalParameterTypes As IEnumerable(Of Type)) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetMethodToken(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetMethodToken : System.Reflection.MethodInfo * seq&lt;Type&gt; -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetMethodToken (method, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="method">The method to get a token for.</param>
        <param name="optionalParameterTypes">A collection of the types of the optional parameters to the method.</param>
        <summary>Returns the token used to identify the method that has the specified attributes and parameter types within this module.</summary>
        <returns>The token used to identify the specified method within this module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The declaring type for the method is not in this module.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public override void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberSignature Language="F#" Value="override this.GetPEKind :  *  -&gt; unit" Usage="moduleBuilder.GetPEKind (peKind, machine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">When this method returns, a combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values indicating the nature of the code in the module.</param>
        <param name="machine">When this method returns, one of the <see cref="T:System.Reflection.ImageFileMachine" /> values indicating the platform targeted by the module.</param>
        <summary>Gets a pair of values indicating the nature of the code in a module and the platform targeted by the module.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per i moduli dinamici `peKind` è sempre <xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType> e `machine` è sempre 0 (zero).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSignatureToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Defines a signature token.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (System.Reflection.Emit.SignatureHelper sigHelper);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(class System.Reflection.Emit.SignatureHelper sigHelper) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignatureToken (sigHelper As SignatureHelper) As SignatureToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::SignatureToken GetSignatureToken(System::Reflection::Emit::SignatureHelper ^ sigHelper);" />
      <MemberSignature Language="F#" Value="member this.GetSignatureToken : System.Reflection.Emit.SignatureHelper -&gt; System.Reflection.Emit.SignatureToken" Usage="moduleBuilder.GetSignatureToken sigHelper" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigHelper" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="sigHelper">The signature.</param>
        <summary>Defines a token for the signature that is defined by the specified <see cref="T:System.Reflection.Emit.SignatureHelper" />.</summary>
        <returns>A token for the defined signature.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente di definire un token di metadati per la firma descritto da `sigHelper`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigHelper" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (byte[] sigBytes, int sigLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(unsigned int8[] sigBytes, int32 sigLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignatureToken (sigBytes As Byte(), sigLength As Integer) As SignatureToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::SignatureToken GetSignatureToken(cli::array &lt;System::Byte&gt; ^ sigBytes, int sigLength);" />
      <MemberSignature Language="F#" Value="member this.GetSignatureToken : byte[] * int -&gt; System.Reflection.Emit.SignatureToken" Usage="moduleBuilder.GetSignatureToken (sigBytes, sigLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigBytes" Type="System.Byte[]" />
        <Parameter Name="sigLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sigBytes">The signature binary large object (BLOB).</param>
        <param name="sigLength">The length of the signature BLOB.</param>
        <summary>Defines a token for the signature that has the specified character array and signature length.</summary>
        <returns>A token for the specified signature.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigBytes" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberSignature Language="F#" Value="override this.GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate" Usage="moduleBuilder.GetSignerCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> object corresponding to the certificate included in the Authenticode signature of the assembly which this module belongs to. If the assembly has not been Authenticode signed, <see langword="null" /> is returned.</summary>
        <returns>A certificate, or <see langword="null" /> if the assembly to which this module belongs has not been Authenticode signed.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStringConstant">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.StringToken GetStringConstant (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.StringToken GetStringConstant(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStringConstant (str As String) As StringToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::StringToken GetStringConstant(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.GetStringConstant : string -&gt; System.Reflection.Emit.StringToken" Usage="moduleBuilder.GetStringConstant str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.StringToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">The string to add to the module's constant pool.</param>
        <summary>Returns the token of the given string in the module’s constant pool.</summary>
        <returns>The token of the string in the constant pool.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `str` è già stato definito, verrà restituito il token esistente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSymWriter">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSymWriter () As ISymbolWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::SymbolStore::ISymbolWriter ^ GetSymWriter();" />
      <MemberSignature Language="F#" Value="member this.GetSymWriter : unit -&gt; System.Diagnostics.SymbolStore.ISymbolWriter" Usage="moduleBuilder.GetSymWriter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the symbol writer associated with this dynamic module.</summary>
        <returns>The symbol writer associated with this dynamic module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the named type defined in the module.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="moduleBuilder.GetType className" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">The name of the <see cref="T:System.Type" /> to get.</param>
        <summary>Gets the named type defined in the module.</summary>
        <returns>The requested type, if the type is defined in this module; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non utilizzare questo metodo per generare i tipi di matrice, tipi di puntatore o tipi byref. Usare la <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> metodi invece.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="className" /> is zero or is greater than 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The requested <see cref="T:System.Type" /> is non-public and the caller does not have <see cref="T:System.Security.Permissions.ReflectionPermission" /> to reflect non-public objects outside the current assembly.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <exception cref="T:System.TypeLoadException">An error is encountered while loading the <see cref="T:System.Type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="moduleBuilder.GetType (className, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">The name of the <see cref="T:System.Type" /> to get.</param>
        <param name="ignoreCase">If <see langword="true" />, the search is case-insensitive. If <see langword="false" />, the search is case-sensitive.</param>
        <summary>Gets the named type defined in the module, optionally ignoring the case of the type name.</summary>
        <returns>The requested type, if the type is defined in this module; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non utilizzare questo metodo per generare i tipi di matrice, tipi di puntatore o tipi byref. Usare la <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> metodi invece.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="className" /> is zero or is greater than 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The requested <see cref="T:System.Type" /> is non-public and the caller does not have <see cref="T:System.Security.Permissions.ReflectionPermission" /> to reflect non-public objects outside the current assembly.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="moduleBuilder.GetType (className, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">The name of the <see cref="T:System.Type" /> to get.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</param>
        <param name="ignoreCase">If <see langword="true" />, the search is case-insensitive. If <see langword="false" />, the search is case-sensitive.</param>
        <summary>Gets the named type defined in the module, optionally ignoring the case of the type name. Optionally throws an exception if the type is not found.</summary>
        <returns>The specified type, if the type is declared in this module; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `throwOnError` parametro ha effetto solo quando il tipo non viene trovato. Non influisce sulle altre eccezioni che potrebbero essere generate. In particolare, se il tipo è stato trovato ma non può essere caricato <xref:System.TypeLoadException> può essere generata anche se `throwOnError` è `false`.  
  
 Non utilizzare questo metodo per generare i tipi di matrice, tipi di puntatore o tipi byref. Usare la <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType> metodi invece.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="className" /> is zero or is greater than 1023.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The requested <see cref="T:System.Type" /> is non-public and the caller does not have <see cref="T:System.Security.Permissions.ReflectionPermission" /> to reflect non-public objects outside the current assembly.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> is <see langword="true" /> and the specified type is not found.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="override this.GetTypes : unit -&gt; Type[]" Usage="moduleBuilder.GetTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns all the classes defined within this module.</summary>
        <returns>An array that contains the types defined within the module that is reflected by this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReflectionTypeLoadException` è un'eccezione di caricamento di classe speciale. Il `ReflectionTypeLoadException.Types` proprietà contiene la matrice delle classi definite nel modulo e caricate. Questa matrice può contenere alcuni valori null. Il `ReflectionTypeLoadException.LoaderExceptions` proprietà è una matrice di eccezioni che rappresentano le eccezioni generate dal caricatore di classe. Le aree libere nella matrice di classe sono allineate le eccezioni.  
  
 Ad esempio, se gli inizializzatori di una delle classi genera un'eccezione durante il caricamento, una `TargetInvocationException` viene archiviato nell'elemento corrispondente del `LoaderExceptions` matrice.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">One or more classes in a module could not be loaded.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a type token.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeToken (name As String) As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeToken GetTypeToken(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetTypeToken : string -&gt; System.Reflection.Emit.TypeToken" Usage="moduleBuilder.GetTypeToken name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the class, including the namespace.</param>
        <summary>Returns the token used to identify the type with the specified name.</summary>
        <returns>The token used to identify the type with the specified name within this module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è utile per i client del <xref:System.Reflection.Emit.MethodRental> classe che desiderano modificare direttamente il corpo di un metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is the empty string ("").  -or-  <paramref name="name" /> represents a <see langword="ByRef" /> type.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.  -or-  The type specified by <paramref name="name" /> could not be found.</exception>
        <exception cref="T:System.InvalidOperationException">This is a non-transient module that references a transient module.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeToken GetTypeToken(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTypeToken : Type -&gt; System.Reflection.Emit.TypeToken" Usage="moduleBuilder.GetTypeToken type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">The type object that represents the class type.</param>
        <summary>Returns the token used to identify the specified type within this module.</summary>
        <returns>The token used to identify the given type within this module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I token vengono usati nelle istruzioni Microsoft intermediate language (MSIL) per identificare gli oggetti. I token sono rispetto al modulo in cui sono contenuti. Ad esempio, il valore del token per `String` è probabilmente diverso da un modulo a modulo. Quando si `GetTypeToken` viene richiamato, viene aggiunto un riferimento al modulo. Il riferimento diventa parte permanente del modulo. più chiamate con lo stesso argomento sono ininfluenti aggiuntive.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> is a <see langword="ByRef" /> type.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This is a non-transient module that references a transient module.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="moduleBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">The type of custom attribute to test for.</param>
        <param name="inherit">This argument is ignored for objects of this type.</param>
        <summary>Returns a value that indicates whether the specified attribute type has been applied to this module.</summary>
        <returns>
          <see langword="true" /> if one or more instances of <paramref name="attributeType" /> have been applied to this module; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime. For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public override bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsResource();" />
      <MemberSignature Language="F#" Value="override this.IsResource : unit -&gt; bool" Usage="moduleBuilder.IsResource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a value indicating whether the object is a resource.</summary>
        <returns>
          <see langword="true" /> if the object is a resource; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTransient">
      <MemberSignature Language="C#" Value="public bool IsTransient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsTransient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsTransient" />
      <MemberSignature Language="VB.NET" Value="Public Function IsTransient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsTransient();" />
      <MemberSignature Language="F#" Value="member this.IsTransient : unit -&gt; bool" Usage="moduleBuilder.IsTransient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether this dynamic module is transient.</summary>
        <returns>
          <see langword="true" /> if this dynamic module is transient; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public override int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MDStreamVersion : int" Usage="System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the metadata stream version.</summary>
        <value>Valore integer a 32 bit che rappresenta la versione del flusso di metadati. I due byte di ordine superiore rappresentano il numero di versione principale e i due byte meno significativi rappresentano il numero di versione secondario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Per altre informazioni sull'intestazione di metadati, vedere "Partition II: Metadata Definition and Semantics" nella documentazione relativa a Common Language Infrastructure (CLI). La documentazione è disponibile online; visualizzare [ECMA c# e Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) su MSDN e [Standard ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sul sito Web di ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a token that identifies the current dynamic module in metadata.</summary>
        <value>Un token integer che identifica il modulo corrente nei metadati.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I token ottenuti usando questa proprietà possono essere passati all'API Reflection non gestita. Per altre informazioni, vedere [API Reflection non gestita](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8).  
  
> [!NOTE]
>  Informazioni sui token di metadati sono disponibili nella documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; visualizzare [ECMA c# e Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) su MSDN e [Standard ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sul sito Web di ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public override Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleVersionId : Guid" Usage="System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a universally unique identifier (UUID) that can be used to distinguish between two versions of a module.</summary>
        <value>Oggetto <see cref="T:System.Guid" /> che può essere usato per la distinzione tra due versioni di un modulo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nei metadati non gestiti, il GUID restituito dal <xref:System.Reflection.Module.ModuleVersionId%2A> proprietà è definita come il `mvid`e viene archiviato nell'heap dei GUID.  
  
> [!NOTE]
>  Altre informazioni sui metadati sono reperibile nella documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; visualizzare [ECMA c# e Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) su MSDN e [Standard ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sul sito Web di ECMA.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>A string that indicates that this is an in-memory module.</summary>
        <value>Testo che indica che si tratta di un modulo in memoria.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è possibile ottenere il nome di un modulo dinamico fino a quando il modulo è stato salvato e ricaricato dal disco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo" Usage="moduleBuilder.ResolveField (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">A metadata token that identifies a field in the module.</param>
        <param name="genericTypeArguments">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</param>
        <param name="genericMethodArguments">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</param>
        <summary>Returns the field identified by the specified metadata token, in the context defined by the specified generic type parameters.</summary>
        <returns>A <see cref="T:System.Reflection.FieldInfo" /> object representing the field that is identified by the specified metadata token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodo sul tipo in cui `metadataToken` si trova nell'ambito per ottenere una matrice di argomenti di tipo generico per `genericTypeArguments`. Usare la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> metodo sul metodo in cui `metadataToken` si trova nell'ambito per ottenere una matrice di argomenti di tipo generico per `genericTypeArguments`. È sempre sicuro fornire questi argomenti, anche quando non sono necessari.  
  
> [!NOTE]
>  Informazioni sui token di metadati sono disponibili nella documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; visualizzare [ECMA c# e Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) su MSDN e [Standard ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sul sito Web di ECMA.  
  
 Per il codice che illustra la risoluzione del token utilizzando il contesto generico (vale a dire, i parametri di tipo generico di tipo generico e/o il metodo generico in cui il token è incorporato) vedere il <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> is not a token for a field in the scope of the current module.  -or-  <paramref name="metadataToken" /> identifies a field whose parent <see langword="TypeSpec" /> has a signature containing element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo" Usage="moduleBuilder.ResolveMember (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">A metadata token that identifies a type or member in the module.</param>
        <param name="genericTypeArguments">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</param>
        <param name="genericMethodArguments">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</param>
        <summary>Returns the type or member identified by the specified metadata token, in the context defined by the specified generic type parameters.</summary>
        <returns>A <see cref="T:System.Reflection.MemberInfo" /> object representing the type or member that is identified by the specified metadata token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodo sul tipo in cui `metadataToken` si trova nell'ambito per ottenere una matrice di argomenti di tipo generico per `genericTypeArguments`. Usare la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> metodo sul metodo in cui `metadataToken` si trova nell'ambito per ottenere una matrice di argomenti di tipo generico per `genericTypeArguments`. È sempre sicuro fornire questi argomenti, anche quando non sono necessari.  
  
> [!NOTE]
>  Informazioni sui token di metadati sono disponibili nella documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; visualizzare [ECMA c# e Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) su MSDN e [Standard ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sul sito Web di ECMA.  
  
 Per il codice che illustra la risoluzione del token utilizzando il contesto generico (vale a dire, i parametri di tipo generico di tipo generico e/o il metodo generico in cui il token è incorporato) vedere il <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> is not a token for a type or member in the scope of the current module.  -or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> or <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.  -or-  <paramref name="metadataToken" /> identifies a property or event.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase" Usage="moduleBuilder.ResolveMethod (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">A metadata token that identifies a method or constructor in the module.</param>
        <param name="genericTypeArguments">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</param>
        <param name="genericMethodArguments">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</param>
        <summary>Returns the method or constructor identified by the specified metadata token, in the context defined by the specified generic type parameters.</summary>
        <returns>A <see cref="T:System.Reflection.MethodBase" /> object representing the method that is identified by the specified metadata token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodo sul tipo in cui `metadataToken` si trova nell'ambito per ottenere una matrice di argomenti di tipo generico per `genericTypeArguments`. Usare la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> metodo sul metodo in cui `metadataToken` si trova nell'ambito per ottenere una matrice di argomenti di tipo generico per `genericMethodArguments`. È sempre sicuro fornire questi argomenti, anche quando non sono necessari.  
  
> [!NOTE]
>  Informazioni sui token di metadati sono disponibili nella documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; visualizzare [ECMA c# e Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) su MSDN e [Standard ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sul sito Web di ECMA.  
  
 Per il codice che illustra la risoluzione del token utilizzando il contesto generico (vale a dire, i parametri di tipo generico di tipo generico e/o il metodo generico in cui il token è incorporato) vedere il <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> is not a token for a method or constructor in the scope of the current module.  -or-  <paramref name="metadataToken" /> is a <see langword="MethodSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public override byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberSignature Language="F#" Value="override this.ResolveSignature : int -&gt; byte[]" Usage="moduleBuilder.ResolveSignature metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">A metadata token that identifies a signature in the module.</param>
        <summary>Returns the signature blob identified by a metadata token.</summary>
        <returns>An array of bytes representing the signature blob.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informazioni sui token di metadati e le firme sono disponibili nella documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; visualizzare [ECMA c# e Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) su MSDN e [Standard ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sul sito Web di ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> is not a valid <see langword="MemberRef" />, <see langword="MethodDef" />, <see langword="TypeSpec" />, signature, or <see langword="FieldDef" /> token in the scope of the current module.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public override string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ResolveString(int metadataToken);" />
      <MemberSignature Language="F#" Value="override this.ResolveString : int -&gt; string" Usage="moduleBuilder.ResolveString metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">A metadata token that identifies a string in the string heap of the module.</param>
        <summary>Returns the string identified by the specified metadata token.</summary>
        <returns>A <see cref="T:System.String" /> containing a string value from the metadata string heap.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Informazioni sui token di metadati sono disponibili nella documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; visualizzare [ECMA c# e Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) su MSDN e [Standard ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sul sito Web di ECMA.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> is not a token for a string in the scope of the current module.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public override Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveType : int * Type[] * Type[] -&gt; Type" Usage="moduleBuilder.ResolveType (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">A metadata token that identifies a type in the module.</param>
        <param name="genericTypeArguments">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the type where the token is in scope, or <see langword="null" /> if that type is not generic.</param>
        <param name="genericMethodArguments">An array of <see cref="T:System.Type" /> objects representing the generic type arguments of the method where the token is in scope, or <see langword="null" /> if that method is not generic.</param>
        <summary>Returns the type identified by the specified metadata token, in the context defined by the specified generic type parameters.</summary>
        <returns>A <see cref="T:System.Type" /> object representing the type that is identified by the specified metadata token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> metodo sul tipo in cui `metadataToken` si trova nell'ambito per ottenere una matrice di argomenti di tipo generico per `genericTypeArguments`. Usare la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType> metodo sul metodo in cui `metadataToken` si trova nell'ambito per ottenere una matrice di argomenti di tipo generico per `genericTypeArguments`. È sempre sicuro fornire questi argomenti, anche quando non sono necessari.  
  
> [!NOTE]
>  Informazioni sui token di metadati sono disponibili nella documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; visualizzare [ECMA c# e Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) su MSDN e [Standard ECMA-335: Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) sul sito Web di ECMA.  
  
 Per il codice che illustra la risoluzione del token utilizzando il contesto generico (vale a dire, i parametri di tipo generico di tipo generico e/o il metodo generico in cui il token è incorporato) vedere il <xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> is not a token for a type in the scope of the current module.  -or-  <paramref name="metadataToken" /> is a <see langword="TypeSpec" /> whose signature contains element type <see langword="var" /> (a type parameter of a generic type) or <see langword="mvar" /> (a type parameter of a generic method), and the necessary generic type arguments were not supplied for either or both of <paramref name="genericTypeArguments" /> and <paramref name="genericMethodArguments" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> is not a valid token in the scope of the current module.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public override string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScopeName : string" Usage="System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a string that represents the name of the dynamic module.</summary>
        <value>Nome del modulo dinamico.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Applies a custom attribute to this module.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="moduleBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">An instance of a helper class that specifies the custom attribute to apply.</param>
        <summary>Applies a custom attribute to this module by using a custom attribute builder.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="moduleBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">The constructor for the custom attribute.</param>
        <param name="binaryAttribute">A byte BLOB representing the attribute.</param>
        <summary>Applies a custom attribute to this module by using a specified binary large object (BLOB) that represents the attribute.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per altre informazioni sulla formattazione `binaryAttribute`, vedere la documentazione di Common Language Infrastructure (CLI), in particolare "Partition II: Metadata Definition and Semantics". La documentazione è disponibile online; vedere [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) (ECMA C# e standard di Common Language Infrastructure) in MSDN e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) nel sito Web internazionale Ecma.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="moduleBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">The name of the custom attribute</param>
        <param name="data">An opaque binary large object (BLOB) of bytes that represents the value of the custom attribute.</param>
        <summary>This method does nothing.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non effettua alcuna operazione.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetUserEntryPoint">
      <MemberSignature Language="C#" Value="public void SetUserEntryPoint (System.Reflection.MethodInfo entryPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetUserEntryPoint(class System.Reflection.MethodInfo entryPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetUserEntryPoint (entryPoint As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetUserEntryPoint(System::Reflection::MethodInfo ^ entryPoint);" />
      <MemberSignature Language="F#" Value="member this.SetUserEntryPoint : System.Reflection.MethodInfo -&gt; unit" Usage="moduleBuilder.SetUserEntryPoint entryPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryPoint" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="entryPoint">The user entry point.</param>
        <summary>Sets the user entry point.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il compilatore potrebbe generare uno stub di avvio prima di chiamare utente principale. Lo stub di avvio saranno il punto di ingresso. Mentre l'utente principale sarà il punto di ingresso dell'utente in modo che non passi debugger al punto di ingresso del compilatore.  
  
> [!NOTE]
>  Inizia con la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], questo membro non è più necessario <xref:System.Security.Permissions.ReflectionPermission> con il <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag. (Vedere [problemi di sicurezza nella Reflection Emit](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Per usare questa funzionalità, l'applicazione deve essere destinata a [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o versione successiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryPoint" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method is called on a dynamic module that is not a debug module.  -or-  <paramref name="entryPoint" /> is not contained in this dynamic module.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ModuleBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ModuleBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="rgszNames">Passed-in array of names to be mapped.</param>
        <param name="cNames">Count of the names to be mapped.</param>
        <param name="lcid">The locale context in which to interpret the names.</param>
        <param name="rgDispId">Caller-allocated array which receives the IDs corresponding to the names.</param>
        <summary>For a description of this member, see <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetIDsOfNames`, consultare la MSDN Library.  
  
 Questo membro è un'implementazione esplicita di un membro di interfaccia. e può essere utilizzato solo quando si esegue il cast dell'istanza di <xref:System.Reflection.Emit.ModuleBuilder> su un'interfaccia <xref:System.Runtime.InteropServices._ModuleBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ModuleBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ModuleBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">The type information to return.</param>
        <param name="lcid">The locale identifier for the type information.</param>
        <param name="ppTInfo">A pointer to the requested type information object.</param>
        <summary>For a description of this member, see <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetTypeInfo`, consultare la MSDN Library.  
  
 Questo membro è un'implementazione esplicita di un membro di interfaccia. e può essere utilizzato solo quando si esegue il cast dell'istanza di <xref:System.Reflection.Emit.ModuleBuilder> su un'interfaccia <xref:System.Runtime.InteropServices._ModuleBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ModuleBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ModuleBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">The location that receives the number of type information interfaces provided by the object.</param>
        <summary>For a description of this member, see <see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::GetTypeInfoCount`, consultare la MSDN Library.  
  
 Questo membro è un'implementazione esplicita di un membro di interfaccia. e può essere utilizzato solo quando si esegue il cast dell'istanza di <xref:System.Reflection.Emit.ModuleBuilder> su un'interfaccia <xref:System.Runtime.InteropServices._ModuleBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ModuleBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ModuleBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">The member ID.</param>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="lcid">The locale context in which to interpret arguments.</param>
        <param name="wFlags">Flags describing the context of the call.</param>
        <param name="pDispParams">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</param>
        <param name="pVarResult">Pointer to the location where the result is to be stored.</param>
        <param name="pExcepInfo">Pointer to a structure that contains exception information.</param>
        <param name="puArgErr">The index of the first argument that has an error.</param>
        <summary>For a description of this member, see <see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per altre informazioni sulle `IDispatch::Invoke`, consultare la MSDN Library.  
  
 Questo membro è un'implementazione esplicita di un membro di interfaccia. e può essere utilizzato solo quando si esegue il cast dell'istanza di <xref:System.Reflection.Emit.ModuleBuilder> su un'interfaccia <xref:System.Runtime.InteropServices._ModuleBuilder>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM <c>IDispatch</c> interface.</exception>
      </Docs>
    </Member>
  </Members>
</Type>