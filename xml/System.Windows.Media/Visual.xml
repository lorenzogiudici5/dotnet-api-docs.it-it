<Type Name="Visual" FullName="System.Windows.Media.Visual">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="956d2bc2d9066c2cc410cbf9e164eee8dcb43199" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51900394" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Visual : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Visual extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Visual" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Visual&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Visual abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Visual = class&#xA;    inherit DependencyObject&#xA;    interface DUCE.IResource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Offre il supporto per il rendering in WPF, che include hit testing, trasformazione delle coordinate e calcoli relativi al rettangolo di selezione.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Visual> classe è l'astrazione di base da cui ogni <xref:System.Windows.FrameworkElement> oggetto deriva. Inoltre viene usato come punto di ingresso per la scrittura di nuovi controlli in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]e in molti modi può essere considerato equivalente di un handle di finestra (HWND) nel [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] modello applicativo.  
  
 Il <xref:System.Windows.Media.Visual> oggetto è dei principali [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] oggetto, il cui ruolo principale consiste nel fornire supporto per il rendering. Controlli dell'interfaccia utente, ad esempio <xref:System.Windows.Controls.Button> e <xref:System.Windows.Controls.TextBox>, derivano dalle <xref:System.Windows.Media.Visual> classe e usare il <xref:System.Windows.Media.Visual> definito le proprietà per rendere persistenti i dati di rendering. Il <xref:System.Windows.Media.Visual> oggetto fornisce il supporto per gli elementi seguenti:  
  
-   Visualizzazione dell'output: eseguire il rendering del contenuto del disegno serializzato e salvato in modo permanente di un oggetto visivo.  
  
-   Trasformazioni: eseguire trasformazioni su un oggetto visivo.  
  
-   Ritaglio: offrire supporto dell'area di ritaglio per un oggetto visivo.  
  
-   L'hit testing: determinare se una coordinata specificata (punto) o una geometria è contenuta all'interno di un oggetto visivo.  
  
-   Calcoli relativi al rettangolo di selezione: determinare il rettangolo delimitatore di un oggetto visivo.  
  
 A livello di architettura, la <xref:System.Windows.Media.Visual> oggetto non include il supporto per altri requisiti di sviluppo di applicazioni / [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funzionalità che non sono immediatamente correlate al rendering, come il seguente:  
  
-   Gestione di eventi  
  
-   Layout  
  
-   Stili  
  
-   Associazione dati  
  
-   Globalizzazione  
  
 <xref:System.Windows.Media.Visual> viene fornito come una classe astratta pubblica da cui possono essere derivate altre classi. La figura seguente mostra la gerarchia degli oggetti visivi esistenti definiti nel [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] architettura.  
  
 ![Diagramma delle classi derivate dall'oggetto visivo](~/add/media/visualclass01.png "diagramma delle classi derivate dall'oggetto Visual")  
Gerarchia delle classi visive  
  
 In alcuni casi, i membri che sono definiti come protetto nel <xref:System.Windows.Media.Visual> vengono esposti come membri più facilmente accessibili con nomi simili in derivato <xref:System.Windows.UIElement> classe.  
  
 Per altre informazioni, vedere [Cenni preliminari sul rendering della grafica WPF](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 Oggetto <xref:System.Windows.Media.Visual> ha un numero limitato di livelli. Nelle versioni precedenti di .NET Framework, la profondità massima è 255. Questo limite è insufficiente per alcuni layout che hanno molti livelli dell'albero visuale.  
  
 Nelle [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], la profondità massima di un <xref:System.Windows.Media.Visual> è 2047, che consente ad albero visuali molto più avanzate. Nella maggior parte delle applicazioni, non c'è spazio sufficiente dello stack per attraversare molti livelli, e il risultato è un <xref:System.StackOverflowException> durante il layout. Per la dimensione predefinita, questa eccezione viene generata in genere quando la profondità dell'albero è circa 800, che corrisponde a circa 190 annidati <xref:System.Windows.Controls.TreeViewItem> oggetti.  
  
 Se questa eccezione viene generata dall'applicazione ed è necessario avere un struttura ad albero visuale più approfondito, è possibile aumentare le dimensioni dello stack dell'applicazione. È possibile aumentare le dimensioni dello stack con essa è in fase di compilazione o con l'utilità EDITBIN. Aumento delle dimensioni dello stack incidere sulle prestazioni dell'applicazione. Per altre informazioni, vedere [Stack Allocations](https://go.microsoft.com/fwlink/?LinkId=165510) e [opzioni di EDITBIN](https://go.microsoft.com/fwlink/?LinkId=165511).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.VisualCollection" />
    <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Visual ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Visual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Fornisce l'inizializzazione di base per oggetti derivati dalla classe <see cref="T:System.Windows.Media.Visual" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddVisualChild">
      <MemberSignature Language="C#" Value="protected void AddVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AddVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AddVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AddVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddVisualChild : System.Windows.Media.Visual -&gt; unit" Usage="visual.AddVisualChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Oggetto visivo figlio da aggiungere all’elemento visivo padre.</param>
        <summary>Definisce la relazione padre-figlio tra due elementi visivi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Visual.AddVisualChild%2A> metodo imposta una relazione padre-figlio tra due oggetti visivi. Questo metodo deve essere utilizzato quando è necessario un maggiore controllo a basso livello rispetto all'implementazione di archiviazione sottostante di oggetti figlio visuali. <xref:System.Windows.Media.VisualCollection> può essere utilizzato come implementazione predefinita per archiviare gli oggetti figlio.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come definire i requisiti di archiviazione personalizzati per un elemento figlio visivo. L'esempio Usa la <xref:System.Windows.Media.Visual.AddVisualChild%2A> e <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> metodi per impostare la relazione padre-figlio tra l'oggetto visivo padre e `child`. Affinché la struttura ad albero visuale da enumerare in modo corretto, l'esempio fornisce le implementazioni del <xref:System.Windows.Media.Visual.GetVisualChild%2A> metodo e <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> proprietà.  
  
> [!NOTE]
>  Sebbene sia possibile usare <xref:System.Windows.Media.VisualCollection> per creare relazioni tra oggetti visivi padre-figlio, è più efficiente per fornire un'implementazione dell'archiviazione personalizzato quando solo un elemento figlio è collegato a un elemento padre.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <Member MemberName="FindCommonVisualAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject FindCommonVisualAncestor (System.Windows.DependencyObject otherVisual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject FindCommonVisualAncestor(class System.Windows.DependencyObject otherVisual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindCommonVisualAncestor (otherVisual As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ FindCommonVisualAncestor(System::Windows::DependencyObject ^ otherVisual);" />
      <MemberSignature Language="F#" Value="member this.FindCommonVisualAncestor : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="visual.FindCommonVisualAncestor otherVisual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherVisual" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="otherVisual">Oggetto visivo di tipo <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Restituisce il predecessore comune di due oggetti visivi.</summary>
        <returns>Predecessore comune dell’oggetto visivo e di <paramref name="otherVisual" /> se esistente; in caso contrario <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli oggetti 2D e 3D possono avere comuni visual predecessori, pertanto è possibile passare un <xref:System.Windows.Media.Media3D.Visual3D> per `otherVisual`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetVisualChild : int -&gt; System.Windows.Media.Visual&#xA;override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="visual.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice del nuovo oggetto visivo nell’oggetto <see cref="T:System.Windows.Media.VisualCollection" />.</param>
        <summary>Restituisce l’oggetto <see cref="T:System.Windows.Media.Visual" /> specificato nell’oggetto <see cref="T:System.Windows.Media.VisualCollection" /> padre.</summary>
        <returns>L’elemento figlio nell’oggetto <see cref="T:System.Windows.Media.VisualCollection" /> al valore <paramref name="index" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un <xref:System.Windows.Media.Visual> non ha elementi figlio. Pertanto, l'implementazione predefinita genera sempre un' <xref:System.ArgumentOutOfRangeException>.  
  
   
  
## Examples  
 L'esempio seguente definisce un'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.GetVisualChild%2A>.  
  
 [!code-csharp[DrawingVisualSample#102b](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102b)]
 [!code-vb[DrawingVisualSample#102b](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102b)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Una classe che deriva da <see cref="T:System.Windows.Media.Visual" /> deve eseguire l'override di questo metodo e anche il <see cref="P:System.Windows.Media.Visual.VisualChildrenCount" /> proprietà, per la struttura ad albero visuale da enumerare in modo corretto.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se il valore di un punto o geometria si trova all'interno dei limiti dell’oggetto visivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As GeometryHitTestParameters) As GeometryHitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::GeometryHitTestResult ^ HitTestCore(System::Windows::Media::GeometryHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="abstract member HitTestCore : System.Windows.Media.GeometryHitTestParameters -&gt; System.Windows.Media.GeometryHitTestResult&#xA;override this.HitTestCore : System.Windows.Media.GeometryHitTestParameters -&gt; System.Windows.Media.GeometryHitTestResult" Usage="visual.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Oggetto <see cref="T:System.Windows.Media.GeometryHitTestParameters" /> in cui è specificato l'oggetto <see cref="T:System.Windows.Media.Geometry" /> su cui effettuare l’hit test.</param>
        <summary>Determina se il valore di una geometria si trova all'interno dei limiti dell’oggetto visivo.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Media.GeometryHitTestResult" /> che rappresenta il risultato dell’hit test.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile eseguire l'override di supporto di hit test per un oggetto visivo eseguendo l'override di <xref:System.Windows.Media.Visual.HitTestCore%2A> (metodo). Ciò significa che quando si richiama il <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> metodo, l'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.HitTestCore%2A> viene chiamato. Il metodo sottoposto a override viene chiamato quando un hit test viene eseguito all'interno del rettangolo di delimitazione dell'oggetto visivo, anche se le coordinate non rientrano la geometria dell'oggetto visivo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire l'override del metodo <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.GeometryHitTestParameters%29>. Un motivo per cui che è possibile eseguire l'override di questo metodo consiste nel fornire funzionalità aggiuntive durante il processo di hit test.  
  
 [!code-csharp[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/GeometryHitTest.cs#hittestingoverviewsnippet13)]
 [!code-vb[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/geometryhittest.vb#hittestingoverviewsnippet13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="abstract member HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult&#xA;override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="visual.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Oggetto <see cref="T:System.Windows.Media.PointHitTestParameters" /> in cui è specificato l'oggetto <see cref="T:System.Windows.Point" /> su cui effettuare l’hit test.</param>
        <summary>Determina se il valore di coordinata di un punto è all'interno dei limiti dell’oggetto visivo.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Media.HitTestResult" /> che rappresenta il <see cref="T:System.Windows.Media.Visual" /> restituito da un hit test.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile sostituire l'impostazione predefinita supporto dell'hit testing sugli oggetti visivi eseguendo l'override di <xref:System.Windows.Media.Visual.HitTestCore%2A> (metodo). Ciò significa che quando si richiama il <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> metodo, l'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.HitTestCore%2A> viene chiamato. Il metodo sottoposto a override viene chiamato quando un hit test viene eseguito all'interno del rettangolo di delimitazione dell'oggetto visivo, anche se le coordinate non rientrano la geometria dell'oggetto visivo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire l'override del metodo <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.PointHitTestParameters%29>. Un motivo per cui che è possibile eseguire l'override di questo metodo consiste nel fornire funzionalità aggiuntive durante il processo di hit test.  
  
 [!code-csharp[HitTestingOverview#107](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#107)]
 [!code-vb[HitTestingOverview#107](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#107)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAncestorOf">
      <MemberSignature Language="C#" Value="public bool IsAncestorOf (System.Windows.DependencyObject descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAncestorOf(class System.Windows.DependencyObject descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAncestorOf (descendant As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAncestorOf(System::Windows::DependencyObject ^ descendant);" />
      <MemberSignature Language="F#" Value="member this.IsAncestorOf : System.Windows.DependencyObject -&gt; bool" Usage="visual.IsAncestorOf descendant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="descendant">Valore di tipo <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Determina se l'oggetto visivo è un predecessore dell'oggetto visivo discendente.</summary>
        <returns>
          <see langword="true" /> se l’oggetto visivo è un predecessore di <paramref name="descendant" />; in caso contrario <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOf">
      <MemberSignature Language="C#" Value="public bool IsDescendantOf (System.Windows.DependencyObject ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDescendantOf(class System.Windows.DependencyObject ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDescendantOf (ancestor As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDescendantOf(System::Windows::DependencyObject ^ ancestor);" />
      <MemberSignature Language="F#" Value="member this.IsDescendantOf : System.Windows.DependencyObject -&gt; bool" Usage="visual.IsDescendantOf ancestor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="ancestor">Valore di tipo <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Determina se l'oggetto visivo è un discendente dell'oggetto visivo predecessore.</summary>
        <returns>
          <see langword="true" /> se l’oggetto visivo è un discendente di <paramref name="ancestor" />; in caso contrario <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="visual.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Impostazione precedente della scala DPI.</param>
        <param name="newDpi">Nuova impostazione della scala DPI.</param>
        <summary>Chiamato in caso di variazione del valore DPI usato per il rendering della vista.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="abstract member OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit&#xA;override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="visual.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="visualAdded">Oggetto <see cref="T:System.Windows.Media.Visual" /> aggiunto all'insieme.</param>
        <param name="visualRemoved">Oggetto <see cref="T:System.Windows.Media.Visual" /> rimosso dall’insieme.</param>
        <summary>Viene chiamato quando l'oggetto <see cref="T:System.Windows.Media.VisualCollection" /> dell’oggetto visivo viene modificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="abstract member OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit&#xA;override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="visual.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Valore di tipo <see cref="T:System.Windows.DependencyObject" /> che rappresenta l’elemento padre precedente dell’oggetto <see cref="T:System.Windows.Media.Visual" />. Se l’oggetto <see cref="T:System.Windows.Media.Visual" /> non aveva un elemento padre precedente, il valore del parametro è <see langword="null" />.</param>
        <summary>Chiamato quando l’elemento padre dell’oggetto visivo viene modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una classe che deriva da <xref:System.Windows.Media.Visual> può scegliere di eseguire l'override di questo metodo.  
  
 Non è alcun evento di "VisualParentChanged" fornita che segnala questa modifica alle istanze. Pertanto, è necessario eseguire l'override di questo metodo per gestire scenari di notifica e fornire una versione dell'istanza della notifica se fa parte del proprio scenario.  
  
   
  
## Examples  
 L'esempio seguente definisce un'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.OnVisualParentChanged%2A>.  
  
 [!code-csharp[VisualSnippets#VisualSnippet10](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet10)]
 [!code-vb[VisualSnippets#VisualSnippet10](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Visual.VisualParent" />
      </Docs>
    </Member>
    <Member MemberName="PointFromScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointFromScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointFromScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointFromScreen(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.PointFromScreen : System.Windows.Point -&gt; System.Windows.Point" Usage="visual.PointFromScreen point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Valore di <see cref="T:System.Windows.Point" /> in coordinate dello schermo.</param>
        <summary>Converte un oggetto <see cref="T:System.Windows.Point" /> sotto forma di coordinate dello schermo in un oggetto <see cref="T:System.Windows.Point" /> che rappresenta il sistema di coordinate corrente dell’oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <returns>Valore <see cref="T:System.Windows.Point" /> convertito che rappresenta il sistema di coordinate corrente dell’oggetto <see cref="T:System.Windows.Media.Visual" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Windows.Media.Visual.PointToScreen%2A> metodo per convertire un <xref:System.Windows.Point> che rappresenta il sistema di coordinate corrente del <xref:System.Windows.Media.Visual> in un <xref:System.Windows.Point> nelle coordinate dello schermo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointToScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointToScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointToScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointToScreen(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.PointToScreen : System.Windows.Point -&gt; System.Windows.Point" Usage="visual.PointToScreen point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Valore <see cref="T:System.Windows.Point" /> che rappresenta il sistema di coordinate corrente dell’oggetto <see cref="T:System.Windows.Media.Visual" />.</param>
        <summary>Converte un oggetto <see cref="T:System.Windows.Point" /> che rappresenta il sistema di coordinate corrente dell’oggetto <see cref="T:System.Windows.Media.Visual" /> in un oggetto <see cref="T:System.Windows.Point" /> sotto forma di coordinate dello schermo.</summary>
        <returns>Valore <see cref="T:System.Windows.Point" /> convertito in coordinate dello schermo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Windows.Media.Visual.PointFromScreen%2A> metodo per convertire un <xref:System.Windows.Point> in coordinate dello schermo in un <xref:System.Windows.Point> che rappresenta il sistema di coordinate corrente del <xref:System.Windows.Media.Visual>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveVisualChild">
      <MemberSignature Language="C#" Value="protected void RemoveVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RemoveVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RemoveVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RemoveVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveVisualChild : System.Windows.Media.Visual -&gt; unit" Usage="visual.RemoveVisualChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Oggetto visivo figlio da rimuovere dall’elemento visivo padre.</param>
        <summary>Rimuove la relazione padre-figlio tra due elementi visivi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> metodo rimuove la relazione padre-figlio tra due oggetti visivi. Questo metodo, insieme al <xref:System.Windows.Media.Visual.AddVisualChild%2A> metodo, deve essere usato quando è necessario maggiore controllo di basso livello rispetto all'implementazione di archiviazione sottostante di oggetti figlio visuali. <xref:System.Windows.Media.VisualCollection> può essere utilizzato come implementazione predefinita per archiviare gli oggetti figlio.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come definire i requisiti di archiviazione personalizzati per un elemento figlio visivo. L'esempio Usa la <xref:System.Windows.Media.Visual.AddVisualChild%2A> e <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> metodi per impostare la relazione padre-figlio tra l'oggetto visivo padre e `child`. Affinché la struttura ad albero visuale da enumerare in modo corretto, l'esempio fornisce le implementazioni del <xref:System.Windows.Media.Visual.GetVisualChild%2A> metodo e <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> proprietà.  
  
> [!NOTE]
>  Sebbene sia possibile usare <xref:System.Windows.Media.VisualCollection> per creare relazioni tra oggetti visivi padre-figlio, è più efficiente per fornire un'implementazione dell'archiviazione personalizzato quando solo un elemento figlio è collegato a un elemento padre.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformToAncestor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> al predecessore specificato dell’oggetto visivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor (System.Windows.Media.Media3D.Visual3D ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor(class System.Windows.Media.Media3D.Visual3D ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual3D) As GeneralTransform2DTo3D" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Media3D::GeneralTransform2DTo3D ^ TransformToAncestor(System::Windows::Media::Media3D::Visual3D ^ ancestor);" />
      <MemberSignature Language="F#" Value="member this.TransformToAncestor : System.Windows.Media.Media3D.Visual3D -&gt; System.Windows.Media.Media3D.GeneralTransform2DTo3D" Usage="visual.TransformToAncestor ancestor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Media3D.GeneralTransform2DTo3D</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Media3D.Visual3D" />
      </Parameters>
      <Docs>
        <param name="ancestor">Oggetto <see cref="T:System.Windows.Media.Media3D.Visual3D" /> nel quale vengono trasformate le coordinate.</param>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> al predecessore <see cref="T:System.Windows.Media.Media3D.Visual3D" /> specificato dell’oggetto visivo.</summary>
        <returns>Trasformazione utilizzabile per trasformare le coordinate da <see cref="T:System.Windows.Media.Visual" /> al predecessore <see cref="T:System.Windows.Media.Media3D.Visual3D" /> specificato dell’oggetto visivo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToAncestor (System.Windows.Media.Visual ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToAncestor(class System.Windows.Media.Visual ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToAncestor(System::Windows::Media::Visual ^ ancestor);" />
      <MemberSignature Language="F#" Value="member this.TransformToAncestor : System.Windows.Media.Visual -&gt; System.Windows.Media.GeneralTransform" Usage="visual.TransformToAncestor ancestor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="ancestor">Oggetto <see cref="T:System.Windows.Media.Visual" /> nel quale vengono trasformate le coordinate.</param>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> al predecessore <see cref="T:System.Windows.Media.Visual" /> specificato dell’oggetto visivo.</summary>
        <returns>Valore di tipo <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In alternativa, è possibile usare il <xref:System.Windows.Media.VisualTreeHelper.GetOffset%2A?displayProperty=nameWithType> metodo per recuperare l'offset di un oggetto visivo rispetto al padre. Sono contenuti i valori di offset all'interno di restituito <xref:System.Windows.Vector> valore.  
  
 [!code-csharp[VisualSnippets#VisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet2)]
 [!code-vb[VisualSnippets#VisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet2)]  
  
   
  
## Examples  
 L'esempio di markup seguente mostra una <xref:System.Windows.Controls.TextBlock> annidato all'interno di due <xref:System.Windows.Controls.StackPanel> oggetti.  
  
 [!code-xaml[VisualSnippets#VisualSnippet7](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window2.xaml#visualsnippet7)]  
  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Media.Visual.TransformToAncestor%2A> metodo per recuperare l'offset del <xref:System.Windows.Controls.TextBlock> rispetto al contenitore <xref:System.Windows.Window>. I valori di offset sono contenuti nell'oggetto restituito <xref:System.Windows.Media.GeneralTransform>.  
  
 [!code-csharp[VisualSnippets#VisualSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet5)]
 [!code-vb[VisualSnippets#VisualSnippet5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet5)]  
  
 L'offset prende in considerazione la <xref:System.Windows.FrameworkElement.Margin%2A> i valori per tutti gli oggetti nel contenitore <xref:System.Windows.Window>. In questo caso <xref:System.Windows.Vector.X%2A> è 28, e <xref:System.Windows.Vector.Y%2A> è 28.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ancestor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ancestor" /> non è un predecessore dell’elemento visivo.</exception>
        <exception cref="T:System.InvalidOperationException">Gli oggetti visivi non sono correlati.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToDescendant">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToDescendant (System.Windows.Media.Visual descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToDescendant(class System.Windows.Media.Visual descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToDescendant (descendant As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToDescendant(System::Windows::Media::Visual ^ descendant);" />
      <MemberSignature Language="F#" Value="member this.TransformToDescendant : System.Windows.Media.Visual -&gt; System.Windows.Media.GeneralTransform" Usage="visual.TransformToDescendant descendant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="descendant">Oggetto <see cref="T:System.Windows.Media.Visual" /> nel quale vengono trasformate le coordinate.</param>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> al discendente specificato dell’oggetto visivo.</summary>
        <returns>Valore di tipo <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio di markup seguente mostra una <xref:System.Windows.Controls.TextBlock> contenuta all'interno di un <xref:System.Windows.Controls.StackPanel> oggetto.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Media.Visual.TransformToDescendant%2A> metodo per recuperare l'offset del <xref:System.Windows.Controls.StackPanel> rispetto al relativo elemento figlio <xref:System.Windows.Controls.TextBlock>. Sono contenuti i valori di offset all'interno di restituito <xref:System.Windows.Media.GeneralTransform> valore.  
  
 [!code-csharp[VisualSnippets#VisualSnippet9](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet9)]
 [!code-vb[VisualSnippets#VisualSnippet9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet9)]  
  
 L'offset prende in considerazione il <xref:System.Windows.FrameworkElement.Margin%2A> i valori per tutti gli oggetti. In questo caso <xref:System.Windows.Vector.X%2A> è -4, e <xref:System.Windows.Vector.Y%2A> è -4. I valori di offset sono valori negativi in quanto l'oggetto padre viene spostato negativamente rispetto al relativo oggetto figlio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="descendant" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L’elemento visivo non è un predecessore dell’elemento visivo <paramref name="descendant" />.</exception>
        <exception cref="T:System.InvalidOperationException">Gli oggetti visivi non sono correlati.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToVisual">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToVisual (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToVisual(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToVisual(System::Windows::Media::Visual ^ visual);" />
      <MemberSignature Language="F#" Value="member this.TransformToVisual : System.Windows.Media.Visual -&gt; System.Windows.Media.GeneralTransform" Usage="visual.TransformToVisual visual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">Oggetto <see cref="T:System.Windows.Media.Visual" /> nel quale vengono trasformate le coordinate.</param>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> all’oggetto visivo specificato.</summary>
        <returns>Valore di tipo <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Visual.TransformToAncestor%2A> e <xref:System.Windows.Media.Visual.TransformToDescendant%2A> metodi possono essere utilizzati anche per restituire una trasformazione per un oggetto visivo.  
  
   
  
## Examples  
 L'esempio di markup seguente mostra una <xref:System.Windows.Controls.TextBlock> contenuta all'interno di un <xref:System.Windows.Controls.StackPanel> oggetto.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Media.Visual.TransformToVisual%2A> metodo per recuperare l'offset del <xref:System.Windows.Controls.StackPanel> rispetto al relativo elemento figlio <xref:System.Windows.Controls.TextBlock>. Sono contenuti i valori di offset all'interno di restituito <xref:System.Windows.Media.GeneralTransform> valore.  
  
 [!code-csharp[VisualSnippets#VisualSnippet8](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet8)]
 [!code-vb[VisualSnippets#VisualSnippet8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet8)]  
  
 L'offset prende in considerazione il <xref:System.Windows.FrameworkElement.Margin%2A> i valori per tutti gli oggetti. In questo caso <xref:System.Windows.Vector.X%2A> è -4, e <xref:System.Windows.Vector.Y%2A> è -4. I valori di offset sono valori negativi in quanto l'oggetto padre viene spostato negativamente rispetto al relativo oggetto figlio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="visual" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Gli oggetti visivi non sono correlati.</exception>
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffect ^ VisualBitmapEffect {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualBitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.Media.Visual.VisualBitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> per <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Effetto bitmap per questo oggetto visivo.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffectInput ^ VisualBitmapEffectInput {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffectInput ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualBitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.Media.Visual.VisualBitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> per <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Valore di input dell'effetto bitmap per questo oggetto visivo.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffectInput" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapScalingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapScalingMode As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::BitmapScalingMode VisualBitmapScalingMode {  protected public:&#xA;System::Windows::Media::BitmapScalingMode get(); protected:&#xA; void set(System::Windows::Media::BitmapScalingMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualBitmapScalingMode : System.Windows.Media.BitmapScalingMode with get, set" Usage="System.Windows.Media.Visual.VisualBitmapScalingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Media.BitmapScalingMode" /> per <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Il valore <see cref="T:System.Windows.Media.BitmapScalingMode" /> per <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualCacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode VisualCacheMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode VisualCacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualCacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualCacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::CacheMode ^ VisualCacheMode {  protected public:&#xA;System::Windows::Media::CacheMode ^ get(); protected:&#xA; void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualCacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.Media.Visual.VisualCacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una rappresentazione nascosta dell'oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Un oggetto <see cref="T:System.Windows.Media.CacheMode" /> che contiene una rappresentazione nascosta dell'oggetto <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.Windows.Media.Visual.VisualCacheMode%2A> proprietà quando è necessario aumentare le prestazioni per il contenuto che richiede molto tempo eseguire il rendering. Per ulteriori informazioni, vedere <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.ContainerVisual.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected virtual int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Media.Visual.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di elementi figlio per l’oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Numero di elementi figlio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un <xref:System.Windows.Media.Visual> non ha elementi figlio. Pertanto, l'implementazione predefinita restituisce sempre 0.  
  
   
  
## Examples  
 L'esempio seguente definisce un'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.VisualChildrenCount%2A>.  
  
 [!code-csharp[DrawingVisualSample#102a](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102a)]
 [!code-vb[DrawingVisualSample#102a](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102a)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Una classe che deriva da <see cref="T:System.Windows.Media.Visual" /> deve eseguire l'override di questa proprietà, nonché il <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> (metodo), per la struttura ad albero visuale da enumerare in modo corretto.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="VisualClearTypeHint">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.ClearTypeHint VisualClearTypeHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.ClearTypeHint VisualClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualClearTypeHint As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::ClearTypeHint VisualClearTypeHint { System::Windows::Media::ClearTypeHint get(); void set(System::Windows::Media::ClearTypeHint value); };" />
      <MemberSignature Language="F#" Value="member this.VisualClearTypeHint : System.Windows.Media.ClearTypeHint with get, set" Usage="System.Windows.Media.Visual.VisualClearTypeHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Media.ClearTypeHint" /> che determina come viene reso ClearType nell'oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.ClearTypeHint" /> dell'oggetto <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualClip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry VisualClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry VisualClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualClip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Geometry ^ VisualClip {  protected public:&#xA;System::Windows::Media::Geometry ^ get(); protected:&#xA; void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualClip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.Media.Visual.VisualClip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'area di ridimensionamento dell'oggetto <see cref="T:System.Windows.Media.Visual" /> specificato sotto forma di valore <see cref="T:System.Windows.Media.Geometry" />.</summary>
        <value>Valore dell’area di ridimensionamento dell’oggetto visivo sotto forma di tipo <see cref="T:System.Windows.Media.Geometry" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms746710(v=vs.90)">Procedura: creare un'area di ritaglio</related>
      </Docs>
    </Member>
    <Member MemberName="VisualEdgeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.EdgeMode VisualEdgeMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.EdgeMode VisualEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEdgeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEdgeMode As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::EdgeMode VisualEdgeMode {  protected public:&#xA;System::Windows::Media::EdgeMode get(); protected:&#xA; void set(System::Windows::Media::EdgeMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualEdgeMode : System.Windows.Media.EdgeMode with get, set" Usage="System.Windows.Media.Visual.VisualEdgeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la modalità di bordo dell’oggetto <see cref="T:System.Windows.Media.Visual" /> sotto forma di valore <see cref="T:System.Windows.Media.EdgeMode" />.</summary>
        <value>Valore <see cref="T:System.Windows.Media.EdgeMode" /> dell’oggetto visivo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect VisualEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect VisualEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEffect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::Effect ^ VisualEffect {  protected public:&#xA;System::Windows::Media::Effects::Effect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualEffect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.Media.Visual.VisualEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'effetto bitmap da applicare all'oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.Effects.Effect" /> che rappresenta l'effetto bitmap.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector VisualOffset { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector VisualOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOffset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Vector VisualOffset {  protected public:&#xA;System::Windows::Vector get(); protected:&#xA; void set(System::Windows::Vector value); };" />
      <MemberSignature Language="F#" Value="member this.VisualOffset : System.Windows.Vector with get, set" Usage="System.Windows.Media.Visual.VisualOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di offset dell’oggetto visivo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Vector" /> che specifica il valore di offset.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacity">
      <MemberSignature Language="C#" Value="public double VisualOpacity { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VisualOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacity" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:  property double VisualOpacity {  protected public:&#xA;double get(); protected:&#xA; void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.VisualOpacity : double with get, set" Usage="System.Windows.Media.Visual.VisualOpacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'opacità di <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Valore di opacità dell’oggetto visivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore di opacità del <xref:System.Windows.Media.Visual> viene espresso come valore compreso tra 0 e 1. Il valore 0 indica che l'elemento è completamente trasparente, mentre un valore pari a 1 indica che l'elemento è completamente opaco. Il valore 0,5 indica che l'elemento è opaco al 50%. I valori minori di 0 vengono considerati come 0. i valori maggiori di 1 vengono considerati come 1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush VisualOpacityMask { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush VisualOpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Brush ^ VisualOpacityMask {  protected public:&#xA;System::Windows::Media::Brush ^ get(); protected:&#xA; void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualOpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.Media.Visual.VisualOpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore <see cref="T:System.Windows.Media.Brush" /> che rappresenta la maschera di opacità dell’oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.Brush" /> che rappresenta il valore della maschera di opacità dell’oggetto visivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La maschera di opacità è un <xref:System.Windows.Media.Brush> che viene applicato a qualsiasi mascheramento del canale alfa per il contenuto di rendering di questo oggetto visivo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualParent">
      <MemberSignature Language="C#" Value="protected System.Windows.DependencyObject VisualParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject VisualParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualParent" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property VisualParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::DependencyObject ^ VisualParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualParent : System.Windows.DependencyObject" Usage="System.Windows.Media.Visual.VisualParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la struttura ad albero padre dell’oggetto visivo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.Visual" /> padre.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Parent" />
        <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="VisualScrollableAreaClip">
      <MemberSignature Language="C#" Value="public Nullable&lt;System.Windows.Rect&gt; VisualScrollableAreaClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;valuetype System.Windows.Rect&gt; VisualScrollableAreaClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualScrollableAreaClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualScrollableAreaClip As Nullable(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:  property Nullable&lt;System::Windows::Rect&gt; VisualScrollableAreaClip {  protected public:&#xA;Nullable&lt;System::Windows::Rect&gt; get(); protected:&#xA; void set(Nullable&lt;System::Windows::Rect&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.VisualScrollableAreaClip : Nullable&lt;System.Windows.Rect&gt; with get, set" Usage="System.Windows.Media.Visual.VisualScrollableAreaClip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un'area scorrevole ritagliata per l'oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Rect" /> che rappresenta l'area di ritaglio scorrevole o <see langword="null" /> se non viene assegnata un'area di ritaglio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> accelerato di proprietà per abilitare lo scorrimento durante il rendering software. Ciò è utile in scenari remoti per il rendering, ad esempio in esecuzione tramite Desktop remoto o in esecuzione in una macchina virtuale. Impostare questa proprietà per l'elemento padre avverrà cui figli. L'impostazione di <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà non ha alcun effetto quando per il rendering con accelerazione hardware.  
  
 Il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà consente scenari specifici e avanzati. L'elenco seguente mostra le raccomandazioni applicabili quando si usa il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà.  
  
-   Lo sfondo dell'area di scorrimento deve essere opaco o lo scorrimento degli elementi si verificherà.  
  
-   Il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà accelera lo scorrimento solo quando WPF esegue il rendering software. Ad esempio, questa situazione si verifica quando l'applicazione è in esecuzione tramite Desktop remoto o in esecuzione in locale in una macchina virtuale.  
  
-   Il comportamento dello scorrimento rimane invariato durante il rendering in hardware. Per evitare che le differenze nel comportamento di scorrimento, è consigliabile mantenere il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà abilitata per l'hardware e software.  
  
-   Trasformazioni di rotazione e inclinazione disabilitano lo scorrimento accelerata. Trasformazioni di scala e le traduzioni orizzontale o verticale sopra l'area di scorrimento funzioni correttamente e non si disabilita l'accelerazione di scorrimento.  
  
-   La modifica del sottoalbero o attivazione di parti dell'area di scorrimento per ridisegnare tramite l'animazione comportarsi come previsto, ma al vantaggio dell'accelerato lo scorrimento per l'area ridisegnata. Le animazioni che invalida l'area di scorrimento durante il frame stesso si verifica in cui lo scorrimento Elimina il vantaggio di questa ottimizzazione.  
  
-   Il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> rettangolo consente di agganciare verso l'interno per pixel. Pertanto, le dimensioni del rettangolo di scorrimento bloccate sono sempre minore o uguale alla dimensione che è stata impostata.  
  
-   Offset di allineamento verso il basso. Ciò significa che la differenza del precedente snapped offset e offset corrente bloccato è sempre un numero intero di pixel.  
  
-   Hit test può essere al massimo un pixel.  
  
-   Arrotondamento del layout deve essere attivato, perché assicura che i bordi delle aree scorrevoli e l'area client della finestra limite vengono bloccati i limiti dei pixel, causando il corretto allineamento.  
  
-   Accelerazione dello scorrimento non funziona nelle finestre sovrapposte. Ciò significa che windows in cui AllowTransparency = = true, Window. WindowStyle = = none e così via.  
  
-   Accelerazione dello scorrimento non si verifica durante il rendering di finestre a full.  
  
-   Accelerazione dello scorrimento non funziona quando la finestra gestisce due monitoraggi.  
  
-   Accelerazione dello scorrimento non funziona in presenza di destinazioni di rendering intermedie nella catena padre dell'elemento a scorrimento. L'elenco seguente illustra che alcune di queste destinazioni di rendering intermedie.  
  
    -   Clip  
  
    -   Effetti  
  
    -   DrawingBrushes  
  
    -   VisualBrushes  
  
    -   OpacityMasks  
  
    -   Opacità  
  
-   Solo uno scorrimento accelerato può verificarsi per ogni fotogramma. Possono essere presenti più aree con accelerazione di scorrimento, ma solo uno di essi può eseguire uno scorrimento accelerato durante un frame. L'area di scorrimento è indeterminato.  
  
-   Accelerazione dello scorrimento supporta contenuto sopra l'area di scorrimento (nell'ordine z) che non scorre con il resto del contenuto. Il sistema calcola tutte le aree dirty necessari e completa lo scorrimento accelerato, ma invia eseguire il backup delle diverse bitmap aggiuntive in transito per spostare la parte involontariamente a scorrimento nella posizione corretta nella schermata.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextHintingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextHintingMode VisualTextHintingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextHintingMode VisualTextHintingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextHintingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextHintingMode As TextHintingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextHintingMode VisualTextHintingMode { System::Windows::Media::TextHintingMode get(); void set(System::Windows::Media::TextHintingMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualTextHintingMode : System.Windows.Media.TextHintingMode with get, set" Usage="System.Windows.Media.Visual.VisualTextHintingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextHintingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Media.TextHintingMode" /> di <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.TextHintingMode" /> applicato a <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextRenderingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextRenderingMode VisualTextRenderingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextRenderingMode VisualTextRenderingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextRenderingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextRenderingMode As TextRenderingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextRenderingMode VisualTextRenderingMode { System::Windows::Media::TextRenderingMode get(); void set(System::Windows::Media::TextRenderingMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualTextRenderingMode : System.Windows.Media.TextRenderingMode with get, set" Usage="System.Windows.Media.Visual.VisualTextRenderingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextRenderingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Media.TextRenderingMode" /> di <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.TextRenderingMode" /> applicato a <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform VisualTransform { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform VisualTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Transform ^ VisualTransform {  protected public:&#xA;System::Windows::Media::Transform ^ get(); protected:&#xA; void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.Media.Visual.VisualTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di <see cref="T:System.Windows.Media.Transform" /> per <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Il valore della trasformazione dell’oggetto visivo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualXSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualXSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualXSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualXSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualXSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualXSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualXSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.Visual.VisualXSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la raccolta delle linee guida per la coordinata X (verticale).</summary>
        <value>Raccolta di linee guida per la coordinata X dell'oggetto visivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blocco dei pixel è il processo nel quale il layout del contenuto è stato risolto in modo che i bordi degli oggetti vengono sottoposti a rendering su pixel specifiche del dispositivo. Il sistema grafico di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] usa unità indipendenti dal dispositivo per assicurare l'indipendenza dalla risoluzione e dal dispositivo. Ogni Device Independent Pixel viene ridimensionato automaticamente con l'impostazione [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] del sistema. In questo modo, le applicazioni [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ottengono il ridimensionamento appropriato per impostazioni [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] diverse e l'applicazione viene automaticamente resa sensibile ai valori [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Tuttavia, ciò [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indipendenza può creare rendering dei bordi irregolare a causa dell'anti-aliasing. Questi elementi, presente comunemente come bordi sfocati o "soft", possono verificarsi quando il percorso di una rete perimetrale cade all'interno di un pixel del dispositivo invece che tra pixel del dispositivo. Per risolvere questo problema, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fornisce un modo dei bordi dell'oggetto in un albero elementi visivi "Guide" ai pixel del dispositivo, eliminando i contorni sfumati prodotta da anti-aliasing.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetXSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
    <Member MemberName="VisualYSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualYSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualYSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualYSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualYSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualYSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualYSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.Visual.VisualYSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la raccolta delle linee guida per la coordinata y (orizzontale).</summary>
        <value>Raccolta delle linee guida per la coordinata y dell'oggetto visivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blocco dei pixel è il processo nel quale il layout del contenuto è stato risolto in modo che i bordi degli oggetti vengono sottoposti a rendering su pixel specifiche del dispositivo. Il sistema grafico di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] usa unità indipendenti dal dispositivo per assicurare l'indipendenza dalla risoluzione e dal dispositivo. Ogni Device Independent Pixel viene ridimensionato automaticamente con l'impostazione [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] del sistema. In questo modo, le applicazioni [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ottengono il ridimensionamento appropriato per impostazioni [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] diverse e l'applicazione viene automaticamente resa sensibile ai valori [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Tuttavia, ciò [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indipendenza può creare rendering dei bordi irregolare a causa dell'anti-aliasing. Questi elementi, presente comunemente come bordi sfocati o "soft", possono verificarsi quando il percorso di una rete perimetrale cade all'interno di un pixel del dispositivo invece che tra pixel del dispositivo. Per risolvere questo problema, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fornisce un modo dei bordi dell'oggetto in un albero elementi visivi "Guide" ai pixel del dispositivo, eliminando i contorni sfumati prodotta da anti-aliasing.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetYSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
  </Members>
</Type>