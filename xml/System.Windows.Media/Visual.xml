<Type Name="Visual" FullName="System.Windows.Media.Visual">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e9ff5e020c2a0b40cc9f1a9cf79c83b9cddf495" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30670115" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Visual : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Visual extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Visual" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Visual&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Visual abstract : System::Windows::DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Offre il supporto per il rendering in WPF, che include hit testing, trasformazione delle coordinate e calcoli relativi al rettangolo di selezione.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Visual> classe è l'astrazione di base da cui ogni <xref:System.Windows.FrameworkElement> oggetto deriva. Funge inoltre il punto di ingresso per la scrittura di nuovi controlli in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]e in molti modi può essere considerato come un equivalente di un handle di finestra (HWND) nei [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] modello dell'applicazione.  
  
 Il <xref:System.Windows.Media.Visual> oggetto è un core [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] oggetto, il cui ruolo primario è di fornire supporto per il rendering. Controlli dell'interfaccia utente, ad esempio <xref:System.Windows.Controls.Button> e <xref:System.Windows.Controls.TextBox>, derivare la <xref:System.Windows.Media.Visual> classe e utilizzare il <xref:System.Windows.Media.Visual> le proprietà definite per salvare in modo permanente i dati di rendering. Il <xref:System.Windows.Media.Visual> oggetto fornisce supporto per le operazioni seguenti:  
  
-   Visualizzazione dell'output: eseguire il rendering del contenuto del disegno serializzato e salvato in modo permanente di un oggetto visivo.  
  
-   Trasformazioni: eseguire trasformazioni su un oggetto visivo.  
  
-   Ritaglio: offrire supporto dell'area di ritaglio per un oggetto visivo.  
  
-   Hit test: determinare se una coordinata specificata (punto) o una geometria è contenuta all'interno di un oggetto visivo.  
  
-   Calcoli relativi al rettangolo di selezione: determinare il rettangolo delimitatore di un oggetto visivo.  
  
 L'architettura di <xref:System.Windows.Media.Visual> oggetto non include il supporto per altri requisiti di sviluppo di applicazioni / [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] funzionalità che non siano immediatamente correlate al rendering, come illustrato di seguito:  
  
-   Gestione di eventi  
  
-   Layout  
  
-   Stili  
  
-   Associazione dati  
  
-   Globalizzazione  
  
 <xref:System.Windows.Media.Visual> viene fornito come classe astratta da cui possono essere derivate ulteriori classi pubblica. Nella figura seguente illustra la gerarchia di oggetti visivi esistenti che sono definiti nel [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] architettura.  
  
 ![Diagramma delle classi derivate dall'oggetto Visual](~/add/media/visualclass01.png "diagramma delle classi derivate dall'oggetto Visual")  
Gerarchia delle classi visive  
  
 In alcuni casi, i membri che sono definiti come protetto nella <xref:System.Windows.Media.Visual> vengono esposti come membri più facilmente accessibili con nomi simili in derivata <xref:System.Windows.UIElement> classe.  
  
 Per altre informazioni, vedere [Cenni preliminari sul rendering della grafica WPF](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 Oggetto <xref:System.Windows.Media.Visual> ha un numero limitato di livelli. Nelle versioni precedenti di .NET Framework, la profondità massima è 255. Questo limite è inadeguato per alcuni layout che hanno numerosi livelli di struttura ad albero visuale.  
  
 In [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], la profondità massima di un <xref:System.Windows.Media.Visual> è 2047, che consente ad albero visuali molto più approfondite. Nella maggior parte delle applicazioni, non c'è abbastanza spazio per attraversare un numero così elevato di livelli e il risultato è un <xref:System.StackOverflowException> durante il layout. Per la dimensione dello stack predefinita, questa eccezione viene generata in genere quando la profondità dell'albero è approssimativamente 800, che corrisponde a 190 annidati <xref:System.Windows.Controls.TreeViewItem> oggetti.  
  
 Se questa eccezione viene generata dall'applicazione ed è necessario disporre di un struttura ad albero visuale più approfondito, è possibile aumentare le dimensioni dello stack dell'applicazione. È possibile aumentare le dimensioni dello stack utilizzando l'opzione /STACK in fase di compilazione o tramite l'utilità EDITBIN. Aumentare la dimensione dello stack influisca sulle prestazioni dell'applicazione. Per ulteriori informazioni, vedere [allocazioni Stack](http://go.microsoft.com/fwlink/?LinkId=165510) e [opzioni di EDITBIN](http://go.microsoft.com/fwlink/?LinkId=165511).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.VisualCollection" />
    <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Visual ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Visual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Fornisce l'inizializzazione di base per oggetti derivati dalla classe <see cref="T:System.Windows.Media.Visual" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddVisualChild">
      <MemberSignature Language="C#" Value="protected void AddVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AddVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AddVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AddVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Oggetto visivo figlio da aggiungere all’elemento visivo padre.</param>
        <summary>Definisce la relazione padre-figlio tra due elementi visivi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Visual.AddVisualChild%2A> metodo imposta una relazione padre-figlio tra due oggetti visivi. Questo metodo deve essere utilizzato quando è necessario un maggiore controllo di basso livello sull'implementazione di archiviazione sottostante degli oggetti visivi figlio. <xref:System.Windows.Media.VisualCollection> può essere utilizzato come un'implementazione predefinita per archiviare gli oggetti figlio.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come definire i requisiti di archiviazione personalizzato per un elemento figlio visivo. Nell'esempio viene utilizzato il <xref:System.Windows.Media.Visual.AddVisualChild%2A> e <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> metodi per impostare la relazione padre-figlio tra l'oggetto visivo padre e `child`. Affinché la struttura ad albero visuale possa avvenire correttamente, l'esempio fornisce le implementazioni del <xref:System.Windows.Media.Visual.GetVisualChild%2A> (metodo) e <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> proprietà.  
  
> [!NOTE]
>  Sebbene sia possibile utilizzare <xref:System.Windows.Media.VisualCollection> per creare relazioni tra oggetti visivi di padre-figlio, risulta più efficiente per fornire la propria implementazione di archiviazione personalizzato quando un solo elemento figlio è collegato a un elemento padre.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <Member MemberName="FindCommonVisualAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject FindCommonVisualAncestor (System.Windows.DependencyObject otherVisual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject FindCommonVisualAncestor(class System.Windows.DependencyObject otherVisual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindCommonVisualAncestor (otherVisual As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ FindCommonVisualAncestor(System::Windows::DependencyObject ^ otherVisual);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherVisual" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="otherVisual">Oggetto visivo di tipo <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Restituisce il predecessore comune di due oggetti visivi.</summary>
        <returns>Predecessore comune dell’oggetto visivo e di <paramref name="otherVisual" /> se esistente; in caso contrario <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gli oggetti 2D e 3D possono avere predecessori visivi comuni, pertanto è possibile passare un <xref:System.Windows.Media.Media3D.Visual3D> per `otherVisual`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice del nuovo oggetto visivo nell’oggetto <see cref="T:System.Windows.Media.VisualCollection" />.</param>
        <summary>Restituisce l’oggetto <see cref="T:System.Windows.Media.Visual" /> specificato nell’oggetto <see cref="T:System.Windows.Media.VisualCollection" /> padre.</summary>
        <returns>L’elemento figlio nell’oggetto <see cref="T:System.Windows.Media.VisualCollection" /> al valore <paramref name="index" /> specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un <xref:System.Windows.Media.Visual> non ha elementi figlio. Pertanto, l'implementazione predefinita genera sempre un' <xref:System.ArgumentOutOfRangeException>.  
  
   
  
## Examples  
 L'esempio seguente definisce un'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.GetVisualChild%2A>.  
  
 [!code-csharp[DrawingVisualSample#102b](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102b)]
 [!code-vb[DrawingVisualSample#102b](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102b)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Una classe che deriva da <see cref="T:System.Windows.Media.Visual" /> deve eseguire l'override di questo metodo, nonché il <see cref="P:System.Windows.Media.Visual.VisualChildrenCount" /> proprietà per la struttura ad albero visuale possa avvenire correttamente.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se il valore di un punto o geometria si trova all'interno dei limiti dell’oggetto visivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As GeometryHitTestParameters) As GeometryHitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::GeometryHitTestResult ^ HitTestCore(System::Windows::Media::GeometryHitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Oggetto <see cref="T:System.Windows.Media.GeometryHitTestParameters" /> in cui è specificato l'oggetto <see cref="T:System.Windows.Media.Geometry" /> su cui effettuare l’hit test.</param>
        <summary>Determina se il valore di una geometria si trova all'interno dei limiti dell’oggetto visivo.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Media.GeometryHitTestResult" /> che rappresenta il risultato dell’hit test.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile eseguire l'override di supporto di hit test per un oggetto visivo eseguendo l'override di <xref:System.Windows.Media.Visual.HitTestCore%2A> metodo. Ciò significa che quando si richiama il <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> (metodo), l'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.HitTestCore%2A> viene chiamato. Il metodo sottoposto a override viene chiamato quando un hit test viene eseguito all'interno del rettangolo di delimitazione dell'oggetto visivo, anche se la coordinata rientra la geometria dell'oggetto visivo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire l'override del metodo <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.GeometryHitTestParameters%29>. Un motivo per cui che è possibile eseguire l'override di questo metodo è fornire funzionalità aggiuntive durante il processo di hit test.  
  
 [!code-csharp[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/GeometryHitTest.cs#hittestingoverviewsnippet13)]
 [!code-vb[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/geometryhittest.vb#hittestingoverviewsnippet13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">Oggetto <see cref="T:System.Windows.Media.PointHitTestParameters" /> in cui è specificato l'oggetto <see cref="T:System.Windows.Point" /> su cui effettuare l’hit test.</param>
        <summary>Determina se il valore di coordinata di un punto è all'interno dei limiti dell’oggetto visivo.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Media.HitTestResult" /> che rappresenta il <see cref="T:System.Windows.Media.Visual" /> restituito da un hit test.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile ignorare il supporto di hit test sugli oggetti visivi eseguendo l'override di <xref:System.Windows.Media.Visual.HitTestCore%2A> metodo. Ciò significa che quando si richiama il <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> (metodo), l'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.HitTestCore%2A> viene chiamato. Il metodo sottoposto a override viene chiamato quando un hit test viene eseguito all'interno del rettangolo di delimitazione dell'oggetto visivo, anche se la coordinata rientra la geometria dell'oggetto visivo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come eseguire l'override del metodo <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.PointHitTestParameters%29>. Un motivo per cui che è possibile eseguire l'override di questo metodo è fornire funzionalità aggiuntive durante il processo di hit test.  
  
 [!code-csharp[HitTestingOverview#107](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#107)]
 [!code-vb[HitTestingOverview#107](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#107)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAncestorOf">
      <MemberSignature Language="C#" Value="public bool IsAncestorOf (System.Windows.DependencyObject descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAncestorOf(class System.Windows.DependencyObject descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAncestorOf (descendant As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAncestorOf(System::Windows::DependencyObject ^ descendant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="descendant">Valore di tipo <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Determina se l'oggetto visivo è un predecessore dell'oggetto visivo discendente.</summary>
        <returns>
          <see langword="true" /> se l’oggetto visivo è un predecessore di <paramref name="descendant" />; in caso contrario <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOf">
      <MemberSignature Language="C#" Value="public bool IsDescendantOf (System.Windows.DependencyObject ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDescendantOf(class System.Windows.DependencyObject ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDescendantOf (ancestor As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDescendantOf(System::Windows::DependencyObject ^ ancestor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="ancestor">Valore di tipo <see cref="T:System.Windows.DependencyObject" />.</param>
        <summary>Determina se l'oggetto visivo è un discendente dell'oggetto visivo predecessore.</summary>
        <returns>
          <see langword="true" /> se l’oggetto visivo è un discendente di <paramref name="ancestor" />; in caso contrario <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Impostazione precedente della scala DPI.</param>
        <param name="newDpi">Nuova impostazione della scala DPI.</param>
        <summary>Chiamato in caso di variazione del valore DPI usato per il rendering della vista.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="visualAdded">Oggetto <see cref="T:System.Windows.Media.Visual" /> aggiunto all'insieme.</param>
        <param name="visualRemoved">Oggetto <see cref="T:System.Windows.Media.Visual" /> rimosso dall’insieme.</param>
        <summary>Viene chiamato quando l'oggetto <see cref="T:System.Windows.Media.VisualCollection" /> dell’oggetto visivo viene modificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Valore di tipo <see cref="T:System.Windows.DependencyObject" /> che rappresenta l’elemento padre precedente dell’oggetto <see cref="T:System.Windows.Media.Visual" />. Se l’oggetto <see cref="T:System.Windows.Media.Visual" /> non aveva un elemento padre precedente, il valore del parametro è <see langword="null" />.</param>
        <summary>Chiamato quando l’elemento padre dell’oggetto visivo viene modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una classe che deriva da <xref:System.Windows.Media.Visual> possibile scegliere di eseguire l'override di questo metodo.  
  
 Sia presente alcun evento di "VisualParentChanged" che riferisca alle istanze di questa modifica. Pertanto, è necessario eseguire l'override di questo metodo per gestire scenari di notifica e fornire una versione dell'istanza della notifica se fa parte del proprio scenario.  
  
   
  
## Examples  
 L'esempio seguente definisce un'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.OnVisualParentChanged%2A>.  
  
 [!code-csharp[VisualSnippets#VisualSnippet10](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet10)]
 [!code-vb[VisualSnippets#VisualSnippet10](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Visual.VisualParent" />
      </Docs>
    </Member>
    <Member MemberName="PointFromScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointFromScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointFromScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointFromScreen(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Valore di <see cref="T:System.Windows.Point" /> in coordinate dello schermo.</param>
        <summary>Converte un oggetto <see cref="T:System.Windows.Point" /> sotto forma di coordinate dello schermo in un oggetto <see cref="T:System.Windows.Point" /> che rappresenta il sistema di coordinate corrente dell’oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <returns>Valore <see cref="T:System.Windows.Point" /> convertito che rappresenta il sistema di coordinate corrente dell’oggetto <see cref="T:System.Windows.Media.Visual" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Media.Visual.PointToScreen%2A> metodo per convertire un <xref:System.Windows.Point> che rappresenta il sistema di coordinate corrente il <xref:System.Windows.Media.Visual> in un <xref:System.Windows.Point> nelle coordinate dello schermo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointToScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointToScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointToScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointToScreen(System::Windows::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Valore <see cref="T:System.Windows.Point" /> che rappresenta il sistema di coordinate corrente dell’oggetto <see cref="T:System.Windows.Media.Visual" />.</param>
        <summary>Converte un oggetto <see cref="T:System.Windows.Point" /> che rappresenta il sistema di coordinate corrente dell’oggetto <see cref="T:System.Windows.Media.Visual" /> in un oggetto <see cref="T:System.Windows.Point" /> sotto forma di coordinate dello schermo.</summary>
        <returns>Valore <see cref="T:System.Windows.Point" /> convertito in coordinate dello schermo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare il <xref:System.Windows.Media.Visual.PointFromScreen%2A> metodo per convertire un <xref:System.Windows.Point> nelle coordinate dello schermo in un <xref:System.Windows.Point> che rappresenta il sistema di coordinate corrente il <xref:System.Windows.Media.Visual>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveVisualChild">
      <MemberSignature Language="C#" Value="protected void RemoveVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RemoveVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RemoveVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RemoveVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">Oggetto visivo figlio da rimuovere dall’elemento visivo padre.</param>
        <summary>Rimuove la relazione padre-figlio tra due elementi visivi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> metodo rimuove la relazione padre-figlio tra due oggetti visivi. Questo metodo, insieme al <xref:System.Windows.Media.Visual.AddVisualChild%2A> metodo, deve essere utilizzato quando è necessario un maggiore controllo di basso livello sull'implementazione di archiviazione sottostante degli oggetti visivi figlio. <xref:System.Windows.Media.VisualCollection> può essere utilizzato come un'implementazione predefinita per archiviare gli oggetti figlio.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come definire i requisiti di archiviazione personalizzato per un elemento figlio visivo. Nell'esempio viene utilizzato il <xref:System.Windows.Media.Visual.AddVisualChild%2A> e <xref:System.Windows.Media.Visual.RemoveVisualChild%2A> metodi per impostare la relazione padre-figlio tra l'oggetto visivo padre e `child`. Affinché la struttura ad albero visuale possa avvenire correttamente, l'esempio fornisce le implementazioni del <xref:System.Windows.Media.Visual.GetVisualChild%2A> (metodo) e <xref:System.Windows.Media.Visual.VisualChildrenCount%2A> proprietà.  
  
> [!NOTE]
>  Sebbene sia possibile utilizzare <xref:System.Windows.Media.VisualCollection> per creare relazioni tra oggetti visivi di padre-figlio, risulta più efficiente per fornire la propria implementazione di archiviazione personalizzato quando un solo elemento figlio è collegato a un elemento padre.  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformToAncestor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> al predecessore specificato dell’oggetto visivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor (System.Windows.Media.Media3D.Visual3D ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor(class System.Windows.Media.Media3D.Visual3D ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual3D) As GeneralTransform2DTo3D" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Media3D::GeneralTransform2DTo3D ^ TransformToAncestor(System::Windows::Media::Media3D::Visual3D ^ ancestor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Media3D.GeneralTransform2DTo3D</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Media3D.Visual3D" />
      </Parameters>
      <Docs>
        <param name="ancestor">Oggetto <see cref="T:System.Windows.Media.Media3D.Visual3D" /> nel quale vengono trasformate le coordinate.</param>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> al predecessore <see cref="T:System.Windows.Media.Media3D.Visual3D" /> specificato dell’oggetto visivo.</summary>
        <returns>Trasformazione utilizzabile per trasformare le coordinate da <see cref="T:System.Windows.Media.Visual" /> al predecessore <see cref="T:System.Windows.Media.Media3D.Visual3D" /> specificato dell’oggetto visivo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToAncestor (System.Windows.Media.Visual ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToAncestor(class System.Windows.Media.Visual ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToAncestor(System::Windows::Media::Visual ^ ancestor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="ancestor">Oggetto <see cref="T:System.Windows.Media.Visual" /> nel quale vengono trasformate le coordinate.</param>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> al predecessore <see cref="T:System.Windows.Media.Visual" /> specificato dell’oggetto visivo.</summary>
        <returns>Valore di tipo <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In alternativa, è possibile utilizzare il <xref:System.Windows.Media.VisualTreeHelper.GetOffset%2A?displayProperty=nameWithType> metodo per recuperare l'offset di un oggetto visivo rispetto al padre. Sono contenuti i valori di offset all'interno di restituito <xref:System.Windows.Vector> valore.  
  
 [!code-csharp[VisualSnippets#VisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet2)]
 [!code-vb[VisualSnippets#VisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet2)]  
  
   
  
## Examples  
 Il markup seguente viene mostrato un <xref:System.Windows.Controls.TextBlock> annidato all'interno di due <xref:System.Windows.Controls.StackPanel> oggetti.  
  
 [!code-xaml[VisualSnippets#VisualSnippet7](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window2.xaml#visualsnippet7)]  
  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Media.Visual.TransformToAncestor%2A> metodo per recuperare l'offset del <xref:System.Windows.Controls.TextBlock> relativo contenitore <xref:System.Windows.Window>. I valori di offset sono contenuti nell'oggetto restituito <xref:System.Windows.Media.GeneralTransform>.  
  
 [!code-csharp[VisualSnippets#VisualSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet5)]
 [!code-vb[VisualSnippets#VisualSnippet5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet5)]  
  
 L'offset prende in considerazione il <xref:System.Windows.FrameworkElement.Margin%2A> i valori per tutti gli oggetti nel contenitore <xref:System.Windows.Window>. In questo caso, <xref:System.Windows.Vector.X%2A> è 28, e <xref:System.Windows.Vector.Y%2A> è 28.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ancestor" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ancestor" /> non è un predecessore dell’elemento visivo.</exception>
        <exception cref="T:System.InvalidOperationException">Gli oggetti visivi non sono correlati.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToDescendant">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToDescendant (System.Windows.Media.Visual descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToDescendant(class System.Windows.Media.Visual descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToDescendant (descendant As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToDescendant(System::Windows::Media::Visual ^ descendant);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="descendant">Oggetto <see cref="T:System.Windows.Media.Visual" /> nel quale vengono trasformate le coordinate.</param>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> al discendente specificato dell’oggetto visivo.</summary>
        <returns>Valore di tipo <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Il markup seguente viene mostrato un <xref:System.Windows.Controls.TextBlock> contenuta all'interno di un <xref:System.Windows.Controls.StackPanel> oggetto.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Media.Visual.TransformToDescendant%2A> metodo per recuperare l'offset del <xref:System.Windows.Controls.StackPanel> rispetto al relativo elemento figlio <xref:System.Windows.Controls.TextBlock>. Sono contenuti i valori di offset all'interno di restituito <xref:System.Windows.Media.GeneralTransform> valore.  
  
 [!code-csharp[VisualSnippets#VisualSnippet9](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet9)]
 [!code-vb[VisualSnippets#VisualSnippet9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet9)]  
  
 L'offset prende in considerazione il <xref:System.Windows.FrameworkElement.Margin%2A> i valori per tutti gli oggetti. In questo caso, <xref:System.Windows.Vector.X%2A> è -4 e <xref:System.Windows.Vector.Y%2A> è -4. I valori di offset sono valori negativi perché l'oggetto padre viene spostato negativamente rispetto all'oggetto figlio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="descendant" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L’elemento visivo non è un predecessore dell’elemento visivo <paramref name="descendant" />.</exception>
        <exception cref="T:System.InvalidOperationException">Gli oggetti visivi non sono correlati.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToVisual">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToVisual (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToVisual(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToVisual(System::Windows::Media::Visual ^ visual);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">Oggetto <see cref="T:System.Windows.Media.Visual" /> nel quale vengono trasformate le coordinate.</param>
        <summary>Restituisce una funzione di trasformazione utilizzabile per trasformare le coordinate dall'oggetto <see cref="T:System.Windows.Media.Visual" /> all’oggetto visivo specificato.</summary>
        <returns>Valore di tipo <see cref="T:System.Windows.Media.GeneralTransform" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.Visual.TransformToAncestor%2A> e <xref:System.Windows.Media.Visual.TransformToDescendant%2A> metodi possono essere usati anche per restituire una trasformazione per un oggetto visivo.  
  
   
  
## Examples  
 Il markup seguente viene mostrato un <xref:System.Windows.Controls.TextBlock> contenuta all'interno di un <xref:System.Windows.Controls.StackPanel> oggetto.  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 Esempio di codice seguente viene illustrato come utilizzare il <xref:System.Windows.Media.Visual.TransformToVisual%2A> metodo per recuperare l'offset del <xref:System.Windows.Controls.StackPanel> rispetto al relativo elemento figlio <xref:System.Windows.Controls.TextBlock>. Sono contenuti i valori di offset all'interno di restituito <xref:System.Windows.Media.GeneralTransform> valore.  
  
 [!code-csharp[VisualSnippets#VisualSnippet8](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet8)]
 [!code-vb[VisualSnippets#VisualSnippet8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet8)]  
  
 L'offset prende in considerazione il <xref:System.Windows.FrameworkElement.Margin%2A> i valori per tutti gli oggetti. In questo caso, <xref:System.Windows.Vector.X%2A> è -4 e <xref:System.Windows.Vector.Y%2A> è -4. I valori di offset sono valori negativi perché l'oggetto padre viene spostato negativamente rispetto all'oggetto figlio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="visual" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Gli oggetti visivi non sono correlati.</exception>
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffect ^ VisualBitmapEffect {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> per <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Effetto bitmap per questo oggetto visivo.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffectInput ^ VisualBitmapEffectInput {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffectInput ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> per <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Valore di input dell'effetto bitmap per questo oggetto visivo.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffectInput" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapScalingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapScalingMode As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::BitmapScalingMode VisualBitmapScalingMode {  protected public:&#xA;System::Windows::Media::BitmapScalingMode get(); protected:&#xA; void set(System::Windows::Media::BitmapScalingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Media.BitmapScalingMode" /> per <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Il valore <see cref="T:System.Windows.Media.BitmapScalingMode" /> per <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualCacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode VisualCacheMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode VisualCacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualCacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualCacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::CacheMode ^ VisualCacheMode {  protected public:&#xA;System::Windows::Media::CacheMode ^ get(); protected:&#xA; void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una rappresentazione nascosta dell'oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Un oggetto <see cref="T:System.Windows.Media.CacheMode" /> che contiene una rappresentazione nascosta dell'oggetto <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.Windows.Media.Visual.VisualCacheMode%2A> proprietà quando è necessario migliorare le prestazioni per il contenuto che richiede molto tempo eseguire il rendering. Per ulteriori informazioni, vedere <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.ContainerVisual.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected virtual int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di elementi figlio per l’oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Numero di elementi figlio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un <xref:System.Windows.Media.Visual> non ha elementi figlio. Pertanto, l'implementazione predefinita restituisce sempre 0.  
  
   
  
## Examples  
 L'esempio seguente definisce un'implementazione sottoposta a override di <xref:System.Windows.Media.Visual.VisualChildrenCount%2A>.  
  
 [!code-csharp[DrawingVisualSample#102a](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102a)]
 [!code-vb[DrawingVisualSample#102a](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102a)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Una classe che deriva da <see cref="T:System.Windows.Media.Visual" /> deve eseguire l'override di questa proprietà, nonché il <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> (metodo), per la struttura ad albero visuale possa avvenire correttamente.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="VisualClearTypeHint">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.ClearTypeHint VisualClearTypeHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.ClearTypeHint VisualClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualClearTypeHint As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::ClearTypeHint VisualClearTypeHint { System::Windows::Media::ClearTypeHint get(); void set(System::Windows::Media::ClearTypeHint value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Media.ClearTypeHint" /> che determina come viene reso ClearType nell'oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.ClearTypeHint" /> dell'oggetto <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualClip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry VisualClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry VisualClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualClip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Geometry ^ VisualClip {  protected public:&#xA;System::Windows::Media::Geometry ^ get(); protected:&#xA; void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'area di ridimensionamento dell'oggetto <see cref="T:System.Windows.Media.Visual" /> specificato sotto forma di valore <see cref="T:System.Windows.Media.Geometry" />.</summary>
        <value>Valore dell’area di ridimensionamento dell’oggetto visivo sotto forma di tipo <see cref="T:System.Windows.Media.Geometry" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualEdgeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.EdgeMode VisualEdgeMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.EdgeMode VisualEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEdgeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEdgeMode As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::EdgeMode VisualEdgeMode {  protected public:&#xA;System::Windows::Media::EdgeMode get(); protected:&#xA; void set(System::Windows::Media::EdgeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la modalità di bordo dell’oggetto <see cref="T:System.Windows.Media.Visual" /> sotto forma di valore <see cref="T:System.Windows.Media.EdgeMode" />.</summary>
        <value>Valore <see cref="T:System.Windows.Media.EdgeMode" /> dell’oggetto visivo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect VisualEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect VisualEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEffect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::Effect ^ VisualEffect {  protected public:&#xA;System::Windows::Media::Effects::Effect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'effetto bitmap da applicare all'oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.Effects.Effect" /> che rappresenta l'effetto bitmap.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector VisualOffset { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector VisualOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOffset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Vector VisualOffset {  protected public:&#xA;System::Windows::Vector get(); protected:&#xA; void set(System::Windows::Vector value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di offset dell’oggetto visivo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Vector" /> che specifica il valore di offset.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacity">
      <MemberSignature Language="C#" Value="public double VisualOpacity { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VisualOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacity" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:  property double VisualOpacity {  protected public:&#xA;double get(); protected:&#xA; void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'opacità di <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Valore di opacità dell’oggetto visivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore dell'opacità del <xref:System.Windows.Media.Visual> viene espresso come un valore compreso tra 0 e 1. Il valore 0 indica che l'elemento è completamente trasparente, mentre un valore pari a 1 indica che l'elemento è completamente opaco. Il valore 0,5 indica che l'elemento è opaca al 50%. I valori minori di 0 vengono considerati come 0; i valori maggiori di 1 vengono considerati come 1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush VisualOpacityMask { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush VisualOpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Brush ^ VisualOpacityMask {  protected public:&#xA;System::Windows::Media::Brush ^ get(); protected:&#xA; void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore <see cref="T:System.Windows.Media.Brush" /> che rappresenta la maschera di opacità dell’oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.Brush" /> che rappresenta il valore della maschera di opacità dell’oggetto visivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La maschera di opacità è un <xref:System.Windows.Media.Brush> che viene applicata a qualsiasi mascheramento del canale alfa per il contenuto di questo oggetto visivo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualParent">
      <MemberSignature Language="C#" Value="protected System.Windows.DependencyObject VisualParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject VisualParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualParent" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property VisualParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::DependencyObject ^ VisualParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene la struttura ad albero padre dell’oggetto visivo.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.Visual" /> padre.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Parent" />
        <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="VisualScrollableAreaClip">
      <MemberSignature Language="C#" Value="public Nullable&lt;System.Windows.Rect&gt; VisualScrollableAreaClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;valuetype System.Windows.Rect&gt; VisualScrollableAreaClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualScrollableAreaClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualScrollableAreaClip As Nullable(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:  property Nullable&lt;System::Windows::Rect&gt; VisualScrollableAreaClip {  protected public:&#xA;Nullable&lt;System::Windows::Rect&gt; get(); protected:&#xA; void set(Nullable&lt;System::Windows::Rect&gt; value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un'area scorrevole ritagliata per l'oggetto <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Rect" /> che rappresenta l'area di ritaglio scorrevole o <see langword="null" /> se non viene assegnata un'area di ritaglio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà per abilitare lo scorrimento accelerato quando il rendering nel software. Ciò risulta utile in scenari remoti per il rendering, ad esempio in esecuzione tramite Desktop remoto o in una macchina virtuale. Impostare questa proprietà per l'elemento padre sarà possibile scorrere i cui elementi figlio. L'impostazione di <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà ha effetto quando per il rendering con accelerazione hardware.  
  
 Il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà consente scenari avanzati specifici. Nell'elenco seguente vengono mostrati le condizioni che si applicano quando si utilizza il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà.  
  
-   Lo sfondo dell'area di scorrimento deve essere opaco o verrà eseguito lo scorrimento degli elementi.  
  
-   Il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà accelera lo scorrimento solo quando WPF viene eseguito il rendering nel software. Ad esempio, questa situazione si verifica quando l'applicazione è in esecuzione tramite Desktop remoto o in esecuzione in locale in una macchina virtuale.  
  
-   Il comportamento di scorrimento è invariato quando il rendering in hardware. Per evitare che le differenze nel comportamento di scorrimento, è consigliabile mantenere il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> proprietà abilitata per l'hardware e software.  
  
-   Trasformazioni di rotazione e inclinazione disabilitano lo scorrimento accelerato. Trasformazioni di scala e le traduzioni in orizzontale o verticale sopra l'area di scorrimento funzioni correttamente e non disabilitare l'accelerazione dello scorrimento.  
  
-   La modifica del sottoalbero o l'attivazione di parti dell'area di scorrimento per ridisegnare tramite l'animazione si comportano come previsto, ma perdere il vantaggio di scorrimento accelerato per l'area ridisegnata. Le animazioni che invalida l'area di scorrimento durante il frame stesso si verifica in cui lo scorrimento Elimina il vantaggio di questa ottimizzazione.  
  
-   Il <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A> rettangolo si blocca verso l'interno in pixel. Di conseguenza, le dimensioni del rettangolo di scorrimento bloccate sono sempre minore o uguale alla dimensione che è stata impostata.  
  
-   Offset snap verso il basso. Ciò significa che la differenza del precedente snap offset e offset bloccati corrente è sempre un numero intero di pixel.  
  
-   Hit test può essere al massimo un pixel.  
  
-   Arrotondamento del layout deve essere acceso, poiché garantisce che i bordi delle aree scorrevoli e l'area client della finestra limite vengono bloccati i limiti di pixel, con allineamento corretto.  
  
-   Accelerazione dello scorrimento non funziona nelle finestre sovrapposte. Ciò significa che windows in cui AllowTransparency = = true, Window. WindowStyle = = nessuno e così via.  
  
-   Accelerazione dello scorrimento non si verifica durante il rendering a finestra intera.  
  
-   Accelerazione dello scorrimento non funziona quando la finestra gestisce due monitoraggi.  
  
-   Accelerazione dello scorrimento non funziona in presenza di destinazioni di rendering intermedie nella catena padre dell'elemento a scorrimento. L'elenco seguente mostra che alcune di queste destinazioni di rendering intermedie.  
  
    -   Clip  
  
    -   Effetti  
  
    -   DrawingBrushes  
  
    -   VisualBrushes  
  
    -   OpacityMasks  
  
    -   Opacità  
  
-   Solo uno scorrimento accelerato può verificarsi per ogni frame. Possono essere presenti più aree di scorrimento accelerato, ma solo uno di essi può eseguire uno scorrimento accelerato durante un frame. L'area di scorrimento è indeterminato.  
  
-   Accelerazione dello scorrimento supporta contenuto sopra l'area di scorrimento (nell'ordine z) che non scorre con il resto del contenuto. Il sistema calcola tutte le aree dirty necessarie e completa lo scorrimento accelerato, ma invia diverse bitmap aggiuntive in transito per spostare la parte involontariamente scorrimento nuovamente nella posizione corretta sullo schermo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextHintingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextHintingMode VisualTextHintingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextHintingMode VisualTextHintingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextHintingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextHintingMode As TextHintingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextHintingMode VisualTextHintingMode { System::Windows::Media::TextHintingMode get(); void set(System::Windows::Media::TextHintingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextHintingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Media.TextHintingMode" /> di <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.TextHintingMode" /> applicato a <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextRenderingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextRenderingMode VisualTextRenderingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextRenderingMode VisualTextRenderingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextRenderingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextRenderingMode As TextRenderingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextRenderingMode VisualTextRenderingMode { System::Windows::Media::TextRenderingMode get(); void set(System::Windows::Media::TextRenderingMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextRenderingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto <see cref="T:System.Windows.Media.TextRenderingMode" /> di <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.TextRenderingMode" /> applicato a <see cref="T:System.Windows.Media.Visual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform VisualTransform { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform VisualTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Transform ^ VisualTransform {  protected public:&#xA;System::Windows::Media::Transform ^ get(); protected:&#xA; void set(System::Windows::Media::Transform ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di <see cref="T:System.Windows.Media.Transform" /> per <see cref="T:System.Windows.Media.Visual" />.</summary>
        <value>Il valore della trasformazione dell’oggetto visivo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualXSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualXSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualXSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualXSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualXSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualXSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la raccolta delle linee guida per la coordinata X (verticale).</summary>
        <value>Raccolta di linee guida per la coordinata X dell'oggetto visivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Allineamento ai pixel è il processo in cui il layout del contenuto è fissa in modo che i bordi degli oggetti vengono sottoposti a rendering in pixel specifiche del dispositivo. Il sistema grafico di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] usa unità indipendenti dal dispositivo per assicurare l'indipendenza dalla risoluzione e dal dispositivo. Ogni Device Independent Pixel viene ridimensionato automaticamente con l'impostazione [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] del sistema. In questo modo, le applicazioni [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ottengono il ridimensionamento appropriato per impostazioni [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] diverse e l'applicazione viene automaticamente resa sensibile ai valori [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Tuttavia, questo [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indipendenza è possibile creare per il rendering irregolare dei bordi a causa di anti-aliasing. Questi elementi, presente comunemente come bordi sfocati o "soft", possono verificarsi quando il percorso di un bordo rientra all'interno di un pixel anziché tra pixel del dispositivo. Per risolvere questo problema, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] offre un modo per i bordi degli oggetti in una struttura ad albero visuale per "Guide" ai pixel del dispositivo, contorni sfumati prodotti dall'anti-aliasing.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetXSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
    <Member MemberName="VisualYSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualYSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualYSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualYSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualYSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualYSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la raccolta delle linee guida per la coordinata y (orizzontale).</summary>
        <value>Raccolta delle linee guida per la coordinata y dell'oggetto visivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Allineamento ai pixel è il processo in cui il layout del contenuto è fissa in modo che i bordi degli oggetti vengono sottoposti a rendering in pixel specifiche del dispositivo. Il sistema grafico di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] usa unità indipendenti dal dispositivo per assicurare l'indipendenza dalla risoluzione e dal dispositivo. Ogni Device Independent Pixel viene ridimensionato automaticamente con l'impostazione [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] del sistema. In questo modo, le applicazioni [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ottengono il ridimensionamento appropriato per impostazioni [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] diverse e l'applicazione viene automaticamente resa sensibile ai valori [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Tuttavia, questo [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indipendenza è possibile creare per il rendering irregolare dei bordi a causa di anti-aliasing. Questi elementi, presente comunemente come bordi sfocati o "soft", possono verificarsi quando il percorso di un bordo rientra all'interno di un pixel anziché tra pixel del dispositivo. Per risolvere questo problema, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] offre un modo per i bordi degli oggetti in una struttura ad albero visuale per "Guide" ai pixel del dispositivo, contorni sfumati prodotti dall'anti-aliasing.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetYSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
  </Members>
</Type>