<Type Name="ContainerVisual" FullName="System.Windows.Media.ContainerVisual">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0cbb5adf0f111144ff2eb9a57eafc59ebdd385ec" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37553934" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContainerVisual : System.Windows.Media.Visual" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContainerVisual extends System.Windows.Media.Visual" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.ContainerVisual" />
  <TypeSignature Language="VB.NET" Value="Public Class ContainerVisual&#xA;Inherits Visual" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContainerVisual : System::Windows::Media::Visual" />
  <TypeSignature Language="F#" Value="type ContainerVisual = class&#xA;    inherit Visual" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Gestisce una raccolta di oggetti <see cref="T:System.Windows.Media.Visual" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.ContainerVisual> classe viene utilizzata come contenitore per una raccolta di <xref:System.Windows.Media.Visual> oggetti. Il <xref:System.Windows.Media.DrawingVisual> deriva dalla classe la <xref:System.Windows.Media.ContainerVisual> (classe), in modo che il <xref:System.Windows.Media.DrawingVisual> classe può anche contenere una raccolta di oggetti visivi.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un <xref:System.Windows.Media.ContainerVisual> oggetto usato come elemento padre per due <xref:System.Windows.Media.DrawingVisual> oggetti. Gli oggetti che vengono aggiunti al <xref:System.Windows.Media.ContainerVisual> oggetto deve essere aggiunto in ordine inverso (dal basso in alto) per garantire che il rendering nell'ordine di disegno corretto. Affinché la struttura ad albero visuale da enumerare in modo corretto, l'esempio fornisce le implementazioni del <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> metodo e <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> proprietà.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContainerVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContainerVisual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Crea una nuova istanza della classe <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come creare una nuova istanza di un <xref:System.Windows.Media.ContainerVisual> dell'oggetto e quindi aggiungervi gli oggetti visivi figlio.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet1)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffect ^ BitmapEffect { System::Windows::Media::Effects::BitmapEffect ^ get(); void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.Media.ContainerVisual.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore di <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> per l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Effetto bitmap per questo oggetto visivo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffectInput ^ BitmapEffectInput { System::Windows::Media::Effects::BitmapEffectInput ^ get(); void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.Media.ContainerVisual.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore di <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> per l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Valore di input dell'effetto bitmap per questo oggetto visivo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CacheMode ^ CacheMode { System::Windows::Media::CacheMode ^ get(); void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.Media.ContainerVisual.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta una rappresentazione nascosta dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Un oggetto <see cref="T:System.Windows.Media.CacheMode" /> che contiene una rappresentazione nascosta dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Impostare il <xref:System.Windows.Media.ContainerVisual.CacheMode%2A> proprietà quando è necessario aumentare le prestazioni per il contenuto che richiede molto tempo eseguire il rendering. Per ulteriori informazioni, vedere <xref:System.Windows.Media.BitmapCache>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.Visual.VisualCacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Media.VisualCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.VisualCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As VisualCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::VisualCollection ^ Children { System::Windows::Media::VisualCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Media.VisualCollection" Usage="System.Windows.Media.ContainerVisual.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.VisualCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'insieme di oggetti figlio dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.VisualCollection" /> contenente gli oggetti figlio dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente viene illustrato come recuperare il <xref:System.Windows.Media.VisualCollection> da un <xref:System.Windows.Media.ContainerVisual> oggetto.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet3)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Geometry ^ Clip { System::Windows::Media::Geometry ^ get(); void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.Media.ContainerVisual.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'area di ritaglio dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.Geometry" /> che definisce l'area di visualizzazione.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="ContentBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect ContentBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect ContentBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect ContentBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentBounds : System.Windows.Rect" Usage="System.Windows.Media.ContainerVisual.ContentBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il riquadro delimitatore del testo per il contenuto dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Rect" /> che specifica il riquadro delimitatore del testo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare la <xref:System.Windows.Media.ContainerVisual.DescendantBounds%2A> proprietà per restituire l'unione di tutto il contenuto per tutti i discendenti di un <xref:System.Windows.Media.ContainerVisual> oggetto, ma non l'oggetto stesso.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come recuperare il rettangolo di delimitazione di un <xref:System.Windows.Media.ContainerVisual> oggetto.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect DescendantBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect DescendantBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DescendantBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect DescendantBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.DescendantBounds : System.Windows.Rect" Usage="System.Windows.Media.ContainerVisual.DescendantBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'unione di tutti i riquadri delimitatori del contenuto per tutti i discendenti dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />, escluso il contenuto dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Rect" /> che specifica il riquadro delimitatore del testo della combinazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ottenere il <xref:System.Windows.Media.ContainerVisual.ContentBounds%2A> proprietà per restituire il rettangolo delimitatore memorizzato nella cache per il <xref:System.Windows.Media.ContainerVisual> stesso.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come recuperare il rettangolo di delimitazione di un <xref:System.Windows.Media.ContainerVisual> discendenti dell'oggetto.  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet4)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Effect" />
      <MemberSignature Language="VB.NET" Value="Public Property Effect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::Effect ^ Effect { System::Windows::Media::Effects::Effect ^ get(); void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Effect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.Media.ContainerVisual.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'effetto bitmap da applicare all'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Oggetto <see cref="T:System.Windows.Media.Effects.Effect" /> che rappresenta l'effetto bitmap.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="containerVisual.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Intero con segno a 32 bit che rappresenta il valore di indice dell'oggetto <see cref="T:System.Windows.Media.Visual" /> figlio. Il valore di <c>indice</c> deve essere compreso tra 0 e <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> - 1.</param>
        <summary>Restituisce un oggetto <see cref="T:System.Windows.Media.Visual" /> figlio specifico per l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" /> padre.</summary>
        <returns>Oggetto <see cref="T:System.Windows.Media.Visual" /> figlio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un <xref:System.Windows.Media.ContainerVisual> non ha elementi figlio.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un <xref:System.Windows.Media.ContainerVisual> oggetto usato come elemento padre per due <xref:System.Windows.Media.DrawingVisual> oggetti. Gli oggetti che vengono aggiunti al <xref:System.Windows.Media.ContainerVisual> oggetto deve essere aggiunto in ordine inverso (dal basso in alto) per garantire che il rendering nell'ordine di disegno corretto. Affinché la struttura ad albero visuale da enumerare in modo corretto, l'esempio fornisce le implementazioni del <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> metodo e <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> proprietà.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La struttura ad albero visuale non può essere modificata durante la chiamata.</para>
        </block>
        <altmember cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTest">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Restituisce l'oggetto visivo di primo livello di un hit test.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Media.HitTestResult HitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.HitTestResult HitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::HitTestResult ^ HitTest(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="override this.HitTest : System.Windows.Point -&gt; System.Windows.Media.HitTestResult" Usage="containerVisual.HitTest point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Valore del punto per l'hit test.</param>
        <summary>Restituisce il primo oggetto visivo di un hit test specificando un oggetto <see cref="T:System.Windows.Point" />.</summary>
        <returns>Risultato dell'hit test relativo all'oggetto visivo restituito come tipo <see cref="T:System.Windows.Media.HitTestResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Windows.Media.HitTestResult.VisualHit%2A> proprietà del valore restituito rappresenta il <xref:System.Windows.Media.Visual> oggetto sottoposta a hit test.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come recuperare il <xref:System.Windows.Media.HitTestResult> valore da restituire il <xref:System.Windows.Media.ContainerVisual.HitTest%2A> (metodo).  
  
 [!code-csharp[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualSnippets/CSharp/Window1.xaml.cs#containervisualsnippet2)]
 [!code-vb[ContainerVisualSnippets#ContainerVisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualSnippets/visualbasic/window1.xaml.vb#containervisualsnippet2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public void HitTest (System.Windows.Media.HitTestFilterCallback filterCallback, System.Windows.Media.HitTestResultCallback resultCallback, System.Windows.Media.HitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HitTest(class System.Windows.Media.HitTestFilterCallback filterCallback, class System.Windows.Media.HitTestResultCallback resultCallback, class System.Windows.Media.HitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.ContainerVisual.HitTest(System.Windows.Media.HitTestFilterCallback,System.Windows.Media.HitTestResultCallback,System.Windows.Media.HitTestParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HitTest(System::Windows::Media::HitTestFilterCallback ^ filterCallback, System::Windows::Media::HitTestResultCallback ^ resultCallback, System::Windows::Media::HitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTest : System.Windows.Media.HitTestFilterCallback * System.Windows.Media.HitTestResultCallback * System.Windows.Media.HitTestParameters -&gt; unit" Usage="containerVisual.HitTest (filterCallback, resultCallback, hitTestParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterCallback" Type="System.Windows.Media.HitTestFilterCallback" />
        <Parameter Name="resultCallback" Type="System.Windows.Media.HitTestResultCallback" />
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.HitTestParameters" />
      </Parameters>
      <Docs>
        <param name="filterCallback">Delegato che consente di ignorare parti della struttura ad albero visuale da non elaborare nei risultati dell'hit test.</param>
        <param name="resultCallback">Delegato usato per controllare il valore restituito delle informazioni relative all'hit test.</param>
        <param name="hitTestParameters">Definisce il set di parametri per un hit test.</param>
        <summary>Avvia un hit test su <see cref="T:System.Windows.Media.ContainerVisual" />, usando gli oggetti <see cref="T:System.Windows.Media.HitTestFilterCallback" /> e <see cref="T:System.Windows.Media.HitTestResultCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `filterCallback` parametro può essere null, nel qual caso, viene ignorato. Se `filterCallback` non è `null`, viene richiamato prima `resultCallback`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector Offset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector Offset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Offset" />
      <MemberSignature Language="VB.NET" Value="Public Property Offset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Vector Offset { System::Windows::Vector get(); void set(System::Windows::Vector value); };" />
      <MemberSignature Language="F#" Value="member this.Offset : System.Windows.Vector with get, set" Usage="System.Windows.Media.ContainerVisual.Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il valore di offset dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" /> in base al relativo punto di riferimento.</summary>
        <value>Oggetto <see cref="T:System.Windows.Vector" /> che rappresenta il valore di offset dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Opacity : double with get, set" Usage="System.Windows.Media.ContainerVisual.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'opacità dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />, in base alle impostazioni 0 = trasparente e 1 = opaco.</summary>
        <value>Valore compreso tra 0 e 1 che specifica un intervallo che va da completamente trasparente a completamente opaco. Un valore pari a 0 indica che l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" /> è completamente trasparente, mentre un valore pari a 1specifica che l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" /> è completamente opaco. Un valore pari a 0,5 rappresenta un'opacità del 50%, un valore pari a 0,725 un'opacità del 72,5% e così via. I valori minori di 0 vengono considerati come 0, mentre i valori maggiori di 1 vengono considerati come 1.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.Opacity" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property OpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ OpacityMask { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.Media.ContainerVisual.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un pennello che specifica una possibile maschera di opacità per l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Valore di tipo <see cref="T:System.Windows.Media.Brush" /> che rappresenta il valore della maschera di opacità dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le maschere di opacità sono utilizzabile per creare effetti, ad esempio Vignette in base ai valori del canale alfa del pennello.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Media.ContainerVisual.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.Windows.Media.Visual" /> padre dell'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Padre dell'oggetto visivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che viene restituito come <xref:System.Windows.DependencyObject>, invece di un oggetto non elaborato.  
  
 Questa proprietà potrebbe restituire `null` in una struttura disconnessa, o se hanno attraversato della radice dell'albero a livello di finestra.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform Transform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform Transform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.Transform" />
      <MemberSignature Language="VB.NET" Value="Public Property Transform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ Transform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Windows.Media.Transform with get, set" Usage="System.Windows.Media.ContainerVisual.Transform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la trasformazione applicata all'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Valore della trasformazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Transform> è una classe di base che include molte forme diverse di trasformazioni. Per informazioni dettagliate, vedere <xref:System.Windows.Media.Transform>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override sealed int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Media.ContainerVisual.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di oggetti figlio per l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Numero di oggetti figlio presenti nell'oggetto <see cref="T:System.Windows.Media.VisualCollection" /> per l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, un <xref:System.Windows.Media.ContainerVisual> non ha elementi figlio.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come creare un <xref:System.Windows.Media.ContainerVisual> oggetto usato come elemento padre per due <xref:System.Windows.Media.DrawingVisual> oggetti. Gli oggetti che vengono aggiunti al <xref:System.Windows.Media.ContainerVisual> oggetto deve essere aggiunto in ordine inverso (dal basso in alto) per garantire che il rendering nell'ordine di disegno corretto. Affinché la struttura ad albero visuale da enumerare in modo corretto, l'esempio fornisce le implementazioni del <xref:System.Windows.Media.ContainerVisual.GetVisualChild%2A> metodo e <xref:System.Windows.Media.ContainerVisual.VisualChildrenCount%2A> proprietà.  
  
 [!code-csharp[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/csharp/VS_Snippets_Wpf/ContainerVisualHost/CSharp/Window1.xaml.cs#containervisualhost01)]
 [!code-vb[ContainerVisualHost#ContainerVisualHost01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContainerVisualHost/visualbasic/window1.xaml.vb#containervisualhost01)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Le classi che derivano da <see cref="T:System.Windows.Media.ContainerVisual" /> deve implementare il <see cref="P:System.Windows.Media.ContainerVisual.VisualChildrenCount" /> proprietà per enumerare gli elementi visivi figlio. La proprietà derivata deve restituire il numero di figli per i <see cref="T:System.Windows.Media.ContainerVisual" />.  La struttura ad albero visuale non può essere modificata durante la chiamata.</para>
        </block>
        <altmember cref="M:System.Windows.Media.ContainerVisual.GetVisualChild(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="XSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection XSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection XSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property XSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ XSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la linea guida X (orizzontale) per l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Linea guida orizzontale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blocco dei pixel è il processo nel quale il layout del contenuto è stato risolto in modo che i bordi degli oggetti vengono sottoposti a rendering su pixel specifiche del dispositivo. Il sistema grafico di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] usa unità indipendenti dal dispositivo per assicurare l'indipendenza dalla risoluzione e dal dispositivo. Ogni Device Independent Pixel viene ridimensionato automaticamente con l'impostazione [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] del sistema. In questo modo, le applicazioni [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ottengono il ridimensionamento appropriato per impostazioni [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] diverse e l'applicazione viene automaticamente resa sensibile ai valori [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Tuttavia, ciò [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indipendenza può creare rendering dei bordi irregolare a causa dell'anti-aliasing. Questi elementi, presente comunemente come bordi sfocati o "soft", possono verificarsi quando il percorso di una rete perimetrale cade all'interno di un pixel del dispositivo invece che tra pixel del dispositivo. Per risolvere questo problema, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fornisce un modo dei bordi dell'oggetto in un albero elementi visivi "Guide" ai pixel del dispositivo tramite il blocco dei pixel, eliminando i contorni sfumati prodotte da anti-aliasing.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      </Docs>
    </Member>
    <Member MemberName="YSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection YSnappingGuidelines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection YSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property YSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::DoubleCollection ^ YSnappingGuidelines { System::Windows::Media::DoubleCollection ^ get(); void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.YSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.ContainerVisual.YSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la linea guida Y (verticale) per l'oggetto <see cref="T:System.Windows.Media.ContainerVisual" />.</summary>
        <value>Linea guida verticale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blocco dei pixel è il processo nel quale il layout del contenuto è stato risolto in modo che i bordi degli oggetti vengono sottoposti a rendering su pixel specifiche del dispositivo. Il sistema grafico di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] usa unità indipendenti dal dispositivo per assicurare l'indipendenza dalla risoluzione e dal dispositivo. Ogni Device Independent Pixel viene ridimensionato automaticamente con l'impostazione [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] del sistema. In questo modo, le applicazioni [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ottengono il ridimensionamento appropriato per impostazioni [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] diverse e l'applicazione viene automaticamente resa sensibile ai valori [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)].  
  
 Tuttavia, ciò [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] indipendenza può creare rendering dei bordi irregolare a causa dell'anti-aliasing. Questi elementi, presente comunemente come bordi sfocati o "soft", possono verificarsi quando il percorso di una rete perimetrale cade all'interno di un pixel del dispositivo invece che tra pixel del dispositivo. Per risolvere questo problema, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] fornisce un modo dei bordi dell'oggetto in un albero elementi visivi "Guide" ai pixel del dispositivo tramite il blocco dei pixel, eliminando i contorni sfumati prodotte da anti-aliasing.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.ContainerVisual.XSnappingGuidelines" />
      </Docs>
    </Member>
  </Members>
</Type>