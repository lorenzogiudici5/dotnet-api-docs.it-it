<Type Name="DrawingContext" FullName="System.Windows.Media.DrawingContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a5501bf2f8e9b049041293d0b34f2441556dee4a" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48628025" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class DrawingContext : System.Windows.Threading.DispatcherObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DrawingContext extends System.Windows.Threading.DispatcherObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.DrawingContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DrawingContext&#xA;Inherits DispatcherObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DrawingContext abstract : System::Windows::Threading::DispatcherObject, IDisposable" />
  <TypeSignature Language="F#" Value="type DrawingContext = class&#xA;    inherit DispatcherObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Descrive il contenuto visivo usando i comandi draw, push e pop.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare un <xref:System.Windows.Media.DrawingContext> per popolare una <xref:System.Windows.Media.Visual> o un <xref:System.Windows.Media.Drawing> con contenuto visivo.  
  
 Anche se il <xref:System.Windows.Media.DrawingContext> metodi di disegno simile ai metodi di disegno del <xref:System.Drawing.Graphics?displayProperty=nameWithType> tipo, funzionano in modo diverso: <xref:System.Windows.Media.DrawingContext> viene utilizzato con un sistema di grafica in modalità differita, mentre il <xref:System.Drawing.Graphics?displayProperty=nameWithType> tipo viene utilizzato con una modalità immediata sistema di grafica. Quando si usa una <xref:System.Windows.Media.DrawingContext> comandi di disegno dell'oggetto, si archivia un set di istruzioni di rendering (anche se il meccanismo di archiviazione esatta dipende dal tipo di oggetto che fornisce il <xref:System.Windows.Media.DrawingContext>) che verrà successivamente utilizzata per la grafica di sistema; è non si disegna sullo schermo in tempo reale. Per altre informazioni su come funziona il sistema di grafica Windows Presentation Foundation (WPF), vedere [Cenni preliminari sul Rendering WPF grafica](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).  
  
 Mai direttamente creare un'istanza di un <xref:System.Windows.Media.DrawingContext>; tuttavia, è possibile, acquisire un contesto di disegno tramite determinati metodi, ad esempio <xref:System.Windows.Media.DrawingGroup.Open%2A?displayProperty=nameWithType> e <xref:System.Windows.Media.DrawingVisual.RenderOpen%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Nell'esempio seguente recupera un' <xref:System.Windows.Media.DrawingContext> da un <xref:System.Windows.Media.DrawingVisual> e viene utilizzato per disegnare un rettangolo.  
  
 [!code-csharp[drawingvisualsample#101](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#101)]
 [!code-vb[drawingvisualsample#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#101)]  
  
 L'esempio successivo illustra il <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, e <xref:System.Windows.Media.DrawingContext.Pop%2A> comandi. Il <xref:System.Windows.Media.DrawingContext> ottenuto da un <xref:System.Windows.Media.DrawingGroup> e visualizzato tramite un <xref:System.Windows.Controls.Image> controllo.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.DrawingGroup" />
    <altmember cref="T:System.Windows.Media.Drawing" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public abstract void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Close" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit" Usage="drawingContext.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chiude l'oggetto <see cref="T:System.Windows.Media.DrawingContext" /> e scarica il contenuto. In seguito non sarà possibile modificare l'oggetto <see cref="T:System.Windows.Media.DrawingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Windows.Media.DrawingContext> devono essere chiusi prima che il relativo contenuto può essere sottoposto a rendering, ma dopo che è stato chiuso, non può essere modificato. Questa chiamata non richiede tutte le chiamate di Push a sono stati estratti.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Questo oggetto è già stato chiuso o eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisposeCore">
      <MemberSignature Language="C#" Value="protected abstract void DisposeCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisposeCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DisposeCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DisposeCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DisposeCore();" />
      <MemberSignature Language="F#" Value="abstract member DisposeCore : unit -&gt; unit" Usage="drawingContext.DisposeCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate da <see cref="T:System.Windows.Media.DrawingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non chiamare questo metodo direttamente dal codice. usare il <xref:System.Windows.Media.DrawingContext.System%23IDisposable%23Dispose%2A> metodo invece.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato chiuso o eliminato.</exception>
        <altmember cref="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      </Docs>
    </Member>
    <Member MemberName="DrawDrawing">
      <MemberSignature Language="C#" Value="public abstract void DrawDrawing (System.Windows.Media.Drawing drawing);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawDrawing(class System.Windows.Media.Drawing drawing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawDrawing(System.Windows.Media.Drawing)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawDrawing(System::Windows::Media::Drawing ^ drawing);" />
      <MemberSignature Language="F#" Value="abstract member DrawDrawing : System.Windows.Media.Drawing -&gt; unit" Usage="drawingContext.DrawDrawing drawing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawing" Type="System.Windows.Media.Drawing" />
      </Parameters>
      <Docs>
        <param name="drawing">Disegno da accodare.</param>
        <summary>Disegna l'oggetto <see cref="T:System.Windows.Media.Drawing" /> specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawEllipse">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Disegna un ellisse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * double * double -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Pennello con cui riempire l'ellisse.  Facoltativo. Può essere <see langword="null" />. Se il pennello è <see langword="null" />, non viene disegnato alcun riempimento.</param>
        <param name="pen">Penna con cui disegnare l'ellisse.  Facoltativo. Può essere <see langword="null" />. Se la penna è <see langword="null" />, non viene disegnato alcun tratto.</param>
        <param name="center">Posizione del centro dell'ellisse.</param>
        <param name="radiusX">Raggio orizzontale dell'ellisse.</param>
        <param name="radiusY">Raggio verticale dell'ellisse.</param>
        <summary>Disegna un'ellisse con gli oggetti <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La penna e il pennello possono essere entrambi `null`.  Se il pennello è `null`, quindi viene eseguito alcun riempimento.  Se la penna è `null`, viene eseguito alcun tratto.  Se la penna e il pennello sono entrambi `null`, quindi non è visibile nel disegno.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawEllipse">
      <MemberSignature Language="C#" Value="public abstract void DrawEllipse (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Point center, System.Windows.Media.Animation.AnimationClock centerAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawEllipse(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Point center, class System.Windows.Media.Animation.AnimationClock centerAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawEllipse(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawEllipse(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Point center, System::Windows::Media::Animation::AnimationClock ^ centerAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawEllipse : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawEllipse (brush, pen, center, centerAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="center" Type="System.Windows.Point" />
        <Parameter Name="centerAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Pennello con cui riempire l'ellisse.  Facoltativo. Può essere <see langword="null" />. Se il pennello è <see langword="null" />, non viene disegnato alcun riempimento.</param>
        <param name="pen">Penna con cui disegnare l'ellisse.  Facoltativo. Può essere <see langword="null" />. Se la penna è <see langword="null" />, non viene disegnato alcun tratto.</param>
        <param name="center">Posizione del centro dell'ellisse.</param>
        <param name="centerAnimations">Clock con cui aggiungere un'animazione al centro dell'ellisse oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione agli oggetti <see cref="T:System.Windows.Point" />.</param>
        <param name="radiusX">Raggio orizzontale dell'ellisse.</param>
        <param name="radiusXAnimations">Clock con il quale aggiungere un'animazione al raggio x dell'ellisse oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione agli oggetti <see cref="T:System.Double" />.</param>
        <param name="radiusY">Raggio verticale dell'ellisse.</param>
        <param name="radiusYAnimations">Clock con il quale aggiungere un'animazione al raggio y dell'ellisse oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione agli oggetti <see cref="T:System.Double" />.</param>
        <summary>Disegna un'ellisse con gli oggetti <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> specificati e applica i clock di animazione definiti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La penna e il pennello possono essere entrambi `null`.  Se il pennello è `null`, quindi viene eseguito alcun riempimento.  Se la penna è `null`, viene eseguito alcun tratto.  Se la penna e il pennello sono entrambi `null`, quindi non è visibile nel disegno.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGeometry">
      <MemberSignature Language="C#" Value="public abstract void DrawGeometry (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Media.Geometry geometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGeometry(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, class System.Windows.Media.Geometry geometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGeometry(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Media.Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGeometry(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Media::Geometry ^ geometry);" />
      <MemberSignature Language="F#" Value="abstract member DrawGeometry : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.DrawGeometry (brush, pen, geometry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="geometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="brush">Oggetto <see cref="T:System.Windows.Media.Brush" /> con cui compilare l'oggetto <see cref="T:System.Windows.Media.Geometry" />. Facoltativo. Può essere <see langword="null" />. Se il pennello è <see langword="null" />, non viene disegnato alcun riempimento.</param>
        <param name="pen">Oggetto <see cref="T:System.Windows.Media.Pen" /> con cui iniziare a disegnare l'oggetto <see cref="T:System.Windows.Media.Geometry" />. Facoltativo. Può essere <see langword="null" />. Se la penna è <see langword="null" />, non viene disegnato alcun tratto.</param>
        <param name="geometry">Classe <see cref="T:System.Windows.Media.Geometry" /> da disegnare.</param>
        <summary>Disegna l'oggetto <see cref="T:System.Windows.Media.Geometry" /> usando gli oggetti <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> specificati.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawGlyphRun">
      <MemberSignature Language="C#" Value="public abstract void DrawGlyphRun (System.Windows.Media.Brush foregroundBrush, System.Windows.Media.GlyphRun glyphRun);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawGlyphRun(class System.Windows.Media.Brush foregroundBrush, class System.Windows.Media.GlyphRun glyphRun) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawGlyphRun(System.Windows.Media.Brush,System.Windows.Media.GlyphRun)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawGlyphRun(System::Windows::Media::Brush ^ foregroundBrush, System::Windows::Media::GlyphRun ^ glyphRun);" />
      <MemberSignature Language="F#" Value="abstract member DrawGlyphRun : System.Windows.Media.Brush * System.Windows.Media.GlyphRun -&gt; unit" Usage="drawingContext.DrawGlyphRun (foregroundBrush, glyphRun)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="foregroundBrush" Type="System.Windows.Media.Brush" />
        <Parameter Name="glyphRun" Type="System.Windows.Media.GlyphRun" />
      </Parameters>
      <Docs>
        <param name="foregroundBrush">Pennello utilizzato per disegnare il testo.</param>
        <param name="glyphRun">Testo da disegnare.</param>
        <summary>Disegna il testo specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawImage">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Disegna un'immagine nell'area definita dall'oggetto <see cref="T:System.Windows.Rect" /> specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="imageSource">Immagine da disegnare.</param>
        <param name="rectangle">Area in cui disegnare l'oggetto <c>bitmapSource</c>.</param>
        <summary>Disegna un'immagine nell'area definita dall'oggetto <see cref="T:System.Windows.Rect" /> specificato.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Per visualizzare le immagini di non aver <see cref="T:System.Net.WebPermission" /> o <see cref="T:System.Security.Permissions.FileIOPermission" /> accedere per. Enumerazione associata: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DrawImage">
      <MemberSignature Language="C#" Value="public abstract void DrawImage (System.Windows.Media.ImageSource imageSource, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawImage(class System.Windows.Media.ImageSource imageSource, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawImage(System.Windows.Media.ImageSource,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawImage(System::Windows::Media::ImageSource ^ imageSource, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawImage : System.Windows.Media.ImageSource * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawImage (imageSource, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageSource" Type="System.Windows.Media.ImageSource" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="imageSource">Immagine da disegnare.</param>
        <param name="rectangle">Area in cui disegnare l'oggetto <c>bitmapSource</c>.</param>
        <param name="rectangleAnimations">Clock con il quale aggiungere un'animazione alle dimensioni del rettangolo oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione agli oggetti <see cref="T:System.Windows.Rect" />.</param>
        <summary>Disegna un'immagine nell'area definita dall'oggetto <see cref="T:System.Windows.Rect" /> specificato e applica il clock di animazione specificato.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Per visualizzare le immagini di non aver <see cref="T:System.Net.WebPermission" /> o <see cref="T:System.Security.Permissions.FileIOPermission" /> accedere per. Enumerazione associata: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawLine">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Disegna una linea con l'oggetto <see cref="T:System.Windows.Media.Pen" /> specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Point point1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, valuetype System.Windows.Point point1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Point point1);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point1" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="pen">Penna con cui disegnare la linea.</param>
        <param name="point0">Punto iniziale della riga.</param>
        <param name="point1">Punto finale della linea.</param>
        <summary>Disegna una linea tra i punti specificati utilizzando l'oggetto <see cref="T:System.Windows.Media.Pen" /> specificato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawLine">
      <MemberSignature Language="C#" Value="public abstract void DrawLine (System.Windows.Media.Pen pen, System.Windows.Point point0, System.Windows.Media.Animation.AnimationClock point0Animations, System.Windows.Point point1, System.Windows.Media.Animation.AnimationClock point1Animations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawLine(class System.Windows.Media.Pen pen, valuetype System.Windows.Point point0, class System.Windows.Media.Animation.AnimationClock point0Animations, valuetype System.Windows.Point point1, class System.Windows.Media.Animation.AnimationClock point1Animations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawLine(System.Windows.Media.Pen,System.Windows.Point,System.Windows.Media.Animation.AnimationClock,System.Windows.Point,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawLine(System::Windows::Media::Pen ^ pen, System::Windows::Point point0, System::Windows::Media::Animation::AnimationClock ^ point0Animations, System::Windows::Point point1, System::Windows::Media::Animation::AnimationClock ^ point1Animations);" />
      <MemberSignature Language="F#" Value="abstract member DrawLine : System.Windows.Media.Pen * System.Windows.Point * System.Windows.Media.Animation.AnimationClock * System.Windows.Point * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawLine (pen, point0, point0Animations, point1, point1Animations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="point0" Type="System.Windows.Point" />
        <Parameter Name="point0Animations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="point1" Type="System.Windows.Point" />
        <Parameter Name="point1Animations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="pen">Penna con cui disegnare la linea.</param>
        <param name="point0">Punto iniziale della riga.</param>
        <param name="point0Animations">Clock con il quale aggiungere un'animazione al punto iniziale della linea oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione agli oggetti <see cref="T:System.Windows.Point" />.</param>
        <param name="point1">Punto finale della linea.</param>
        <param name="point1Animations">Clock con il quale aggiungere un'animazione al punto finale della linea oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione agli oggetti <see cref="T:System.Windows.Point" />.</param>
        <summary>Disegna una linea tra i punti specificati utilizzando l'oggetto <see cref="T:System.Windows.Media.Pen" /> definito e applica i clock di animazione specificati.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Disegna un rettangolo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="brush">Pennello con cui riempire il rettangolo.  Facoltativo. Può essere <see langword="null" />. Se il pennello è <see langword="null" />, non viene disegnato alcun riempimento.</param>
        <param name="pen">Penna con cui disegnare il rettangolo.  Facoltativo. Può essere <see langword="null" />. Se la penna è <see langword="null" />, non viene disegnato alcun tratto.</param>
        <param name="rectangle">Rettangolo da disegnare.</param>
        <summary>Disegna un rettangolo con gli oggetti <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> specificati. La penna e il pennello possono essere entrambi impostati su <see langword="null" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La penna e il pennello possono essere entrambi `null`.  Se il pennello è `null`, quindi viene eseguito alcun riempimento.  Se la penna è `null`, viene eseguito alcun tratto.  Se la penna e il pennello sono entrambi `null`, quindi non è visibile nel disegno.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRectangle (brush, pen, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Pennello con cui riempire il rettangolo.  Facoltativo. Può essere <see langword="null" />. Se il pennello è <see langword="null" />, non viene disegnato alcun riempimento.</param>
        <param name="pen">Penna con cui disegnare il rettangolo.  Facoltativo. Può essere <see langword="null" />. Se la penna è <see langword="null" />, non viene disegnato alcun tratto.</param>
        <param name="rectangle">Rettangolo da disegnare.</param>
        <param name="rectangleAnimations">Clock con il quale aggiungere un'animazione alle dimensioni del rettangolo oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione agli oggetti <see cref="T:System.Windows.Rect" />.</param>
        <summary>Disegna un rettangolo con gli oggetti <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> specificati e applica i clock di animazione definiti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La penna e il pennello possono essere entrambi `null`.  Se il pennello è `null`, quindi viene eseguito alcun riempimento.  Se la penna è `null`, viene eseguito alcun tratto.  Se la penna e il pennello sono entrambi `null`, quindi non è visibile nel disegno.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawRoundedRectangle">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Disegna un rettangolo arrotondato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, float64 radiusX, float64 radiusY) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Double,System.Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, double radiusX, double radiusY);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * double * double -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, radiusX, radiusY)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusY" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="brush">Pennello utilizzato per riempire il rettangolo.</param>
        <param name="pen">Penna utilizzata per disegnare il rettangolo.</param>
        <param name="rectangle">Rettangolo da disegnare.</param>
        <param name="radiusX">Raggio degli angoli arrotondati nella dimensione X.  Verrà impostato un valore compreso tra 0 e <see cref="P:System.Windows.Rect.Width" />/2.</param>
        <param name="radiusY">Raggio degli angoli arrotondati nella dimensione Y.  Questo parametro verrà impostato su un valore compreso tra 0 e <see cref="P:System.Windows.Rect.Height" />/2.</param>
        <summary>Disegna un rettangolo arrotondato con gli oggetti <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La penna e il pennello possono essere entrambi `null`.  Se il pennello è `null`, quindi viene eseguito alcun riempimento.  Se la penna è `null`, viene eseguito alcun tratto.  Se la penna e il pennello sono entrambi `null`, quindi non è visibile nel disegno.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawRoundedRectangle">
      <MemberSignature Language="C#" Value="public abstract void DrawRoundedRectangle (System.Windows.Media.Brush brush, System.Windows.Media.Pen pen, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations, double radiusX, System.Windows.Media.Animation.AnimationClock radiusXAnimations, double radiusY, System.Windows.Media.Animation.AnimationClock radiusYAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawRoundedRectangle(class System.Windows.Media.Brush brush, class System.Windows.Media.Pen pen, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations, float64 radiusX, class System.Windows.Media.Animation.AnimationClock radiusXAnimations, float64 radiusY, class System.Windows.Media.Animation.AnimationClock radiusYAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawRoundedRectangle(System.Windows.Media.Brush,System.Windows.Media.Pen,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock,System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawRoundedRectangle(System::Windows::Media::Brush ^ brush, System::Windows::Media::Pen ^ pen, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations, double radiusX, System::Windows::Media::Animation::AnimationClock ^ radiusXAnimations, double radiusY, System::Windows::Media::Animation::AnimationClock ^ radiusYAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawRoundedRectangle : System.Windows.Media.Brush * System.Windows.Media.Pen * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock * double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawRoundedRectangle (brush, pen, rectangle, rectangleAnimations, radiusX, radiusXAnimations, radiusY, radiusYAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="brush" Type="System.Windows.Media.Brush" />
        <Parameter Name="pen" Type="System.Windows.Media.Pen" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusX" Type="System.Double" />
        <Parameter Name="radiusXAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="radiusY" Type="System.Double" />
        <Parameter Name="radiusYAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="brush">Pennello utilizzato per riempire il rettangolo oppure <see langword="null" /> se non viene applicato alcun riempimento.</param>
        <param name="pen">Penna usata per disegnare il rettangolo oppure <see langword="null" /> se non viene disegnato alcun elemento.</param>
        <param name="rectangle">Rettangolo da disegnare.</param>
        <param name="rectangleAnimations">Clock con il quale aggiungere un'animazione alle dimensioni del rettangolo oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione agli oggetti <see cref="T:System.Windows.Rect" />.</param>
        <param name="radiusX">Raggio degli angoli arrotondati nella dimensione X.  Verrà impostato un valore compreso tra 0 e <see cref="P:System.Windows.Rect.Width" />/2.</param>
        <param name="radiusXAnimations">Clock con il quale aggiungere un'animazione al valore <c>radiusX</c> del rettangolo oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione ai valori <see cref="T:System.Double" />.</param>
        <param name="radiusY">Raggio degli angoli arrotondati nella dimensione Y.  Questo parametro verrà impostato su un valore compreso tra 0 e <see cref="P:System.Windows.Rect.Height" />/2.</param>
        <param name="radiusYAnimations">Clock con il quale aggiungere un'animazione al valore <c>radiusY</c> del rettangolo oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione ai valori <see cref="T:System.Double" />.</param>
        <summary>Disegna un rettangolo arrotondato con gli oggetti <see cref="T:System.Windows.Media.Brush" /> e <see cref="T:System.Windows.Media.Pen" /> specificati e applica i clock di animazione definiti.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La penna e il pennello possono essere entrambi `null`.  Se il pennello è `null`, quindi viene eseguito alcun riempimento.  Se la penna è `null`, viene eseguito alcun tratto.  Se la penna e il pennello sono entrambi `null`, quindi non è visibile nel disegno.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawText">
      <MemberSignature Language="C#" Value="public void DrawText (System.Windows.Media.FormattedText formattedText, System.Windows.Point origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawText(class System.Windows.Media.FormattedText formattedText, valuetype System.Windows.Point origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawText(System.Windows.Media.FormattedText,System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawText(System::Windows::Media::FormattedText ^ formattedText, System::Windows::Point origin);" />
      <MemberSignature Language="F#" Value="member this.DrawText : System.Windows.Media.FormattedText * System.Windows.Point -&gt; unit" Usage="drawingContext.DrawText (formattedText, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="formattedText" Type="System.Windows.Media.FormattedText" />
        <Parameter Name="origin" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="formattedText">Testo formattato da disegnare.</param>
        <param name="origin">Posizione in cui il testo deve essere disegnato.</param>
        <summary>Disegna il testo formattato nella posizione specificata.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">L'oggetto è già stato chiuso o eliminato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DrawVideo">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un video nell'area specificata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="player">Elemento multimediale da creare.</param>
        <param name="rectangle">Area in cui disegnare il parametro <c>player</c>.</param>
        <summary>Crea un video nell'area specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che il supporto verrà esteso per adattarsi all'interno dell'area definita dal parametro del rettangolo. Se il rettangolo e i supporti hanno proporzioni diverse, si verificherà una distorsione. Per un maggiore controllo sul modo in cui supporto viene usato per riempire un'area, usare il <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> comando per disegnare un rettangolo e popolarlo con una <xref:System.Windows.Media.VisualBrush> contenente supporti.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Per visualizzare gli elementi multimediali che non dispongono <see cref="T:System.Net.WebPermission" /> o <see cref="T:System.Security.Permissions.FileIOPermission" /> accedere per. Enumerazione associata: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DrawVideo">
      <MemberSignature Language="C#" Value="public abstract void DrawVideo (System.Windows.Media.MediaPlayer player, System.Windows.Rect rectangle, System.Windows.Media.Animation.AnimationClock rectangleAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DrawVideo(class System.Windows.Media.MediaPlayer player, valuetype System.Windows.Rect rectangle, class System.Windows.Media.Animation.AnimationClock rectangleAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.DrawVideo(System.Windows.Media.MediaPlayer,System.Windows.Rect,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DrawVideo (player As MediaPlayer, rectangle As Rect, rectangleAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DrawVideo(System::Windows::Media::MediaPlayer ^ player, System::Windows::Rect rectangle, System::Windows::Media::Animation::AnimationClock ^ rectangleAnimations);" />
      <MemberSignature Language="F#" Value="abstract member DrawVideo : System.Windows.Media.MediaPlayer * System.Windows.Rect * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.DrawVideo (player, rectangle, rectangleAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="player" Type="System.Windows.Media.MediaPlayer" />
        <Parameter Name="rectangle" Type="System.Windows.Rect" />
        <Parameter Name="rectangleAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="player">Elemento multimediale da creare.</param>
        <param name="rectangle">Area in cui creare l'elemento multimediale.</param>
        <param name="rectangleAnimations">Clock con il quale aggiungere un'animazione alle dimensioni del rettangolo oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione agli oggetti <see cref="T:System.Windows.Rect" />.</param>
        <summary>Crea un video nell'area specificata e applica il clock di animazione definito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che il supporto verrà esteso per adattarsi all'interno dell'area definita dal parametro del rettangolo. Se il rettangolo e i supporti hanno proporzioni diverse, si verificherà una distorsione. Per un maggiore controllo sul modo in cui supporto viene usato per riempire un'area, usare il <xref:System.Windows.Media.DrawingContext.DrawRectangle%2A> comando per disegnare un rettangolo e popolarlo con una <xref:System.Windows.Media.VisualBrush> contenente supporti.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.MediaPermission">Per visualizzare gli elementi multimediali che non dispongono <see cref="T:System.Net.WebPermission" /> o <see cref="T:System.Security.Permissions.FileIOPermission" /> accedere per. Enumerazione associata: <see cref="F:System.Security.Permissions.MediaPermissionImage.SafeImage" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public abstract void Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.Pop" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Pop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Pop();" />
      <MemberSignature Language="F#" Value="abstract member Pop : unit -&gt; unit" Usage="drawingContext.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Estrae l'ultima operazione relativa a una maschera di opacità, all'opacità, al ridimensionamento, a un effetto o una trasformazione inserita nel contesto del disegno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una volta che un'operazione viene estratto, non viene più applicato ai comandi di disegni successivi.  
  
   
  
## Examples  
 L'esempio seguente illustra l'effetto del <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
 [!code-csharp[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PopExample.cs#popexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PopExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/popexample.vb#popexamplewholepage)]  
  
 La figura seguente mostra l'output di questo esempio:  
  
 ![Rettangoli disegnati con diversi valori di opacità](~/add/media/graphicsmm-drawingcontextpopexample.gif "rettangoli disegnati con diversi valori di opacità")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushClip">
      <MemberSignature Language="C#" Value="public abstract void PushClip (System.Windows.Media.Geometry clipGeometry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushClip(class System.Windows.Media.Geometry clipGeometry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushClip(System.Windows.Media.Geometry)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushClip (clipGeometry As Geometry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushClip(System::Windows::Media::Geometry ^ clipGeometry);" />
      <MemberSignature Language="F#" Value="abstract member PushClip : System.Windows.Media.Geometry -&gt; unit" Usage="drawingContext.PushClip clipGeometry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipGeometry" Type="System.Windows.Media.Geometry" />
      </Parameters>
      <Docs>
        <param name="clipGeometry">Area di ridimensionamento da applicare ai comandi di disegno successivi.</param>
        <summary>Inserisce l'area di ridimensionamento specificata nel contesto del disegno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'area di ritaglio si applica a tutti i comandi di disegno successivi fino a quando non viene rimosso dal <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushEffect">
      <MemberSignature Language="C#" Value="public abstract void PushEffect (System.Windows.Media.Effects.BitmapEffect effect, System.Windows.Media.Effects.BitmapEffectInput effectInput);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushEffect(class System.Windows.Media.Effects.BitmapEffect effect, class System.Windows.Media.Effects.BitmapEffectInput effectInput) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushEffect(System.Windows.Media.Effects.BitmapEffect,System.Windows.Media.Effects.BitmapEffectInput)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushEffect (effect As BitmapEffect, effectInput As BitmapEffectInput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushEffect(System::Windows::Media::Effects::BitmapEffect ^ effect, System::Windows::Media::Effects::BitmapEffectInput ^ effectInput);" />
      <MemberSignature Language="F#" Value="abstract member PushEffect : System.Windows.Media.Effects.BitmapEffect * System.Windows.Media.Effects.BitmapEffectInput -&gt; unit" Usage="drawingContext.PushEffect (effect, effectInput)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="effect" Type="System.Windows.Media.Effects.BitmapEffect" />
        <Parameter Name="effectInput" Type="System.Windows.Media.Effects.BitmapEffectInput" />
      </Parameters>
      <Docs>
        <param name="effect">Effetto da applicare ai disegni successivi.</param>
        <param name="effectInput">Area a cui viene applicato l'effetto oppure <see langword="null" /> se l'effetto deve essere applicato all'intera area dei disegni successivi.</param>
        <summary>Inserisce l'oggetto <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> specificato nel contesto del disegno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'effetto viene applicato a tutte le operazioni di disegnare successive fino a quando non viene rimosso dal <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, e <xref:System.Windows.Media.DrawingContext.Pop%2A> comandi.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushGuidelineSet">
      <MemberSignature Language="C#" Value="public abstract void PushGuidelineSet (System.Windows.Media.GuidelineSet guidelines);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushGuidelineSet(class System.Windows.Media.GuidelineSet guidelines) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushGuidelineSet(System.Windows.Media.GuidelineSet)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushGuidelineSet (guidelines As GuidelineSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushGuidelineSet(System::Windows::Media::GuidelineSet ^ guidelines);" />
      <MemberSignature Language="F#" Value="abstract member PushGuidelineSet : System.Windows.Media.GuidelineSet -&gt; unit" Usage="drawingContext.PushGuidelineSet guidelines" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guidelines" Type="System.Windows.Media.GuidelineSet" />
      </Parameters>
      <Docs>
        <param name="guidelines">Insieme di linee guida da applicare ai comandi di disegno successivi.</param>
        <summary>Inserisce l'oggetto <see cref="T:System.Windows.Media.GuidelineSet" /> specificato nel contesto del disegno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Insieme di linee guida si applica a tutti i comandi di disegno successivi fino a quando non viene rimosso dal <xref:System.Windows.Media.DrawingContext.Pop%2A> operazione.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.GuidelineSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PushOpacity">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserisce l'impostazione di opacità specificata nel contesto del disegno.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double -&gt; unit" Usage="drawingContext.PushOpacity opacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="opacity">Fattore di opacità da applicare ai comandi di disegno successivi. Questo fattore è cumulativo con le operazioni <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" /> precedenti.</param>
        <summary>Inserisce l'impostazione di opacità specificata nel contesto del disegno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'opacità viene fusa in tutti i comandi di disegno successivi fino a quando non viene rimosso dal <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il <xref:System.Windows.Media.DrawingContext.PushOpacity%2A>, <xref:System.Windows.Media.DrawingContext.PushEffect%2A>, e <xref:System.Windows.Media.DrawingContext.Pop%2A> comandi.  
  
 [!code-csharp[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingContext_procedural_snip/CSharp/PushEffectExample.cs#pusheffectexamplewholepage)]
 [!code-vb[DrawingContext_procedural_snip#PushEffectExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingContext_procedural_snip/visualbasic/pusheffectexample.vb#pusheffectexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacity">
      <MemberSignature Language="C#" Value="public abstract void PushOpacity (double opacity, System.Windows.Media.Animation.AnimationClock opacityAnimations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacity(float64 opacity, class System.Windows.Media.Animation.AnimationClock opacityAnimations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacity (opacity As Double, opacityAnimations As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacity(double opacity, System::Windows::Media::Animation::AnimationClock ^ opacityAnimations);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacity : double * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="drawingContext.PushOpacity (opacity, opacityAnimations)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacity" Type="System.Double" />
        <Parameter Name="opacityAnimations" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="opacity">Fattore di opacità da applicare ai comandi di disegno successivi. Questo fattore è cumulativo con le operazioni <see cref="M:System.Windows.Media.DrawingContext.PushOpacity(System.Double)" /> precedenti.</param>
        <param name="opacityAnimations">Clock con il quale aggiungere un'animazione al valore di opacità oppure <see langword="null" /> se non viene applicata alcuna animazione. È necessario creare il clock in base a un oggetto <see cref="T:System.Windows.Media.Animation.AnimationTimeline" /> in grado di aggiungere un'animazione ai valori <see cref="T:System.Double" />.</param>
        <summary>Inserisce l'impostazione di opacità specificata nel contesto del disegno e applica il clock di animazione definito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'opacità viene fusa in tutti i comandi di disegno successivi fino a quando non viene rimosso dal <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushOpacityMask">
      <MemberSignature Language="C#" Value="public abstract void PushOpacityMask (System.Windows.Media.Brush opacityMask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushOpacityMask(class System.Windows.Media.Brush opacityMask) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushOpacityMask(System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub PushOpacityMask (opacityMask As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushOpacityMask(System::Windows::Media::Brush ^ opacityMask);" />
      <MemberSignature Language="F#" Value="abstract member PushOpacityMask : System.Windows.Media.Brush -&gt; unit" Usage="drawingContext.PushOpacityMask opacityMask" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="opacityMask" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="opacityMask">Maschera di opacità da applicare ai disegni successivi. I valori alfa di questa pennello determinano l'opacità del disegno a cui viene applicata tale proprietà.</param>
        <summary>Inserisce la maschera di opacità specificata nel contesto del disegno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La maschera viene applicata a tutti i comandi di disegno successivi fino a quando non viene rimosso dal <xref:System.Windows.Media.DrawingContext.Pop%2A> operazione.  
  
 Per altre informazioni sulla creazione di maschere di opacità, vedere [Cenni preliminari sulle maschere di opacità](~/docs/framework/wpf/graphics-multimedia/opacity-masks-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushTransform">
      <MemberSignature Language="C#" Value="public abstract void PushTransform (System.Windows.Media.Transform transform);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PushTransform(class System.Windows.Media.Transform transform) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.PushTransform(System.Windows.Media.Transform)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void PushTransform(System::Windows::Media::Transform ^ transform);" />
      <MemberSignature Language="F#" Value="abstract member PushTransform : System.Windows.Media.Transform -&gt; unit" Usage="drawingContext.PushTransform transform" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transform" Type="System.Windows.Media.Transform" />
      </Parameters>
      <Docs>
        <param name="transform">Trasformazione da applicare ai comandi di disegno successivi.</param>
        <summary>Inserisce l'oggetto <see cref="T:System.Windows.Media.Transform" /> specificato nel contesto del disegno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La trasformazione si applica a tutti i comandi di disegno successivi fino a quando non viene rimosso dal <xref:System.Windows.Media.DrawingContext.Pop%2A> comando.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Questo membro supporta l'infrastruttura di [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e non deve essere usato direttamente dal codice.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyApiNonstructuralChange">
      <MemberSignature Language="C#" Value="protected virtual void VerifyApiNonstructuralChange ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void VerifyApiNonstructuralChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.DrawingContext.VerifyApiNonstructuralChange" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub VerifyApiNonstructuralChange ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void VerifyApiNonstructuralChange();" />
      <MemberSignature Language="F#" Value="abstract member VerifyApiNonstructuralChange : unit -&gt; unit&#xA;override this.VerifyApiNonstructuralChange : unit -&gt; unit" Usage="drawingContext.VerifyApiNonstructuralChange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Questo membro supporta l'infrastruttura di [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] e non deve essere usato direttamente dal codice.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>