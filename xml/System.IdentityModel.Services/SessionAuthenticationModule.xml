<Type Name="SessionAuthenticationModule" FullName="System.IdentityModel.Services.SessionAuthenticationModule">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b7d2c3e066c7161e9965fffcf3d748c0a45c666c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30419945" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SessionAuthenticationModule : System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionAuthenticationModule extends System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.SessionAuthenticationModule" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionAuthenticationModule&#xA;Inherits HttpModuleBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionAuthenticationModule : System::IdentityModel::Services::HttpModuleBase" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Services.HttpModuleBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implementa un modulo ASP.NET che elabora i cookie di sessione in scenari di WS-Federation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando è presente nella pipeline ASP.NET, il <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) elabora i cookie di sessione in scenari di WS-Federation. Viene utilizzato il gestore del cookie specificato per il <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> proprietà per leggere il cookie di sessione non elaborato della richiesta HTTP e scriverlo nella risposta HTTP. Usa il <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> che è configurato per un'applicazione deserializzare il cookie di sessione non elaborato in <xref:System.IdentityModel.Tokens.SessionSecurityToken> oggetti. Il token di sicurezza di sessione contiene le attestazioni (<xref:System.Security.Claims.Claim>) e dell'entità (<xref:System.Security.Claims.ClaimsPrincipal>) associato all'entità per cui viene gestita la richiesta.  
  
 Aggiunge il modulo SAM relativo <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> gestore eventi per il <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> eventi nella pipeline ASP.NET. Questo gestore intercetta le richieste di accesso e, se è presente un cookie di sessione, deserializza in un token di sessione e imposta il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> e <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> proprietà per l'entità delle attestazioni contenute nel token di sessione. Viene richiamato, molti dei metodi esposti dal servizio di gestione durante questo processo.  
  
 Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo può essere richiamato per eseguire l'accesso l'utente da una sessione (ad esempio, in un file code-behind SignOut.aspx.cs).  
  
 Il modulo SAM espone diversi eventi che forniscono l'accesso per la pipeline di elaborazione. Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> e <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> eventi consentono di modificare i token di sessione che vengono lette dal cookie o creati durante l'elaborazione. Questa operazione viene eseguita in genere, per aggiungere, rimuovere o trasformare le attestazioni nel token oppure per regolare l'ora di scadenza. Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut>, e <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> eventi forniscono hook nell'elaborazione di richieste di disconnessione. Per molti scenari, semplicemente l'aggiunta di gestori per questi eventi, frequenza con cui il file global.asax.cs, sarà sufficiente.  
  
 Per scenari più complessi, è possibile derivare da <xref:System.IdentityModel.Services.SessionAuthenticationModule> per implementare una SAM personalizzata. A tal fine, molti dei metodi che vengono richiamati durante <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> e <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> vengono esposte in modo che è possibile fornire un comportamento personalizzato in specifiche fasi del ciclo di vita di elaborazione della sessione.  
  
 È possibile aggiungere il modulo SAM nella pipeline ASP.NET in un file di configurazione, aggiungerlo ai moduli HTTP sotto il `<system.webServer>` elemento IIS versione 7 e versioni successive o sotto il `<system.web>` elemento per le versioni precedenti di IIS 7. Il gestore di cookie usato dal servizio di gestione può essere configurato con il [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento.  
  
   
  
## Examples  
 [!code-csharp[WifSAM#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#1)]  
  
 Il codice XML seguente viene illustrato come configurare il modulo SAM nella pipeline ASP.NET. Molti altri elementi presenti in una configurazione tipica vengono omessi qui per ragioni di brevità.  
  
```xml  
<configuration>  
  <system.webServer>  
    <modules>  
      <!--WIF 4.5 modules -->  
      <add name="SessionAuthenticationModule" type="System.IdentityModel.Services.SessionAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
      <add name="WsFederationAuthenticationModule" type="System.IdentityModel.Services.WSFederationAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
  </system.webServer>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionAuthenticationModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionAuthenticationModule();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.IdentityModel.Services.SessionAuthenticationModule" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> è impostata su `false` e <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> proprietà viene inizializzata su un'istanza predefinita del <xref:System.IdentityModel.Services.CookieHandlerElement.ChunkedCookieHandler%2A> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateSessionSecurityToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateSessionSecurityToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken(System.IdentityModel.Tokens.SessionSecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateSessionSecurityToken (sessionToken As SessionSecurityToken, writeCookie As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateSessionSecurityToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken, bool writeCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="writeCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Token di sicurezza della sessione da utilizzare per autenticare la richiesta HTTP in ingresso.</param>
        <param name="writeCookie">
          <see langword="true" /> per scrivere il cookie di sessione; in caso contrario, <see langword="false" />.</param>
        <summary>Autentica la richiesta in entrata convalidando il token di sessione in ingresso. Dopo aver completato correttamente la convalida, il contesto HTTP corrente e l'entità del thread vengono aggiornati con l'elemento <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> metodo viene chiamato dal <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> metodo. Chiama il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken%2A> metodo per convalidare il token in ingresso e l'aggiornamento di <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> e <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> proprietà. Se il `writeCookie` parametro `true`, <xref:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie%2A> metodo viene richiamato per scrivere il token di sessione in un cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSessionTokenCookie">
      <MemberSignature Language="C#" Value="public bool ContainsSessionTokenCookie (System.Web.HttpCookieCollection httpCookieCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsSessionTokenCookie(class System.Web.HttpCookieCollection httpCookieCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ContainsSessionTokenCookie(System.Web.HttpCookieCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsSessionTokenCookie(System::Web::HttpCookieCollection ^ httpCookieCollection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpCookieCollection" Type="System.Web.HttpCookieCollection" />
      </Parameters>
      <Docs>
        <param name="httpCookieCollection">Raccolta di cookie in cui cercare.</param>
        <summary>Determina se un cookie di sessione è presente nella raccolta di cookie specificata.</summary>
        <returns>
          <see langword="true" /> se viene rilevato un cookie di sessione; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="httpCookieCollection" /> è null</exception>
      </Docs>
    </Member>
    <Member MemberName="ContextSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.ContextSessionSecurityToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContextSessionSecurityToken As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IdentityModel::Tokens::SessionSecurityToken ^ ContextSessionSecurityToken { System::IdentityModel::Tokens::SessionSecurityToken ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'oggetto <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> attivo per l'oggetto <see cref="T:System.Web.HttpContext" /> corrente.</summary>
        <value>Token di sicurezza della sessione attiva.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieHandler">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Services.CookieHandler CookieHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Services.CookieHandler CookieHandler" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property CookieHandler As CookieHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Services::CookieHandler ^ CookieHandler { System::IdentityModel::Services::CookieHandler ^ get(); void set(System::IdentityModel::Services::CookieHandler ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Services.CookieHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il gestore di cookie utilizzato per leggere, scrivere ed eliminare i cookie di sessione.</summary>
        <value>Gestore di cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> proprietà viene inizializzata dal <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration%2A> metodo. Questo metodo inizializza la proprietà in base al gestore del cookie specificato nel <xref:System.IdentityModel.Services.Configuration.FederationConfiguration> oggetto impostato sul <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> proprietà. È possibile impostare il gestore di cookie in un file di configurazione tramite il [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, valuetype System.DateTime validFrom, valuetype System.DateTime validTo, bool isPersistent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.DateTime,System.DateTime,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, validFrom As DateTime, validTo As DateTime, isPersistent As Boolean) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
        <Parameter Name="isPersistent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="principal">Entità da acquisire nel token.</param>
        <param name="context">Stringa di contesto definita dall'applicazione.</param>
        <param name="validFrom">L'indicazione del momento a partire dal quale il token è valido.</param>
        <param name="validTo">L'indicazione del momento di fine di validità del token.</param>
        <param name="isPersistent">
          <see langword="true" /> se il valore deve essere mantenuto dall'agente utente; in caso contrario, <see langword="false" />.</param>
        <summary>Crea <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> dai parametri specificati tramite il gestore token di sessione configurato.</summary>
        <returns>Token della sessione.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Non c'è un gestore del token di sessione valido configurato. (Nessun <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurato nella proprietà <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteSessionTokenCookie">
      <MemberSignature Language="C#" Value="public void DeleteSessionTokenCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSessionTokenCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSessionTokenCookie ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSessionTokenCookie();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina il cookie di sessione e lo rimuove dalla cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elimina il cookie di sessione utilizzando il gestore del cookie specificato per il <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> proprietà. Questo metodo viene chiamato durante la disconnessione dal <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeModule">
      <MemberSignature Language="C#" Value="protected override void InitializeModule (System.Web.HttpApplication context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializeModule(class System.Web.HttpApplication context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule(System.Web.HttpApplication)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InitializeModule (context As HttpApplication)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InitializeModule(System::Web::HttpApplication ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpApplication" />
      </Parameters>
      <Docs>
        <param name="context">Applicazione HTTP che contiene il modulo.</param>
        <summary>Inizializza il modulo e lo prepara alla gestione di eventi dal relativo oggetto applicazione di [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] del modulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aggiunge il <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> e <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A> gestori per il <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> e <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> eventi dell'oggetto applicazione specificata dal `context` parametro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializePropertiesFromConfiguration">
      <MemberSignature Language="C#" Value="protected override void InitializePropertiesFromConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializePropertiesFromConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InitializePropertiesFromConfiguration ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InitializePropertiesFromConfiguration();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inizializza le proprietà del modulo in base alle definizioni presenti nel file di configurazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inizializza il <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> proprietà da parte del gestore specificato nella configurazione per il <xref:System.IdentityModel.Services.Configuration.FederationConfiguration?displayProperty=nameWithType> oggetto impostato sul <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> proprietà. È possibile specificare il gestore di cookie in un file di configurazione tramite il [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceMode">
      <MemberSignature Language="C#" Value="public bool IsReferenceMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReferenceMode" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReferenceMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReferenceMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che specifica se le informazioni sulla sessione (i valori di attestazione e così via) devono essere archiviate in un cookie di sessione o se il contenuto della sessione deve essere memorizzato sul lato server, utilizzando il cookie per archiviare solo un riferimento.</summary>
        <value>
          <see langword="true" /> se i cookie rilasciati sono in modalità di riferimento; in caso contrario, <see langword="false" />. L'impostazione predefinita è <see langword="false" /> che specifica che i cookie emessi non sono in modalità di riferimento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In modalità di riferimento, il <xref:System.IdentityModel.Tokens.SessionSecurityToken> viene archiviato in una cache sul lato server (un oggetto che deriva da <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>). Il cookie emesso contiene solo un identificatore di contesto che viene utilizzato per recuperare il token dalla cache.  
  
> [!IMPORTANT]
>  Per funzionare in modalità di riferimento, Microsoft consiglia di fornire un gestore per il <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated?displayProperty=nameWithType> evento nel file global.asax.cs e impostazione di <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> proprietà il token passato nel <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> proprietà. Questo garantisce che il token di sessione viene eseguita in modalità di riferimento per ogni richiesta ed è preferibile all'impostazione semplicemente il <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A?displayProperty=nameWithType> proprietà del modulo di autenticazione della sessione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthenticateRequest (object sender, EventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthenticateRequest(object sender, class System.EventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthenticateRequest(System::Object ^ sender, EventArgs ^ eventArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Origine dell'evento. Deve essere un oggetto <see cref="T:System.Web.HttpApplication" />.</param>
        <param name="eventArgs">Dati per l'evento.</param>
        <summary>Gestisce l'evento <see cref="E:System.Web.HttpApplication.AuthenticateRequest" /> dalla pipeline [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo effettua le operazioni seguenti:  
  
1.  Richiama il <xref:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie%2A> metodo per leggere un <xref:System.IdentityModel.Tokens.SessionSecurityToken> dal cookie di sessione, se presente.  
  
2.  Se una sessione non può essere token di sicurezza (probabilmente perché non è stata stabilita una sessione), lettura restituito.  
  
3.  Richiama il <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived%2A> metodo per generare il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento. Ciò fornisce una possibilità per il token letto dal cookie da modificare o per la richiesta deve essere annullato. Il gestore può inoltre specificare che il token deve essere riemesso, impostando il <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> proprietà.  
  
4.  Se il token deve essere riemesso, rimuoverlo dalla cache e richiama il <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated%2A> metodo per generare il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> evento. Questo offre l'opportunità per il token nuovo da modificare. Il comportamento di eseguire nuovamente può anche essere modificato impostando la <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> proprietà nel gestore eventi.  
  
5.  Richiama il <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> metodo di autenticazione dell'utente. Se ha esito positivo, questo ha l'effetto dell'impostazione di <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> proprietà per l'entità che è contenuto nel <xref:System.IdentityModel.Tokens.SessionSecurityToken.ClaimsPrincipal%2A?displayProperty=nameWithType> proprietà del token in ingresso.  
  
6.  Se la sessione è scaduta, richiama il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo.  
  
 Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> metodo viene aggiunto per i gestori per il <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> evento nel <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Non c'è un gestore del token di sessione valido configurato. (Nessun <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurato nella proprietà <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPostAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnPostAuthenticateRequest (object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPostAuthenticateRequest(object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPostAuthenticateRequest (sender As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPostAuthenticateRequest(System::Object ^ sender, EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Origine dell'evento. Deve essere un oggetto <see cref="T:System.Web.HttpApplication" />.</param>
        <param name="e">Dati per l'evento.</param>
        <summary>Gestisce l'evento <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> dalla pipeline [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'implementazione predefinita è vuota.  
  
 Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A> gestore viene aggiunto per i gestori per il <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> evento nel <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenCreated (System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenCreated(class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated(System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionSecurityTokenCreated (args As SessionSecurityTokenCreatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionSecurityTokenCreated(System::IdentityModel::Services::SessionSecurityTokenCreatedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Dati per l'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamato dal <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenReceived (System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenReceived(class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived(System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionSecurityTokenReceived (args As SessionSecurityTokenReceivedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionSecurityTokenReceived(System::IdentityModel::Services::SessionSecurityTokenReceivedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Dati per l'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamato dal <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignedOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSignedOut (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignedOut(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSignedOut (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSignedOut(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene richiamato il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo dopo la disconnessione è stata eseguita e il cookie di sessione è stato eliminato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSigningOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSigningOut (System.IdentityModel.Services.SigningOutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSigningOut(class System.IdentityModel.Services.SigningOutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut(System.IdentityModel.Services.SigningOutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSigningOut (e As SigningOutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSigningOut(System::IdentityModel::Services::SigningOutEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.SigningOutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene richiamato il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo per eseguire una disconnessione. Viene richiamato prima che venga eliminato il cookie di sessione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignOutError">
      <MemberSignature Language="C#" Value="protected virtual void OnSignOutError (System.IdentityModel.Services.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignOutError(class System.IdentityModel.Services.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError(System.IdentityModel.Services.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSignOutError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSignOutError(System::IdentityModel::Services::ErrorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Dati per l'evento.</param>
        <summary>Genera l'evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene richiamato il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo se si verifica un errore durante la disconnessione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie (byte[] sessionCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie(unsigned int8[] sessionCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSessionTokenFromCookie (sessionCookie As Byte()) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SessionSecurityToken ^ ReadSessionTokenFromCookie(cli::array &lt;System::Byte&gt; ^ sessionCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionCookie" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="sessionCookie">Il cookie, in formato non elaborato, che contiene il token della sessione.</param>
        <summary>Legge un oggetto <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> dal cookie di sessione specificato.</summary>
        <returns>Token della sessione letto dal cookie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Non c'è un gestore del token di sessione valido configurato. (Nessun <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurato nella proprietà <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />
      <MemberSignature Language="VB.NET" Value="Public Event SessionSecurityTokenCreated As EventHandler(Of SessionSecurityTokenCreatedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SessionSecurityTokenCreatedEventArgs ^&gt; ^ SessionSecurityTokenCreated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando viene creato un token di sicurezza della sessione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile utilizzare questo evento per modificare il token di sicurezza della sessione prima che venga scritto in un cookie.  
  
 Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> evento viene generato dall'interno di <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> metodo dopo un token di sessione (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) è stato creato. Ciò si verifica, ad esempio, se un gestore eventi per il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento modifica il token.  
  
 È possibile utilizzare questo evento per modificare le proprietà del token di sessione prima di essere passato ulteriore lungo la pipeline e viene usato per autenticare l'entità che effettua la richiesta (utente).  
  
 In un gestore eventi, è possibile accedere il token tramite il <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> proprietà. Dopo aver modificato il token, è possibile assicurarsi che si è scritti nuovamente nel cookie impostando il <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> proprietà `true`. A differenza di, il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> evento <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> non è un evento annullabile.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato un gestore per il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> evento implementato nel file global.asax.cs di un'applicazione web ASP.NET. È inoltre necessario aggiungere il gestore per l'evento. Cui è riportato un esempio più completo di <xref:System.IdentityModel.Services.SessionAuthenticationModule> argomento introduttivo.  
  
 [!code-csharp[WifSAM#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />
      <MemberSignature Language="VB.NET" Value="Public Event SessionSecurityTokenReceived As EventHandler(Of SessionSecurityTokenReceivedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SessionSecurityTokenReceivedEventArgs ^&gt; ^ SessionSecurityTokenReceived;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando un token di sicurezza della sessione è stato letto da un cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento viene generato dall'interno di <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> metodo dopo un token di sessione (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) è stato letto dal cookie di sessione.  
  
 È possibile utilizzare questo evento per modificare le proprietà del token di sessione prima di essere passato ulteriore lungo la pipeline e viene usato per autenticare l'entità che effettua la richiesta (utente). Uno degli scenari più comuni modificandone l'ora di scadenza della sessione (accessibile tramite il <xref:System.IdentityModel.Tokens.SessionSecurityToken.ValidTo%2A?displayProperty=nameWithType> proprietà) per eseguire l'override l'ora di scadenza della sessione impostato nella configurazione tramite il `lifetime` attributo del [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) elemento. Modificando questa proprietà per ogni richiesta, è possibile implementare una sessione di scorrimento. una sessione in cui la durata viene esteso ogni ora, ovvero gli accessi utente del sito.  
  
 In un gestore eventi, è possibile accedere il token tramite il <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.SessionToken%2A?displayProperty=nameWithType> proprietà. Dopo aver modificato il token, è possibile assicurarsi che si è scritti nuovamente nel cookie impostando il <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> a `true`. Infine, il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> tratta di un evento annullabile, e che è possibile impostare il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs> per interrompere un'ulteriore elaborazione della richiesta.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato un gestore per il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento implementato nel file global.asax.cs di un'applicazione web ASP.NET. È inoltre necessario aggiungere il gestore per l'evento. Cui è riportato un esempio più completo di <xref:System.IdentityModel.Services.SessionAuthenticationModule> argomento introduttivo.  
  
 [!code-csharp[WifSAM#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalFromSessionToken">
      <MemberSignature Language="C#" Value="protected virtual void SetPrincipalFromSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetPrincipalFromSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetPrincipalFromSessionToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionSecurityToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">Token della sessione da cui impostare l'entità.</param>
        <summary>Imposta l'entità su <see cref="T:System.Web.HttpContext" /> e su <see cref="T:System.Threading.Thread" /> sull'entità contenuta nel token di sessione specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Richiama il <xref:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken%2A> (metodo) e imposta il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> proprietà e <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> proprietà <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> usando le identità che vengono restituite.  
  
 Questo metodo viene chiamato dal <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignedOut">
      <MemberSignature Language="C#" Value="public event EventHandler SignedOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SignedOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />
      <MemberSignature Language="VB.NET" Value="Public Event SignedOut As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SignedOut;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica dopo la disconnessione dell'utente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generato dal <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo subito dopo il <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> metodo viene richiamato.  
  
 Questo evento non deve necessariamente essere chiamato per ogni sessione. Ad esempio, possono eliminare i cookie sul lato client, in questo caso, questo evento non verrà mai generato perché non vi è alcun evento sul lato server per l'eliminazione della sessione.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato un gestore per il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut> evento implementato nel file global.asax.cs di un'applicazione web ASP.NET. È inoltre necessario aggiungere il gestore per l'evento. Cui è riportato un esempio più completo di <xref:System.IdentityModel.Services.SessionAuthenticationModule> argomento introduttivo.  
  
 [!code-csharp[WifSAM#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SigningOut">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />
      <MemberSignature Language="VB.NET" Value="Public Event SigningOut As EventHandler(Of SigningOutEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SigningOutEventArgs ^&gt; ^ SigningOut;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica prima dell'eliminazione della sessione di accesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generato dal <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo appena prima di <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> metodo viene richiamato.  
  
 Questo evento non deve necessariamente essere chiamato per ogni sessione. Ad esempio, possono eliminare i cookie sul lato client, in questo caso, questo evento non verrà mai generato perché non vi è alcun evento sul lato server per l'eliminazione della sessione.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato un gestore per il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut> evento implementato nel file global.asax.cs di un'applicazione web ASP.NET. È inoltre necessario aggiungere il gestore per l'evento. Cui è riportato un esempio più completo di <xref:System.IdentityModel.Services.SessionAuthenticationModule> argomento introduttivo.  
  
 [!code-csharp[WifSAM#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOut">
      <MemberSignature Language="C#" Value="public virtual void SignOut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SignOut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SignOut" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SignOut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SignOut();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esegue l'uscita dell'utente corrente e genera gli eventi associati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Richiama il <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut%2A>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A>, e <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut%2A> metodi per eseguire una disconnessione. Se si verifica un'eccezione, il <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError%2A> metodo viene richiamato per generare il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> evento. È possibile impostare il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.IdentityModel.Services.ErrorEventArgs> oggetto passato nel gestore eventi per questo evento per annullare il processo di disconnessione e impedire che l'eccezione viene propagata al client.  
  
 È possibile eseguire l'override di questo metodo per aggiungere un comportamento specifico dell'applicazione.  
  
   
  
## Examples  
 Il codice seguente mostra il codice per richiamare il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo da una pagina SignOut (SignOut.aspx.cs) in un'applicazione web ASP.NET. Cui è riportato un esempio più completo di <xref:System.IdentityModel.Services.SessionAuthenticationModule> argomento introduttivo.  
  
 [!code-csharp[WifSAM#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOutError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />
      <MemberSignature Language="VB.NET" Value="Public Event SignOutError As EventHandler(Of ErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::ErrorEventArgs ^&gt; ^ SignOutError;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Si verifica quando è presente un errore durante la disconnessione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generato il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> metodo quando si verifica un errore durante la disconnessione.  
  
 In un gestore eventi, è possibile ottenere l'eccezione che ha generato nell'evento viene generato il <xref:System.IdentityModel.Services.ErrorEventArgs.Exception%2A?displayProperty=nameWithType> proprietà. È possibile annullare un'ulteriore elaborazione dell'eccezione, che è il risultato di non propagare l'eccezione al client, impostando il <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> proprietà del <xref:System.IdentityModel.Services.ErrorEventArgs> a `true`.  
  
 Questo evento non deve necessariamente essere chiamato per ogni sessione. Ad esempio, possono eliminare i cookie sul lato client, in questo caso, questo evento non verrà mai generato perché non vi è alcun evento sul lato server per l'eliminazione della sessione.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato un gestore per il <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> evento implementato nel file global.asax.cs di un'applicazione web ASP.NET. È inoltre necessario aggiungere il gestore per l'evento. Cui è riportato un esempio più completo di <xref:System.IdentityModel.Services.SessionAuthenticationModule> argomento introduttivo.  
  
 [!code-csharp[WifSAM#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public bool TryReadSessionTokenFromCookie (out System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadSessionTokenFromCookie([out] class System.IdentityModel.Tokens.SessionSecurityToken&amp; sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadSessionTokenFromCookie (ByRef sessionToken As SessionSecurityToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReadSessionTokenFromCookie([Runtime::InteropServices::Out] System::IdentityModel::Tokens::SessionSecurityToken ^ % sessionToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Quando in questo metodo viene eseguita la restituzione, contiene il token di sicurezza della sessione letto dal cookie di sessione.</param>
        <summary>Tenta di leggere un <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> da un cookie di sessione e restituisce un valore che indica se il cookie di sessione è stato letto correttamente.</summary>
        <returns>
          <see langword="true" /> se il cookie di sessione è stato correttamente letto dalla richiesta; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legge il cookie utilizzando il gestore di cookie che è configurato nel <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> proprietà e quindi richiama il <xref:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie%2A> metodo da cui leggere il token del cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSessionToken">
      <MemberSignature Language="C#" Value="protected System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateSessionToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionSecurityToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">Token da convalidare.</param>
        <summary>Convalida <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> specificato e ne restituisce le identità.</summary>
        <returns>La raccolta di identità che sono contenute nel token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato dal <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> metodo. Richiama il <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A?displayProperty=nameWithType> metodo del gestore del token di sessione configurata per convalidare il token ed estrarre le identità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Services.FederatedSessionExpiredException">Il token è scaduto.</exception>
        <exception cref="T:System.IdentityModel.Services.FederationException">L'ora di inizio del token non è ancora valida.</exception>
        <exception cref="T:System.InvalidOperationException">Non c'è un gestore del token di sessione valido configurato. (Nessun <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurato nella proprietà <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSessionTokenToCookie">
      <MemberSignature Language="C#" Value="public void WriteSessionTokenToCookie (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSessionTokenToCookie(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSessionTokenToCookie (sessionToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSessionTokenToCookie(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Token di sicurezza della sessione da scrivere.</param>
        <summary>Scrive il <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> specificato in un cookie di sessione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scrive il cookie utilizzando il gestore di cookie che è configurato nel <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sessionToken" /> è <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Non c'è un gestore del token di sessione valido configurato. (Nessun <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurato nella proprietà <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
  </Members>
</Type>