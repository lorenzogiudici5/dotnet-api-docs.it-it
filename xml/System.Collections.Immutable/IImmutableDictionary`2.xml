<Type Name="IImmutableDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8085dab8492bb4dd94ba1b97795b259e9c2c6ec7" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36712379" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IImmutableDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IImmutableDictionary`2&lt;TKey, TValue&gt; implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Immutable.IImmutableDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Interface IImmutableDictionary(Of TKey, TValue)&#xA;Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public interface class IImmutableDictionary : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;" />
  <TypeSignature Language="F#" Value="type IImmutableDictionary&lt;'Key, 'Value&gt; = interface&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Immutable</AssemblyName>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
    <AssemblyVersion>1.2.1.0</AssemblyVersion>
    <AssemblyVersion>1.2.2.0</AssemblyVersion>
    <AssemblyVersion>1.2.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TKey">Tipo delle chiavi nel dizionario.</typeparam>
    <typeparam name="TValue">Tipo dei valori nel dizionario.</typeparam>
    <summary>Represents an immutable collection of key/value pairs.  **NuGet package**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#Remarks">about immutable collections and how to install</see>)</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Collections.Immutable.IImmutableDictionary%602> richiede un'implementazione di operatore di confronto di uguaglianza per determinare se due chiavi sono uguali.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableDictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (key As TKey, value As TValue) As IImmutableDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; System.Collections.Immutable.IImmutableDictionary&lt;'Key, 'Value&gt;" Usage="iImmutableDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">The key of the element to add.</param>
        <param name="value">The value of the element to add.</param>
        <summary>Adds an element with the specified key and value to the dictionary.</summary>
        <returns>A new immutable dictionary that contains the additional key/value pair.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la coppia chiave/valore specificata esiste giÃ  nel dizionario, questo metodo restituisce l'istanza esistente del dizionario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The given key already exists in the dictionary but has a different value.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; AddRange (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; pairs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; AddRange(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; pairs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableDictionary`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddRange (pairs As IEnumerable(Of KeyValuePair(Of TKey, TValue))) As IImmutableDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ AddRange(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ pairs);" />
      <MemberSignature Language="F#" Value="abstract member AddRange : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; -&gt; System.Collections.Immutable.IImmutableDictionary&lt;'Key, 'Value&gt;" Usage="iImmutableDictionary.AddRange pairs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="pairs">The key/value pairs to add.</param>
        <summary>Adds the specified key/value pairs to the dictionary.</summary>
        <returns>A new immutable dictionary that contains the additional key/value pairs.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">One of the given keys already exists in the dictionary but has a different value.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableDictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As IImmutableDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; System.Collections.Immutable.IImmutableDictionary&lt;'Key, 'Value&gt;" Usage="iImmutableDictionary.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an empty dictionary that has the same ordering and key/value comparison rules as this dictionary instance.</summary>
        <returns>An empty dictionary with equivalent ordering and key/value comparison rules.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; pair);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; pair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (pair As KeyValuePair(Of TKey, TValue)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; pair);" />
      <MemberSignature Language="F#" Value="abstract member Contains : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt; -&gt; bool" Usage="iImmutableDictionary.Contains pair" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="pair">The key/value pair to locate.</param>
        <summary>Determines whether the immutable dictionary contains the specified key/value pair.</summary>
        <returns>
          <see langword="true" /> if the specified key/value pair is found in the dictionary; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableDictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As IImmutableDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; System.Collections.Immutable.IImmutableDictionary&lt;'Key, 'Value&gt;" Usage="iImmutableDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">The key of the element to remove.</param>
        <summary>Removes the element with the specified key from the immutable dictionary.</summary>
        <returns>A new immutable dictionary with the specified element removed; or this instance if the specified key cannot be found in the dictionary.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; RemoveRange (System.Collections.Generic.IEnumerable&lt;TKey&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; RemoveRange(class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableDictionary`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveRange (keys As IEnumerable(Of TKey)) As IImmutableDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ RemoveRange(System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member RemoveRange : seq&lt;'Key&gt; -&gt; System.Collections.Immutable.IImmutableDictionary&lt;'Key, 'Value&gt;" Usage="iImmutableDictionary.RemoveRange keys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">The keys of the elements to remove.</param>
        <summary>Removes the elements with the specified keys from the immutable dictionary.</summary>
        <returns>A new immutable dictionary with the specified keys removed; or this instance if the specified keys cannot be found in the dictionary.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; SetItem (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; SetItem(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableDictionary`2.SetItem(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetItem (key As TKey, value As TValue) As IImmutableDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ SetItem(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member SetItem : 'Key * 'Value -&gt; System.Collections.Immutable.IImmutableDictionary&lt;'Key, 'Value&gt;" Usage="iImmutableDictionary.SetItem (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">The key of the entry to add.</param>
        <param name="value">The key value to set.</param>
        <summary>Sets the specified key and value in the immutable dictionary, possibly overwriting an existing value for the key.</summary>
        <returns>A new immutable dictionary that contains the specified key/value pair.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se la coppia chiave/valore specificata esiste giÃ  nel dizionario, questo metodo restituisce l'istanza esistente. Se la chiave esiste giÃ  ma ha un valore diverso, questo metodo restituisce una nuova istanza del dizionario con il valore sovrascritto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItems">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt; SetItems (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableDictionary`2&lt;!TKey, !TValue&gt; SetItems(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableDictionary`2.SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetItems (items As IEnumerable(Of KeyValuePair(Of TKey, TValue))) As IImmutableDictionary(Of TKey, TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableDictionary&lt;TKey, TValue&gt; ^ SetItems(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ items);" />
      <MemberSignature Language="F#" Value="abstract member SetItems : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; -&gt; System.Collections.Immutable.IImmutableDictionary&lt;'Key, 'Value&gt;" Usage="iImmutableDictionary.SetItems items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="items">The key/value pairs to set in the dictionary. If any of the keys already exist in the dictionary, this method will overwrite their previous values.</param>
        <summary>Sets the specified key/value pairs in the immutable dictionary, possibly overwriting existing values for the keys.</summary>
        <returns>A new immutable dictionary that contains the specified key/value pairs.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetKey">
      <MemberSignature Language="C#" Value="public bool TryGetKey (TKey equalKey, out TKey actualKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetKey(!TKey equalKey, [out] !TKey&amp; actualKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableDictionary`2.TryGetKey(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetKey (equalKey As TKey, ByRef actualKey As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetKey(TKey equalKey, [Runtime::InteropServices::Out] TKey % actualKey);" />
      <MemberSignature Language="F#" Value="abstract member TryGetKey : 'Key *  -&gt; bool" Usage="iImmutableDictionary.TryGetKey (equalKey, actualKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalKey" Type="TKey" />
        <Parameter Name="actualKey" Type="TKey&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalKey">The key to search for.</param>
        <param name="actualKey">The matching key located in the dictionary if found, or <c>equalkey</c> if no match is found.</param>
        <summary>Determines whether this dictionary contains a specified key.</summary>
        <returns>
          <see langword="true" /> if a match for <paramref name="equalKey" /> is found; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ecco alcuni scenari in cui <xref:System.Collections.Immutable.IImmutableDictionary%602.TryGetKey%2A> possono risultare utili:  
  
-   Si desidera riutilizzare un riferimento all'oggetto archiviato in precedenza anzichÃ© creare un nuovo riferimento.  
  
-   Si desidera cercare il valore canonico di un oggetto  
  
-   Si desidera recuperare i dati piÃ¹ completi su un oggetto  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>