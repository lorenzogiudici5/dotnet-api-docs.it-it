<Type Name="IListContract&lt;T&gt;" FullName="System.AddIn.Contract.IListContract&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b2513a6cab6839b3b17032eea88926b5b0951e44" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51923197" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IListContract&lt;T&gt; : System.AddIn.Contract.IContract" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IListContract`1&lt;T&gt; implements class System.AddIn.Contract.IContract" />
  <TypeSignature Language="DocId" Value="T:System.AddIn.Contract.IListContract`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface IListContract(Of T)&#xA;Implements IContract" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public interface class IListContract : System::AddIn::Contract::IContract" />
  <TypeSignature Language="F#" Value="type IListContract&lt;'T&gt; = interface&#xA;    interface IContract" />
  <AssemblyInfo>
    <AssemblyName>System.AddIn.Contract</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.AddIn.Contract.IContract</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T">Tipo di contratto degli oggetti nell'elenco.</typeparam>
    <summary>Rappresenta un elenco generico di tipi che vengono definiti da un contratto e che vengono utilizzati per passare insiemi di tale tipo di contratto tra un host e un componente aggiuntivo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AddIn.Pipeline.CollectionAdapters> classe Usa un <xref:System.AddIn.Contract.IListContract%601> interfaccia passare raccolte, in entrambe le direzioni, tra l'host e il componente aggiuntivo. È consigliabile usare il <xref:System.AddIn.Pipeline.CollectionAdapters> classe invece di usare questa classe direttamente nel codice. Per un esempio, vedere [procedura dettagliata: passaggio di raccolte tra host e Add-Ins](https://msdn.microsoft.com/library/b532c604-548e-4fab-b11c-377257dd0ee5).  
  
 Questa classe è utilizzabile per passare oggetti mediante riferimenti tra i domini applicazione perché non vengono serializzati gli oggetti.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit" Usage="iListContract.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da aggiungere.</param>
        <summary>Aggiunge un oggetto a un insieme <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `item` parametro deve essere di un tipo definito dal contratto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit" Usage="iListContract.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rimuove tutti gli oggetti da un insieme <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool" Usage="iListContract.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Oggetto da cercare nell'insieme.</param>
        <summary>Determina se un elemento specifico è contenuto in un insieme <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <returns>È <see langword="true" /> se <paramref name="item" /> si trova nella raccolta. In caso contrario è <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public int GetCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.GetCount" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCount () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCount();" />
      <MemberSignature Language="F#" Value="abstract member GetCount : unit -&gt; int" Usage="iListContract.GetCount " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene il numero di elementi contenuti in un insieme <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <returns>Numero di elementi nella raccolta.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumeratorContract">
      <MemberSignature Language="C#" Value="public System.AddIn.Contract.IEnumeratorContract&lt;T&gt; GetEnumeratorContract ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.AddIn.Contract.IEnumeratorContract`1&lt;!T&gt; GetEnumeratorContract() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.GetEnumeratorContract" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumeratorContract () As IEnumeratorContract(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::AddIn::Contract::IEnumeratorContract&lt;T&gt; ^ GetEnumeratorContract();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumeratorContract : unit -&gt; System.AddIn.Contract.IEnumeratorContract&lt;'T&gt;" Usage="iListContract.GetEnumeratorContract " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AddIn.Contract.IEnumeratorContract&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Viene restituito un enumeratore che scorre un insieme <see cref="T:System.AddIn.Contract.IListContract`1" />.</summary>
        <returns>Enumeratore <see cref="T:System.AddIn.Contract.IEnumeratorContract`1" /> che scorre l'insieme.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsReadOnly">
      <MemberSignature Language="C#" Value="public bool GetIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.GetIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member GetIsReadOnly : unit -&gt; bool" Usage="iListContract.GetIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se un insieme <see cref="T:System.AddIn.Contract.IListContract`1" /> è in sola lettura.</summary>
        <returns>
          <see langword="true" /> se la raccolta è di sola lettura; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItem">
      <MemberSignature Language="C#" Value="public T GetItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T GetItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.GetItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItem (index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T GetItem(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetItem : int -&gt; 'T" Usage="iListContract.GetItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero dell'elemento da ottenere.</param>
        <summary>Restituisce l'elemento di un insieme <see cref="T:System.AddIn.Contract.IListContract`1" />in corrispondenza dell'indice specificato.</summary>
        <returns>Elemento in corrispondenza dell'indice specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AddIn.Contract.IListContract%601.GetItem%2A> metodo non rimuove l'elemento in corrispondenza dell'indice specificato. Per rimuovere un elemento dal <xref:System.AddIn.Contract.IListContract%601> raccolta, uso il <xref:System.AddIn.Contract.IListContract%601.RemoveAt%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> è maggiore o uguale al valore restituito di <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int" Usage="iListContract.IndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Elemento della raccolta.</param>
        <summary>Restituisce l'indice di un elemento specifico di un insieme <see cref="T:System.AddIn.Contract.Collections.IListContract`1" />.</summary>
        <returns>Indice dell'elemento specificato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se sono presenti più oggetti dello stesso tipo nella raccolta, questo metodo identifica l'indice dell'elemento che è la prima occorrenza del tipo specificato nella raccolta.  
  
 Il <xref:System.AddIn.Contract.IListContract%601.GetItem%2A> metodo non rimuove l'elemento in corrispondenza dell'indice specificato. Per rimuovere un elemento dal <xref:System.AddIn.Contract.IListContract%601> raccolta, uso il <xref:System.AddIn.Contract.IListContract%601.RemoveAt%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> è maggiore o uguale al valore restituito dal metodo <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit" Usage="iListContract.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero in corrispondenza del quale inserire l'oggetto <c>item</c>.</param>
        <param name="item">Oggetto <see cref="T:System.AddIn.Contract.IContract" /> da inserire nell'insieme <see cref="T:System.AddIn.Contract.IListContract`1" />.</param>
        <summary>Inserisce un elemento nell'insieme <see cref="T:System.AddIn.Contract.IListContract`1" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo aver chiamato il <xref:System.AddIn.Contract.IListContract%601.Insert%2A> metodo, spostare gli elementi che seguono il punto di inserimento contenere il nuovo elemento. Gli indici degli elementi che vengono spostati vengono aggiornati. Per sostituire un elemento in corrispondenza dell'indice specificato, usare il <xref:System.AddIn.Contract.IListContract%601.SetItem%2A> (metodo).  
  
 Per determinare se un' <xref:System.AddIn.Contract.IListContract%601> raccolta è di sola lettura, chiamare il <xref:System.AddIn.Contract.IListContract%601.GetIsReadOnly%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> è maggiore o uguale al valore restituito di <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
        <exception cref="T:System.NotSupportedException">L'insieme <see cref="T:System.AddIn.Contract.IListContract`1" /> è in sola lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool" Usage="iListContract.Remove item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Elemento da rimuovere dall'insieme.</param>
        <summary>Rimuove da un insieme <see cref="T:System.AddIn.Contract.IListContract`1" /> un elemento di tipo specificato.</summary>
        <returns>
          <see langword="true" /> se viene rimosso un elemento. In caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario ripetere questo metodo per ogni oggetto di un tipo specifico nella raccolta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit" Usage="iListContract.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indice dell'elemento da rimuovere.</param>
        <summary>Rimuove da un insieme <see cref="T:System.AddIn.Contract.IListContract`1" /> l'elemento in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dopo aver chiamato <xref:System.AddIn.Contract.IListContract%601.RemoveAt%2A>, spostano gli elementi che seguono l'elemento rimosso occupare la posizione rimasta vuota. Gli indici degli elementi che vengono spostati vengono aggiornati.  
  
 Per determinare se un' <xref:System.AddIn.Contract.IListContract%601> raccolta è di sola lettura, chiamare il <xref:System.AddIn.Contract.IListContract%601.GetIsReadOnly%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> è maggiore o uguale al valore restituito dal metodo <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
        <exception cref="T:System.NotSupportedException">L'insieme <see cref="T:System.AddIn.Contract.IListContract`1" /> è in sola lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="public void SetItem (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetItem(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Contract.IListContract`1.SetItem(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetItem (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetItem(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member SetItem : int * 'T -&gt; unit" Usage="iListContract.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn.Contract</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Indice in base zero in corrispondenza del quale impostare l'elemento.</param>
        <param name="item">Elemento da impostare in corrispondenza dell'indice specificato.</param>
        <summary>Imposta l'elemento di un insieme <see cref="T:System.AddIn.Contract.IListContract`1" /> in corrispondenza dell'indice specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.AddIn.Contract.IListContract%601.SetItem%2A> metodo imposta l'elemento in corrispondenza dell'indice specificato. Per aggiungere un elemento per il <xref:System.AddIn.Contract.IListContract%601> raccolta, uso il <xref:System.AddIn.Contract.IListContract%601.Insert%2A> (metodo).  
  
 Per determinare se un' <xref:System.AddIn.Contract.IListContract%601> raccolta è di sola lettura, chiamare il <xref:System.AddIn.Contract.IListContract%601.GetIsReadOnly%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> è minore di zero.  
  
oppure 
 <paramref name="index" /> è maggiore o uguale al valore restituito dal metodo <see cref="M:System.AddIn.Contract.IListContract`1.GetCount" />.</exception>
        <exception cref="T:System.NotSupportedException">L'insieme <see cref="T:System.AddIn.Contract.IListContract`1" /> è in sola lettura.</exception>
      </Docs>
    </Member>
  </Members>
</Type>