<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9f9c9e42dff8e89feb11010c57e7d17bc9b44648" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48675434" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="8e443-101">Fornisce un pool di thread che può essere usato per eseguire attività, inviare elementi di lavoro, elaborare operazioni di I/O asincrone, attendere per conto di altri thread ed elaborare timer.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8e443-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-102">Molte applicazioni creano thread che spendono una notevole quantità di tempo nello stato inattivo, in attesa di un evento si verifichi.</span><span class="sxs-lookup"><span data-stu-id="8e443-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="8e443-103">Altri thread potrebbero entrare in uno stato di solo a essere riattivati periodicamente per eseguire il polling di una modifica o aggiornare le informazioni sullo stato.</span><span class="sxs-lookup"><span data-stu-id="8e443-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="8e443-104">Il pool di thread consente di usare i thread in modo più efficiente fornendo all'applicazione con un pool di thread di lavoro gestiti dal sistema.</span><span class="sxs-lookup"><span data-stu-id="8e443-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="8e443-105">Esempi di operazioni che usano i pool di thread includono quanto segue:</span><span class="sxs-lookup"><span data-stu-id="8e443-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="8e443-106">Quando si crea una <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> oggetto effettui alcune attività in modo asincrono, per impostazione predefinita l'attività viene pianificata per l'esecuzione in un pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="8e443-107">Timer asincroni usano il pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="8e443-108">Eseguire le richiamate dal pool di thread di <xref:System.Threading.Timer?displayProperty=nameWithType> classi e generare eventi dal <xref:System.Timers.Timer?displayProperty=nameWithType> classe.</span><span class="sxs-lookup"><span data-stu-id="8e443-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="8e443-109">Quando si usano gli handle di attesa registrata, un thread di sistema consente di monitorare lo stato dell'handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="8e443-110">Quando viene completata un'operazione di attesa, un thread di lavoro dal pool di thread viene eseguita la funzione di callback corrispondente.</span><span class="sxs-lookup"><span data-stu-id="8e443-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="8e443-111">Quando si chiama il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metodo per accodare un metodo per l'esecuzione in un pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="8e443-112">Eseguire questa operazione passando al metodo un <xref:System.Threading.WaitCallback> delegare.</span><span class="sxs-lookup"><span data-stu-id="8e443-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="8e443-113">Il delegato ha la firma</span><span class="sxs-lookup"><span data-stu-id="8e443-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="8e443-114">in cui `state` è un oggetto che contiene i dati da utilizzare dal delegato.</span><span class="sxs-lookup"><span data-stu-id="8e443-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="8e443-115">I dati effettivi possono essere passati al delegato chiamando il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8e443-116">I thread nel pool di thread gestiti sono thread in background.</span><span class="sxs-lookup"><span data-stu-id="8e443-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="8e443-117">Vale a dire loro <xref:System.Threading.Thread.IsBackground%2A> sono proprietà `true`.</span><span class="sxs-lookup"><span data-stu-id="8e443-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="8e443-118">Ciò significa che un <xref:System.Threading.ThreadPool> thread non manterrà un'applicazione in esecuzione dopo il termine di tutti i thread in primo piano.</span><span class="sxs-lookup"><span data-stu-id="8e443-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8e443-119">Quando il pool di thread riusa un thread, non cancella i dati nell'archiviazione thread-local o nei campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="8e443-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="8e443-120">Pertanto, quando un metodo esamina l'archiviazione thread-local o i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo, i valori rilevati potrebbero essere rimasti un uso precedente del thread del pool.</span><span class="sxs-lookup"><span data-stu-id="8e443-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="8e443-121">È anche possibile accodare gli elementi di lavoro non correlati a un'operazione di attesa per il pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="8e443-122">Per richiedere che un elemento di lavoro gestito da un thread nel pool di thread, chiamare il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="8e443-123">Questo metodo accetta come parametro un riferimento al metodo o delegato che verrà chiamato dal thread selezionato dal pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="8e443-124">Non è possibile annullare un elemento di lavoro dopo che è stata accodata.</span><span class="sxs-lookup"><span data-stu-id="8e443-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="8e443-125">I timer della coda del timer e le operazioni di attesa registrata anche usano il pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="8e443-126">Le funzioni di callback vengono accodate al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="8e443-127">È un pool di thread per ogni processo.</span><span class="sxs-lookup"><span data-stu-id="8e443-127">There is one thread pool per process.</span></span> <span data-ttu-id="8e443-128">A partire da [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la dimensione predefinita del pool di thread per un processo dipende da diversi fattori, ad esempio la dimensione dello spazio degli indirizzi virtuali.</span><span class="sxs-lookup"><span data-stu-id="8e443-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="8e443-129">Un processo può chiamare il metodo <xref:System.Threading.ThreadPool.GetMaxThreads%2A> per determinare il numero di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="8e443-130">Il numero di thread nel pool di thread può essere modificato tramite la <xref:System.Threading.ThreadPool.SetMaxThreads%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="8e443-131">Ogni thread Usa la dimensione predefinita e viene eseguito con la priorità predefinita.</span><span class="sxs-lookup"><span data-stu-id="8e443-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8e443-132">Il codice non gestito che ospita .NET Framework è possibile modificare le dimensioni del pool di thread usando il `CorSetMaxThreads` funzione, definito nel file di Mscoree. h.</span><span class="sxs-lookup"><span data-stu-id="8e443-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="8e443-133">Il pool di thread fornisce nuovi thread di lavoro o thread di completamento i/o su richiesta fino a quando non raggiunge il valore minimo per ogni categoria.</span><span class="sxs-lookup"><span data-stu-id="8e443-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="8e443-134">Quando viene raggiunto un valore minimo, il pool di thread può creare thread aggiuntivi in tale categoria o attendere fino al completamento di alcune attività.</span><span class="sxs-lookup"><span data-stu-id="8e443-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="8e443-135">A partire da [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], il pool di thread crea ed elimina i thread di lavoro per ottimizzare la velocità effettiva, definita come numero di attività completate per unità di tempo.</span><span class="sxs-lookup"><span data-stu-id="8e443-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="8e443-136">Un numero troppo ridotto di thread potrebbe non usare in modo ottimale le risorse disponibili, mentre troppi thread potrebbero aumentare il conflitto per le risorse.</span><span class="sxs-lookup"><span data-stu-id="8e443-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8e443-137">Quando la richiesta è bassa, il numero effettivo di thread del pool può scendere sotto i valori minimi.</span><span class="sxs-lookup"><span data-stu-id="8e443-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="8e443-138">È possibile usare il metodo <xref:System.Threading.ThreadPool.GetMinThreads%2A> per ottenere questi valori minimi.</span><span class="sxs-lookup"><span data-stu-id="8e443-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8e443-139">È possibile usare il <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodo per aumentare il numero minimo di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="8e443-140">Tuttavia, un aumento non necessario di questi valori può provocare problemi di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="8e443-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="8e443-141">Se si avviano troppe attività contemporaneamente, potrebbero sembrare tutte lente.</span><span class="sxs-lookup"><span data-stu-id="8e443-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="8e443-142">Nella maggior parte dei casi, il pool di thread offre prestazioni migliori con il proprio algoritmo per l'allocazione dei thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e443-143">Nell'esempio seguente, il thread principale dell'applicazione Accoda un metodo denominato `ThreadProc` da eseguire in un pool di thread, viene sospeso per un secondo e quindi viene chiusa.</span><span class="sxs-lookup"><span data-stu-id="8e443-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="8e443-144">Il `ThreadProc` metodo visualizza semplicemente un messaggio.</span><span class="sxs-lookup"><span data-stu-id="8e443-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="8e443-145">Se impostare come commento la chiamata al <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo, il thread principale viene chiuso prima di metodo viene eseguito nel pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="8e443-146">Il pool di thread utilizza i thread in background, che non mantengono l'applicazione in esecuzione se tutti i thread in primo piano sono terminati.</span><span class="sxs-lookup"><span data-stu-id="8e443-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="8e443-147">(Questo è un esempio semplice di una race condition.)</span><span class="sxs-lookup"><span data-stu-id="8e443-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="8e443-148">Questo tipo è thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8e443-148">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
      <span data-ttu-id="8e443-149">Thread e threading</span>
      <span class="sxs-lookup">
        <span data-stu-id="8e443-149">Threads and Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
      <span data-ttu-id="8e443-150">Il pool di Thread gestiti</span>
      <span class="sxs-lookup">
        <span data-stu-id="8e443-150">The Managed Thread Pooling</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e443-151">Associa un handle del sistema operativo al <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="8e443-152">
            <see cref="T:System.IntPtr" /> che contiene l'handle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="8e443-153">È necessario che l'handle sia stato aperto per operazioni di I/O sovrapposte nella parte non gestita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-154">Associa un handle del sistema operativo al <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-155">
            <see langword="true" /> se l'handle è associato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-155">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8e443-156">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-156">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="8e443-157">la possibilità di chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-157">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="8e443-158">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-158">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="8e443-159">Oggetto <see cref="T:System.Runtime.InteropServices.SafeHandle" /> che contiene l'handle del sistema operativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="8e443-160">È necessario che l'handle sia stato aperto per operazioni di I/O sovrapposte nella parte non gestita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-160">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-161">Associa un handle del sistema operativo al <see cref="T:System.Threading.ThreadPool" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-161">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-162">
            <see langword="true" /> se l'handle è associato; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-162">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-163">Il `osHandle` il parametro deve essere un <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, che deriva dalla classe astratta <xref:System.Runtime.InteropServices.SafeHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="8e443-163">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8e443-164">
            <paramref name="osHandle" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-164">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="8e443-165">la possibilità di chiamare codice non gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-165">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="8e443-166">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-166">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8e443-167">Numero di thread di lavoro disponibili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-167">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8e443-168">Numero di thread I/O asincroni disponibili.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-168">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-169">Recupera la differenza tra il numero massimo di thread del pool di thread restituito dal metodo <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> e il numero attualmente attivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-169">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-170">Quando <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> viene restituito, la variabile specificata dalla `workerThreads` contiene il numero di thread di lavoro aggiuntivi che possono essere avviati e la variabile specificata dalla `completionPortThreads` contiene il numero di thread i/o asincrono che può essere avviato.</span><span class="sxs-lookup"><span data-stu-id="8e443-170">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="8e443-171">Se non sono disponibili thread, richieste del pool di thread aggiuntivi rimangono in coda finché non diventano disponibili thread del pool.</span><span class="sxs-lookup"><span data-stu-id="8e443-171">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e443-172">Nell'esempio seguente visualizza il numero di thread di lavoro e i thread dei / o disponibile quando viene avviata un'app semplice.</span><span class="sxs-lookup"><span data-stu-id="8e443-172">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8e443-173">Numero massimo di thread di lavoro nel pool di thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-173">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8e443-174">Numero massimo di thread I/O asincroni nel pool di thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-174">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-175">Recupera il numero di richieste al pool di thread che possono essere attive contemporaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-175">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="8e443-176">Tutte le richieste al di fuori di tale numero rimangono in coda fino a quando non diventano disponibili thread di pool di thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-176">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-177">Quando <xref:System.Threading.ThreadPool.GetMaxThreads%2A> viene restituito, la variabile specificata dalla `workerThreads` contiene il numero massimo di thread di lavoro consentiti nel pool di thread e la variabile specificata dalla `completionPortThreads` contiene il numero massimo di thread dei / o asincroni consentito di pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-177">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="8e443-178">È possibile usare il <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> metodo per determinare il numero effettivo di thread nel pool di thread in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="8e443-178">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="8e443-179">È possibile usare il <xref:System.Threading.ThreadPool.SetMaxThreads%2A> per impostare il numero massimo di thread di lavoro e i thread dei / o asincroni nel pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-179">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="8e443-180">È possibile accodare come molte richieste del pool di thread come memoria di sistema consente.</span><span class="sxs-lookup"><span data-stu-id="8e443-180">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="8e443-181">Se sono presenti più richieste rispetto ai pool di thread, le richieste aggiuntive rimangono in coda finché non diventano disponibili thread del pool.</span><span class="sxs-lookup"><span data-stu-id="8e443-181">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e443-182">Esempio di codice seguente viene illustrato come recuperare un conteggio del numero disponibile e massimo di thread nel pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-182">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="8e443-183">Un elemento di lavoro è in coda che usa `FileStream` scrivere in modo asincrono per due file.</span><span class="sxs-lookup"><span data-stu-id="8e443-183">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="8e443-184">I metodi di callback vengono temporizzati sovrapporsi.</span><span class="sxs-lookup"><span data-stu-id="8e443-184">The callback methods are timed to overlap.</span></span> <span data-ttu-id="8e443-185">Un thread di lavoro gestisce l'elemento di lavoro e, a seconda della velocità e numero di processori nel computer, uno o due thread della porta di completamento di gestire le operazioni di scrittura.</span><span class="sxs-lookup"><span data-stu-id="8e443-185">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8e443-186">Quando il metodo viene restituito, contiene il numero minimo di thread di lavoro che il pool di thread crea su richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-186">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8e443-187">Quando il metodo viene restituito, contiene il numero minimo di thread I/O asincroni che il pool di thread crea su richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-187">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-188">Recupera il numero minimo di thread che il pool di thread crea, man mano che vengono effettuate nuove richieste, prima di passare a un algoritmo per la gestione della creazione e dell'eliminazione del thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-188">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-189">Il pool di thread fornisce nuovi thread di lavoro o thread di completamento i/o su richiesta fino a quando non raggiunge il valore minimo per ogni categoria.</span><span class="sxs-lookup"><span data-stu-id="8e443-189">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="8e443-190">Per impostazione predefinita, il numero minimo di thread è impostato sul numero di processori in un sistema.</span><span class="sxs-lookup"><span data-stu-id="8e443-190">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="8e443-191">Quando viene raggiunto il valore minimo, il pool di thread può creare thread aggiuntivi in tale categoria o attendere fino al completamento di alcune attività.</span><span class="sxs-lookup"><span data-stu-id="8e443-191">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="8e443-192">A partire dal [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], il pool di thread crea ed elimina i thread per ottimizzare la velocità effettiva, che viene definita come il numero di attività completate per unità di tempo.</span><span class="sxs-lookup"><span data-stu-id="8e443-192">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="8e443-193">Un numero troppo ridotto di thread potrebbe non usare in modo ottimale le risorse disponibili, mentre troppi thread potrebbero aumentare il conflitto per le risorse.</span><span class="sxs-lookup"><span data-stu-id="8e443-193">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8e443-194">Quando la richiesta è bassa, il numero effettivo di thread del pool può scendere sotto i valori minimi.</span><span class="sxs-lookup"><span data-stu-id="8e443-194">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e443-195">Nell'esempio seguente imposta il numero minimo di thread di lavoro a quattro e mantiene il valore originale per il numero minimo di thread di completamento i/o asincrono.</span><span class="sxs-lookup"><span data-stu-id="8e443-195">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e443-196">Accoda un metodo da eseguire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-196">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="8e443-197">Il metodo viene eseguito quando un thread del pool di thread diventa disponibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-197">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="8e443-198">Oggetto <see cref="T:System.Threading.WaitCallback" /> che rappresenta il metodo da eseguire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-198">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-199">Accoda un metodo da eseguire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-199">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="8e443-200">Il metodo viene eseguito quando un thread del pool di thread diventa disponibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-200">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-201">
            <see langword="true" /> se il metodo viene accodato correttamente. Viene generata l'eccezione <see cref="T:System.NotSupportedException" /> se non è stato possibile accodare l'elemento di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-201">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-202">È possibile inserire i dati necessari per il metodo in coda i campi di istanza della classe in cui il metodo è definito o è possibile usare il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload che accetta un oggetto che contiene i dati necessari.</span><span class="sxs-lookup"><span data-stu-id="8e443-202">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8e443-203">Gli utenti di Visual Basic è possono omettere il <xref:System.Threading.WaitCallback> costruttore e usare semplicemente il `AddressOf` operatore quando si passa il metodo di callback per <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="8e443-203">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="8e443-204">Visual Basic chiama automaticamente il costruttore di delegato corretto.</span><span class="sxs-lookup"><span data-stu-id="8e443-204">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8e443-205">Informazioni sulla versione</span><span class="sxs-lookup"><span data-stu-id="8e443-205">Version Information</span></span>  
 <span data-ttu-id="8e443-206">In .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-206">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="8e443-207">Nelle versioni precedenti, le informazioni dell'entità non viene propagate.</span><span class="sxs-lookup"><span data-stu-id="8e443-207">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e443-208">L'esempio seguente usa il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> overload del metodo per accodare un'attività, che è rappresentato dal `ThreadProc` metodo, da eseguire quando un thread diventa disponibile.</span><span class="sxs-lookup"><span data-stu-id="8e443-208">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="8e443-209">Nessuna informazione di attività viene fornita con questo overload.</span><span class="sxs-lookup"><span data-stu-id="8e443-209">No task information is supplied with this overload.</span></span> <span data-ttu-id="8e443-210">Di conseguenza, le informazioni che sono disponibile per il `ThreadProc` metodo è limitato all'oggetto al quale appartiene il metodo.</span><span class="sxs-lookup"><span data-stu-id="8e443-210">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8e443-211">
            <paramref name="callBack" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-211">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8e443-212">Common Language Runtime (CLR) è ospitato e l'host non supporta questa azione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-212">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-213">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-213">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="8e443-214">
            <see cref="T:System.Threading.WaitCallback" /> che rappresenta il metodo da eseguire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-214">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-215">Oggetto contenente i dati che devono essere usati dal metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-215">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-216">Accoda un metodo da eseguire e specifica un oggetto che contiene i dati che dovranno essere usati dal metodo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-216">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="8e443-217">Il metodo viene eseguito quando un thread del pool di thread diventa disponibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-217">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-218">
            <see langword="true" /> se il metodo viene accodato correttamente. Viene generata l'eccezione <see cref="T:System.NotSupportedException" /> se non è stato possibile accodare l'elemento di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-218">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-219">Se il metodo di callback sono necessari dati complessi, è possibile definire una classe per contenere i dati.</span><span class="sxs-lookup"><span data-stu-id="8e443-219">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8e443-220">Gli utenti di Visual Basic è possono omettere il <xref:System.Threading.WaitCallback> costruttore e usare semplicemente il `AddressOf` operatore quando si passa il metodo di callback per <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="8e443-220">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="8e443-221">Visual Basic chiama automaticamente il costruttore di delegato corretto.</span><span class="sxs-lookup"><span data-stu-id="8e443-221">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8e443-222">Informazioni sulla versione</span><span class="sxs-lookup"><span data-stu-id="8e443-222">Version Information</span></span>  
 <span data-ttu-id="8e443-223">In .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-223">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="8e443-224">Nelle versioni precedenti, le informazioni dell'entità non viene propagate.</span><span class="sxs-lookup"><span data-stu-id="8e443-224">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e443-225">L'esempio seguente usa il pool di thread .NET per la quale calcolare il `Fibonacci` risultato per cinque numeri compresi tra 20 e 40.</span><span class="sxs-lookup"><span data-stu-id="8e443-225">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="8e443-226">Ogni risultato di `Fibonacci` viene rappresentato dalla classe `Fibonacci`, che fornisce un metodo denominato `ThreadPoolCallback` per l'esecuzione del calcolo.</span><span class="sxs-lookup"><span data-stu-id="8e443-226">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="8e443-227">Viene creato un oggetto che rappresenta ogni valore `Fibonacci`, il metodo `ThreadPoolCallback` viene passato a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, che assegna un thread disponibile del pool per eseguire il metodo.</span><span class="sxs-lookup"><span data-stu-id="8e443-227">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="8e443-228">Poiché ogni `Fibonacci` oggetto viene assegnato un valore semi-casuale da calcolare e poiché ogni thread sarà in competizione per il tempo del processore, non è possibile sapere in anticipo quanto tempo impiegherà per tutti i cinque risultati deve essere calcolato.</span><span class="sxs-lookup"><span data-stu-id="8e443-228">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="8e443-229">Per questo motivo a ogni oggetto `Fibonacci` viene passata un'istanza della classe <xref:System.Threading.ManualResetEvent> durante la costruzione.</span><span class="sxs-lookup"><span data-stu-id="8e443-229">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="8e443-230">Ogni oggetto segnala l'oggetto evento fornito quando cui il calcolo viene completato, che consente al thread primario può bloccare l'esecuzione con <xref:System.Threading.WaitHandle.WaitAll%2A> finché tutti e cinque `Fibonacci` gli oggetti hanno calcolato un risultato.</span><span class="sxs-lookup"><span data-stu-id="8e443-230">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="8e443-231">Il metodo `Main` visualizza quindi ogni risultato `Fibonacci`.</span><span class="sxs-lookup"><span data-stu-id="8e443-231">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8e443-232">Common Language Runtime (CLR) è ospitato e l'host non supporta questa azione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-232">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8e443-233">
            <paramref name="callBack" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-233">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-234">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-234">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e443-235">Registra un delegato in attesa di un <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-235">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8e443-236">
            <see cref="T:System.Threading.WaitHandle" /> da registrare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-236">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8e443-237">Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-237">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8e443-238">Delegato <see cref="T:System.Threading.WaitOrTimerCallback" /> da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-238">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-239">Oggetto passato al delegato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-239">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8e443-240">Timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-240">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8e443-241">Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-241">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8e443-242">Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-242">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8e443-243">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-243">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-244">Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore intero con segno a 32 bit per il timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-244">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-245">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> che incapsula l'handle nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-245">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-246">Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-246">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8e443-247">È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="8e443-247">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8e443-248">Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-248">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="8e443-249">Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo Accoda il delegato specificato al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-249">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="8e443-250">Il delegato di un thread di lavoro verrà eseguito quando si verifica una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="8e443-250">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="8e443-251">L'oggetto specificato è nello stato segnalato.</span><span class="sxs-lookup"><span data-stu-id="8e443-251">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="8e443-252">L'intervallo di timeout scade.</span><span class="sxs-lookup"><span data-stu-id="8e443-252">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="8e443-253">Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo controlla lo stato corrente dell'oggetto specificato <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="8e443-253">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="8e443-254">Se non è segnalato lo stato dell'oggetto, il metodo registra un'operazione di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-254">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="8e443-255">L'operazione di attesa viene eseguita da un thread dal pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-255">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="8e443-256">Il delegato viene eseguito da un thread di lavoro quando lo stato dell'oggetto diventa segnalato o scade il timeout.</span><span class="sxs-lookup"><span data-stu-id="8e443-256">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="8e443-257">Se il `timeOutInterval` parametro non è 0 (zero) e il `executeOnlyOnce` parametro è `false`, il timer viene reimpostato ogni volta che l'evento viene segnalato o scade il timeout.</span><span class="sxs-lookup"><span data-stu-id="8e443-257">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8e443-258">Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.</span><span class="sxs-lookup"><span data-stu-id="8e443-258">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="8e443-259">Invece di un <xref:System.Threading.Mutex>, usare un <xref:System.Threading.Semaphore> con un numero massimo di 1.</span><span class="sxs-lookup"><span data-stu-id="8e443-259">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="8e443-260">Per annullare l'operazione di attesa, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-260">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8e443-261">Attesa thread utilizza Win32 `WaitForMultipleObjects` (funzione) per monitorare le operazioni di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-261">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="8e443-262">Pertanto, se è necessario usare lo stesso handle nativo del sistema operativo in più chiamate alla <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, è necessario duplicare l'handle utilizzando Win32 `DuplicateHandle` (funzione).</span><span class="sxs-lookup"><span data-stu-id="8e443-262">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="8e443-263">Si noti che deve eseguire il pulse un oggetto evento passato al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, perché il thread di attesa potrebbe non rilevare che l'evento viene segnalato prima della reimpostazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-263">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="8e443-264">Prima di restituire, la funzione modifica lo stato di alcuni tipi di oggetti di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-264">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="8e443-265">La modifica avviene solo per l'oggetto il cui stato segnalato ha causato la condizione di attesa devono essere soddisfatti.</span><span class="sxs-lookup"><span data-stu-id="8e443-265">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="8e443-266">Ad esempio, il conteggio del semaforo viene ridotta di uno.</span><span class="sxs-lookup"><span data-stu-id="8e443-266">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8e443-267">Informazioni sulla versione</span><span class="sxs-lookup"><span data-stu-id="8e443-267">Version Information</span></span>  
 <span data-ttu-id="8e443-268">A partire da .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-268">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="8e443-269">Nelle versioni precedenti, le informazioni dell'entità non viene propagate.</span><span class="sxs-lookup"><span data-stu-id="8e443-269">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8e443-270">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-270">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-271">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-271">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8e443-272">
            <see cref="T:System.Threading.WaitHandle" /> da registrare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-272">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8e443-273">Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-273">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8e443-274">Delegato <see cref="T:System.Threading.WaitOrTimerCallback" /> da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-274">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-275">Oggetto passato al delegato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-275">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8e443-276">Timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-276">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8e443-277">Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-277">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8e443-278">Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-278">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8e443-279">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-279">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-280">Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore intero con segno a 64 bit per il timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-280">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-281">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> che incapsula l'handle nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-281">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-282">Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-282">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8e443-283">È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="8e443-283">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8e443-284">Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-284">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="8e443-285">Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo Accoda il delegato specificato al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-285">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="8e443-286">Il delegato di un thread di lavoro verrà eseguito quando si verifica una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="8e443-286">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="8e443-287">L'oggetto specificato è nello stato segnalato.</span><span class="sxs-lookup"><span data-stu-id="8e443-287">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="8e443-288">L'intervallo di timeout scade.</span><span class="sxs-lookup"><span data-stu-id="8e443-288">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="8e443-289">Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo controlla lo stato corrente dell'oggetto specificato <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="8e443-289">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="8e443-290">Se non è segnalato lo stato dell'oggetto, il metodo registra un'operazione di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-290">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="8e443-291">L'operazione di attesa viene eseguita da un thread dal pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-291">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="8e443-292">Il delegato viene eseguito da un thread di lavoro quando lo stato dell'oggetto diventa segnalato o scade il timeout.</span><span class="sxs-lookup"><span data-stu-id="8e443-292">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="8e443-293">Se il `timeOutInterval` parametro non è 0 (zero) e il `executeOnlyOnce` parametro è `false`, il timer viene reimpostato ogni volta che l'evento viene segnalato o scade il timeout.</span><span class="sxs-lookup"><span data-stu-id="8e443-293">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8e443-294">Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.</span><span class="sxs-lookup"><span data-stu-id="8e443-294">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="8e443-295">Invece di un <xref:System.Threading.Mutex>, usare un <xref:System.Threading.Semaphore> con un numero massimo di 1.</span><span class="sxs-lookup"><span data-stu-id="8e443-295">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="8e443-296">Per annullare l'operazione di attesa, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-296">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8e443-297">Attesa thread utilizza Win32 `WaitForMultipleObjects` (funzione) per monitorare le operazioni di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-297">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="8e443-298">Pertanto, se è necessario usare lo stesso handle nativo del sistema operativo in più chiamate alla <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, è necessario duplicare l'handle utilizzando Win32 `DuplicateHandle` (funzione).</span><span class="sxs-lookup"><span data-stu-id="8e443-298">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="8e443-299">Si noti che deve eseguire il pulse un oggetto evento passato al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, perché il thread di attesa potrebbe non rilevare che l'evento viene segnalato prima della reimpostazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-299">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="8e443-300">Prima di restituire, la funzione modifica lo stato di alcuni tipi di oggetti di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-300">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="8e443-301">La modifica avviene solo per l'oggetto il cui stato segnalato ha causato la condizione di attesa devono essere soddisfatti.</span><span class="sxs-lookup"><span data-stu-id="8e443-301">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="8e443-302">Ad esempio, il conteggio del semaforo viene ridotta di uno.</span><span class="sxs-lookup"><span data-stu-id="8e443-302">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8e443-303">Informazioni sulla versione</span><span class="sxs-lookup"><span data-stu-id="8e443-303">Version Information</span></span>  
 <span data-ttu-id="8e443-304">A partire da .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-304">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="8e443-305">Nelle versioni precedenti, le informazioni dell'entità non viene propagate.</span><span class="sxs-lookup"><span data-stu-id="8e443-305">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8e443-306">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-306">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-307">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-307">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8e443-308">
            <see cref="T:System.Threading.WaitHandle" /> da registrare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-308">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8e443-309">Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-309">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8e443-310">Delegato <see cref="T:System.Threading.WaitOrTimerCallback" /> da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-310">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-311">Oggetto passato al delegato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-311">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="8e443-312">Il timeout rappresentato da un valore <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-312">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="8e443-313">Se <c>timeout</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-313">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8e443-314">Se <c>timeout</c> è -1, l'intervallo di timeout della funzione non termina mai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-314">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8e443-315">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-315">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-316">Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore <see cref="T:System.TimeSpan" /> per il timeout.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-316">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-317">
            <see cref="T:System.Threading.RegisteredWaitHandle" /> che incapsula l'handle nativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-317">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-318">Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-318">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8e443-319">È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="8e443-319">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8e443-320">Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-320">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="8e443-321">Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo Accoda il delegato specificato al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-321">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="8e443-322">Il delegato di un thread di lavoro verrà eseguito quando si verifica una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="8e443-322">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="8e443-323">L'oggetto specificato è nello stato segnalato.</span><span class="sxs-lookup"><span data-stu-id="8e443-323">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="8e443-324">L'intervallo di timeout scade.</span><span class="sxs-lookup"><span data-stu-id="8e443-324">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="8e443-325">Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo controlla lo stato corrente dell'oggetto specificato <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="8e443-325">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="8e443-326">Se non è segnalato lo stato dell'oggetto, il metodo registra un'operazione di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-326">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="8e443-327">L'operazione di attesa viene eseguita da un thread dal pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-327">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="8e443-328">Il delegato viene eseguito da un thread di lavoro quando lo stato dell'oggetto diventa segnalato o scade il timeout.</span><span class="sxs-lookup"><span data-stu-id="8e443-328">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="8e443-329">Se il `timeOutInterval` parametro non è 0 (zero) e il `executeOnlyOnce` parametro è `false`, il timer viene reimpostato ogni volta che l'evento viene segnalato o scade il timeout.</span><span class="sxs-lookup"><span data-stu-id="8e443-329">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8e443-330">Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.</span><span class="sxs-lookup"><span data-stu-id="8e443-330">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="8e443-331">Invece di un <xref:System.Threading.Mutex>, usare un <xref:System.Threading.Semaphore> con un numero massimo di 1.</span><span class="sxs-lookup"><span data-stu-id="8e443-331">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="8e443-332">Per annullare l'operazione di attesa, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-332">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8e443-333">Attesa thread utilizza Win32 `WaitForMultipleObjects` (funzione) per monitorare le operazioni di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-333">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="8e443-334">Pertanto, se è necessario usare lo stesso handle nativo del sistema operativo in più chiamate alla <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, è necessario duplicare l'handle utilizzando Win32 `DuplicateHandle` (funzione).</span><span class="sxs-lookup"><span data-stu-id="8e443-334">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="8e443-335">Si noti che deve eseguire il pulse un oggetto evento passato al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, perché il thread di attesa potrebbe non rilevare che l'evento viene segnalato prima della reimpostazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-335">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="8e443-336">Prima di restituire, la funzione modifica lo stato di alcuni tipi di oggetti di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-336">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="8e443-337">La modifica avviene solo per l'oggetto il cui stato segnalato ha causato la condizione di attesa devono essere soddisfatti.</span><span class="sxs-lookup"><span data-stu-id="8e443-337">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="8e443-338">Ad esempio, il conteggio del semaforo viene ridotta di uno.</span><span class="sxs-lookup"><span data-stu-id="8e443-338">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8e443-339">Informazioni sulla versione</span><span class="sxs-lookup"><span data-stu-id="8e443-339">Version Information</span></span>  
 <span data-ttu-id="8e443-340">A partire da .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-340">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="8e443-341">Nelle versioni precedenti, le informazioni dell'entità non viene propagate.</span><span class="sxs-lookup"><span data-stu-id="8e443-341">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8e443-342">Il parametro <paramref name="timeout" /> è minore di -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-342">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8e443-343">Il parametro <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-343">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-344">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-344">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8e443-345">
            <see cref="T:System.Threading.WaitHandle" /> da registrare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-345">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8e443-346">Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-346">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8e443-347">Delegato <see cref="T:System.Threading.WaitOrTimerCallback" /> da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-347">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-348">Oggetto passato al delegato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-348">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8e443-349">Timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-349">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8e443-350">Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-350">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8e443-351">Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-351">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8e443-352">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-352">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-353">Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un intero senza segno a 32 bit per il timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-353">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-354">Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-354">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-355">Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-355">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8e443-356">È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="8e443-356">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8e443-357">Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-357">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="8e443-358">Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo Accoda il delegato specificato al pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-358">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="8e443-359">Il delegato di un thread di lavoro verrà eseguito quando si verifica una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="8e443-359">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="8e443-360">L'oggetto specificato è nello stato segnalato.</span><span class="sxs-lookup"><span data-stu-id="8e443-360">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="8e443-361">L'intervallo di timeout scade.</span><span class="sxs-lookup"><span data-stu-id="8e443-361">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="8e443-362">Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo controlla lo stato corrente dell'oggetto specificato <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="8e443-362">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="8e443-363">Se non è segnalato lo stato dell'oggetto, il metodo registra un'operazione di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-363">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="8e443-364">L'operazione di attesa viene eseguita da un thread dal pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-364">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="8e443-365">Il delegato viene eseguito da un thread di lavoro quando lo stato dell'oggetto diventa segnalato o scade il timeout.</span><span class="sxs-lookup"><span data-stu-id="8e443-365">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="8e443-366">Se il `timeOutInterval` parametro non è 0 (zero) e il `executeOnlyOnce` parametro è `false`, il timer viene reimpostato ogni volta che l'evento viene segnalato o scade il timeout.</span><span class="sxs-lookup"><span data-stu-id="8e443-366">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8e443-367">Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.</span><span class="sxs-lookup"><span data-stu-id="8e443-367">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="8e443-368">Invece di un <xref:System.Threading.Mutex>, usare un <xref:System.Threading.Semaphore> con un numero massimo di 1.</span><span class="sxs-lookup"><span data-stu-id="8e443-368">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="8e443-369">Per annullare l'operazione di attesa, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-369">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8e443-370">Attesa thread utilizza Win32 `WaitForMultipleObjects` (funzione) per monitorare le operazioni di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-370">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="8e443-371">Pertanto, se è necessario usare lo stesso handle nativo del sistema operativo in più chiamate alla <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, è necessario duplicare l'handle utilizzando Win32 `DuplicateHandle` (funzione).</span><span class="sxs-lookup"><span data-stu-id="8e443-371">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="8e443-372">Si noti che deve eseguire il pulse un oggetto evento passato al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, perché il thread di attesa potrebbe non rilevare che l'evento viene segnalato prima della reimpostazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-372">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="8e443-373">Prima di restituire, la funzione modifica lo stato di alcuni tipi di oggetti di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-373">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="8e443-374">La modifica avviene solo per l'oggetto il cui stato segnalato ha causato la condizione di attesa devono essere soddisfatti.</span><span class="sxs-lookup"><span data-stu-id="8e443-374">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="8e443-375">Ad esempio, il conteggio del semaforo viene ridotta di uno.</span><span class="sxs-lookup"><span data-stu-id="8e443-375">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8e443-376">Informazioni sulla versione</span><span class="sxs-lookup"><span data-stu-id="8e443-376">Version Information</span></span>  
 <span data-ttu-id="8e443-377">A partire da .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-377">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="8e443-378">Nelle versioni precedenti, le informazioni dell'entità non viene propagate.</span><span class="sxs-lookup"><span data-stu-id="8e443-378">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e443-379">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo per eseguire un metodo di callback specificato quando viene segnalato un handle di attesa specificato.</span><span class="sxs-lookup"><span data-stu-id="8e443-379">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="8e443-380">In questo esempio, è il metodo di callback `WaitProc`, e l'handle di attesa è un <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="8e443-380">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="8e443-381">L'esempio definisce un `TaskInfo` classe per contenere le informazioni che viene passate al callback durante l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="8e443-381">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="8e443-382">Nell'esempio viene creato un `TaskInfo` dell'oggetto e lo assegna alcuni dati di tipo stringa.</span><span class="sxs-lookup"><span data-stu-id="8e443-382">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="8e443-383">Il <xref:System.Threading.RegisteredWaitHandle> restituito dal <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo viene assegnato al `Handle` campo il `TaskInfo` dell'oggetto in modo che il metodo di callback può accedere al <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="8e443-383">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="8e443-384">Oltre a specificare `TaskInfo` dell'oggetto da passare al metodo di callback, la chiamata al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo specifica il <xref:System.Threading.AutoResetEvent> che dovrà attendere l'attività, una <xref:System.Threading.WaitOrTimerCallback> delegato che rappresenta il `WaitProc` metodo di callback, un un secondo intervallo di timeout e più callback.</span><span class="sxs-lookup"><span data-stu-id="8e443-384">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="8e443-385">Quando il thread principale segnala la <xref:System.Threading.AutoResetEvent> chiamando relativi <xref:System.Threading.EventWaitHandle.Set%2A> metodo, il <xref:System.Threading.WaitOrTimerCallback> delegato viene richiamato.</span><span class="sxs-lookup"><span data-stu-id="8e443-385">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="8e443-386">Il `WaitProc` metodo test <xref:System.Threading.RegisteredWaitHandle> per determinare se si è verificato un timeout.</span><span class="sxs-lookup"><span data-stu-id="8e443-386">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="8e443-387">Se è stato richiamato il callback perché è stato segnalato l'handle di attesa, il `WaitProc` metodo annulla la registrazione di <xref:System.Threading.RegisteredWaitHandle>, l'arresto di callback aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="8e443-387">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="8e443-388">Nel caso di un timeout, l'attività resta in attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-388">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="8e443-389">Il `WaitProc` metodo termina con la stampa un messaggio nella console.</span><span class="sxs-lookup"><span data-stu-id="8e443-389">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8e443-390">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-390">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-391">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-391">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8e443-392">Numero massimo di thread di lavoro nel pool di thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-392">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8e443-393">Numero massimo di thread I/O asincroni nel pool di thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-393">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-394">Imposta il numero di richieste al pool di thread che possono essere attivate contemporaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-394">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="8e443-395">Tutte le richieste al di fuori di tale numero rimangono in coda fino a quando non diventano disponibili thread di pool di thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-395">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-396">
            <see langword="true" /> se la modifica ha esito positivo; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-396">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-397">Non è possibile impostare il numero massimo di thread di lavoro o thread di completamento i/o su un numero inferiore al numero di processori nel computer.</span><span class="sxs-lookup"><span data-stu-id="8e443-397">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="8e443-398">Per determinare il numero di processori è presente, recuperare il valore della <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="8e443-398">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8e443-399">È inoltre, non è possibile impostare il numero massimo di thread di lavoro o thread di completamento i/o su un numero inferiore al numero corrispondente minimo di thread di lavoro o thread di completamento i/o.</span><span class="sxs-lookup"><span data-stu-id="8e443-399">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="8e443-400">Per determinare le dimensioni del pool di thread minimi, chiamare il <xref:System.Threading.ThreadPool.GetMinThreads%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="8e443-400">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="8e443-401">Se è ospitato in common language runtime, ad esempio da Internet Information Services (IIS) o SQL Server, l'host può limitare o impedire le modifiche alla dimensione del pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-401">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="8e443-402">Prestare attenzione quando si modifica il numero massimo di thread nel pool di thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-402">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="8e443-403">Il codice potrebbe essere utile, la modifica potrebbe avere effetti negativi sulle librerie di codice che si utilizza.</span><span class="sxs-lookup"><span data-stu-id="8e443-403">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="8e443-404">Impostare le dimensioni del pool di thread troppo elevato può causare problemi di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="8e443-404">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="8e443-405">Se troppi thread sono in esecuzione nello stesso momento, il passaggio da un sovraccarico diventa un fattore significativo.</span><span class="sxs-lookup"><span data-stu-id="8e443-405">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="8e443-406">per la possibilità di controllare i thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-406">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="8e443-407">Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-407">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8e443-408">Il numero minimo di thread di lavoro che vengono creati su richiesta dal pool di thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-408">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8e443-409">Il numero minimo di thread I/O asincroni che vengono creati su richiesta dal pool di thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-409">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-410">Imposta il numero minimo di thread che il pool di thread crea, man mano che vengono effettuate nuove richieste, prima di passare a un algoritmo per la gestione della creazione e dell'eliminazione del thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-410">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-411">
            <see langword="true" /> se la modifica ha esito positivo; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-411">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-412">Il pool di thread fornisce nuovi thread di lavoro o thread di completamento i/o su richiesta fino a quando non raggiunge il valore minimo per ogni categoria.</span><span class="sxs-lookup"><span data-stu-id="8e443-412">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="8e443-413">Quando viene raggiunto il valore minimo, il pool di thread può creare thread aggiuntivi in tale categoria o attendere fino al completamento di alcune attività.</span><span class="sxs-lookup"><span data-stu-id="8e443-413">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="8e443-414">A partire dal [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], il pool di thread crea ed elimina i thread per ottimizzare la velocità effettiva, che viene definita come il numero di attività completate per unità di tempo.</span><span class="sxs-lookup"><span data-stu-id="8e443-414">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="8e443-415">Un numero troppo ridotto di thread potrebbe non usare in modo ottimale le risorse disponibili, mentre troppi thread potrebbero aumentare il conflitto per le risorse.</span><span class="sxs-lookup"><span data-stu-id="8e443-415">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="8e443-416">Quando la richiesta è bassa, il numero effettivo di thread del pool può scendere sotto i valori minimi.</span><span class="sxs-lookup"><span data-stu-id="8e443-416">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="8e443-417">Se si specifica un numero negativo o un numero maggiore del numero massimo di pool di thread attivi (ottenuti usando il <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> restituisce `false` e non viene modificato uno dei valori minimi.</span><span class="sxs-lookup"><span data-stu-id="8e443-417">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8e443-418">Per impostazione predefinita, il numero minimo di thread è impostato sul numero di processori in un sistema.</span><span class="sxs-lookup"><span data-stu-id="8e443-418">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="8e443-419">È possibile usare il <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodo per aumentare la ofthreads numero minimo.</span><span class="sxs-lookup"><span data-stu-id="8e443-419">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="8e443-420">Tuttavia, un aumento non necessario di questi valori può provocare problemi di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="8e443-420">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="8e443-421">Se si avviano troppe attività contemporaneamente, potrebbero sembrare tutte lente.</span><span class="sxs-lookup"><span data-stu-id="8e443-421">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="8e443-422">Nella maggior parte dei casi, il pool di thread offrono prestazioni migliori con il proprio algoritmo di allocazione dei thread.</span><span class="sxs-lookup"><span data-stu-id="8e443-422">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="8e443-423">La riduzione al minimo a inferiore al numero di processori può anche influire negativamente sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="8e443-423">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8e443-424">Nell'esempio seguente imposta il numero minimo di thread di lavoro a quattro e mantiene il valore originale per il numero minimo di thread di completamento i/o asincrono.</span><span class="sxs-lookup"><span data-stu-id="8e443-424">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="8e443-425">per la possibilità di controllare i thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-425">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="8e443-426">Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-426">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="8e443-427">Struttura <see cref="T:System.Threading.NativeOverlapped" /> da accodare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-427">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-428">Accoda un'operazione di I/O sovrapposta per l'esecuzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-428">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-429">
            <see langword="true" /> se l'accodamento dell'operazione a una porta di completamento di I/O è stato eseguito correttamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-429">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-430">Per informazioni sull'uso di nativo Win32 overlapped dei / o, vedere la <xref:System.Threading.Overlapped> (classe), il <xref:System.Threading.NativeOverlapped> struttura e il `OVERLAPPED` struttura in Win32 Platform SDK.</span><span class="sxs-lookup"><span data-stu-id="8e443-430">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8e443-431">Uso di <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> metodo potrebbe inavvertitamente aprire un problema di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-431">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="8e443-432">Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack.</span><span class="sxs-lookup"><span data-stu-id="8e443-432">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8e443-433">Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, lo stack del thread del pool non dispone il contesto dei chiamanti in posizione effettive.</span><span class="sxs-lookup"><span data-stu-id="8e443-433">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="8e443-434">Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-434">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8e443-435">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-435">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8e443-436">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-436">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="8e443-437">Oggetto <see cref="T:System.Threading.WaitCallback" /> che rappresenta il delegato da richiamare quando un thread nel pool di thread sceglie l'elemento di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-437">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-438">Oggetto passato al delegato quando viene servito dal pool di thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-438">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-439">Accoda il delegato specificato al pool di thread, ma non propaga lo stack di chiamata nel thread di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-439">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-440">
            <see langword="true" /> se il metodo viene eseguito correttamente. Viene generata l'eccezione <see cref="T:System.OutOfMemoryException" /> se non è stato possibile accodare l'elemento di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-440">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-441">A differenza di <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metodo <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> non propaga lo stack di chiamata al thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="8e443-441">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8e443-442">In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-442">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8e443-443">Usando <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> potrebbe inavvertitamente aprire un problema di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-443">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8e443-444">Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack.</span><span class="sxs-lookup"><span data-stu-id="8e443-444">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8e443-445">Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive.</span><span class="sxs-lookup"><span data-stu-id="8e443-445">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8e443-446">Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-446">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8e443-447">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-447">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="8e443-448">È stata rilevata una condizione di memoria insufficiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-448">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="8e443-449">Non è stato possibile accodare l'elemento di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-449">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8e443-450">
            <paramref name="callBack" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-450">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8e443-451">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-451">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8e443-452">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-452">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-453">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-453">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8e443-454">Registra un delegato per l'attesa di un <see cref="T:System.Threading.WaitHandle" />, ma non propaga lo stack di chiamata nel thread di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-454">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8e443-455">
            <see cref="T:System.Threading.WaitHandle" /> da registrare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-455">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8e443-456">Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-456">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8e443-457">Delegato da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-457">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-458">Oggetto passato al delegato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-458">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8e443-459">Timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-459">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8e443-460">Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-460">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8e443-461">Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-461">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8e443-462">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-462">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-463">Registra un delegato per l'attesa di un <see cref="T:System.Threading.WaitHandle" />, specificando un intero con segno a 32 bit per il timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-463">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8e443-464">Questo metodo non propaga lo stack di chiamate al thread di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-464">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-465">Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-465">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-466">A differenza di <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> non propaga lo stack di chiamata al thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="8e443-466">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8e443-467">In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-467">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8e443-468">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> potrebbe inavvertitamente aprire un problema di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-468">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8e443-469">Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack.</span><span class="sxs-lookup"><span data-stu-id="8e443-469">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8e443-470">Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive.</span><span class="sxs-lookup"><span data-stu-id="8e443-470">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8e443-471">Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-471">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="8e443-472">Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.</span><span class="sxs-lookup"><span data-stu-id="8e443-472">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="8e443-473">Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-473">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8e443-474">È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="8e443-474">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8e443-475">Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-475">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8e443-476">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-476">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8e443-477">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-477">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8e443-478">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-478">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8e443-479">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-479">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-480">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-480">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8e443-481">
            <see cref="T:System.Threading.WaitHandle" /> da registrare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-481">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8e443-482">Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-482">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8e443-483">Delegato da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-483">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-484">Oggetto passato al delegato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-484">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8e443-485">Timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-485">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8e443-486">Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-486">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8e443-487">Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-487">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8e443-488">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-488">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-489">Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore intero con segno a 64 bit per il timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-489">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8e443-490">Questo metodo non propaga lo stack di chiamate al thread di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-490">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-491">Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-491">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-492">A differenza di <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> non propaga lo stack di chiamata al thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="8e443-492">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8e443-493">In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-493">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8e443-494">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> potrebbe inavvertitamente aprire un problema di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-494">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8e443-495">Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack.</span><span class="sxs-lookup"><span data-stu-id="8e443-495">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8e443-496">Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive.</span><span class="sxs-lookup"><span data-stu-id="8e443-496">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8e443-497">Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-497">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="8e443-498">Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.</span><span class="sxs-lookup"><span data-stu-id="8e443-498">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="8e443-499">Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-499">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8e443-500">È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="8e443-500">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8e443-501">Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-501">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8e443-502">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-502">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8e443-503">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-503">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8e443-504">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-504">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8e443-505">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-505">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-506">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-506">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8e443-507">
            <see cref="T:System.Threading.WaitHandle" /> da registrare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-507">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8e443-508">Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-508">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8e443-509">Delegato da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-509">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-510">Oggetto passato al delegato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-510">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="8e443-511">Il timeout rappresentato da un valore <see cref="T:System.TimeSpan" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-511">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="8e443-512">Se <c>timeout</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-512">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8e443-513">Se <c>timeout</c> è -1, l'intervallo di timeout della funzione non termina mai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-513">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8e443-514">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-514">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-515">Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore <see cref="T:System.TimeSpan" /> per il timeout. Questo metodo non propaga lo stack di chiamate al thread di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-515">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-516">Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-516">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-517">A differenza di <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> non propaga lo stack di chiamata al thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="8e443-517">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8e443-518">In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-518">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8e443-519">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> potrebbe inavvertitamente aprire un problema di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-519">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8e443-520">Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack.</span><span class="sxs-lookup"><span data-stu-id="8e443-520">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8e443-521">Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive.</span><span class="sxs-lookup"><span data-stu-id="8e443-521">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8e443-522">Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-522">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="8e443-523">Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.</span><span class="sxs-lookup"><span data-stu-id="8e443-523">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="8e443-524">Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-524">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8e443-525">È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="8e443-525">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8e443-526">Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-526">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8e443-527">Il parametro <paramref name="timeout" /> è minore di -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-527">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8e443-528">Il parametro <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-528">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8e443-529">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-529">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8e443-530">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-530">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8e443-531">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-531">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-532">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-532">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8e443-533">
            <see cref="T:System.Threading.WaitHandle" /> da registrare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-533">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8e443-534">Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-534">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8e443-535">Delegato da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-535">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8e443-536">Oggetto passato al delegato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-536">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8e443-537">Timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-537">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8e443-538">Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-538">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8e443-539">Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-539">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8e443-540">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-540">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8e443-541">Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un intero senza segno a 32 bit per il timeout in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-541">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8e443-542">Questo metodo non propaga lo stack di chiamate al thread di lavoro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-542">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8e443-543">Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-543">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8e443-544">A differenza di <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> non propaga lo stack di chiamata al thread di lavoro.</span><span class="sxs-lookup"><span data-stu-id="8e443-544">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8e443-545">In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-545">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8e443-546">Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> potrebbe inavvertitamente aprire un problema di sicurezza.</span><span class="sxs-lookup"><span data-stu-id="8e443-546">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8e443-547">Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack.</span><span class="sxs-lookup"><span data-stu-id="8e443-547">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8e443-548">Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive.</span><span class="sxs-lookup"><span data-stu-id="8e443-548">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8e443-549">Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.</span><span class="sxs-lookup"><span data-stu-id="8e443-549">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="8e443-550">Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.</span><span class="sxs-lookup"><span data-stu-id="8e443-550">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="8e443-551">Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="8e443-551">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8e443-552">È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="8e443-552">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8e443-553">Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.</span><span class="sxs-lookup"><span data-stu-id="8e443-553">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8e443-554">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-554">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8e443-555">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-555">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8e443-556">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-556">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="8e443-557">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="8e443-557">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>