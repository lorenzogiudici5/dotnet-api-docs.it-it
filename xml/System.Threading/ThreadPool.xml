<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a3111b9d3890e99871797d80fe33a669a253dba6" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39851175" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornisce un pool di thread che può essere usato per eseguire attività, inviare elementi di lavoro, elaborare operazioni di I/O asincrone, attendere per conto di altri thread ed elaborare timer.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Molte applicazioni creano thread che spendono una notevole quantità di tempo nello stato inattivo, in attesa di un evento si verifichi. Altri thread potrebbero entrare in uno stato di solo a essere riattivati periodicamente per eseguire il polling di una modifica o aggiornare le informazioni sullo stato. Il pool di thread consente di usare i thread in modo più efficiente fornendo all'applicazione con un pool di thread di lavoro gestiti dal sistema. Esempi di operazioni che usano i pool di thread includono quanto segue:  
  
-   Quando si crea una <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> oggetto effettui alcune attività in modo asincrono, per impostazione predefinita l'attività viene pianificata per l'esecuzione in un pool di thread.  
  
-   Timer asincroni usano il pool di thread. Eseguire le richiamate dal pool di thread di <xref:System.Threading.Timer?displayProperty=nameWithType> classi e generare eventi dal <xref:System.Timers.Timer?displayProperty=nameWithType> classe.  
  
-   Quando si usano gli handle di attesa registrata, un thread di sistema consente di monitorare lo stato dell'handle di attesa. Quando viene completata un'operazione di attesa, un thread di lavoro dal pool di thread viene eseguita la funzione di callback corrispondente.  
  
-   Quando si chiama il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metodo per accodare un metodo per l'esecuzione in un pool di thread. Eseguire questa operazione passando al metodo un <xref:System.Threading.WaitCallback> delegare.   Il delegato ha la firma  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     in cui `state` è un oggetto che contiene i dati da utilizzare dal delegato. I dati effettivi possono essere passati al delegato chiamando il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> (metodo).  
  
> [!NOTE]
>  I thread nel pool di thread gestiti sono thread in background. Vale a dire loro <xref:System.Threading.Thread.IsBackground%2A> sono proprietà `true`. Ciò significa che un <xref:System.Threading.ThreadPool> thread non manterrà un'applicazione in esecuzione dopo il termine di tutti i thread in primo piano.  
  
> [!IMPORTANT]
>  Quando il pool di thread riusa un thread, non cancella i dati nell'archiviazione thread-local o nei campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo. Pertanto, quando un metodo esamina l'archiviazione thread-local o i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo, i valori rilevati potrebbero essere rimasti un uso precedente del thread del pool.  
  
 È anche possibile accodare gli elementi di lavoro non correlati a un'operazione di attesa per il pool di thread. Per richiedere che un elemento di lavoro gestito da un thread nel pool di thread, chiamare il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (metodo). Questo metodo accetta come parametro un riferimento al metodo o delegato che verrà chiamato dal thread selezionato dal pool di thread. Non è possibile annullare un elemento di lavoro dopo che è stata accodata.  
  
 I timer della coda del timer e le operazioni di attesa registrata anche usano il pool di thread. Le funzioni di callback vengono accodate al pool di thread.  
  
 È un pool di thread per ogni processo. A partire da [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la dimensione predefinita del pool di thread per un processo dipende da diversi fattori, ad esempio la dimensione dello spazio degli indirizzi virtuali. Un processo può chiamare il metodo <xref:System.Threading.ThreadPool.GetMaxThreads%2A> per determinare il numero di thread. Il numero di thread nel pool di thread può essere modificato tramite la <xref:System.Threading.ThreadPool.SetMaxThreads%2A> (metodo). Ogni thread Usa la dimensione predefinita e viene eseguito con la priorità predefinita.  
  
> [!NOTE]
>  Il codice non gestito che ospita .NET Framework è possibile modificare le dimensioni del pool di thread usando il `CorSetMaxThreads` funzione, definito nel file di Mscoree. h.  
  
 Il pool di thread fornisce nuovi thread di lavoro o thread di completamento i/o su richiesta fino a quando non raggiunge il valore minimo per ogni categoria. Quando viene raggiunto un valore minimo, il pool di thread può creare thread aggiuntivi in tale categoria o attendere fino al completamento di alcune attività. A partire da [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], il pool di thread crea ed elimina i thread di lavoro per ottimizzare la velocità effettiva, definita come numero di attività completate per unità di tempo. Un numero troppo ridotto di thread potrebbe non usare in modo ottimale le risorse disponibili, mentre troppi thread potrebbero aumentare il conflitto per le risorse.  
  
> [!NOTE]
>  Quando la richiesta è bassa, il numero effettivo di thread del pool può scendere sotto i valori minimi.  
  
 È possibile usare il metodo <xref:System.Threading.ThreadPool.GetMinThreads%2A> per ottenere questi valori minimi.  
  
> [!CAUTION]
>  È possibile usare il <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodo per aumentare il numero minimo di thread. Tuttavia, un aumento non necessario di questi valori può provocare problemi di prestazioni. Se si avviano troppe attività contemporaneamente, potrebbero sembrare tutte lente. Nella maggior parte dei casi, il pool di thread offre prestazioni migliori con il proprio algoritmo per l'allocazione dei thread.  
  
   
  
## Examples  
 Nell'esempio seguente, il thread principale dell'applicazione Accoda un metodo denominato `ThreadProc` da eseguire in un pool di thread, viene sospeso per un secondo e quindi viene chiusa. Il `ThreadProc` metodo visualizza semplicemente un messaggio.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 Se impostare come commento la chiamata al <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo, il thread principale viene chiuso prima di metodo viene eseguito nel pool di thread.  Il pool di thread utilizza i thread in background, che non mantengono l'applicazione in esecuzione se tutti i thread in primo piano sono terminati.  (Questo è un esempio semplice di una race condition.)  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Associa un handle del sistema operativo al <see cref="T:System.Threading.ThreadPool" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <see cref="T:System.IntPtr" /> che contiene l'handle. È necessario che l'handle sia stato aperto per operazioni di I/O sovrapposte nella parte non gestita.</param>
        <summary>Associa un handle del sistema operativo al <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>
          <see langword="true" /> se l'handle è associato; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">Oggetto <see cref="T:System.Runtime.InteropServices.SafeHandle" /> che contiene l'handle del sistema operativo. È necessario che l'handle sia stato aperto per operazioni di I/O sovrapposte nella parte non gestita.</param>
        <summary>Associa un handle del sistema operativo al <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>
          <see langword="true" /> se l'handle è associato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `osHandle` il parametro deve essere un <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, che deriva dalla classe astratta <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="osHandle" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la possibilità di chiamare codice non gestito. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Numero di thread di lavoro disponibili.</param>
        <param name="completionPortThreads">Numero di thread I/O asincroni disponibili.</param>
        <summary>Recupera la differenza tra il numero massimo di thread del pool di thread restituito dal metodo <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> e il numero attualmente attivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> viene restituito, la variabile specificata dalla `workerThreads` contiene il numero di thread di lavoro aggiuntivi che possono essere avviati e la variabile specificata dalla `completionPortThreads` contiene il numero di thread i/o asincrono che può essere avviato.  
  
 Se non sono disponibili thread, richieste del pool di thread aggiuntivi rimangono in coda finché non diventano disponibili thread del pool.  
  
   
  
## Examples  
 Nell'esempio seguente visualizza il numero di thread di lavoro e i thread dei / o disponibile quando viene avviata un'app semplice.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Numero massimo di thread di lavoro nel pool di thread.</param>
        <param name="completionPortThreads">Numero massimo di thread I/O asincroni nel pool di thread.</param>
        <summary>Recupera il numero di richieste al pool di thread che possono essere attive contemporaneamente. Tutte le richieste al di fuori di tale numero rimangono in coda fino a quando non diventano disponibili thread di pool di thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Threading.ThreadPool.GetMaxThreads%2A> viene restituito, la variabile specificata dalla `workerThreads` contiene il numero massimo di thread di lavoro consentiti nel pool di thread e la variabile specificata dalla `completionPortThreads` contiene il numero massimo di thread dei / o asincroni consentito di pool di thread.  
  
 È possibile usare il <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> metodo per determinare il numero effettivo di thread nel pool di thread in qualsiasi momento.  
  
 È possibile usare il <xref:System.Threading.ThreadPool.SetMaxThreads%2A> per impostare il numero massimo di thread di lavoro e i thread dei / o asincroni nel pool di thread.  
  
 È possibile accodare come molte richieste del pool di thread come memoria di sistema consente. Se sono presenti più richieste rispetto ai pool di thread, le richieste aggiuntive rimangono in coda finché non diventano disponibili thread del pool.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come recuperare un conteggio del numero disponibile e massimo di thread nel pool di thread. Un elemento di lavoro è in coda che usa `FileStream` scrivere in modo asincrono per due file. I metodi di callback vengono temporizzati sovrapporsi. Un thread di lavoro gestisce l'elemento di lavoro e, a seconda della velocità e numero di processori nel computer, uno o due thread della porta di completamento di gestire le operazioni di scrittura.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Quando il metodo viene restituito, contiene il numero minimo di thread di lavoro che il pool di thread crea su richiesta.</param>
        <param name="completionPortThreads">Quando il metodo viene restituito, contiene il numero minimo di thread I/O asincroni che il pool di thread crea su richiesta.</param>
        <summary>Recupera il numero minimo di thread che il pool di thread crea, man mano che vengono effettuate nuove richieste, prima di passare a un algoritmo per la gestione della creazione e dell'eliminazione del thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il pool di thread fornisce nuovi thread di lavoro o thread di completamento i/o su richiesta fino a quando non raggiunge il valore minimo per ogni categoria. Per impostazione predefinita, il numero minimo di thread è impostato sul numero di processori in un sistema. Quando viene raggiunto il valore minimo, il pool di thread può creare thread aggiuntivi in tale categoria o attendere fino al completamento di alcune attività. A partire dal [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], il pool di thread crea ed elimina i thread per ottimizzare la velocità effettiva, che viene definita come il numero di attività completate per unità di tempo. Un numero troppo ridotto di thread potrebbe non usare in modo ottimale le risorse disponibili, mentre troppi thread potrebbero aumentare il conflitto per le risorse.  
  
> [!NOTE]
>  Quando la richiesta è bassa, il numero effettivo di thread del pool può scendere sotto i valori minimi.  
  
   
  
## Examples  
 Nell'esempio seguente imposta il numero minimo di thread di lavoro a quattro e mantiene il valore originale per il numero minimo di thread di completamento i/o asincrono.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Accoda un metodo da eseguire. Il metodo viene eseguito quando un thread del pool di thread diventa disponibile.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">Oggetto <see cref="T:System.Threading.WaitCallback" /> che rappresenta il metodo da eseguire.</param>
        <summary>Accoda un metodo da eseguire. Il metodo viene eseguito quando un thread del pool di thread diventa disponibile.</summary>
        <returns>
          <see langword="true" /> se il metodo viene accodato correttamente. Viene generata l'eccezione <see cref="T:System.NotSupportedException" /> se non è stato possibile accodare l'elemento di lavoro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile inserire i dati necessari per il metodo in coda i campi di istanza della classe in cui il metodo è definito o è possibile usare il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload che accetta un oggetto che contiene i dati necessari.  
  
> [!NOTE]
>  Gli utenti di Visual Basic è possono omettere il <xref:System.Threading.WaitCallback> costruttore e usare semplicemente il `AddressOf` operatore quando si passa il metodo di callback per <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic chiama automaticamente il costruttore di delegato corretto.  
  
## <a name="version-information"></a>Informazioni sulla versione  
 In .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (metodo). Nelle versioni precedenti, le informazioni dell'entità non viene propagate.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> overload del metodo per accodare un'attività, che è rappresentato dal `ThreadProc` metodo, da eseguire quando un thread diventa disponibile. Nessuna informazione di attività viene fornita con questo overload. Di conseguenza, le informazioni che sono disponibile per il `ThreadProc` metodo è limitato all'oggetto al quale appartiene il metodo.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Common Language Runtime (CLR) è ospitato e l'host non supporta questa azione.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <see cref="T:System.Threading.WaitCallback" /> che rappresenta il metodo da eseguire.</param>
        <param name="state">Oggetto contenente i dati che devono essere usati dal metodo.</param>
        <summary>Accoda un metodo da eseguire e specifica un oggetto che contiene i dati che dovranno essere usati dal metodo. Il metodo viene eseguito quando un thread del pool di thread diventa disponibile.</summary>
        <returns>
          <see langword="true" /> se il metodo viene accodato correttamente. Viene generata l'eccezione <see cref="T:System.NotSupportedException" /> se non è stato possibile accodare l'elemento di lavoro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il metodo di callback sono necessari dati complessi, è possibile definire una classe per contenere i dati.  
  
> [!NOTE]
>  Gli utenti di Visual Basic è possono omettere il <xref:System.Threading.WaitCallback> costruttore e usare semplicemente il `AddressOf` operatore quando si passa il metodo di callback per <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic chiama automaticamente il costruttore di delegato corretto.  
  
## <a name="version-information"></a>Informazioni sulla versione  
 In .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> (metodo). Nelle versioni precedenti, le informazioni dell'entità non viene propagate.  
  
   
  
## Examples  
 L'esempio seguente usa il pool di thread .NET per la quale calcolare il `Fibonacci` risultato per cinque numeri compresi tra 20 e 40. Ogni risultato di `Fibonacci` viene rappresentato dalla classe `Fibonacci`, che fornisce un metodo denominato `ThreadPoolCallback` per l'esecuzione del calcolo. Viene creato un oggetto che rappresenta ogni valore `Fibonacci`, il metodo `ThreadPoolCallback` viene passato a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, che assegna un thread disponibile del pool per eseguire il metodo.  
  
 Poiché ogni `Fibonacci` oggetto viene assegnato un valore semi-casuale da calcolare e poiché ogni thread sarà in competizione per il tempo del processore, non è possibile sapere in anticipo quanto tempo impiegherà per tutti i cinque risultati deve essere calcolato. Per questo motivo a ogni oggetto `Fibonacci` viene passata un'istanza della classe <xref:System.Threading.ManualResetEvent> durante la costruzione. Ogni oggetto segnala l'oggetto evento fornito quando cui il calcolo viene completato, che consente al thread primario può bloccare l'esecuzione con <xref:System.Threading.WaitHandle.WaitAll%2A> finché tutti e cinque `Fibonacci` gli oggetti hanno calcolato un risultato. Il metodo `Main` visualizza quindi ogni risultato `Fibonacci`.
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Common Language Runtime (CLR) è ospitato e l'host non supporta questa azione.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra un delegato in attesa di un <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> da registrare. Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegato <see cref="T:System.Threading.WaitOrTimerCallback" /> da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</param>
        <param name="state">Oggetto passato al delegato.</param>
        <param name="millisecondsTimeOutInterval">Timeout in millisecondi. Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore. Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</param>
        <param name="executeOnlyOnce">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</param>
        <summary>Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore intero con segno a 32 bit per il timeout in millisecondi.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> che incapsula l'handle nativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa. È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`. Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.  
  
 Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo Accoda il delegato specificato al pool di thread. Il delegato di un thread di lavoro verrà eseguito quando si verifica una delle operazioni seguenti:  
  
-   L'oggetto specificato è nello stato segnalato.  
  
-   L'intervallo di timeout scade.  
  
 Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo controlla lo stato corrente dell'oggetto specificato <xref:System.Threading.WaitHandle>. Se non è segnalato lo stato dell'oggetto, il metodo registra un'operazione di attesa. L'operazione di attesa viene eseguita da un thread dal pool di thread. Il delegato viene eseguito da un thread di lavoro quando lo stato dell'oggetto diventa segnalato o scade il timeout. Se il `timeOutInterval` parametro non è 0 (zero) e il `executeOnlyOnce` parametro è `false`, il timer viene reimpostato ogni volta che l'evento viene segnalato o scade il timeout.  
  
> [!IMPORTANT]
>  Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti. Invece di un <xref:System.Threading.Mutex>, usare un <xref:System.Threading.Semaphore> con un numero massimo di 1.  
  
 Per annullare l'operazione di attesa, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (metodo).  
  
 Attesa thread utilizza Win32 `WaitForMultipleObjects` (funzione) per monitorare le operazioni di attesa registrata. Pertanto, se è necessario usare lo stesso handle nativo del sistema operativo in più chiamate alla <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, è necessario duplicare l'handle utilizzando Win32 `DuplicateHandle` (funzione). Si noti che deve eseguire il pulse un oggetto evento passato al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, perché il thread di attesa potrebbe non rilevare che l'evento viene segnalato prima della reimpostazione.  
  
 Prima di restituire, la funzione modifica lo stato di alcuni tipi di oggetti di sincronizzazione. La modifica avviene solo per l'oggetto il cui stato segnalato ha causato la condizione di attesa devono essere soddisfatti. Ad esempio, il conteggio del semaforo viene ridotta di uno.  
  
## <a name="version-information"></a>Informazioni sulla versione  
 A partire da .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (metodo). Nelle versioni precedenti, le informazioni dell'entità non viene propagate.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> da registrare. Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegato <see cref="T:System.Threading.WaitOrTimerCallback" /> da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</param>
        <param name="state">Oggetto passato al delegato.</param>
        <param name="millisecondsTimeOutInterval">Timeout in millisecondi. Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore. Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</param>
        <param name="executeOnlyOnce">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</param>
        <summary>Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore intero con segno a 64 bit per il timeout in millisecondi.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> che incapsula l'handle nativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa. È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`. Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.  
  
 Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo Accoda il delegato specificato al pool di thread. Il delegato di un thread di lavoro verrà eseguito quando si verifica una delle operazioni seguenti:  
  
-   L'oggetto specificato è nello stato segnalato.  
  
-   L'intervallo di timeout scade.  
  
 Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo controlla lo stato corrente dell'oggetto specificato <xref:System.Threading.WaitHandle>. Se non è segnalato lo stato dell'oggetto, il metodo registra un'operazione di attesa. L'operazione di attesa viene eseguita da un thread dal pool di thread. Il delegato viene eseguito da un thread di lavoro quando lo stato dell'oggetto diventa segnalato o scade il timeout. Se il `timeOutInterval` parametro non è 0 (zero) e il `executeOnlyOnce` parametro è `false`, il timer viene reimpostato ogni volta che l'evento viene segnalato o scade il timeout.  
  
> [!IMPORTANT]
>  Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti. Invece di un <xref:System.Threading.Mutex>, usare un <xref:System.Threading.Semaphore> con un numero massimo di 1.  
  
 Per annullare l'operazione di attesa, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (metodo).  
  
 Attesa thread utilizza Win32 `WaitForMultipleObjects` (funzione) per monitorare le operazioni di attesa registrata. Pertanto, se è necessario usare lo stesso handle nativo del sistema operativo in più chiamate alla <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, è necessario duplicare l'handle utilizzando Win32 `DuplicateHandle` (funzione). Si noti che deve eseguire il pulse un oggetto evento passato al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, perché il thread di attesa potrebbe non rilevare che l'evento viene segnalato prima della reimpostazione.  
  
 Prima di restituire, la funzione modifica lo stato di alcuni tipi di oggetti di sincronizzazione. La modifica avviene solo per l'oggetto il cui stato segnalato ha causato la condizione di attesa devono essere soddisfatti. Ad esempio, il conteggio del semaforo viene ridotta di uno.  
  
## <a name="version-information"></a>Informazioni sulla versione  
 A partire da .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (metodo). Nelle versioni precedenti, le informazioni dell'entità non viene propagate.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> da registrare. Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegato <see cref="T:System.Threading.WaitOrTimerCallback" /> da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</param>
        <param name="state">Oggetto passato al delegato.</param>
        <param name="timeout">Il timeout rappresentato da un valore <see cref="T:System.TimeSpan" />. Se <c>timeout</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore. Se <c>timeout</c> è -1, l'intervallo di timeout della funzione non termina mai.</param>
        <param name="executeOnlyOnce">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</param>
        <summary>Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore <see cref="T:System.TimeSpan" /> per il timeout.</summary>
        <returns>
          <see cref="T:System.Threading.RegisteredWaitHandle" /> che incapsula l'handle nativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa. È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`. Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.  
  
 Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo Accoda il delegato specificato al pool di thread. Il delegato di un thread di lavoro verrà eseguito quando si verifica una delle operazioni seguenti:  
  
-   L'oggetto specificato è nello stato segnalato.  
  
-   L'intervallo di timeout scade.  
  
 Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo controlla lo stato corrente dell'oggetto specificato <xref:System.Threading.WaitHandle>. Se non è segnalato lo stato dell'oggetto, il metodo registra un'operazione di attesa. L'operazione di attesa viene eseguita da un thread dal pool di thread. Il delegato viene eseguito da un thread di lavoro quando lo stato dell'oggetto diventa segnalato o scade il timeout. Se il `timeOutInterval` parametro non è 0 (zero) e il `executeOnlyOnce` parametro è `false`, il timer viene reimpostato ogni volta che l'evento viene segnalato o scade il timeout.  
  
> [!IMPORTANT]
>  Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti. Invece di un <xref:System.Threading.Mutex>, usare un <xref:System.Threading.Semaphore> con un numero massimo di 1.  
  
 Per annullare l'operazione di attesa, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (metodo).  
  
 Attesa thread utilizza Win32 `WaitForMultipleObjects` (funzione) per monitorare le operazioni di attesa registrata. Pertanto, se è necessario usare lo stesso handle nativo del sistema operativo in più chiamate alla <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, è necessario duplicare l'handle utilizzando Win32 `DuplicateHandle` (funzione). Si noti che deve eseguire il pulse un oggetto evento passato al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, perché il thread di attesa potrebbe non rilevare che l'evento viene segnalato prima della reimpostazione.  
  
 Prima di restituire, la funzione modifica lo stato di alcuni tipi di oggetti di sincronizzazione. La modifica avviene solo per l'oggetto il cui stato segnalato ha causato la condizione di attesa devono essere soddisfatti. Ad esempio, il conteggio del semaforo viene ridotta di uno.  
  
## <a name="version-information"></a>Informazioni sulla versione  
 A partire da .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (metodo). Nelle versioni precedenti, le informazioni dell'entità non viene propagate.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="timeout" /> è minore di -1.</exception>
        <exception cref="T:System.NotSupportedException">Il parametro <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> da registrare. Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegato <see cref="T:System.Threading.WaitOrTimerCallback" /> da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</param>
        <param name="state">Oggetto passato al delegato.</param>
        <param name="millisecondsTimeOutInterval">Timeout in millisecondi. Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore. Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</param>
        <param name="executeOnlyOnce">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</param>
        <summary>Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un intero senza segno a 32 bit per il timeout in millisecondi.</summary>
        <returns>Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa. È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`. Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.  
  
 Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo Accoda il delegato specificato al pool di thread. Il delegato di un thread di lavoro verrà eseguito quando si verifica una delle operazioni seguenti:  
  
-   L'oggetto specificato è nello stato segnalato.  
  
-   L'intervallo di timeout scade.  
  
 Il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo controlla lo stato corrente dell'oggetto specificato <xref:System.Threading.WaitHandle>. Se non è segnalato lo stato dell'oggetto, il metodo registra un'operazione di attesa. L'operazione di attesa viene eseguita da un thread dal pool di thread. Il delegato viene eseguito da un thread di lavoro quando lo stato dell'oggetto diventa segnalato o scade il timeout. Se il `timeOutInterval` parametro non è 0 (zero) e il `executeOnlyOnce` parametro è `false`, il timer viene reimpostato ogni volta che l'evento viene segnalato o scade il timeout.  
  
> [!IMPORTANT]
>  Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti. Invece di un <xref:System.Threading.Mutex>, usare un <xref:System.Threading.Semaphore> con un numero massimo di 1.  
  
 Per annullare l'operazione di attesa, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> (metodo).  
  
 Attesa thread utilizza Win32 `WaitForMultipleObjects` (funzione) per monitorare le operazioni di attesa registrata. Pertanto, se è necessario usare lo stesso handle nativo del sistema operativo in più chiamate alla <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, è necessario duplicare l'handle utilizzando Win32 `DuplicateHandle` (funzione). Si noti che deve eseguire il pulse un oggetto evento passato al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, perché il thread di attesa potrebbe non rilevare che l'evento viene segnalato prima della reimpostazione.  
  
 Prima di restituire, la funzione modifica lo stato di alcuni tipi di oggetti di sincronizzazione. La modifica avviene solo per l'oggetto il cui stato segnalato ha causato la condizione di attesa devono essere soddisfatti. Ad esempio, il conteggio del semaforo viene ridotta di uno.  
  
## <a name="version-information"></a>Informazioni sulla versione  
 A partire da .NET Framework versione 2.0, il <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valore della proprietà viene propagato al thread di lavoro in coda tramite il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> (metodo). Nelle versioni precedenti, le informazioni dell'entità non viene propagate.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo per eseguire un metodo di callback specificato quando viene segnalato un handle di attesa specificato. In questo esempio, è il metodo di callback `WaitProc`, e l'handle di attesa è un <xref:System.Threading.AutoResetEvent>.  
  
 L'esempio definisce un `TaskInfo` classe per contenere le informazioni che viene passate al callback durante l'esecuzione. Nell'esempio viene creato un `TaskInfo` dell'oggetto e lo assegna alcuni dati di tipo stringa. Il <xref:System.Threading.RegisteredWaitHandle> restituito dal <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo viene assegnato al `Handle` campo il `TaskInfo` dell'oggetto in modo che il metodo di callback può accedere al <xref:System.Threading.RegisteredWaitHandle>.  
  
 Oltre a specificare `TaskInfo` dell'oggetto da passare al metodo di callback, la chiamata al <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo specifica il <xref:System.Threading.AutoResetEvent> che dovrà attendere l'attività, una <xref:System.Threading.WaitOrTimerCallback> delegato che rappresenta il `WaitProc` metodo di callback, un un secondo intervallo di timeout e più callback.  
  
 Quando il thread principale segnala la <xref:System.Threading.AutoResetEvent> chiamando relativi <xref:System.Threading.EventWaitHandle.Set%2A> metodo, il <xref:System.Threading.WaitOrTimerCallback> delegato viene richiamato. Il `WaitProc` metodo test <xref:System.Threading.RegisteredWaitHandle> per determinare se si è verificato un timeout. Se è stato richiamato il callback perché è stato segnalato l'handle di attesa, il `WaitProc` metodo annulla la registrazione di <xref:System.Threading.RegisteredWaitHandle>, l'arresto di callback aggiuntivi. Nel caso di un timeout, l'attività resta in attesa. Il `WaitProc` metodo termina con la stampa un messaggio nella console.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Numero massimo di thread di lavoro nel pool di thread.</param>
        <param name="completionPortThreads">Numero massimo di thread I/O asincroni nel pool di thread.</param>
        <summary>Imposta il numero di richieste al pool di thread che possono essere attivate contemporaneamente. Tutte le richieste al di fuori di tale numero rimangono in coda fino a quando non diventano disponibili thread di pool di thread.</summary>
        <returns>
          <see langword="true" /> se la modifica ha esito positivo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Non è possibile impostare il numero massimo di thread di lavoro o thread di completamento i/o su un numero inferiore al numero di processori nel computer. Per determinare il numero di processori è presente, recuperare il valore della <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> proprietà. È inoltre, non è possibile impostare il numero massimo di thread di lavoro o thread di completamento i/o su un numero inferiore al numero corrispondente minimo di thread di lavoro o thread di completamento i/o. Per determinare le dimensioni del pool di thread minimi, chiamare il <xref:System.Threading.ThreadPool.GetMinThreads%2A> (metodo).  
  
 Se è ospitato in common language runtime, ad esempio da Internet Information Services (IIS) o SQL Server, l'host può limitare o impedire le modifiche alla dimensione del pool di thread.  
  
 Prestare attenzione quando si modifica il numero massimo di thread nel pool di thread. Il codice potrebbe essere utile, la modifica potrebbe avere effetti negativi sulle librerie di codice che si utilizza.  
  
 Impostare le dimensioni del pool di thread troppo elevato può causare problemi di prestazioni. Se troppi thread sono in esecuzione nello stesso momento, il passaggio da un sovraccarico diventa un fattore significativo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la possibilità di controllare i thread. Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Il numero minimo di thread di lavoro che vengono creati su richiesta dal pool di thread.</param>
        <param name="completionPortThreads">Il numero minimo di thread I/O asincroni che vengono creati su richiesta dal pool di thread.</param>
        <summary>Imposta il numero minimo di thread che il pool di thread crea, man mano che vengono effettuate nuove richieste, prima di passare a un algoritmo per la gestione della creazione e dell'eliminazione del thread.</summary>
        <returns>
          <see langword="true" /> se la modifica ha esito positivo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il pool di thread fornisce nuovi thread di lavoro o thread di completamento i/o su richiesta fino a quando non raggiunge il valore minimo per ogni categoria. Quando viene raggiunto il valore minimo, il pool di thread può creare thread aggiuntivi in tale categoria o attendere fino al completamento di alcune attività. A partire dal [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], il pool di thread crea ed elimina i thread per ottimizzare la velocità effettiva, che viene definita come il numero di attività completate per unità di tempo. Un numero troppo ridotto di thread potrebbe non usare in modo ottimale le risorse disponibili, mentre troppi thread potrebbero aumentare il conflitto per le risorse.  
  
 Quando la richiesta è bassa, il numero effettivo di thread del pool può scendere sotto i valori minimi.  
  
 Se si specifica un numero negativo o un numero maggiore del numero massimo di pool di thread attivi (ottenuti usando il <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> restituisce `false` e non viene modificato uno dei valori minimi.  
  
> [!CAUTION]
>  Per impostazione predefinita, il numero minimo di thread è impostato sul numero di processori in un sistema. È possibile usare il <xref:System.Threading.ThreadPool.SetMinThreads%2A> metodo per aumentare la ofthreads numero minimo. Tuttavia, un aumento non necessario di questi valori può provocare problemi di prestazioni. Se si avviano troppe attività contemporaneamente, potrebbero sembrare tutte lente. Nella maggior parte dei casi, il pool di thread offrono prestazioni migliori con il proprio algoritmo di allocazione dei thread. La riduzione al minimo a inferiore al numero di processori può anche influire negativamente sulle prestazioni.  
  
   
  
## Examples  
 Nell'esempio seguente imposta il numero minimo di thread di lavoro a quattro e mantiene il valore originale per il numero minimo di thread di completamento i/o asincrono.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la possibilità di controllare i thread. Valore dell'autorizzazione: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">Struttura <see cref="T:System.Threading.NativeOverlapped" /> da accodare.</param>
        <summary>Accoda un'operazione di I/O sovrapposta per l'esecuzione.</summary>
        <returns>
          <see langword="true" /> se l'accodamento dell'operazione a una porta di completamento di I/O è stato eseguito correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per informazioni sull'uso di nativo Win32 overlapped dei / o, vedere la <xref:System.Threading.Overlapped> (classe), il <xref:System.Threading.NativeOverlapped> struttura e il `OVERLAPPED` struttura in Win32 Platform SDK.  
  
> [!CAUTION]
>  Uso di <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> metodo potrebbe inavvertitamente aprire un problema di sicurezza. Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack. Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, lo stack del thread del pool non dispone il contesto dei chiamanti in posizione effettive. Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">Oggetto <see cref="T:System.Threading.WaitCallback" /> che rappresenta il delegato da richiamare quando un thread nel pool di thread sceglie l'elemento di lavoro.</param>
        <param name="state">Oggetto passato al delegato quando viene servito dal pool di thread.</param>
        <summary>Accoda il delegato specificato al pool di thread, ma non propaga lo stack di chiamata nel thread di lavoro.</summary>
        <returns>
          <see langword="true" /> se il metodo viene eseguito correttamente. Viene generata l'eccezione <see cref="T:System.OutOfMemoryException" /> se non è stato possibile accodare l'elemento di lavoro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza di <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> metodo <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> non propaga lo stack di chiamata al thread di lavoro. In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.  
  
> [!CAUTION]
>  Usando <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> potrebbe inavvertitamente aprire un problema di sicurezza. Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack. Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive. Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.ApplicationException">È stata rilevata una condizione di memoria insufficiente.</exception>
        <exception cref="T:System.OutOfMemoryException">Non è stato possibile accodare l'elemento di lavoro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBack" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra un delegato per l'attesa di un <see cref="T:System.Threading.WaitHandle" />, ma non propaga lo stack di chiamata nel thread di lavoro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> da registrare. Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegato da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</param>
        <param name="state">Oggetto passato al delegato.</param>
        <param name="millisecondsTimeOutInterval">Timeout in millisecondi. Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore. Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</param>
        <param name="executeOnlyOnce">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</param>
        <summary>Registra un delegato per l'attesa di un <see cref="T:System.Threading.WaitHandle" />, specificando un intero con segno a 32 bit per il timeout in millisecondi. Questo metodo non propaga lo stack di chiamate al thread di lavoro.</summary>
        <returns>Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza di <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> non propaga lo stack di chiamata al thread di lavoro. In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.  
  
> [!CAUTION]
>  Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> potrebbe inavvertitamente aprire un problema di sicurezza. Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack. Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive. Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.  
  
 Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.  
  
 Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa. È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`. Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> da registrare. Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegato da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</param>
        <param name="state">Oggetto passato al delegato.</param>
        <param name="millisecondsTimeOutInterval">Timeout in millisecondi. Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore. Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</param>
        <param name="executeOnlyOnce">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</param>
        <summary>Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore intero con segno a 64 bit per il timeout in millisecondi. Questo metodo non propaga lo stack di chiamate al thread di lavoro.</summary>
        <returns>Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza di <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> non propaga lo stack di chiamata al thread di lavoro. In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.  
  
> [!CAUTION]
>  Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> potrebbe inavvertitamente aprire un problema di sicurezza. Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack. Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive. Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.  
  
 Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.  
  
 Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa. È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`. Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="millisecondsTimeOutInterval" /> è minore di -1.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> da registrare. Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegato da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</param>
        <param name="state">Oggetto passato al delegato.</param>
        <param name="timeout">Il timeout rappresentato da un valore <see cref="T:System.TimeSpan" />. Se <c>timeout</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore. Se <c>timeout</c> è -1, l'intervallo di timeout della funzione non termina mai.</param>
        <param name="executeOnlyOnce">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</param>
        <summary>Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un valore <see cref="T:System.TimeSpan" /> per il timeout. Questo metodo non propaga lo stack di chiamate al thread di lavoro.</summary>
        <returns>Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza di <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> non propaga lo stack di chiamata al thread di lavoro. In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.  
  
> [!CAUTION]
>  Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> potrebbe inavvertitamente aprire un problema di sicurezza. Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack. Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive. Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.  
  
 Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.  
  
 Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa. È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`. Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="timeout" /> è minore di -1.</exception>
        <exception cref="T:System.NotSupportedException">Il parametro <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <see cref="T:System.Threading.WaitHandle" /> da registrare. Usare una classe <see cref="T:System.Threading.WaitHandle" /> diversa da <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Delegato da chiamare quando il parametro <c>waitObject</c> riceve un segnale.</param>
        <param name="state">Oggetto passato al delegato.</param>
        <param name="millisecondsTimeOutInterval">Timeout in millisecondi. Se il parametro <c>millisecondsTimeOutInterval</c> è pari a 0 (zero), la funzione verifica lo stato dell'oggetto e restituisce immediatamente un valore. Se <c>millisecondsTimeOutInterval</c> è -1, l'intervallo di timeout della funzione non termina mai.</param>
        <param name="executeOnlyOnce">Viene restituito <see langword="true" /> per indicare che il thread non attenderà più in base al parametro <c>waitObject</c> dopo la chiamata al delegato. <see langword="false" /> per indicare che il timer viene reimpostato ogni volta che l'operazione di attesa viene completata fino all'annullamento della registrazione dell'attesa.</param>
        <summary>Registra un delegato per l'attesa di un oggetto <see cref="T:System.Threading.WaitHandle" />, specificando un intero senza segno a 32 bit per il timeout in millisecondi. Questo metodo non propaga lo stack di chiamate al thread di lavoro.</summary>
        <returns>Oggetto <see cref="T:System.Threading.RegisteredWaitHandle" /> che può essere usato per annullare l'operazione di attesa registrata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A differenza di <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> metodo <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> non propaga lo stack di chiamata al thread di lavoro. In questo modo il codice perde lo stack di chiamate e in tal modo di elevare i privilegi di sicurezza.  
  
> [!CAUTION]
>  Usando <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> potrebbe inavvertitamente aprire un problema di sicurezza. Sicurezza dall'accesso di codice si basa relative controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack. Quando lavoro è in coda in un thread di pool di thread tramite <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, lo stack del thread del pool non avrà il contesto dei chiamanti in posizione effettive. Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.  
  
 Usando un <xref:System.Threading.Mutex> per `waitObject` non fornisce l'esclusione reciproca per i callback perché l'API Win32 sottostante Usa il valore predefinito `WT_EXECUTEDEFAULT` flag, pertanto ogni callback viene inviato in un pool di thread distinti.  
  
 Al termine usando il <xref:System.Threading.RegisteredWaitHandle> restituito da questo metodo, chiamare il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo per rilasciare i riferimenti all'handle di attesa. È consigliabile chiamare sempre il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> metodo, anche se si specifica `true` per `executeOnlyOnce`. Funzionamento di Garbage collection più efficiente se si chiama il <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> invece del metodo a seconda del finalizzatore dell'handle di attesa registrata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>