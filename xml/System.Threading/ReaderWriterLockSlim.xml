<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3464038fcf06fcd6ab722a9c4b6f82b812141c99" />
    <Meta Name="ms.sourcegitcommit" Value="84c54c0c7d64827a5637d1f05e74e1f0598606a1" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/27/2018" />
    <Meta Name="ms.locfileid" Value="42942853" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Rappresenta un blocco che viene usato per gestire l'accesso a una risorsa, consentendo più thread per la lettura o l'accesso esclusivo per la scrittura.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare <xref:System.Threading.ReaderWriterLockSlim> per proteggere una risorsa che viene letta da più thread e scritta da un solo thread alla volta. <xref:System.Threading.ReaderWriterLockSlim> consente a più thread essere in modalità di lettura, consente a un solo thread essere in modalità di scrittura con la proprietà esclusiva del blocco e consente a un thread che ha accesso in lettura sia in modalità di lettura aggiornabile, da cui il thread può eseguire l'aggiornamento alla modalità di scrittura senza la necessità di lasciare lo s accesso in lettura alla risorsa.  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim> è simile a <xref:System.Threading.ReaderWriterLock>, ma include regole semplificate per la ricorsione e per l'aggiornamento e il downgrade dello stato del blocco. <xref:System.Threading.ReaderWriterLockSlim> evita molti casi di deadlock potenziale. Inoltre, le prestazioni di <xref:System.Threading.ReaderWriterLockSlim> sono significativamente migliori di <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> è consigliato per tutte le nuove fasi di sviluppo.  
  
 Per impostazione predefinita, le nuove istanze di <xref:System.Threading.ReaderWriterLockSlim> vengono creati con la <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag e non consentono la ricorsione. Il criterio predefinito è consigliato per tutti i nuovi progetti di sviluppo, poiché la ricorsione introduce complicazioni non necessari e rende il codice più soggette a deadlock. Per semplificare la migrazione da esistente i progetti che usano <xref:System.Threading.Monitor> oppure <xref:System.Threading.ReaderWriterLock>, è possibile utilizzare il <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag per creare istanze di <xref:System.Threading.ReaderWriterLockSlim> che consentono la ricorsione.  
  
 Un thread può accedere al blocco in tre modalità: lettura modalità, modalità di scrittura e modalità di lettura aggiornabile. (Nella parte restante di questo argomento, "modalità di lettura aggiornabile" fa riferimento come "modalità aggiornabile" e la frase "immettere `x` modalità" viene usato preferita la frase più lunga "Immettere il blocco in `x` modalità".)  
  
 Indipendentemente dai criteri di ricorsione, solo un thread può essere in modalità di scrittura in qualsiasi momento. Quando un thread è in modalità scrittura, nessun altro thread può accedere al blocco in qualsiasi modalità. Solo un thread può essere in modalità aggiornabile in qualsiasi momento. Qualsiasi numero di thread può essere in modalità di lettura e può esistere un solo thread in modalità aggiornabile mentre altri thread sono in modalità lettura.  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare il tipo direttamente, chiamare relativi <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 <xref:System.Threading.ReaderWriterLockSlim> ha gestito l'affinità di thread; vale a dire, ognuna <xref:System.Threading.Thread> oggetto deve eseguire la propria chiamate di metodo per attivare e disattivare la modalità di blocco. Nessun thread può modificare la modalità di un altro thread.  
  
 Se un <xref:System.Threading.ReaderWriterLockSlim> non supporta la ricorsione, un thread che prova ad attivare il blocco può essere bloccato per diversi motivi:  
  
-   Un thread che prova ad attivare la modalità lettura blocchi se sono presenti thread in attesa di immettere la modalità scrittura o è presente un singolo thread in modalità di scrittura.  
  
    > [!NOTE]
    >  Blocchi i lettori di nuovo quando vengono messe in coda i writer è un criterio di equità di blocco che predilige i thread. I criteri di equità correnti bilanciano equità tra i lettori e writer, per aumentare la velocità effettiva in scenari più comuni. Le versioni future del [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] può introdurre nuovi criteri di equità.  
  
-   Un thread che prova ad attivare i blocchi alla modalità aggiornabile se esiste già un thread in modalità aggiornabile, se sono presenti thread in attesa di attivazione della modalità scrittura, o se è presente un singolo thread in modalità di scrittura.  
  
-   Un thread che prova ad attivare i blocchi in modalità scrittura se è presente un thread in una qualsiasi delle tre modalità.  
  
## <a name="upgrading-and-downgrading-locks"></a>Blocchi di aggiornamento e downgrade  
 La modalità aggiornabile è destinata ai casi in cui un thread in genere legge da risorsa protetta, ma potrebbe essere necessario per la scrittura se vengono soddisfatte determinate condizioni. Un thread entrato in un <xref:System.Threading.ReaderWriterLockSlim> in modalità aggiornabile con accesso in lettura alla risorsa protetta e può essere aggiornato alla modalità di scrittura chiamando il <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodi. Poiché può esserci un solo thread in modalità aggiornabile in una fase, l'aggiornamento alla modalità di scrittura non è possibile deadlock durante la ricorsione non è consentita, ovvero i criteri predefiniti.  
  
> [!IMPORTANT]
>  Indipendentemente dai criteri di ricorsione, un thread che ha inizialmente acceduto leggere in modalità non è consentita l'aggiornamento alla modalità aggiornabile o modalità scrittura, perché ciò comporterebbe una forte probabilità di deadlock. Ad esempio, se due thread in modalità lettura che entrambi tentano di accedere alla modalità di scrittura, provocano un deadlock. La modalità aggiornabile è progettata per evitare deadlock di questo tipo.  
  
 Se sono presenti altri thread in modalità di lettura, il thread che sta eseguendo l'aggiornamento di blocchi. Mentre il thread è bloccato, altri thread che tentano di accedere alla modalità di lettura vengono bloccate. Quando tutti i thread sono usciti dalla modalità di lettura, il thread bloccato aggiornabile passa alla modalità di scrittura. Se sono presenti altri thread in attesa di immettere la modalità scrittura, rimangono bloccati, perché il thread singolo che si trova in modalità aggiornabile impedisce loro di ottenere accesso esclusivo alla risorsa.  
  
 Quando il thread in modalità aggiornabile esce dalla modalità di scrittura, altri thread in attesa di attivare la modalità di lettura possono farlo, a meno che non sono presenti thread in attesa di immettere la modalità scrittura. Il thread in modalità aggiornabile può eseguire l'aggiornamento e il downgrade a tempo indeterminato, purché è il thread che scrive alla risorsa protetta.  
  
> [!IMPORTANT]
>  Se si consente a più thread immettere modalità di scrittura o la modalità aggiornabile, che non è necessario consentire un solo thread monopolizza modalità aggiornabile. In caso contrario, i thread che tentano di accedere in scrittura modalità direttamente verrà bloccata per un periodo illimitato e mentre sono bloccati, altri thread sarà in grado di attivare la modalità di lettura.  
  
 Possa effettuare il downgrade di un thread in modalità aggiornabile per la modalità lettura chiamando prima il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo e chiamando quindi il <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> (metodo). Questo modello il downgrade è consentito anche per tutti i criteri di ricorsione di blocco, <xref:System.Threading.LockRecursionPolicy.NoRecursion>.  
  
 Dopo il downgrade alla modalità di lettura, un thread non è possibile immettere nuovamente la modalità aggiornabile fino a quando non è stato terminato dalla modalità di lettura.  
  
## <a name="entering-the-lock-recursively"></a>Immettere il blocco in modo ricorsivo  
 È possibile creare un <xref:System.Threading.ReaderWriterLockSlim> che supporta l'immissione di blocco ricorsiva tramite il <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> costruttore che consente di specificare criteri di blocco e specificando <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.  
  
> [!NOTE]
>  L'uso di ricorsione non è consigliabile per i nuovi sviluppi, in quanto introduce complessità non necessarie e rende il codice più soggette a deadlock.  
  
 Per un <xref:System.Threading.ReaderWriterLockSlim> che consente la ricorsione, si possono affermare seguenti sulle modalità di un thread può accedere:  
  
-   Un thread in modalità di lettura possa accedere in modo ricorsivo modalità lettura, ma non è possibile immettere la modalità scrittura o in modalità aggiornabile. Se tenta di eseguire questa operazione, un <xref:System.Threading.LockRecursionException> viene generata un'eccezione. Immissione di leggere la modalità e immettendo quindi la modalità scrittura o la modalità aggiornabile è un modello con una forte probabilità di deadlock, in modo che non è consentito. Come illustrato in precedenza, la modalità aggiornabile viene fornita per i casi in cui è necessario un blocco di aggiornamento.  
  
-   Un thread in modalità aggiornabile possibile immettere la modalità di scrittura e/o modalità di lettura e può accedere a ognuna le tre modalità ricorsiva. Tuttavia, un tentativo di immettere scrivere modalità blocchi se sono presenti altri thread in modalità lettura.  
  
-   Un thread in modalità di scrittura può immettere la modalità lettura e/o la modalità aggiornabile e possibile immettere qualsiasi in modo ricorsivo le tre modalità.  
  
-   Un thread che non ha acceduto al blocco è possibile immettere qualsiasi modalità. Questo tentativo può essere bloccato per gli stessi motivi un tentativo di attivare un blocco di non ricorsiva.  
  
 Un thread può uscire le modalità che è stato attivato in qualsiasi ordine, purché si conclude ogni modalità esattamente come tutte le volte che passato in tale modalità. Se un thread prova a uscire da una modalità troppe volte o per uscire da una modalità non ha acceduto, un <xref:System.Threading.SynchronizationLockException> viene generata un'eccezione.  
  
## <a name="lock-states"></a>Stati di blocco  
 Potrebbe essere utile sapere che il blocco in termini di stati. Oggetto <xref:System.Threading.ReaderWriterLockSlim> può trovarsi in uno dei quattro stati: non immesso, lettura, aggiornamento e scrittura.  
  
-   Non è stato immesso: In questo stato, nessun thread ha acceduto al blocco (o tutti i thread sono usciti dal blocco).  
  
-   Leggere: In questo stato, uno o più thread hanno acceduto al blocco per l'accesso in lettura alla risorsa protetta.  
  
    > [!NOTE]
    >  Un thread può accedere al blocco in modalità di lettura usando il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodi, o il downgrade dalla modalità aggiornabile.  
  
-   Aggiornamento: In questo stato, un thread ha acceduto al blocco per l'accesso in lettura con la possibilità di eseguire l'aggiornamento per l'accesso in scrittura (vale a dire, in modalità aggiornabile), e zero o più thread hanno acceduto al blocco per l'accesso in lettura. Non più di un thread alla volta può attivare il blocco con l'opzione per aggiornare; gli altri thread che tenta di accedere alla modalità aggiornabile vengono bloccate.  
  
-   Scrittura: In questo stato, un thread ha acceduto al blocco per l'accesso in scrittura alla risorsa protetta. Thread in questione sia esclusivo proprietaria del blocco. Un altro thread che prova ad attivare il blocco per qualsiasi motivo è bloccato.  
  
 La tabella seguente descrive le transizioni tra stati di blocco, per i blocchi che non consentono la ricorsione, quando un thread `t` accetta l'azione descritta nella colonna più a sinistra. Al momento accetta l'azione, `t` non possiede alcuna modalità. (Il caso speciale in cui `t` è in modalità aggiornabile è descritto nel piè di pagina di tabella.) La prima riga descrive lo stato inizio del blocco. Le celle viene descritto cosa succede al thread e visualizzare le modifiche apportate allo stato di blocco tra parentesi.  
  
||Nessun accesso (N)|Read (R)|Aggiornamento (U)|Scrittura (S)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` passa alla modalità di lettura|`t` assume (R).|`t` blocchi se sono thread in attesa per la modalità scrittura; in caso contrario, `t` immette.|`t` blocchi se sono thread in attesa per la modalità scrittura; in caso contrario, `t` immette.<sup> 1</sup>|`t` blocchi.|  
|`t` passa alla modalità aggiornabile|`t` assume (U).|`t` blocchi se sono thread in attesa per la modalità di scrittura o la modalità di aggiornamento; in caso contrario, `t` immette (U).|`t` blocchi.|`t` blocchi.|  
|`t` passa alla modalità di scrittura|`t` immette (W).|`t` blocchi.|`t` blocchi. <sup>2</sup>|`t` blocchi.|  
  
 <sup>1</sup> se `t` avvia orizzontale in modalità aggiornabile, entra in modalità lettura. Blocca mai questa azione. Lo stato del blocco rimane invariato. (Il thread possa quindi completare un downgrade alla modalità di lettura da disattivare la modalità aggiornabile.)  
  
 <sup>2</sup> se `t` viene avviato in modalità aggiornabile, si blocca se sono presenti thread in modalità lettura. In caso contrario, che venga aggiornato alla modalità di scrittura. I cambiamenti di stato di blocco per scrittura (S). Se `t` blocca perché sono presenti thread in modalità di lettura, passa alla modalità di scrittura, non appena l'ultimo thread esce dalla modalità di lettura, anche se sono presenti thread in attesa di immettere la modalità scrittura.  
  
 Quando una modifica dello stato è dovuto al fatto che un thread termina il blocco, il thread successivo che riattivati viene selezionato come indicato di seguito:  
  
-   In primo luogo, un thread in attesa per la modalità scrittura ed è già in modalità aggiornabile (possono essere presenti al massimo un thread di questo tipo).  
  
-   In mancanza di questo, un thread in attesa per la modalità scrittura.  
  
-   In mancanza di questo, un thread in attesa per la modalità aggiornabile.  
  
-   Esito negativo, tutti i thread in attesa per la modalità lettura.  
  
 Lo stato successivo del blocco è sempre di scrittura (W) nei primi due casi e aggiornamento (U) nel terzo caso, indipendentemente dallo stato del blocco quando il thread in fase di chiusura ha attivato la modifica dello stato. Nell'ultimo caso, lo stato del blocco è eseguire l'aggiornamento (U) se non vi è un thread in modalità aggiornabile dopo la modifica dello stato e Read (R) in caso contrario, indipendentemente dallo stato precedente.  
  
   
  
## Examples  
 L'esempio seguente illustra una semplice cache sincronizzata che contiene le stringhe con chiavi di interi. Un'istanza di <xref:System.Threading.ReaderWriterLockSlim> utilizzato per sincronizzare l'accesso al <xref:System.Collections.Generic.Dictionary%602> che funge da cache interna.  
  
 L'esempio include metodi semplici per aggiungere alla cache, eliminare dalla cache e leggere dalla cache. Per illustrare i timeout, l'esempio include un metodo che viene aggiunto alla cache solo se è possibile eseguire questa operazione all'interno di un timeout specificato.  
  
 Per illustrare la modalità aggiornabile, l'esempio include un metodo che recupera il valore associato alla chiave e lo confronta con un nuovo valore. Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica. Se viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore. Se il valore è stato modificato, viene aggiornata. La modalità aggiornabile consente al thread di eseguire l'aggiornamento da accesso in lettura per l'accesso in scrittura in base alle necessità, senza il rischio di deadlock.  
  
 L'esempio include un'enumerazione annidata che consente di specificare i valori restituiti per il metodo che illustra la modalità aggiornabile.  
  
 L'esempio Usa il costruttore predefinito per creare il blocco, in modo che non è consentita la ricorsione. Programmazione di <xref:System.Threading.ReaderWriterLockSlim> è più semplice e meno soggetta a errori quando il blocco non supporta la ricorsione.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Il codice seguente usa quindi il `SynchronizedCache` oggetto usato per archiviare un dizionario di nomi vegetali. Crea tre attività. Il primo vengono scritti i nomi di verdure archiviate in una matrice a un `SynchronizedCache` istanza. La seconda e terza attività visualizzare i nomi di verdura, il primo in modo crescente (da bassa indice in indice elevata), la seconda in ordine decrescente. L'attività finale cerca la stringa "cucumber" e, quando la trova, chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo per sostituire la stringa "verde bean".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> con i valori predefiniti delle proprietà.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oggetto <xref:System.Threading.ReaderWriterLockSlim> che viene inizializzato con questo costruttore non consente la ricorsione. Quindi la proprietà <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> restituisce <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.  
  
 Per altre informazioni sui criteri di ricorsione e i relativi effetti, vedere la <xref:System.Threading.LockRecursionPolicy> enumerazione e <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
   
  
## Examples  
 L'esempio seguente illustra una semplice cache sincronizzata che contiene le stringhe con chiavi di interi. Un'istanza di <xref:System.Threading.ReaderWriterLockSlim> utilizzato per sincronizzare l'accesso al <xref:System.Collections.Generic.Dictionary%602> che funge da cache interna. Il costruttore senza parametri consente di creare il blocco.  
  
 L'esempio include metodi semplici per aggiungere alla cache, eliminare dalla cache e leggere dalla cache. Per illustrare i timeout, l'esempio include un metodo che viene aggiunto alla cache solo se è possibile eseguire questa operazione all'interno di un timeout specificato.  
  
 Per illustrare la modalità aggiornabile, l'esempio include un metodo che recupera il valore associato alla chiave e lo confronta con un nuovo valore. Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica. Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore. Se il valore è stato modificato, viene aggiornata. La modalità aggiornabile consente al thread di eseguire l'aggiornamento da accesso in lettura per l'accesso in scrittura in base alle necessità, senza il rischio di deadlock.  
  
 L'esempio include un'enumerazione annidata che consente di specificare i valori restituiti per il metodo che illustra la modalità aggiornabile.  
  
 L'esempio Usa il costruttore predefinito per creare il blocco, in modo che non è consentita la ricorsione. Programmazione di <xref:System.Threading.ReaderWriterLockSlim> è più semplice e meno soggetta a errori quando il blocco non supporta la ricorsione.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 Il codice seguente usa quindi il `SynchronizedCache` oggetto usato per archiviare un dizionario di nomi vegetali. Crea tre attività. Il primo vengono scritti i nomi di verdure archiviate in una matrice a un `SynchronizedCache` istanza. La seconda e terza attività visualizzare i nomi di verdura, il primo in modo crescente (da bassa indice in indice elevata), la seconda in ordine decrescente. L'attività finale cerca la stringa "cucumber" e, quando la trova, chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo per sostituire la stringa "verde bean".  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, specificando i criteri di ricorsione del blocco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Criteri di ricorsione determinano le restrizioni sul thread che accedono al blocco più volte. Ad esempio, se un blocco è stato creato con <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> e un thread ha acceduto al blocco in modalità lettura <xref:System.Threading.LockRecursionException> viene generata se il thread tenta di accedere nuovamente al blocco in modalità lettura. Analogamente, se un thread ha acceduto al blocco in modalità scrittura, <xref:System.Threading.LockRecursionException> viene generata se il thread tenta di accedere nuovamente al blocco in qualsiasi modalità.  
  
> [!NOTE]
>  Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o un downgrade dalla modalità indipendentemente dall'impostazione di criteri di ricorsione di blocco di lettura.  
  
 Indipendentemente dai criteri di ricorsione, un thread che ha inizialmente acceduto leggere in modalità non è consentita l'aggiornamento alla modalità aggiornabile o modalità scrittura, perché ciò comporterebbe una forte probabilità di deadlock.  
  
 Per altre informazioni sui criteri di ricorsione e i relativi effetti, vedere la <xref:System.Threading.LockRecursionPolicy> enumerazione e <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
   
  
## Examples  
 L'esempio seguente illustra due scenari di eccezione, che dipende la <xref:System.Threading.LockRecursionPolicy> impostazione e l'altro no.  
  
 Nel primo scenario, il thread entra in modalità di lettura e quindi tenta di accedere in modo ricorsivo modalità lettura. Se il <xref:System.Threading.ReaderWriterLockSlim> viene creato usando il costruttore predefinito, che imposta i criteri di ricorsione <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, viene generata un'eccezione. Se <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> viene usato per creare il <xref:System.Threading.ReaderWriterLockSlim>, viene generata alcuna eccezione.  
  
 Nel secondo scenario, il thread entra in modalità di lettura e quindi tenta di accedere alla modalità di scrittura. <xref:System.Threading.LockRecursionException> viene generata un'eccezione indipendentemente dai criteri di ricorsione del blocco.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 Il codice seguente usa quindi il `SynchronizedCache` oggetto usato per archiviare un dizionario di nomi vegetali. Crea tre attività. Il primo vengono scritti i nomi di verdure archiviate in una matrice a un `SynchronizedCache` istanza. La seconda e terza attività visualizzare i nomi di verdura, il primo in modo crescente (da bassa indice in indice elevata), la seconda in ordine decrescente. L'attività finale cerca la stringa "cucumber" e, quando la trova, chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo per sostituire la stringa "verde bean".  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero complessivo di thread univoci per i quali è stato attivato il blocco in modalità lettura.</summary>
        <value>Numero di thread univoci per i quali è stato attivato il blocco in modalità lettura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread viene conteggiata una sola volta, anche se il blocco consente la ricorsione e il thread ha acceduto alla modalità lettura più volte.  
  
 Utilizzare questa proprietà solo per il debug, profilatura e a scopo di registrazione e non per controllare il comportamento di un algoritmo. I risultati possono modificare non appena che sono state calcolate. Pertanto, non sicuro prendere decisioni basate su questa proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> proprietà per generare una voce nel registro eventi, se il numero di thread in modalità lettura supera una soglia.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare il metodo <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> dopo aver terminato di utilizzare l'oggetto <xref:System.Threading.ReaderWriterLockSlim>. Il metodo <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> lascia l'oggetto <xref:System.Threading.ReaderWriterLockSlim> in una condizione di inutilizzabilità. Dopo la chiamata <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, è necessario rilasciare tutti i riferimenti per il <xref:System.Threading.ReaderWriterLockSlim> in modo che il garbage collector di recuperare la memoria che il <xref:System.Threading.ReaderWriterLockSlim> occupata. Per altre informazioni, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementa un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Chiamare sempre <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> prima di rilasciare l'ultimo riferimento al <xref:System.Threading.ReaderWriterLockSlim> oggetto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> è maggiore di zero.  
  
oppure 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> è maggiore di zero.  
  
oppure 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> è maggiore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prova ad attivare il blocco in modalità lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si blocca fino a quando il thread chiamante entra nel blocco e pertanto potrebbe non essere mai restituito. Usare il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodo blocca per un intervallo specificato e quindi restituire se il thread chiamante non ha acceduto alla modalità di lettura durante l'intervallo.  
  
 Modalità di lettura possono accedere più thread contemporaneamente.  
  
 Se uno o più thread sono in attesa di attivazione della modalità scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo si blocca fino a quando i thread hanno un timeout o passato in modalità scrittura e quindi sia terminato da quest'ultimo.  
  
> [!NOTE]
>  Se un blocco consente la ricorsione, un thread ha acceduto al blocco in modalità di lettura può accedere in modo ricorsivo modalità lettura, anche se altri thread in attesa di passare alla modalità di scrittura.  
  
 Al massimo un thread può essere in modalità aggiornabile, mentre altri thread è in modalità lettura. Se altri thread in attesa di accedere alla modalità aggiornabile e non sono presenti thread in attesa di attivazione della modalità scrittura, i thread che chiamano il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo passare immediatamente alla modalità di lettura e non vengono bloccati.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo ad attivare il blocco in modalità lettura. Il metodo illustrato nell'esempio recupera il valore associato alla chiave. Se la chiave non viene trovata, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> è consentito per il metodo terminate. Oggetto `finally` blocco viene utilizzato per eseguire il <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> metodo, assicurando che il chiamante esca dalla modalità di lettura.  
  
 Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di lettura.  
  
oppure 
La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di scrittura.  
  
oppure 
Il numero di ricorsioni supererebbe la capacità del contatore. Questo limite è talmente elevato che questa eccezione non dovrebbe essere mai riscontrata.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prova ad attivare il blocco in modalità aggiornabile.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si blocca fino a quando il thread chiamante entra nel blocco e pertanto potrebbe non essere mai restituito. Usare il <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metodo blocca per un intervallo specificato e quindi restituire se il thread chiamante non ha acceduto alla modalità aggiornabile durante tale intervallo.  
  
 Utilizzare la modalità aggiornabile quando un thread accede in genere la risorsa protetta dal <xref:System.Threading.ReaderWriterLockSlim> in modalità lettura, ma potrebbe essere necessario immettere la modalità scrittura, se vengono soddisfatte determinate condizioni. Un thread in modalità aggiornabile può downgrade alla modalità di lettura o eseguire l'aggiornamento alla modalità di scrittura.  
  
 Solo un thread può accedere alla modalità aggiornabile in qualsiasi momento. Se un thread è in modalità aggiornabile e non sono presenti thread in attesa di attivazione della modalità scrittura, un numero qualsiasi di altri thread può passare alla modalità di lettura, anche se sono presenti thread in attesa di accedere alla modalità aggiornabile.  
  
 Se uno o più thread sono in attesa di attivazione della modalità scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo si blocca fino a quando i thread hanno un timeout o passato in modalità scrittura e quindi sia terminato da quest'ultimo.  
  
> [!NOTE]
>  Se un blocco consente la ricorsione, un thread ha acceduto al blocco in modalità aggiornabile può accedere in modo ricorsivo la modalità aggiornabile, anche se altri thread in attesa di passare alla modalità di scrittura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo ad attivare il blocco in modalità aggiornabile. Oggetto `finally` blocco viene utilizzato per eseguire il <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> metodo, assicurando che il chiamante esca dalla modalità aggiornabile.  
  
 Il metodo illustrato nell'esempio recupera il valore associato alla chiave e lo confronta con un nuovo valore. Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica. Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore. Se il valore è stato modificato, viene aggiornata. La modalità aggiornabile consente al thread eseguire l'aggiornamento il blocco di lettura in base alle necessità, senza il rischio di deadlock.  
  
 L'esempio Usa il costruttore predefinito per creare il blocco, in modo che non è consentita la ricorsione. Programmazione di <xref:System.Threading.ReaderWriterLockSlim> è più semplice e meno soggetta a errori quando il blocco non supporta la ricorsione.  
  
 Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco in tutte le modalità.  
  
oppure 
Il thread corrente ha acceduto alla modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.  
  
oppure 
Il numero di ricorsioni supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Prova ad attivare il blocco in modalità scrittura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo si blocca fino a quando il thread chiamante entra nel blocco e pertanto potrebbe non essere mai restituito. Usare il <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodo blocca per un intervallo specificato e quindi restituire se il thread chiamante non ha acceduto alla modalità di scrittura durante l'intervallo.  
  
 Se altri thread è stato attivato il blocco in modalità di lettura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metodo si blocca fino a quando i thread sono usciti dalla modalità di lettura. Quando sono presenti thread in attesa di attivazione della modalità scrittura, gli altri thread che tentano di accedere alla modalità di lettura o la modalità aggiornabile blocco fino a quando non hanno tutti i thread in attesa di attivazione della modalità scrittura o timeout passato in modalità scrittura e quindi sia terminato da quest'ultimo.  
  
> [!NOTE]
>  Se un blocco consente la ricorsione, un thread ha acceduto al blocco in modalità di scrittura può accedere in modo ricorsivo la modalità scrittura, anche se altri thread in attesa di passare alla modalità di scrittura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metodo ad attivare il blocco in modalità di scrittura. Il metodo illustrato nell'esempio aggiunge una nuova coppia chiave/valore per la cache sincronizzata. Se la chiave esiste già nella cache, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> è consentito per il metodo terminate. Oggetto `finally` blocco viene utilizzato per eseguire il <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metodo, assicurando che il chiamante esce dalla modalità di scrittura.  
  
 Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco in tutte le modalità.  
  
oppure 
Il thread corrente ha acceduto alla modalità di lettura e non possiede già un blocco in scrittura, pertanto il tentativo di accedere al blocco in modalità di scrittura creerebbe la possibilità di un deadlock.  
  
oppure 
Il numero di ricorsioni supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riduce il numero di ricorsioni per la modalità lettura ed esce da questa modalità se il numero risultante è 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è sensibile all'ordine di ricorsione. Ad esempio, se un thread entra in un blocco in modalità aggiornabile e quindi accede al blocco in modalità di lettura, l'ordine in cui il thread venga chiuso le due modalità non è rilevante. Se un blocco consente la ricorsione, un thread può attivare il blocco in modalità di scrittura e quindi in modo ricorsivo in modalità lettura; l'ordine in cui il thread esce dalla modalità di lettura e scrittura in modalità non è rilevante.  
  
 Disattivazione del blocco potrebbe segnalare altri thread in attesa.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un `finally` esecuzione del blocco di <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> metodo, assicurando che il chiamante esca dalla modalità di lettura. Il metodo illustrato nell'esempio recupera il valore associato alla chiave. Se la chiave non viene trovata, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> è consentito per il metodo terminate. Il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo viene utilizzato per attivare la modalità di lettura.  
  
 Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread corrente non ha acceduto al blocco in modalità di lettura.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riduce il numero di ricorsioni per la modalità aggiornabile ed esce da questa modalità se il numero risultante è 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è sensibile all'ordine di ricorsione. Ad esempio, se un thread entra in un blocco in modalità aggiornabile e quindi accede al blocco in modalità scrittura, l'ordine in cui il thread venga chiuso le due modalità non è rilevante. Se un blocco consente la ricorsione, un thread può attivare il blocco in modalità di scrittura e quindi in modo ricorsivo in modalità aggiornabile; non è importante l'ordine in cui il thread esce dalla modalità di scrittura e la modalità aggiornabile.  
  
 Disattivazione del blocco potrebbe segnalare altri thread in attesa.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un `finally` esecuzione del blocco di <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> metodo, assicurando che il chiamante esca dalla modalità aggiornabile.  
  
 Il metodo illustrato nell'esempio recupera il valore associato alla chiave e lo confronta con un nuovo valore. Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica. Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore. Se il valore è stato modificato, viene aggiornata. La modalità aggiornabile consente al thread eseguire l'aggiornamento il blocco di lettura in base alle necessità, senza il rischio di deadlock.  
  
 L'esempio Usa il costruttore predefinito per creare il blocco, in modo che non è consentita la ricorsione. Programmazione di <xref:System.Threading.ReaderWriterLockSlim> è più semplice e meno soggetta a errori quando il blocco non supporta la ricorsione.  
  
 Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread corrente non ha acceduto al blocco in modalità aggiornabile.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riduce il numero di ricorsioni per la modalità scrittura ed esce da questa modalità se il numero risultante è 0 (zero).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è sensibile all'ordine di ricorsione. Ad esempio, se un thread entra in un blocco in modalità aggiornabile e quindi accede al blocco in modalità scrittura, l'ordine in cui il thread venga chiuso le due modalità non è rilevante. Se un blocco consente la ricorsione, un thread può attivare il blocco in modalità di scrittura e quindi in modo ricorsivo in modalità lettura; l'ordine in cui il thread esce dalla modalità di lettura e scrittura in modalità non è rilevante.  
  
 Disattivazione del blocco potrebbe segnalare altri thread in attesa.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un `finally` esecuzione del blocco di <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metodo, assicurando che il chiamante esce dalla modalità di scrittura. Il metodo illustrato nell'esempio aggiunge una nuova coppia chiave/valore per la cache sincronizzata. Se la chiave esiste già nella cache, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> è consentito per il metodo terminate. Il <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metodo viene utilizzato per attivare il blocco in modalità di scrittura.  
  
 Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread corrente non ha acceduto al blocco in modalità di scrittura.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se per il thread corrente è stato attivato il blocco in modalità lettura.</summary>
        <value>
          <see langword="true" /> se per il thread corrente è stata attivata la modalità lettura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà deve essere utilizzata nelle asserzioni o per altri scopi di debug. Non utilizzarlo per controllare il flusso dell'esecuzione del programma.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> proprietà per generare un'asserzione se il thread corrente ha acceduto alla modalità di lettura in modo imprevisto.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se per il thread corrente è stato attivato il blocco in modalità aggiornabile.</summary>
        <value>
          <see langword="true" /> se il thread corrente ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà deve essere utilizzata nelle asserzioni o per altri scopi di debug. Non utilizzarlo per controllare il flusso dell'esecuzione del programma.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> proprietà per generare un'asserzione se il thread corrente ha acceduto alla modalità aggiornabile in modo imprevisto.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se per il thread corrente è stato attivato il blocco in modalità scrittura.</summary>
        <value>
          <see langword="true" /> se il thread corrente ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà deve essere utilizzata nelle asserzioni o per altri scopi di debug. Non utilizzarlo per controllare il flusso dell'esecuzione del programma.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> proprietà per generare un'asserzione se il thread corrente ha acceduto alla modalità di scrittura in modo imprevisto.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica i criteri di ricorsione per l'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> corrente.</summary>
        <value>Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Criteri di ricorsione determinano le restrizioni sul thread che accedono al blocco più volte. Ad esempio, se un blocco è stato creato con <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> e un thread ha acceduto al blocco in modalità lettura <xref:System.Threading.LockRecursionException> viene generata se il thread tenta di accedere nuovamente al blocco in modalità lettura.  
  
> [!NOTE]
>  Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o un downgrade dalla modalità indipendentemente dall'impostazione di criteri di ricorsione di blocco di lettura.  
  
 Indipendentemente dai criteri di ricorsione, un thread che ha inizialmente acceduto leggere in modalità non è consentita l'aggiornamento alla modalità aggiornabile o modalità scrittura, perché ciò comporterebbe una forte probabilità di deadlock.  
  
 Per altre informazioni sui criteri di ricorsione e i relativi effetti, vedere la <xref:System.Threading.LockRecursionPolicy> enumerazione e <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di volte in cui per il thread corrente è stato attivato il blocco in modalità lettura, come indicazione della ricorsione.</summary>
        <value>0 (zero) se il thread corrente non ha acceduto alla modalità di lettura, 1 se il thread ha acceduto alla modalità lettura ma non in modo ricorsivo, oppure *n* se il thread è stato attivato il blocco in modo ricorsivo *n* - 1 volte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà solo per il debug, profilatura e a scopo di registrazione e non per controllare il comportamento di un algoritmo. I risultati possono modificare non appena che sono state calcolate. Pertanto, non sicuro prendere decisioni basate su questa proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di volte in cui per il thread corrente è stato attivato il blocco in modalità aggiornabile, come indicazione della ricorsione.</summary>
        <value>0 se il thread corrente non ha acceduto alla modalità aggiornabile, 1 se il thread ha acceduto alla modalità aggiornabile ma non è stata attivata, in modo ricorsivo, oppure *n* se il thread ha acceduto alla modalità aggiornabile in modo ricorsivo *n* - 1 orari.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà solo per il debug, profilatura e a scopo di registrazione e non per controllare il comportamento di un algoritmo. I risultati possono modificare non appena che sono state calcolate. Pertanto, non sicuro prendere decisioni basate su questa proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero di volte in cui per il thread corrente è stato attivato il blocco in modalità scrittura, come indicazione della ricorsione.</summary>
        <value>0 se il thread corrente non ha acceduto alla modalità di scrittura, 1 se il thread ha acceduto alla modalità scrittura ma non in modo ricorsivo, oppure *n* se il thread ha acceduto alla modalità di scrittura in modo ricorsivo *n* - 1 volte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà solo per il debug, profilatura e a scopo di registrazione e non per controllare il comportamento di un algoritmo. I risultati possono modificare non appena che sono state calcolate. Pertanto, non sicuro prendere decisioni basate su questa proprietà.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova ad attivare il blocco in modalità lettura con un timeout facoltativo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per un'attesa indefinita.</param>
        <summary>Prova ad attivare il blocco in modalità lettura con un timeout intero facoltativo.</summary>
        <returns>
          <see langword="true" /> se il thread chiamante è passato in modalità lettura; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.  
  
 Modalità di lettura possono accedere più thread contemporaneamente.  
  
 Se uno o più thread sono in attesa di attivazione della modalità scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodo si blocca fino a quando i thread hanno sia un timeout o passato in modalità scrittura e quindi sia terminato da quest'ultimo, o fino alla scadenza dell'intervallo di timeout del thread chiamante.  
  
> [!NOTE]
>  Se un blocco consente la ricorsione, un thread ha acceduto al blocco in modalità di lettura può accedere in modo ricorsivo modalità lettura, anche se altri thread in attesa di passare alla modalità di scrittura.  
  
 Un thread può essere in modalità aggiornabile, mentre altri thread è in modalità lettura. Se altri thread in attesa di accedere alla modalità aggiornabile e non sono presenti thread in attesa di attivazione della modalità scrittura, i thread che chiamano il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodo passare immediatamente alla modalità di lettura e non vengono bloccati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.  
  
oppure 
Il numero di ricorsioni supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervallo di attesa oppure -1 millisecondi per un'attesa indefinita.</param>
        <summary>Prova ad attivare il blocco in modalità lettura con un timeout facoltativo.</summary>
        <returns>
          <see langword="true" /> se il thread chiamante è passato in modalità lettura; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.  
  
 Più thread possono accedere al blocco in modalità di lettura nello stesso momento.  
  
 Se uno o più thread sono in coda per attivare la modalità di scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodo si blocca fino a quando i thread hanno sia un timeout o passato in modalità scrittura e quindi sia terminato da quest'ultimo, o fino alla scadenza dell'intervallo di timeout del thread chiamante.  
  
> [!NOTE]
>  Se un blocco consente la ricorsione, un thread ha acceduto al blocco in modalità di lettura può accedere in modo ricorsivo modalità lettura, anche se altri thread in attesa di passare alla modalità di scrittura.  
  
 Un thread può essere in modalità aggiornabile, mentre altri thread è in modalità lettura. Se altri thread in attesa di accedere alla modalità aggiornabile e non sono presenti thread in attesa di attivazione della modalità scrittura, i thread che chiamano il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodo passare immediatamente alla modalità di lettura e non vengono bloccati.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.  
  
oppure 
Il numero di ricorsioni supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.  
  
oppure 
Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova ad attivare il blocco in modalità aggiornabile con un timeout facoltativo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per un'attesa indefinita.</param>
        <summary>Prova ad attivare il blocco in modalità aggiornabile con un timeout facoltativo.</summary>
        <returns>
          <see langword="true" /> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.  
  
 Utilizzare la modalità aggiornabile quando un thread accede in genere la risorsa protetta dal <xref:System.Threading.ReaderWriterLockSlim> in modalità lettura, ma potrebbe essere necessario immettere la modalità scrittura, se vengono soddisfatte determinate condizioni. Un thread in modalità aggiornabile può eseguire l'aggiornamento alla modalità di scrittura o il downgrade per la modalità lettura.  
  
 Solo un thread può accedere un blocco in modalità aggiornabile in qualsiasi momento. Se un thread è in modalità aggiornabile e non sono presenti thread in attesa di attivazione della modalità scrittura, un numero qualsiasi di altri thread può passare alla modalità di lettura, anche se sono presenti thread in attesa di accedere alla modalità aggiornabile.  
  
 Se uno o più thread sono in attesa di attivazione della modalità scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metodo si blocca fino a quando i thread hanno sia un timeout o passato in modalità scrittura e quindi sia terminato da quest'ultimo, o fino alla scadenza dell'intervallo di timeout del thread chiamante.  
  
> [!NOTE]
>  Se un blocco consente la ricorsione, un thread ha acceduto al blocco in modalità aggiornabile può accedere in modo ricorsivo la modalità aggiornabile, anche se altri thread in attesa di passare alla modalità di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.  
  
oppure 
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.  
  
oppure 
Il numero di ricorsioni supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervallo di attesa oppure -1 millisecondi per un'attesa indefinita.</param>
        <summary>Prova ad attivare il blocco in modalità aggiornabile con un timeout facoltativo.</summary>
        <returns>
          <see langword="true" /> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.  
  
 Utilizzare la modalità aggiornabile quando un thread è in genere accedere alla risorsa protetta dal <xref:System.Threading.ReaderWriterLockSlim> in modalità lettura, ma potrebbe essere necessario immettere la modalità scrittura, se vengono soddisfatte determinate condizioni. Un thread in modalità aggiornabile può eseguire l'aggiornamento alla modalità di scrittura o il downgrade per la modalità lettura.  
  
 Solo un thread può accedere un blocco in modalità aggiornabile in qualsiasi momento. Se un thread è in modalità aggiornabile e non sono presenti thread in attesa di attivazione della modalità scrittura, un numero qualsiasi di altri thread può passare alla modalità di lettura, anche se sono presenti thread in attesa di accedere alla modalità aggiornabile.  
  
 Se uno o più thread sono in attesa di attivazione della modalità scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metodo si blocca fino a quando i thread hanno sia un timeout o passato in modalità scrittura e quindi sia terminato da quest'ultimo, o fino alla scadenza dell'intervallo di timeout del thread chiamante.  
  
> [!NOTE]
>  Se un blocco consente la ricorsione, un thread ha acceduto al blocco in modalità aggiornabile può accedere in modo ricorsivo la modalità aggiornabile, anche se altri thread in attesa di passare alla modalità di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.  
  
oppure 
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.  
  
oppure 
Il numero di ricorsioni supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.  
  
oppure 
Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova ad attivare il blocco in modalità scrittura con un timeout facoltativo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per un'attesa indefinita.</param>
        <summary>Prova ad attivare il blocco in modalità scrittura con un timeout facoltativo.</summary>
        <returns>
          <see langword="true" /> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.  
  
 Se altri thread è stato attivato il blocco in modalità di lettura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodo si blocca fino a quando tali thread sono usciti dal modalità lettura o fino a quando non è trascorso l'intervallo di timeout. Mentre i thread sono bloccati in attesa di attivazione della modalità scrittura, gli altri thread che tentano di accedere alla modalità di lettura o in modalità aggiornabile bloccare fino a quando tutti i thread in attesa di immettere la modalità scrivono hanno entrambi un timeout o passato in modalità scrittura e quindi sia terminato da quest'ultimo.  
  
> [!NOTE]
>  Se un blocco consente la ricorsione, un thread ha acceduto al blocco in modalità di scrittura può accedere in modo ricorsivo la modalità scrittura, anche se altri thread in attesa di passare alla modalità di scrittura.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodo ad attivare il blocco in modalità di scrittura, con un timeout. Il metodo illustrato nell'esempio aggiunge una nuova coppia chiave/valore per la cache sincronizzata. Se l'intervallo di timeout specificato deve trascorrere prima che il thread entra nel blocco, il metodo restituisce `false`. Il metodo restituisce `true` se viene aggiunta la coppia chiave/valore.  
  
 Se la chiave esiste già nella cache, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> è consentito per il metodo terminate. Oggetto `finally` blocco viene utilizzato per eseguire il <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metodo, assicurando che il chiamante termina il blocco.  
  
 Questo codice è parte di un esempio più esaustivo disponibile per il <xref:System.Threading.ReaderWriterLockSlim> classe.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.  
  
oppure 
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.  
  
oppure 
Il numero di ricorsioni supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervallo di attesa oppure -1 millisecondi per un'attesa indefinita.</param>
        <summary>Prova ad attivare il blocco in modalità scrittura con un timeout facoltativo.</summary>
        <returns>
          <see langword="true" /> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.  
  
 Se altri thread è stato attivato il blocco in modalità di lettura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodo si blocca fino a quando tali thread sono usciti dal modalità lettura o fino a quando non è trascorso l'intervallo di timeout. Mentre i thread sono bloccati in attesa di attivazione della modalità scrittura, gli altri thread che tentano di accedere alla modalità di lettura o in modalità aggiornabile bloccare fino a quando tutti i thread in attesa di immettere la modalità scrivono hanno entrambi un timeout o passato in modalità scrittura e quindi sia terminato da quest'ultimo.  
  
> [!NOTE]
>  Se un blocco consente la ricorsione, un thread ha acceduto al blocco in modalità di scrittura può accedere in modo ricorsivo la modalità scrittura, anche se altri thread in attesa di passare alla modalità di scrittura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.  
  
oppure 
Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.  
  
oppure 
Il numero di ricorsioni supererebbe la capacità del contatore. Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.  
  
oppure 
Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</exception>
        <exception cref="T:System.ObjectDisposedException">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero complessivo di thread in attesa di attivazione del blocco in modalità lettura.</summary>
        <value>Numero complessivo di thread in attesa di attivazione della modalità lettura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà solo per il debug, profilatura e a scopo di registrazione e non per controllare il comportamento di un algoritmo. I risultati possono modificare non appena che sono state calcolate. Pertanto, non sicuro prendere decisioni basate su questa proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> proprietà per generare una voce nel registro eventi, se il numero di thread che sono bloccati in attesa di attivazione della modalità di lettura, supera una soglia.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero complessivo di thread in attesa di attivazione del blocco in modalità aggiornabile.</summary>
        <value>Numero complessivo di thread in attesa di attivazione della modalità aggiornabile.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà solo per il debug, profilatura e a scopo di registrazione e non per controllare il comportamento di un algoritmo. I risultati possono modificare non appena che sono state calcolate. Pertanto, non sicuro prendere decisioni basate su questa proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> proprietà per generare una voce nel registro eventi, se il numero di thread che sono bloccati in attesa di passare alla modalità aggiornabile, supera una soglia.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il numero complessivo di thread in attesa di attivazione del blocco in modalità scrittura.</summary>
        <value>Numero complessivo di thread in attesa di attivazione della modalità scrittura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questa proprietà solo per il debug, profilatura e a scopo di registrazione e non per controllare il comportamento di un algoritmo. I risultati possono modificare non appena che sono state calcolate. Pertanto, non sicuro prendere decisioni basate su questa proprietà.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> proprietà per generare una voce nel registro eventi, se il numero di thread che sono bloccati in attesa di passare alla modalità di scrittura, supera una soglia.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>