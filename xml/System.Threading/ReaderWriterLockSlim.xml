<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2ff770bb9446d6ebe71649784ebe115f60734cc0" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531355" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="b92f6-101">Rappresenta un blocco che viene usato per gestire l'accesso a una risorsa, consentendo più thread per la lettura o l'accesso esclusivo per la scrittura.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b92f6-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-102">Utilizzare <xref:System.Threading.ReaderWriterLockSlim> per proteggere una risorsa che viene letta da più thread e scritta da un thread alla volta.</span><span class="sxs-lookup"><span data-stu-id="b92f6-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="b92f6-103"><xref:System.Threading.ReaderWriterLockSlim> consente a più thread in modalità di lettura, consente a un thread di essere in modalità scrittura con proprietà esclusiva del blocco e consente a un thread che è in modalità di lettura aggiornabile, da cui il thread può essere aggiornato alla modalità di scrittura senza la necessità di lasciare l'accesso in lettura s accesso in lettura alla risorsa.</span><span class="sxs-lookup"><span data-stu-id="b92f6-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-104"><xref:System.Threading.ReaderWriterLockSlim> è simile a <xref:System.Threading.ReaderWriterLock>, ma include regole semplificate per la ricorsione e per l'aggiornamento e il downgrade dello stato del blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="b92f6-105"><xref:System.Threading.ReaderWriterLockSlim> evita molti casi di deadlock potenziale.</span><span class="sxs-lookup"><span data-stu-id="b92f6-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="b92f6-106">Inoltre, le prestazioni di <xref:System.Threading.ReaderWriterLockSlim> sono significativamente migliori di <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="b92f6-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="b92f6-107"><xref:System.Threading.ReaderWriterLockSlim> è consigliato per tutte le nuove fasi di sviluppo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="b92f6-108">Per impostazione predefinita, le nuove istanze di <xref:System.Threading.ReaderWriterLockSlim> vengono creati con il <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag e non consentono la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="b92f6-109">Il criterio predefinito è consigliato per lo sviluppo di nuovo, poiché la ricorsione presenta inutili complicazioni e rende il codice più soggetto a deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="b92f6-110">Per semplificare la migrazione da esistente progetti che utilizzano <xref:System.Threading.Monitor> o <xref:System.Threading.ReaderWriterLock>, è possibile utilizzare il <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag per creare istanze di <xref:System.Threading.ReaderWriterLockSlim> che consentono la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="b92f6-111">Un thread può attivare il blocco in tre modalità: lettura modalità, modalità di scrittura e lettura aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="b92f6-112">(Nella parte restante di questo argomento, "modalità di lettura aggiornabile" viene considerata "modalità aggiornabile", mentre la frase "immettere `x` modalità" viene utilizzato al posto di frase più lunga "Immettere il blocco in `x` modalità".)</span><span class="sxs-lookup"><span data-stu-id="b92f6-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="b92f6-113">Indipendentemente dalla criteri di ricorsione, solo un thread può essere in modalità di scrittura in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="b92f6-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="b92f6-114">Quando un thread è in modalità di scrittura, nessun altro thread può attivare il blocco in qualsiasi modalità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="b92f6-115">Solo un thread può essere in modalità aggiornabile in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="b92f6-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="b92f6-116">Qualsiasi numero di thread può essere in modalità di lettura e può esistere un solo thread in modalità aggiornabile mentre altri thread sono in modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b92f6-117">Questo tipo implementa il <xref:System.IDisposable> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b92f6-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="b92f6-118">Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente.</span><span class="sxs-lookup"><span data-stu-id="b92f6-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="b92f6-119">Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="b92f6-120">Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="b92f6-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="b92f6-121">Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b92f6-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="b92f6-122"><xref:System.Threading.ReaderWriterLockSlim> ha gestito l'affinità di thread; ovvero ogni <xref:System.Threading.Thread> oggetto deve effettuare chiamate il proprio metodo per immettere e uscire dalla modalità di blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="b92f6-123">Nessun thread può modificare la modalità di un altro thread.</span><span class="sxs-lookup"><span data-stu-id="b92f6-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="b92f6-124">Se un <xref:System.Threading.ReaderWriterLockSlim> non consente la ricorsione, un thread che tenta di attivare il blocco può essere bloccato per diversi motivi:</span><span class="sxs-lookup"><span data-stu-id="b92f6-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="b92f6-125">Un thread che tenta di accedere in modalità lettura blocchi se sono presenti thread in attesa di accedere alla modalità di scrittura o se è un thread singolo in modalità scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b92f6-126">Blocchi i lettori di nuovo quando vengono messe in coda i writer è un criterio di blocco equità che predilige i thread.</span><span class="sxs-lookup"><span data-stu-id="b92f6-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="b92f6-127">I criteri di equità corrente bilanciano equità tra i lettori e writer, per aumentare la velocità effettiva negli scenari più comuni.</span><span class="sxs-lookup"><span data-stu-id="b92f6-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="b92f6-128">Le versioni future del [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] può introdurre nuovi criteri di equità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="b92f6-129">Un thread che tenta di accedere a blocchi in modalità aggiornabile se è già presente un thread in modalità aggiornabile, se sono presenti thread in attesa di passare alla modalità di scrittura o se è presente un thread singolo in modalità scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="b92f6-130">Un thread che tenta di accedere a modalità di scrittura viene bloccato se è presente un thread in una qualsiasi delle tre modalità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="b92f6-131">L'aggiornamento e downgrade dei blocchi</span><span class="sxs-lookup"><span data-stu-id="b92f6-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="b92f6-132">La modalità aggiornabile è destinata ai casi in cui un thread in genere legge da una risorsa protetta, ma potrebbe essere necessario per la scrittura se vengono soddisfatte determinate condizioni.</span><span class="sxs-lookup"><span data-stu-id="b92f6-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="b92f6-133">Un thread che ha immesso un <xref:System.Threading.ReaderWriterLockSlim> in modalità aggiornabile con accesso in lettura alla risorsa protetta e possibile eseguire l'aggiornamento alla modalità di scrittura chiamando il <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> o <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="b92f6-134">Poiché possono esistere solo un thread in modalità aggiornabile in una fase, l'aggiornamento alla modalità di scrittura non può causare un deadlock durante la ricorsione non è consentita, ovvero i criteri predefiniti.</span><span class="sxs-lookup"><span data-stu-id="b92f6-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b92f6-135">Indipendentemente dal fatto di criteri di ricorsione, un thread che immesso inizialmente lettura modalità non è consentita eseguire l'aggiornamento in modalità aggiornabile o in modalità di scrittura, perché tale modello crea una forte probabilità di deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="b92f6-136">Ad esempio, se due thread in modalità lettura che entrambi tentano di accedere alla modalità di scrittura, provocano un deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="b92f6-137">La modalità aggiornabile è progettata per evitare tali deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="b92f6-138">Se sono presenti altri thread in modalità lettura, il thread che sta eseguendo l'aggiornamento di blocchi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="b92f6-139">Mentre il thread è bloccato, altri thread che tenta di passare alla modalità di lettura vengono bloccate.</span><span class="sxs-lookup"><span data-stu-id="b92f6-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="b92f6-140">Quando tutti i thread sono usciti dalla modalità di lettura, il thread aggiornabile bloccato passa alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="b92f6-141">Se sono presenti altri thread in attesa di accedere alla modalità di scrittura, rimangono bloccati, perché il thread singolo in modalità aggiornabile impedisce loro di ottenere accesso esclusivo alla risorsa.</span><span class="sxs-lookup"><span data-stu-id="b92f6-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="b92f6-142">Quando il thread in modalità aggiornabile esce dalla modalità di scrittura, altri thread in attesa di passare alla modalità di lettura possono farlo, a meno che non sono presenti thread in attesa di accedere alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="b92f6-143">Il thread in modalità aggiornabile può aggiornare o effettuare il downgrade all'infinito, fino a quando è l'unico thread che consente di scrivere la risorsa protetta.</span><span class="sxs-lookup"><span data-stu-id="b92f6-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="b92f6-144">Se si consente a più thread immettere modalità di scrittura o la modalità aggiornabile, che non è necessario consentire un thread di monopolizzare la modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="b92f6-145">In caso contrario, i thread che tentano di accedere scrivere modalità direttamente verrà bloccata per un periodo illimitato, e mentre sono bloccati, altri thread sarà in grado di accedere alla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="b92f6-146">Può effettuare il downgrade di un thread in modalità aggiornabile per la modalità di lettura da chiamare prima il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo e chiamando quindi il <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="b92f6-147">Questo modello di downgrade è consentito anche per tutti i criteri di ricorsione di blocco, <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span><span class="sxs-lookup"><span data-stu-id="b92f6-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="b92f6-148">Dopo il downgrade alla modalità di lettura, un thread non è possibile immettere nuovamente la modalità aggiornabile fino a quando non sarà uscito dalla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="b92f6-149">Immettere il blocco in modo ricorsivo</span><span class="sxs-lookup"><span data-stu-id="b92f6-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="b92f6-150">È possibile creare un <xref:System.Threading.ReaderWriterLockSlim> che supporta una voce ricorsiva blocco tramite il <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> costruttore che specifica i criteri di blocco e specificando <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b92f6-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-151">Non è consigliabile usare di ricorsione per un nuovo sviluppo, in quanto presenta inutili complicazioni e rende il codice più soggetto a deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="b92f6-152">Per un <xref:System.Threading.ReaderWriterLockSlim> che consente la ricorsione, sulle modalità di un thread può entrare possono affermare che le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="b92f6-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="b92f6-153">Un thread in modalità lettura è possibile immettere in modo ricorsivo alla modalità di lettura, ma non può accedere alla modalità di scrittura o in modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="b92f6-154">Se tenta di eseguire questa operazione, un <xref:System.Threading.LockRecursionException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="b92f6-155">Immissione di leggere modalità e quindi immettere la modalità scrittura o in modalità aggiornabile è un modello con una forte probabilità di deadlock, pertanto non è consentita.</span><span class="sxs-lookup"><span data-stu-id="b92f6-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="b92f6-156">Come illustrato in precedenza, la modalità aggiornabile viene fornita per i casi in cui è necessario eseguire l'aggiornamento di un blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="b92f6-157">Un thread in modalità aggiornabile può immettere modalità di scrittura e/o modalità di lettura e può accedere a ognuna in modo ricorsivo le tre modalità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="b92f6-158">Tuttavia, un tentativo di immettere scrivere blocchi di modalità se sono presenti altri thread in modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="b92f6-159">Un thread in modalità di scrittura è possibile immettere modalità di lettura e/o in modalità aggiornabile e può accedere a ognuna in modo ricorsivo le tre modalità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="b92f6-160">Un thread che non è stato attivato il blocco è possibile immettere qualsiasi modalità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="b92f6-161">Questo tentativo può essere bloccato per gli stessi motivi un tentativo di attivare un blocco non ricorsivo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="b92f6-162">Un thread può uscire le modalità che è entrato in qualsiasi ordine, purché al termine di ogni modalità esattamente le volte che tale modalità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="b92f6-163">Se un thread di prova per uscire da una modalità troppe volte o per uscire da una modalità non ha immesso, un <xref:System.Threading.SynchronizationLockException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="b92f6-164">Stati di blocco</span><span class="sxs-lookup"><span data-stu-id="b92f6-164">Lock States</span></span>  
 <span data-ttu-id="b92f6-165">Si può risultare utile pensare in termini di stati di blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="b92f6-166">Oggetto <xref:System.Threading.ReaderWriterLockSlim> può essere in uno dei quattro stati: non si immette, lettura, aggiornamento e scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="b92f6-167">Non è stato immesso: In questo stato, nessun thread è stato attivato il blocco (o tutti i thread sono usciti dal blocco).</span><span class="sxs-lookup"><span data-stu-id="b92f6-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="b92f6-168">Leggere: In questo stato, uno o più thread hanno attivato il blocco per l'accesso in lettura alla risorsa protetta.</span><span class="sxs-lookup"><span data-stu-id="b92f6-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="b92f6-169">Un thread può accedere il blocco in modalità lettura con il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> o <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodi, o il downgrade dalla modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="b92f6-170">Aggiornamento: In questo stato, un thread è stato attivato il blocco per l'accesso in lettura con l'opzione di aggiornamento per l'accesso in scrittura (ovvero in modalità aggiornabile), e zero o più thread è stato attivato il blocco per l'accesso in lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="b92f6-171">Non più di un thread alla volta può attivare il blocco con l'opzione di aggiornamento; gli altri thread che tenta di accedere alla modalità aggiornabile vengono bloccate.</span><span class="sxs-lookup"><span data-stu-id="b92f6-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="b92f6-172">Scrittura: In questo stato, un thread è stato attivato il blocco dell'accesso in scrittura alla risorsa protetta.</span><span class="sxs-lookup"><span data-stu-id="b92f6-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="b92f6-173">Il thread ha possesso esclusivo del blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="b92f6-174">Qualsiasi altro thread che tenta di attivare il blocco per qualsiasi motivo è bloccato.</span><span class="sxs-lookup"><span data-stu-id="b92f6-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="b92f6-175">Nella tabella seguente vengono descritte le transizioni tra stati di blocco, per i blocchi che non consentono la ricorsione, quando un thread `t` esegue l'azione descritta nella colonna più a sinistra.</span><span class="sxs-lookup"><span data-stu-id="b92f6-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="b92f6-176">Quando esegue l'azione, `t` non possiede alcuna modalità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="b92f6-177">(Il caso speciale in cui `t` è in modalità aggiornabile è descritto nella piè di pagina di tabella.) La riga superiore descrive lo stato inizio del blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="b92f6-178">Le celle viene descritto cosa succede al thread e visualizzare le modifiche apportate allo stato di blocco tra parentesi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="b92f6-179">Nessun accesso (N)</span><span class="sxs-lookup"><span data-stu-id="b92f6-179">Not entered (N)</span></span>|<span data-ttu-id="b92f6-180">Read (R)</span><span class="sxs-lookup"><span data-stu-id="b92f6-180">Read (R)</span></span>|<span data-ttu-id="b92f6-181">Aggiornamento (U)</span><span class="sxs-lookup"><span data-stu-id="b92f6-181">Upgrade (U)</span></span>|<span data-ttu-id="b92f6-182">Scrittura (S)</span><span class="sxs-lookup"><span data-stu-id="b92f6-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="b92f6-183">`t` passa alla modalità di lettura</span><span class="sxs-lookup"><span data-stu-id="b92f6-183">`t` enters read mode</span></span>|<span data-ttu-id="b92f6-184">`t` immette (R).</span><span class="sxs-lookup"><span data-stu-id="b92f6-184">`t` enters (R).</span></span>|<span data-ttu-id="b92f6-185">`t` viene bloccato se i thread sono in attesa per la modalità scrittura; in caso contrario, `t` immette.</span><span class="sxs-lookup"><span data-stu-id="b92f6-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="b92f6-186">`t` viene bloccato se i thread sono in attesa per la modalità scrittura; in caso contrario, `t` immette.<sup> 1</sup></span><span class="sxs-lookup"><span data-stu-id="b92f6-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="b92f6-187">`t` blocchi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-187">`t` blocks.</span></span>|  
|<span data-ttu-id="b92f6-188">`t` passa alla modalità aggiornabile</span><span class="sxs-lookup"><span data-stu-id="b92f6-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="b92f6-189">`t` immette (U).</span><span class="sxs-lookup"><span data-stu-id="b92f6-189">`t` enters (U).</span></span>|<span data-ttu-id="b92f6-190">`t` viene bloccato se i thread sono in attesa per la modalità di scrittura o la modalità di aggiornamento; in caso contrario, `t` immette (U).</span><span class="sxs-lookup"><span data-stu-id="b92f6-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="b92f6-191">`t` blocchi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-191">`t` blocks.</span></span>|<span data-ttu-id="b92f6-192">`t` blocchi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-192">`t` blocks.</span></span>|  
|<span data-ttu-id="b92f6-193">`t` passa alla modalità di scrittura</span><span class="sxs-lookup"><span data-stu-id="b92f6-193">`t` enters write mode</span></span>|<span data-ttu-id="b92f6-194">`t` immette (W).</span><span class="sxs-lookup"><span data-stu-id="b92f6-194">`t` enters (W).</span></span>|<span data-ttu-id="b92f6-195">`t` blocchi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-195">`t` blocks.</span></span>|<span data-ttu-id="b92f6-196">`t` blocchi. <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="b92f6-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="b92f6-197">`t` blocchi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="b92f6-198"><sup>1</sup> se `t` inizia la disconnessione in modalità aggiornabile, passa alla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="b92f6-199">Blocca mai questa azione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-199">This action never blocks.</span></span> <span data-ttu-id="b92f6-200">Non modifica lo stato del blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-200">The lock state does not change.</span></span> <span data-ttu-id="b92f6-201">(Il thread può quindi completare un downgrade alla modalità di lettura per disattivare la modalità aggiornabile.)</span><span class="sxs-lookup"><span data-stu-id="b92f6-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="b92f6-202"><sup>2</sup> se `t` viene avviato in modalità aggiornabile, si blocca se sono presenti thread in modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="b92f6-203">In caso contrario si effettua l'aggiornamento alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="b92f6-204">Le modifiche di stato di blocco per scrittura (S).</span><span class="sxs-lookup"><span data-stu-id="b92f6-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="b92f6-205">Se `t` blocca perché sono presenti thread in modalità lettura, passa alla modalità di scrittura non appena l'ultimo thread esce dalla modalità di lettura, anche se sono presenti thread in attesa di accedere alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="b92f6-206">Quando una modifica dello stato si verifica perché un thread termina il blocco, il successivo thread che riattivati viene selezionato come segue:</span><span class="sxs-lookup"><span data-stu-id="b92f6-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="b92f6-207">Innanzitutto, un thread in attesa di modalità di scrittura ed è già in modalità aggiornabile (possono essere presenti al massimo un thread di questo tipo).</span><span class="sxs-lookup"><span data-stu-id="b92f6-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="b92f6-208">Mancanza, un thread in attesa per la modalità scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="b92f6-209">Mancanza, un thread in attesa per la modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="b92f6-210">Mancanza, tutti i thread in attesa per la modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="b92f6-211">Lo stato del blocco successivo è sempre scrittura (S) del primo di due casi e aggiornamento (U) nel terzo caso, indipendentemente dallo stato del blocco quando il thread in fase di chiusura è attivato il cambiamento di stato.</span><span class="sxs-lookup"><span data-stu-id="b92f6-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="b92f6-212">Nell'ultimo caso, lo stato del blocco è aggiornamento (U) se non vi è un thread in modalità aggiornabile dopo la modifica dello stato e Read (R) in caso contrario, indipendentemente dallo stato precedente.</span><span class="sxs-lookup"><span data-stu-id="b92f6-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-213">Nell'esempio seguente viene illustrato una semplice cache sincronizzata contenente stringhe con chiavi di interi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="b92f6-214">Un'istanza di <xref:System.Threading.ReaderWriterLockSlim> viene utilizzato per sincronizzare l'accesso per il <xref:System.Collections.Generic.Dictionary%602> che funge da cache interna.</span><span class="sxs-lookup"><span data-stu-id="b92f6-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="b92f6-215">L'esempio include metodi semplici per aggiungere alla cache, eliminare dalla cache e leggere dalla cache.</span><span class="sxs-lookup"><span data-stu-id="b92f6-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="b92f6-216">Per illustrare i timeout, l'esempio include un metodo che viene aggiunto alla cache solo se è possibile eseguire questa operazione all'interno di un timeout specificato.</span><span class="sxs-lookup"><span data-stu-id="b92f6-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="b92f6-217">Per dimostrare la modalità aggiornabile, l'esempio include un metodo che recupera il valore associato alla chiave e lo confronta con un nuovo valore.</span><span class="sxs-lookup"><span data-stu-id="b92f6-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="b92f6-218">Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b92f6-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="b92f6-219">Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore.</span><span class="sxs-lookup"><span data-stu-id="b92f6-219">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="b92f6-220">Se il valore è stata modificata, viene aggiornata.</span><span class="sxs-lookup"><span data-stu-id="b92f6-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="b92f6-221">La modalità aggiornabile consente al thread di eseguire l'aggiornamento da accesso in lettura all'accesso in scrittura in base alle necessità, senza il rischio di deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="b92f6-222">L'esempio include un'enumerazione nidificata che specifica i valori restituiti per il metodo che illustra la modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="b92f6-223">L'esempio Usa il costruttore predefinito per creare il blocco, quindi non è consentita la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-223">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="b92f6-224">Programmazione di <xref:System.Threading.ReaderWriterLockSlim> è più semplice e meno soggetto a errori quando il blocco non consente la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="b92f6-225">Il codice seguente usa quindi il `SynchronizedCache` oggetto usato per archiviare un dizionario di nomi ortaggi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="b92f6-226">Crea tre attività.</span><span class="sxs-lookup"><span data-stu-id="b92f6-226">It creates three tasks.</span></span> <span data-ttu-id="b92f6-227">Il primo vengono scritti i nomi di verdure archiviate in una matrice a un `SynchronizedCache` istanza.</span><span class="sxs-lookup"><span data-stu-id="b92f6-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="b92f6-228">L'attività di seconda e terza visualizzare i nomi di verdura, il primo in senso crescente (da bassa indice indice massimo), il secondo in ordine decrescente.</span><span class="sxs-lookup"><span data-stu-id="b92f6-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="b92f6-229">L'attività finale cerca la stringa "cucumber" e, quando viene trovata, chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo per sostituire la stringa "verde bean".</span><span class="sxs-lookup"><span data-stu-id="b92f6-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="b92f6-230">Questo tipo è thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="b92f6-230">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-231">Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-232">Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> con i valori predefiniti delle proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-233">Oggetto <xref:System.Threading.ReaderWriterLockSlim> che viene inizializzato con questo costruttore non consente la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="b92f6-234">Quindi la proprietà <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> restituisce <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b92f6-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b92f6-235">Per ulteriori informazioni sui criteri di ricorsione e i relativi effetti, vedere il <xref:System.Threading.LockRecursionPolicy> enumerazione e la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-236">Nell'esempio seguente viene illustrato una semplice cache sincronizzata contenente stringhe con chiavi di interi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="b92f6-237">Un'istanza di <xref:System.Threading.ReaderWriterLockSlim> viene utilizzato per sincronizzare l'accesso per il <xref:System.Collections.Generic.Dictionary%602> che funge da cache interna.</span><span class="sxs-lookup"><span data-stu-id="b92f6-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="b92f6-238">Il costruttore senza parametri viene utilizzato per creare il blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="b92f6-239">L'esempio include metodi semplici per aggiungere alla cache, eliminare dalla cache e leggere dalla cache.</span><span class="sxs-lookup"><span data-stu-id="b92f6-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="b92f6-240">Per illustrare i timeout, l'esempio include un metodo che viene aggiunto alla cache solo se è possibile eseguire questa operazione all'interno di un timeout specificato.</span><span class="sxs-lookup"><span data-stu-id="b92f6-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="b92f6-241">Per dimostrare la modalità aggiornabile, l'esempio include un metodo che recupera il valore associato alla chiave e lo confronta con un nuovo valore.</span><span class="sxs-lookup"><span data-stu-id="b92f6-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="b92f6-242">Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b92f6-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="b92f6-243">Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore.</span><span class="sxs-lookup"><span data-stu-id="b92f6-243">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="b92f6-244">Se il valore è stata modificata, viene aggiornata.</span><span class="sxs-lookup"><span data-stu-id="b92f6-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="b92f6-245">La modalità aggiornabile consente al thread di eseguire l'aggiornamento da accesso in lettura all'accesso in scrittura in base alle necessità, senza il rischio di deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="b92f6-246">L'esempio include un'enumerazione nidificata che specifica i valori restituiti per il metodo che illustra la modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="b92f6-247">L'esempio Usa il costruttore predefinito per creare il blocco, quindi non è consentita la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-247">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="b92f6-248">Programmazione di <xref:System.Threading.ReaderWriterLockSlim> è più semplice e meno soggetto a errori quando il blocco non consente la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="b92f6-249">Il codice seguente usa quindi il `SynchronizedCache` oggetto usato per archiviare un dizionario di nomi ortaggi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="b92f6-250">Crea tre attività.</span><span class="sxs-lookup"><span data-stu-id="b92f6-250">It creates three tasks.</span></span> <span data-ttu-id="b92f6-251">Il primo vengono scritti i nomi di verdure archiviate in una matrice a un `SynchronizedCache` istanza.</span><span class="sxs-lookup"><span data-stu-id="b92f6-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="b92f6-252">L'attività di seconda e terza visualizzare i nomi di verdura, il primo in senso crescente (da bassa indice indice massimo), il secondo in ordine decrescente.</span><span class="sxs-lookup"><span data-stu-id="b92f6-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="b92f6-253">L'attività finale cerca la stringa "cucumber" e, quando viene trovata, chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo per sostituire la stringa "verde bean".</span><span class="sxs-lookup"><span data-stu-id="b92f6-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">
          <span data-ttu-id="b92f6-254">Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-254">One of the enumeration values that specifies the lock recursion policy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b92f6-255">Inizializza una nuova istanza della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, specificando i criteri di ricorsione del blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-256">Criteri di ricorsione determinano le restrizioni sui thread che accedono al blocco più volte.</span><span class="sxs-lookup"><span data-stu-id="b92f6-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="b92f6-257">Ad esempio, se un blocco è stato creato con <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> e un thread è stato attivato il blocco in modalità lettura <xref:System.Threading.LockRecursionException> viene generata se il thread tenta di accedere nuovamente al blocco in modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="b92f6-258">Analogamente, se un thread è stato attivato il blocco in modalità scrittura <xref:System.Threading.LockRecursionException> viene generata se il thread tenta di accedere nuovamente al blocco in qualsiasi modalità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-259">Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o downgrade alla modalità indipendentemente dall'impostazione di criteri di ricorsione di blocco di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="b92f6-260">Indipendentemente dal fatto di criteri di ricorsione, un thread che immesso inizialmente lettura modalità non è consentita eseguire l'aggiornamento in modalità aggiornabile o in modalità di scrittura, perché tale modello crea una forte probabilità di deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="b92f6-261">Per ulteriori informazioni sui criteri di ricorsione e i relativi effetti, vedere il <xref:System.Threading.LockRecursionPolicy> enumerazione e la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-262">L'esempio seguente mostra due scenari di eccezione, che varia a seconda di <xref:System.Threading.LockRecursionPolicy> impostazione e l'altro no.</span><span class="sxs-lookup"><span data-stu-id="b92f6-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="b92f6-263">Nel primo scenario, il thread passa alla modalità di lettura e quindi tenta di accedere in modo ricorsivo alla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="b92f6-264">Se il <xref:System.Threading.ReaderWriterLockSlim> viene creato utilizzando il costruttore predefinito, che imposta i criteri di ricorsione per <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="b92f6-265">Se <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> viene utilizzato per creare il <xref:System.Threading.ReaderWriterLockSlim>, viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="b92f6-266">Nel secondo scenario, il thread passa alla modalità di lettura e quindi tenta di accedere alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="b92f6-267"><xref:System.Threading.LockRecursionException> viene generata un'eccezione indipendentemente dai criteri di ricorsione del blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="b92f6-268">Il codice seguente usa quindi il `SynchronizedCache` oggetto usato per archiviare un dizionario di nomi ortaggi.</span><span class="sxs-lookup"><span data-stu-id="b92f6-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="b92f6-269">Crea tre attività.</span><span class="sxs-lookup"><span data-stu-id="b92f6-269">It creates three tasks.</span></span> <span data-ttu-id="b92f6-270">Il primo vengono scritti i nomi di verdure archiviate in una matrice a un `SynchronizedCache` istanza.</span><span class="sxs-lookup"><span data-stu-id="b92f6-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="b92f6-271">L'attività di seconda e terza visualizzare i nomi di verdura, il primo in senso crescente (da bassa indice indice massimo), il secondo in ordine decrescente.</span><span class="sxs-lookup"><span data-stu-id="b92f6-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="b92f6-272">L'attività finale cerca la stringa "cucumber" e, quando viene trovata, chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo per sostituire la stringa "verde bean".</span><span class="sxs-lookup"><span data-stu-id="b92f6-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-273">Ottiene il numero complessivo di thread univoci per i quali è stato attivato il blocco in modalità lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-273">Gets the total number of unique threads that have entered the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-274">Numero di thread univoci per i quali è stato attivato il blocco in modalità lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-274">The number of unique threads that have entered the lock in read mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-275">Un thread viene conteggiato una sola volta, anche se il blocco consente la ricorsione e il thread è in modalità lettura più volte.</span><span class="sxs-lookup"><span data-stu-id="b92f6-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="b92f6-276">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="b92f6-277">I risultati possono cambiare come che sono state calcolate.</span><span class="sxs-lookup"><span data-stu-id="b92f6-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="b92f6-278">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</span><span class="sxs-lookup"><span data-stu-id="b92f6-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-279">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> proprietà per generare una voce del registro eventi se il numero di thread in modalità lettura supera una soglia.</span><span class="sxs-lookup"><span data-stu-id="b92f6-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-280">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-281">Chiamare il metodo <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> dopo aver terminato di utilizzare l'oggetto <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="b92f6-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="b92f6-282">Il metodo <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> lascia l'oggetto <xref:System.Threading.ReaderWriterLockSlim> in una condizione di inutilizzabilità.</span><span class="sxs-lookup"><span data-stu-id="b92f6-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="b92f6-283">Dopo la chiamata <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, è necessario rilasciare tutti i riferimenti al <xref:System.Threading.ReaderWriterLockSlim> in modo che il garbage collector può recuperare la memoria che di <xref:System.Threading.ReaderWriterLockSlim> occupata.</span><span class="sxs-lookup"><span data-stu-id="b92f6-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="b92f6-284">Per ulteriori informazioni, vedere [la pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md) e [implementazione di un metodo Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="b92f6-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-285">Chiamare sempre il metodo <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> prima di rilasciare l'ultimo riferimento al <xref:System.Threading.ReaderWriterLockSlim> oggetto.</span><span class="sxs-lookup"><span data-stu-id="b92f6-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="b92f6-286">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> è maggiore di zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-286">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span>
          </span>
          <span data-ttu-id="b92f6-287">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-287">-or-</span>
          </span>
          <span data-ttu-id="b92f6-288">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> è maggiore di zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-288">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span>
          </span>
          <span data-ttu-id="b92f6-289">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-289">-or-</span>
          </span>
          <span data-ttu-id="b92f6-290">
            <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> è maggiore di zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-290">
              <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-291">Prova ad attivare il blocco in modalità lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-291">Tries to enter the lock in read mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-292">Questo metodo si blocca fino a quando il thread chiamante accede al blocco e pertanto potrebbe non essere mai restituito.</span><span class="sxs-lookup"><span data-stu-id="b92f6-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="b92f6-293">Utilizzare il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> modalità di lettura per blocco per un intervallo specificato e quindi restituire se il thread chiamante non ha immesso durante l'intervallo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="b92f6-294">Più thread possono accedere in modalità di lettura nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="b92f6-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="b92f6-295">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo si blocca fino a quando non avere tali thread timeout o in modalità di scrittura e quindi sia terminato da esso.</span><span class="sxs-lookup"><span data-stu-id="b92f6-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-296">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità lettura possibile immettere in modo ricorsivo modalità lettura, anche se altri thread in attesa di passare alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="b92f6-297">Al massimo un thread può essere in modalità aggiornabile, mentre altri thread è in modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="b92f6-298">Se i thread aggiuntivi sono in attesa di attivazione della modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, thread che chiamano il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo passare immediatamente alla modalità di lettura e non vengono bloccati.</span><span class="sxs-lookup"><span data-stu-id="b92f6-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-299">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo per attivare il blocco in modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="b92f6-300">Il metodo illustrato nell'esempio recupera il valore associato alla chiave.</span><span class="sxs-lookup"><span data-stu-id="b92f6-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="b92f6-301">Se la chiave non viene trovata, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> può terminare il metodo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="b92f6-302">Oggetto `finally` blocco viene utilizzato per eseguire il <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> (metodo), assicurando che il chiamante esca dalla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="b92f6-303">Questo codice è parte di un esempio più esaustivo disponibile per la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="b92f6-304">Il thread corrente non è in grado di acquisire il blocco di scrittura quando contiene il blocco di lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-304">The current thread cannot acquire the write lock when it holds the read lock.</span>
          </span>
          <span data-ttu-id="b92f6-305">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-305">-or-</span>
          </span>
          <span data-ttu-id="b92f6-306">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span>
          </span>
          <span data-ttu-id="b92f6-307">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-307">-or-</span>
          </span>
          <span data-ttu-id="b92f6-308">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-308">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span>
          </span>
          <span data-ttu-id="b92f6-309">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-309">-or-</span>
          </span>
          <span data-ttu-id="b92f6-310">Il numero di ricorsioni supererebbe la capacità del contatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-310">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="b92f6-311">Questo limite è talmente elevato che questa eccezione non dovrebbe essere mai riscontrata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-311">This limit is so large that applications should never encounter this exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b92f6-312">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-312">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-313">Prova ad attivare il blocco in modalità aggiornabile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-313">Tries to enter the lock in upgradeable mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-314">Questo metodo si blocca fino a quando il thread chiamante accede al blocco e pertanto potrebbe non essere mai restituito.</span><span class="sxs-lookup"><span data-stu-id="b92f6-314">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="b92f6-315">Utilizzare il <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metodo di blocco per un intervallo specificato e restituire quindi se il thread chiamante non ha passato in modalità aggiornabile durante l'intervallo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-315">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="b92f6-316">Utilizzare la modalità aggiornabile quando un thread è in genere accede alla risorsa protetta dal <xref:System.Threading.ReaderWriterLockSlim> in modalità di lettura, ma potrebbe essere necessario passare alla modalità di scrittura, se vengono soddisfatte determinate condizioni.</span><span class="sxs-lookup"><span data-stu-id="b92f6-316">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="b92f6-317">Un thread in modalità aggiornabile può downgrade alla modalità di lettura o l'aggiornamento alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-317">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="b92f6-318">Solo un thread può accedere alla modalità aggiornabile in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="b92f6-318">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="b92f6-319">Se un thread è in modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, un numero qualsiasi di altri thread può passare alla modalità lettura, anche se sono presenti thread in attesa di attivazione della modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-319">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="b92f6-320">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo si blocca fino a quando non avere tali thread timeout o in modalità di scrittura e quindi sia terminato da esso.</span><span class="sxs-lookup"><span data-stu-id="b92f6-320">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-321">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità aggiornabile può accedere in modo ricorsivo in modalità aggiornabile, anche se altri thread in attesa di passare alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-321">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-322">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> metodo per attivare il blocco in modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-322">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="b92f6-323">Oggetto `finally` blocco viene utilizzato per eseguire il <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> (metodo), assicurando che il chiamante esca dalla modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-323">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="b92f6-324">Il metodo illustrato nell'esempio recupera il valore associato alla chiave e lo confronta con un nuovo valore.</span><span class="sxs-lookup"><span data-stu-id="b92f6-324">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="b92f6-325">Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b92f6-325">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="b92f6-326">Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore.</span><span class="sxs-lookup"><span data-stu-id="b92f6-326">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="b92f6-327">Se il valore è stata modificata, viene aggiornata.</span><span class="sxs-lookup"><span data-stu-id="b92f6-327">If the value has changed, it is updated.</span></span> <span data-ttu-id="b92f6-328">La modalità aggiornabile consente al thread di aggiornare il blocco di lettura in base alle necessità, senza il rischio di deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-328">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="b92f6-329">L'esempio Usa il costruttore predefinito per creare il blocco, quindi non è consentita la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-329">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="b92f6-330">Programmazione di <xref:System.Threading.ReaderWriterLockSlim> è più semplice e meno soggetto a errori quando il blocco non consente la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-330">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="b92f6-331">Questo codice è parte di un esempio più esaustivo disponibile per la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-331">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="b92f6-332">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco in tutte le modalità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-332">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          </span>
          <span data-ttu-id="b92f6-333">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-333">-or-</span>
          </span>
          <span data-ttu-id="b92f6-334">Il thread corrente ha acceduto alla modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-334">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="b92f6-335">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-335">-or-</span>
          </span>
          <span data-ttu-id="b92f6-336">Il numero di ricorsioni supererebbe la capacità del contatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-336">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="b92f6-337">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-337">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b92f6-338">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-338">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-339">Prova ad attivare il blocco in modalità scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-339">Tries to enter the lock in write mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-340">Questo metodo si blocca fino a quando il thread chiamante accede al blocco e pertanto potrebbe non essere mai restituito.</span><span class="sxs-lookup"><span data-stu-id="b92f6-340">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="b92f6-341">Utilizzare il <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodo di blocco per un intervallo specificato e restituire quindi se il thread chiamante non ha passato in modalità scrittura durante l'intervallo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-341">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="b92f6-342">Se altri thread è stato attivato il blocco in modalità lettura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metodo si blocca fino a quando tali thread sono usciti dalla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-342">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="b92f6-343">Quando sono presenti thread in attesa di passare alla modalità di scrittura, gli altri thread che tentano di accedere alla modalità di lettura o di blocco in modalità aggiornabile fino a che i tutti i thread in attesa di passare alla modalità di scrittura verificato il timeout o in modalità di scrittura e quindi sia terminato da esso.</span><span class="sxs-lookup"><span data-stu-id="b92f6-343">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-344">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità di scrittura può accedere in modo ricorsivo la modalità di scrittura, anche se altri thread in attesa di passare alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-344">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-345">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metodo per attivare il blocco in modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-345">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="b92f6-346">Il metodo illustrato nell'esempio aggiunge una nuova coppia chiave/valore per la cache sincronizzata.</span><span class="sxs-lookup"><span data-stu-id="b92f6-346">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="b92f6-347">Se la chiave esiste già nella cache, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> può terminare il metodo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-347">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="b92f6-348">Oggetto `finally` blocco viene utilizzato per eseguire il <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> (metodo), assicurando che il chiamante esca dalla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-348">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="b92f6-349">Questo codice è parte di un esempio più esaustivo disponibile per la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-349">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="b92f6-350">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco in tutte le modalità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-350">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span>
          </span>
          <span data-ttu-id="b92f6-351">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-351">-or-</span>
          </span>
          <span data-ttu-id="b92f6-352">Il thread corrente ha acceduto alla modalità di lettura, pertanto il tentativo di accedere al blocco in modalità di scrittura creerebbe la possibilità di un deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-352">The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="b92f6-353">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-353">-or-</span>
          </span>
          <span data-ttu-id="b92f6-354">Il numero di ricorsioni supererebbe la capacità del contatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-354">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="b92f6-355">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-355">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b92f6-356">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-356">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-357">Riduce il numero di ricorsioni per la modalità lettura ed esce da questa modalità se il numero risultante è 0 (zero).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-357">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-358">Questo metodo non sono riservato all'ordine di ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-358">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="b92f6-359">Ad esempio, se un thread entra in un blocco in modalità aggiornabile e successivamente il blocco in modalità lettura, l'ordine in cui le due modalità si esce dal thread non è rilevante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-359">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="b92f6-360">Se un blocco consente la ricorsione, un thread può attivare il blocco in modalità di scrittura e quindi in modo ricorsivo in modalità lettura; l'ordine in cui la chiusura del thread in modalità lettura e scrittura non è importante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-360">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="b92f6-361">L'uscita dal blocco potrebbe segnalare altri thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="b92f6-361">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-362">Nell'esempio seguente viene illustrato come utilizzare un `finally` esecuzione del blocco di <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> (metodo), assicurando che il chiamante esca dalla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-362">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="b92f6-363">Il metodo illustrato nell'esempio recupera il valore associato alla chiave.</span><span class="sxs-lookup"><span data-stu-id="b92f6-363">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="b92f6-364">Se la chiave non viene trovata, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> può terminare il metodo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-364">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="b92f6-365">Il <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> metodo viene utilizzato per passare alla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-365">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="b92f6-366">Questo codice è parte di un esempio più esaustivo disponibile per la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-366">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="b92f6-367">Il thread corrente non ha acceduto al blocco in modalità di lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-367">The current thread has not entered the lock in read mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-368">Riduce il numero di ricorsioni per la modalità aggiornabile ed esce da questa modalità se il numero risultante è 0 (zero).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-368">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-369">Questo metodo non sono riservato all'ordine di ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-369">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="b92f6-370">Ad esempio, se un thread entra in un blocco in modalità aggiornabile e successivamente il blocco in modalità di scrittura, l'ordine in cui le due modalità si esce dal thread non è rilevante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-370">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="b92f6-371">Se un blocco consente la ricorsione, un thread può attivare il blocco in modalità di scrittura e quindi in modo ricorsivo in modalità aggiornabile; l'ordine in cui il thread esce da questa modalità di scrittura e di modalità non è rilevante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-371">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="b92f6-372">L'uscita dal blocco potrebbe segnalare altri thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="b92f6-372">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-373">Nell'esempio seguente viene illustrato come utilizzare un `finally` esecuzione del blocco di <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> (metodo), assicurando che il chiamante esca dalla modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-373">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="b92f6-374">Il metodo illustrato nell'esempio recupera il valore associato alla chiave e lo confronta con un nuovo valore.</span><span class="sxs-lookup"><span data-stu-id="b92f6-374">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="b92f6-375">Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica.</span><span class="sxs-lookup"><span data-stu-id="b92f6-375">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="b92f6-376">Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore.</span><span class="sxs-lookup"><span data-stu-id="b92f6-376">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="b92f6-377">Se il valore è stata modificata, viene aggiornata.</span><span class="sxs-lookup"><span data-stu-id="b92f6-377">If the value has changed, it is updated.</span></span> <span data-ttu-id="b92f6-378">La modalità aggiornabile consente al thread di aggiornare il blocco di lettura in base alle necessità, senza il rischio di deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-378">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="b92f6-379">L'esempio Usa il costruttore predefinito per creare il blocco, quindi non è consentita la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-379">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="b92f6-380">Programmazione di <xref:System.Threading.ReaderWriterLockSlim> è più semplice e meno soggetto a errori quando il blocco non consente la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-380">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="b92f6-381">Questo codice è parte di un esempio più esaustivo disponibile per la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-381">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="b92f6-382">Il thread corrente non ha acceduto al blocco in modalità aggiornabile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-382">The current thread has not entered the lock in upgradeable mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-383">Riduce il numero di ricorsioni per la modalità scrittura ed esce da questa modalità se il numero risultante è 0 (zero).</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-383">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-384">Questo metodo non sono riservato all'ordine di ricorsione.</span><span class="sxs-lookup"><span data-stu-id="b92f6-384">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="b92f6-385">Ad esempio, se un thread entra in un blocco in modalità aggiornabile e successivamente il blocco in modalità di scrittura, l'ordine in cui le due modalità si esce dal thread non è rilevante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-385">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="b92f6-386">Se un blocco consente la ricorsione, un thread può attivare il blocco in modalità di scrittura e quindi in modo ricorsivo in modalità lettura; l'ordine in cui la chiusura del thread in modalità lettura e scrittura non è importante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-386">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="b92f6-387">L'uscita dal blocco potrebbe segnalare altri thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="b92f6-387">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-388">Nell'esempio seguente viene illustrato come utilizzare un `finally` esecuzione del blocco di <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> (metodo), assicurando che il chiamante esca dalla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-388">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="b92f6-389">Il metodo illustrato nell'esempio aggiunge una nuova coppia chiave/valore per la cache sincronizzata.</span><span class="sxs-lookup"><span data-stu-id="b92f6-389">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="b92f6-390">Se la chiave esiste già nella cache, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> può terminare il metodo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-390">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="b92f6-391">Il <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> metodo viene utilizzato per attivare il blocco in modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-391">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="b92f6-392">Questo codice è parte di un esempio più esaustivo disponibile per la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-392">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="b92f6-393">Il thread corrente non ha acceduto al blocco in modalità di scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-393">The current thread has not entered the lock in write mode.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-394">Ottiene un valore che indica se per il thread corrente è stato attivato il blocco in modalità lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-394">Gets a value that indicates whether the current thread has entered the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-395">
            <see langword="true" /> se per il thread corrente è stata attivata la modalità lettura; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-395">
              <see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-396">Questa proprietà deve essere utilizzata nelle asserzioni o per altri scopi di debug.</span><span class="sxs-lookup"><span data-stu-id="b92f6-396">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="b92f6-397">Non utilizzarlo per controllare il flusso dell'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="b92f6-397">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-398">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> proprietà per generare un'asserzione se il thread corrente è passato alla modalità di lettura in modo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="b92f6-398">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-399">Ottiene un valore che indica se per il thread corrente è stato attivato il blocco in modalità aggiornabile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-399">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-400">
            <see langword="true" /> se il thread corrente ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-400">
              <see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-401">Questa proprietà deve essere utilizzata nelle asserzioni o per altri scopi di debug.</span><span class="sxs-lookup"><span data-stu-id="b92f6-401">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="b92f6-402">Non utilizzarlo per controllare il flusso dell'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="b92f6-402">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-403">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> proprietà per generare un'asserzione se il thread corrente è in modalità aggiornabile in modo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="b92f6-403">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-404">Ottiene un valore che indica se per il thread corrente è stato attivato il blocco in modalità scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-404">Gets a value that indicates whether the current thread has entered the lock in write mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-405">
            <see langword="true" /> se il thread corrente ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-405">
              <see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-406">Questa proprietà deve essere utilizzata nelle asserzioni o per altri scopi di debug.</span><span class="sxs-lookup"><span data-stu-id="b92f6-406">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="b92f6-407">Non utilizzarlo per controllare il flusso dell'esecuzione del programma.</span><span class="sxs-lookup"><span data-stu-id="b92f6-407">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-408">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> proprietà per generare un'asserzione se il thread corrente è in modalità scrittura in modo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="b92f6-408">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-409">Ottiene un valore che indica i criteri di ricorsione per l'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-409">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-410">Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-410">One of the enumeration values that specifies the lock recursion policy.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-411">Criteri di ricorsione determinano le restrizioni sui thread che accedono al blocco più volte.</span><span class="sxs-lookup"><span data-stu-id="b92f6-411">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="b92f6-412">Ad esempio, se un blocco è stato creato con <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> e un thread è stato attivato il blocco in modalità lettura <xref:System.Threading.LockRecursionException> viene generata se il thread tenta di accedere nuovamente al blocco in modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-412">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-413">Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o downgrade alla modalità indipendentemente dall'impostazione di criteri di ricorsione di blocco di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-413">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="b92f6-414">Indipendentemente dal fatto di criteri di ricorsione, un thread che immesso inizialmente lettura modalità non è consentita eseguire l'aggiornamento in modalità aggiornabile o in modalità di scrittura, perché tale modello crea una forte probabilità di deadlock.</span><span class="sxs-lookup"><span data-stu-id="b92f6-414">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="b92f6-415">Per ulteriori informazioni sui criteri di ricorsione e i relativi effetti, vedere il <xref:System.Threading.LockRecursionPolicy> enumerazione e la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-415">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-416">Ottiene il numero di volte in cui per il thread corrente è stato attivato il blocco in modalità lettura, come indicazione della ricorsione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-416">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-417">0 (zero) se il thread corrente non è stata attivata la modalità lettura, 1 se il thread è in modalità lettura ma non in modo ricorsivo o *n* se il thread è stato attivato il blocco in modo ricorsivo *n* - 1 volte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-417">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-418">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-418">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="b92f6-419">I risultati possono cambiare come che sono state calcolate.</span><span class="sxs-lookup"><span data-stu-id="b92f6-419">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="b92f6-420">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</span><span class="sxs-lookup"><span data-stu-id="b92f6-420">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-421">Ottiene il numero di volte in cui per il thread corrente è stato attivato il blocco in modalità aggiornabile, come indicazione della ricorsione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-421">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-422">0 se il thread corrente non è stata attivata la modalità aggiornabile, 1 se il thread è in modalità aggiornabile ma non è stata attivata, in modo ricorsivo, o *n* se il thread è stata attivata la modalità aggiornabile in modo ricorsivo *n* - 1 volte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-422">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-423">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-423">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="b92f6-424">I risultati possono cambiare come che sono state calcolate.</span><span class="sxs-lookup"><span data-stu-id="b92f6-424">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="b92f6-425">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</span><span class="sxs-lookup"><span data-stu-id="b92f6-425">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-426">Ottiene il numero di volte in cui per il thread corrente è stato attivato il blocco in modalità scrittura, come indicazione della ricorsione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-426">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-427">0 se il thread corrente non è stata attivata la modalità scrittura, 1 se il thread è stata attivata la modalità scrittura ma non in modo ricorsivo o *n* se il thread è stata attivata la modalità di scrittura in modo ricorsivo *n* - 1 volte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-427">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-428">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-428">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="b92f6-429">I risultati possono cambiare come che sono state calcolate.</span><span class="sxs-lookup"><span data-stu-id="b92f6-429">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="b92f6-430">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</span><span class="sxs-lookup"><span data-stu-id="b92f6-430">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-431">Prova ad attivare il blocco in modalità lettura con un timeout facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-431">Tries to enter the lock in read mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="b92f6-432">Numero di millisecondi di attesa oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-432">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b92f6-433">Prova ad attivare il blocco in modalità lettura con un timeout intero facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-433">Tries to enter the lock in read mode, with an optional integer time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b92f6-434">
            <see langword="true" /> se il thread chiamante è passato in modalità lettura; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-434">
              <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-435">Se `millisecondsTimeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-435">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="b92f6-436">Più thread possono accedere in modalità di lettura nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="b92f6-436">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="b92f6-437">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodo si blocca fino a quando tali thread dispone di timeout o in modalità di scrittura e quindi sia terminato da esso o fino alla scadenza dell'intervallo di timeout del thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-437">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-438">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità lettura possibile immettere in modo ricorsivo modalità lettura, anche se altri thread in attesa di passare alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-438">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="b92f6-439">Un thread può essere in modalità aggiornabile, mentre altri thread è in modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-439">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="b92f6-440">Se i thread aggiuntivi sono in attesa di attivazione della modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, thread che chiamano il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodo passare immediatamente alla modalità di lettura e non vengono bloccati.</span><span class="sxs-lookup"><span data-stu-id="b92f6-440">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="b92f6-441">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-441">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="b92f6-442">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-442">-or-</span>
          </span>
          <span data-ttu-id="b92f6-443">Il numero di ricorsioni supererebbe la capacità del contatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-443">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="b92f6-444">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-444">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b92f6-445">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-445">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b92f6-446">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-446">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="b92f6-447">Intervallo di attesa oppure -1 millisecondi per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-447">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b92f6-448">Prova ad attivare il blocco in modalità lettura con un timeout facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-448">Tries to enter the lock in read mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b92f6-449">
            <see langword="true" /> se il thread chiamante è passato in modalità lettura; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-449">
              <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-450">Se `timeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-450">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="b92f6-451">Più thread può accedere al blocco in modalità di lettura nello stesso momento.</span><span class="sxs-lookup"><span data-stu-id="b92f6-451">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="b92f6-452">Se uno o più thread sono in coda per passare alla modalità di scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodo si blocca fino a quando tali thread dispone di timeout o in modalità di scrittura e quindi sia terminato da esso o fino alla scadenza dell'intervallo di timeout del thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-452">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-453">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità lettura possibile immettere in modo ricorsivo modalità lettura, anche se altri thread in attesa di passare alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-453">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="b92f6-454">Un thread può essere in modalità aggiornabile, mentre altri thread è in modalità lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-454">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="b92f6-455">Se i thread aggiuntivi sono in attesa di attivazione della modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, thread che chiamano il <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> metodo passare immediatamente alla modalità di lettura e non vengono bloccati.</span><span class="sxs-lookup"><span data-stu-id="b92f6-455">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="b92f6-456">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-456">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="b92f6-457">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-457">-or-</span>
          </span>
          <span data-ttu-id="b92f6-458">Il numero di ricorsioni supererebbe la capacità del contatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-458">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="b92f6-459">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-459">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b92f6-460">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-460">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="b92f6-461">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-461">-or-</span>
          </span>
          <span data-ttu-id="b92f6-462">Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-462">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b92f6-463">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-463">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-464">Prova ad attivare il blocco in modalità aggiornabile con un timeout facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="b92f6-465">Numero di millisecondi di attesa oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-465">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b92f6-466">Prova ad attivare il blocco in modalità aggiornabile con un timeout facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-466">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b92f6-467">
            <see langword="true" /> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-467">
              <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-468">Se `millisecondsTimeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-468">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="b92f6-469">Utilizzare la modalità aggiornabile quando un thread è in genere accede alla risorsa protetta dal <xref:System.Threading.ReaderWriterLockSlim> in modalità di lettura, ma potrebbe essere necessario passare alla modalità di scrittura, se vengono soddisfatte determinate condizioni.</span><span class="sxs-lookup"><span data-stu-id="b92f6-469">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="b92f6-470">Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o downgrade alla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-470">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="b92f6-471">Solo un thread può accedere un blocco in modalità aggiornabile in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="b92f6-471">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="b92f6-472">Se un thread è in modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, un numero qualsiasi di altri thread può passare alla modalità lettura, anche se sono presenti thread in attesa di attivazione della modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-472">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="b92f6-473">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metodo si blocca fino a quando tali thread dispone di timeout o in modalità di scrittura e quindi sia terminato da esso o fino alla scadenza dell'intervallo di timeout del thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-473">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-474">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità aggiornabile può accedere in modo ricorsivo in modalità aggiornabile, anche se altri thread in attesa di passare alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-474">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="b92f6-475">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-475">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="b92f6-476">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-476">-or-</span>
          </span>
          <span data-ttu-id="b92f6-477">Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-477">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="b92f6-478">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-478">-or-</span>
          </span>
          <span data-ttu-id="b92f6-479">Il numero di ricorsioni supererebbe la capacità del contatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-479">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="b92f6-480">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-480">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b92f6-481">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-481">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b92f6-482">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-482">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="b92f6-483">Intervallo di attesa oppure -1 millisecondi per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-483">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b92f6-484">Prova ad attivare il blocco in modalità aggiornabile con un timeout facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-484">Tries to enter the lock in upgradeable mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b92f6-485">
            <see langword="true" /> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-485">
              <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-486">Se `timeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-486">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="b92f6-487">Utilizzare la modalità aggiornabile quando un thread è in genere accedere alla risorsa protetta dal <xref:System.Threading.ReaderWriterLockSlim> in modalità di lettura, ma potrebbe essere necessario passare alla modalità di scrittura, se vengono soddisfatte determinate condizioni.</span><span class="sxs-lookup"><span data-stu-id="b92f6-487">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="b92f6-488">Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o downgrade alla modalità di lettura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-488">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="b92f6-489">Solo un thread può accedere un blocco in modalità aggiornabile in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="b92f6-489">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="b92f6-490">Se un thread è in modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, un numero qualsiasi di altri thread può passare alla modalità lettura, anche se sono presenti thread in attesa di attivazione della modalità aggiornabile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-490">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="b92f6-491">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> metodo si blocca fino a quando tali thread dispone di timeout o in modalità di scrittura e quindi sia terminato da esso o fino alla scadenza dell'intervallo di timeout del thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="b92f6-491">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-492">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità aggiornabile può accedere in modo ricorsivo in modalità aggiornabile, anche se altri thread in attesa di passare alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-492">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="b92f6-493">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-493">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="b92f6-494">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-494">-or-</span>
          </span>
          <span data-ttu-id="b92f6-495">Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-495">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="b92f6-496">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-496">-or-</span>
          </span>
          <span data-ttu-id="b92f6-497">Il numero di ricorsioni supererebbe la capacità del contatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-497">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="b92f6-498">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-498">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b92f6-499">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-499">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="b92f6-500">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-500">-or-</span>
          </span>
          <span data-ttu-id="b92f6-501">Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-501">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b92f6-502">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-502">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-503">Prova ad attivare il blocco in modalità scrittura con un timeout facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-503">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="b92f6-504">Numero di millisecondi di attesa oppure -1 (<see cref="F:System.Threading.Timeout.Infinite" />) per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-504">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b92f6-505">Prova ad attivare il blocco in modalità scrittura con un timeout facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-505">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b92f6-506">
            <see langword="true" /> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-506">
              <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-507">Se `millisecondsTimeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-507">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="b92f6-508">Se altri thread è stato attivato il blocco in modalità lettura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodo si blocca fino a quando tali thread sono usciti modalità lettura o fino a quando non è trascorso l'intervallo di timeout.</span><span class="sxs-lookup"><span data-stu-id="b92f6-508">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="b92f6-509">Mentre i thread sono bloccati in attesa di passare alla modalità di scrittura, gli altri thread che tentano di accedere alla modalità di lettura o in modalità aggiornabile bloccata fino a quando tutti i thread in attesa di accedere alla modalità di scrittura sono uno timeout o in modalità di scrittura e quindi sia terminato da esso.</span><span class="sxs-lookup"><span data-stu-id="b92f6-509">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-510">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità di scrittura può accedere in modo ricorsivo la modalità di scrittura, anche se altri thread in attesa di passare alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-510">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-511">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodo per attivare il blocco in modalità scrittura con un timeout. Il metodo illustrato nell'esempio aggiunge una nuova coppia chiave/valore per la cache sincronizzata.</span><span class="sxs-lookup"><span data-stu-id="b92f6-511">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="b92f6-512">Se l'intervallo di timeout specificato scade prima che il thread viene inserito il blocco, il metodo restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="b92f6-512">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="b92f6-513">Il metodo restituisce `true` se si aggiunge la coppia chiave/valore.</span><span class="sxs-lookup"><span data-stu-id="b92f6-513">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="b92f6-514">Se la chiave esiste già nella cache, l'eccezione generata dall'interno <xref:System.Collections.Generic.Dictionary%602> può terminare il metodo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-514">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="b92f6-515">Oggetto `finally` blocco viene utilizzato per eseguire il <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> metodo, assicurando che il chiamante viene chiuso il blocco.</span><span class="sxs-lookup"><span data-stu-id="b92f6-515">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="b92f6-516">Questo codice è parte di un esempio più esaustivo disponibile per la <xref:System.Threading.ReaderWriterLockSlim> classe.</span><span class="sxs-lookup"><span data-stu-id="b92f6-516">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="b92f6-517">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-517">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="b92f6-518">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-518">-or-</span>
          </span>
          <span data-ttu-id="b92f6-519">Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-519">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="b92f6-520">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-520">-or-</span>
          </span>
          <span data-ttu-id="b92f6-521">Il numero di ricorsioni supererebbe la capacità del contatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-521">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="b92f6-522">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-522">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b92f6-523">Il valore di <paramref name="millisecondsTimeout" /> è negativo, ma non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1), ovvero l'unico valore negativo consentito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-523">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b92f6-524">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-524">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="b92f6-525">Intervallo di attesa oppure -1 millisecondi per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-525">The interval to wait, or -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="b92f6-526">Prova ad attivare il blocco in modalità scrittura con un timeout facoltativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-526">Tries to enter the lock in write mode, with an optional time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="b92f6-527">
            <see langword="true" /> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-527">
              <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-528">Se `timeout` è 0 (zero), questo metodo controlla lo stato di blocco e restituisce `false` immediatamente se lo stato desiderato non è disponibile.</span><span class="sxs-lookup"><span data-stu-id="b92f6-528">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="b92f6-529">Se altri thread è stato attivato il blocco in modalità lettura, un thread che chiama il <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> metodo si blocca fino a quando tali thread sono usciti modalità lettura o fino a quando non è trascorso l'intervallo di timeout.</span><span class="sxs-lookup"><span data-stu-id="b92f6-529">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="b92f6-530">Mentre i thread sono bloccati in attesa di passare alla modalità di scrittura, gli altri thread che tentano di accedere alla modalità di lettura o in modalità aggiornabile bloccata fino a quando tutti i thread in attesa di accedere alla modalità di scrittura sono uno timeout o in modalità di scrittura e quindi sia terminato da esso.</span><span class="sxs-lookup"><span data-stu-id="b92f6-530">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b92f6-531">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità di scrittura può accedere in modo ricorsivo la modalità di scrittura, anche se altri thread in attesa di passare alla modalità di scrittura.</span><span class="sxs-lookup"><span data-stu-id="b92f6-531">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <span data-ttu-id="b92f6-532">La proprietà <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> è <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> e il thread corrente ha già acceduto al blocco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-532">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span>
          </span>
          <span data-ttu-id="b92f6-533">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-533">-or-</span>
          </span>
          <span data-ttu-id="b92f6-534">Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-534">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span>
          </span>
          <span data-ttu-id="b92f6-535">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-535">-or-</span>
          </span>
          <span data-ttu-id="b92f6-536">Il numero di ricorsioni supererebbe la capacità del contatore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-536">The recursion number would exceed the capacity of the counter.</span>
          </span>
          <span data-ttu-id="b92f6-537">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-537">The limit is so large that applications should never encounter it.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="b92f6-538">Il valore di <paramref name="timeout" /> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-538">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span>
          </span>
          <span data-ttu-id="b92f6-539">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-539">-or-</span>
          </span>
          <span data-ttu-id="b92f6-540">Il valore di <paramref name="timeout" /> è superiore a <see cref="F:System.Int32.MaxValue" /> millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-540">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="b92f6-541">L'oggetto <see cref="T:System.Threading.ReaderWriterLockSlim" /> è stato eliminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-541">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-542">Ottiene il numero complessivo di thread in attesa di attivazione del blocco in modalità lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-542">Gets the total number of threads that are waiting to enter the lock in read mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-543">Numero complessivo di thread in attesa di attivazione della modalità lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-543">The total number of threads that are waiting to enter read mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-544">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-544">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="b92f6-545">I risultati possono cambiare come che sono state calcolate.</span><span class="sxs-lookup"><span data-stu-id="b92f6-545">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="b92f6-546">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</span><span class="sxs-lookup"><span data-stu-id="b92f6-546">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-547">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> proprietà per generare una voce del registro eventi se il numero di thread bloccati, in attesa di attivazione della modalità di lettura, supera una soglia.</span><span class="sxs-lookup"><span data-stu-id="b92f6-547">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-548">Ottiene il numero complessivo di thread in attesa di attivazione del blocco in modalità aggiornabile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-548">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-549">Numero complessivo di thread in attesa di attivazione della modalità aggiornabile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-549">The total number of threads that are waiting to enter upgradeable mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-550">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-550">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="b92f6-551">I risultati possono cambiare come che sono state calcolate.</span><span class="sxs-lookup"><span data-stu-id="b92f6-551">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="b92f6-552">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</span><span class="sxs-lookup"><span data-stu-id="b92f6-552">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-553">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> proprietà per generare una voce del registro eventi se il numero di thread bloccati, in attesa di attivazione della modalità aggiornabile, supera una soglia.</span><span class="sxs-lookup"><span data-stu-id="b92f6-553">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="b92f6-554">Ottiene il numero complessivo di thread in attesa di attivazione del blocco in modalità scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-554">Gets the total number of threads that are waiting to enter the lock in write mode.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="b92f6-555">Numero complessivo di thread in attesa di attivazione della modalità scrittura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="b92f6-555">The total number of threads that are waiting to enter write mode.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b92f6-556">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="b92f6-556">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="b92f6-557">I risultati possono cambiare come che sono state calcolate.</span><span class="sxs-lookup"><span data-stu-id="b92f6-557">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="b92f6-558">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</span><span class="sxs-lookup"><span data-stu-id="b92f6-558">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b92f6-559">Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> proprietà per generare una voce del registro eventi se il numero di thread bloccati, in attesa di attivazione della modalità di scrittura, supera una soglia.</span><span class="sxs-lookup"><span data-stu-id="b92f6-559">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>