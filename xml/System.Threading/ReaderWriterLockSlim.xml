<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ReaderWriterLockSlim.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52ff770bb9446d6ebe71649784ebe115f60734cc0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ff770bb9446d6ebe71649784ebe115f60734cc0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</source>
          <target state="translated">Rappresenta un blocco che viene usato per gestire l'accesso a una risorsa, consentendo più thread per la lettura o l'accesso esclusivo per la scrittura.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> to protect a resource that is read by multiple threads and written to by one thread at a time.</source>
          <target state="translated">Utilizzare <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> per proteggere una risorsa che viene letta da più thread e scritta da un thread alla volta.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> consente a più thread in modalità di lettura, consente a un thread di essere in modalità scrittura con proprietà esclusiva del blocco e consente a un thread che è in modalità di lettura aggiornabile, da cui il thread può essere aggiornato alla modalità di scrittura senza la necessità di lasciare l'accesso in lettura s accesso in lettura alla risorsa.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> è simile a <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, ma include regole semplificate per la ricorsione e per l'aggiornamento e il downgrade dello stato del blocco.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> avoids many cases of potential deadlock.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> evita molti casi di deadlock potenziale.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In addition, the performance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is significantly better than <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">Inoltre, le prestazioni di <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> sono significativamente migliori di <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is recommended for all new development.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> è consigliato per tutte le nuove fasi di sviluppo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>By default, new instances of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> are created with the <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> flag and do not allow recursion.</source>
          <target state="translated">Per impostazione predefinita, le nuove istanze di <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> vengono creati con il <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> flag e non consentono la ricorsione.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">Il criterio predefinito è consigliato per lo sviluppo di nuovo, poiché la ricorsione presenta inutili complicazioni e rende il codice più soggetto a deadlock.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To simplify migration from existing projects that use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, you can use the <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> flag to create instances of <ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allow recursion.</source>
          <target state="translated">Per semplificare la migrazione da esistente progetti che utilizzano <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, è possibile utilizzare il <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> flag per creare istanze di <ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> che consentono la ricorsione.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</source>
          <target state="translated">Un thread può attivare il blocco in tre modalità: lettura modalità, modalità di scrittura e lettura aggiornabile.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter <ph id="ph1">`x`</ph> mode" is used in preference to the longer phrase "enter the lock in <ph id="ph2">`x`</ph> mode".)</source>
          <target state="translated">(Nella parte restante di questo argomento, "modalità di lettura aggiornabile" viene considerata "modalità aggiornabile", mentre la frase "immettere <ph id="ph1">`x`</ph> modalità" viene utilizzato al posto di frase più lunga "Immettere il blocco in <ph id="ph2">`x`</ph> modalità".)</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, only one thread can be in write mode at any time.</source>
          <target state="translated">Indipendentemente dalla criteri di ricorsione, solo un thread può essere in modalità di scrittura in qualsiasi momento.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a thread is in write mode, no other thread can enter the lock in any mode.</source>
          <target state="translated">Quando un thread è in modalità di scrittura, nessun altro thread può attivare il blocco in qualsiasi modalità.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Only one thread can be in upgradeable mode at any time.</source>
          <target state="translated">Solo un thread può essere in modalità aggiornabile in qualsiasi momento.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Qualsiasi numero di thread può essere in modalità di lettura e può esistere un solo thread in modalità aggiornabile mentre altri thread sono in modalità lettura.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Questo tipo implementa il <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaccia.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Per eliminare direttamente il tipo, chiamare il relativo <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> metodo in un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> blocco.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio <ph id="ph1">`using`</ph> in C# o <ph id="ph2">`Using`</ph> in Visual Basic.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> argomento relativo all'interfaccia.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> has managed thread affinity; that is, each <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> object must make its own method calls to enter and exit lock modes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> ha gestito l'affinità di thread; ovvero ogni <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> oggetto deve effettuare chiamate il proprio metodo per immettere e uscire dalla modalità di blocco.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No thread can change the mode of another thread.</source>
          <target state="translated">Nessun thread può modificare la modalità di un altro thread.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</source>
          <target state="translated">Se un <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> non consente la ricorsione, un thread che tenta di attivare il blocco può essere bloccato per diversi motivi:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</source>
          <target state="translated">Un thread che tenta di accedere in modalità lettura blocchi se sono presenti thread in attesa di accedere alla modalità di scrittura o se è un thread singolo in modalità scrittura.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Blocking new readers when writers are queued is a lock fairness policy that favors writers.</source>
          <target state="translated">Blocchi i lettori di nuovo quando vengono messe in coda i writer è un criterio di blocco equità che predilige i thread.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</source>
          <target state="translated">I criteri di equità corrente bilanciano equità tra i lettori e writer, per aumentare la velocità effettiva negli scenari più comuni.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Future versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> may introduce new fairness policies.</source>
          <target state="translated">Le versioni future del <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> può introdurre nuovi criteri di equità.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</source>
          <target state="translated">Un thread che tenta di accedere a blocchi in modalità aggiornabile se è già presente un thread in modalità aggiornabile, se sono presenti thread in attesa di passare alla modalità di scrittura o se è presente un thread singolo in modalità scrittura.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</source>
          <target state="translated">Un thread che tenta di accedere a modalità di scrittura viene bloccato se è presente un thread in una qualsiasi delle tre modalità.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrading and Downgrading Locks</source>
          <target state="translated">L'aggiornamento e downgrade dei blocchi</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</source>
          <target state="translated">La modalità aggiornabile è destinata ai casi in cui un thread in genere legge da una risorsa protetta, ma potrebbe essere necessario per la scrittura se vengono soddisfatte determinate condizioni.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has entered a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> methods.</source>
          <target state="translated">Un thread che ha immesso un <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in modalità aggiornabile con accesso in lettura alla risorsa protetta e possibile eseguire l'aggiornamento alla modalità di scrittura chiamando il <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> metodi.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</source>
          <target state="translated">Poiché possono esistere solo un thread in modalità aggiornabile in una fase, l'aggiornamento alla modalità di scrittura non può causare un deadlock durante la ricorsione non è consentita, ovvero i criteri predefiniti.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Indipendentemente dal fatto di criteri di ricorsione, un thread che immesso inizialmente lettura modalità non è consentita eseguire l'aggiornamento in modalità aggiornabile o in modalità di scrittura, perché tale modello crea una forte probabilità di deadlock.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For example, if two threads in read mode both try to enter write mode, they will deadlock.</source>
          <target state="translated">Ad esempio, se due thread in modalità lettura che entrambi tentano di accedere alla modalità di scrittura, provocano un deadlock.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is designed to avoid such deadlocks.</source>
          <target state="translated">La modalità aggiornabile è progettata per evitare tali deadlock.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads in read mode, the thread that is upgrading blocks.</source>
          <target state="translated">Se sono presenti altri thread in modalità lettura, il thread che sta eseguendo l'aggiornamento di blocchi.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>While the thread is blocked, other threads that try to enter read mode are blocked.</source>
          <target state="translated">Mentre il thread è bloccato, altri thread che tenta di passare alla modalità di lettura vengono bloccate.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</source>
          <target state="translated">Quando tutti i thread sono usciti dalla modalità di lettura, il thread aggiornabile bloccato passa alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</source>
          <target state="translated">Se sono presenti altri thread in attesa di accedere alla modalità di scrittura, rimangono bloccati, perché il thread singolo in modalità aggiornabile impedisce loro di ottenere accesso esclusivo alla risorsa.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</source>
          <target state="translated">Quando il thread in modalità aggiornabile esce dalla modalità di scrittura, altri thread in attesa di passare alla modalità di lettura possono farlo, a meno che non sono presenti thread in attesa di accedere alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</source>
          <target state="translated">Il thread in modalità aggiornabile può aggiornare o effettuare il downgrade all'infinito, fino a quando è l'unico thread che consente di scrivere la risorsa protetta.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</source>
          <target state="translated">Se si consente a più thread immettere modalità di scrittura o la modalità aggiornabile, che non è necessario consentire un thread di monopolizzare la modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</source>
          <target state="translated">In caso contrario, i thread che tentano di accedere scrivere modalità direttamente verrà bloccata per un periodo illimitato, e mentre sono bloccati, altri thread sarà in grado di accedere alla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can downgrade to read mode by first calling the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method and then calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method.</source>
          <target state="translated">Può effettuare il downgrade di un thread in modalità aggiornabile per la modalità di lettura da chiamare prima il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> metodo e chiamando quindi il <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This downgrade pattern is allowed for all lock recursion policies, even <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.</source>
          <target state="translated">Questo modello di downgrade è consentito anche per tutti i criteri di ricorsione di blocco, <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</source>
          <target state="translated">Dopo il downgrade alla modalità di lettura, un thread non è possibile immettere nuovamente la modalità aggiornabile fino a quando non sarà uscito dalla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering the Lock Recursively</source>
          <target state="translated">Immettere il blocco in modo ricorsivo</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that supports recursive lock entry by using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> constructor that specifies lock policy, and specifying <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">È possibile creare un <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> che supporta una voce ricorsiva blocco tramite il <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> costruttore che specifica i criteri di blocco e specificando <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">Non è consigliabile usare di ricorsione per un nuovo sviluppo, in quanto presenta inutili complicazioni e rende il codice più soggetto a deadlock.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allows recursion, the following can be said about the modes a thread can enter:</source>
          <target state="translated">Per un <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> che consente la ricorsione, sulle modalità di un thread può entrare possono affermare che le operazioni seguenti:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</source>
          <target state="translated">Un thread in modalità lettura è possibile immettere in modo ricorsivo alla modalità di lettura, ma non può accedere alla modalità di scrittura o in modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If it tries to do this, a <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown.</source>
          <target state="translated">Se tenta di eseguire questa operazione, un <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</source>
          <target state="translated">Immissione di leggere modalità e quindi immettere la modalità scrittura o in modalità aggiornabile è un modello con una forte probabilità di deadlock, pertanto non è consentita.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</source>
          <target state="translated">Come illustrato in precedenza, la modalità aggiornabile viene fornita per i casi in cui è necessario eseguire l'aggiornamento di un blocco.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</source>
          <target state="translated">Un thread in modalità aggiornabile può immettere modalità di scrittura e/o modalità di lettura e può accedere a ognuna in modo ricorsivo le tre modalità.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>However, an attempt to enter write mode blocks if there are other threads in read mode.</source>
          <target state="translated">Tuttavia, un tentativo di immettere scrivere blocchi di modalità se sono presenti altri thread in modalità lettura.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</source>
          <target state="translated">Un thread in modalità di scrittura è possibile immettere modalità di lettura e/o in modalità aggiornabile e può accedere a ognuna in modo ricorsivo le tre modalità.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has not entered the lock can enter any mode.</source>
          <target state="translated">Un thread che non è stato attivato il blocco è possibile immettere qualsiasi modalità.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</source>
          <target state="translated">Questo tentativo può essere bloccato per gli stessi motivi un tentativo di attivare un blocco non ricorsivo.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</source>
          <target state="translated">Un thread può uscire le modalità che è entrato in qualsiasi ordine, purché al termine di ogni modalità esattamente le volte che tale modalità.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> is thrown.</source>
          <target state="translated">Se un thread di prova per uscire da una modalità troppe volte o per uscire da una modalità non ha immesso, un <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Lock States</source>
          <target state="translated">Stati di blocco</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You may find it useful to think of the lock in terms of its states.</source>
          <target state="translated">Si può risultare utile pensare in termini di stati di blocco.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> can be in one of four states: not entered, read, upgrade, and write.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> può essere in uno dei quattro stati: non si immette, lettura, aggiornamento e scrittura.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</source>
          <target state="translated">Non è stato immesso: In questo stato, nessun thread è stato attivato il blocco (o tutti i thread sono usciti dal blocco).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read: In this state, one or more threads have entered the lock for read access to the protected resource.</source>
          <target state="translated">Leggere: In questo stato, uno o più thread hanno attivato il blocco per l'accesso in lettura alla risorsa protetta.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in read mode by using the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> methods, or by downgrading from upgradeable mode.</source>
          <target state="translated">Un thread può accedere il blocco in modalità lettura con il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metodi, o il downgrade dalla modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</source>
          <target state="translated">Aggiornamento: In questo stato, un thread è stato attivato il blocco per l'accesso in lettura con l'opzione di aggiornamento per l'accesso in scrittura (ovvero in modalità aggiornabile), e zero o più thread è stato attivato il blocco per l'accesso in lettura.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</source>
          <target state="translated">Non più di un thread alla volta può attivare il blocco con l'opzione di aggiornamento; gli altri thread che tenta di accedere alla modalità aggiornabile vengono bloccate.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write: In this state, one thread has entered the lock for write access to the protected resource.</source>
          <target state="translated">Scrittura: In questo stato, un thread è stato attivato il blocco dell'accesso in scrittura alla risorsa protetta.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>That thread has exclusive possession of the lock.</source>
          <target state="translated">Il thread ha possesso esclusivo del blocco.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any other thread that tries to enter the lock for any reason is blocked.</source>
          <target state="translated">Qualsiasi altro thread che tenta di attivare il blocco per qualsiasi motivo è bloccato.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread <ph id="ph1">`t`</ph> takes the action described in the leftmost column.</source>
          <target state="translated">Nella tabella seguente vengono descritte le transizioni tra stati di blocco, per i blocchi che non consentono la ricorsione, quando un thread <ph id="ph1">`t`</ph> esegue l'azione descritta nella colonna più a sinistra.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>At the time it takes the action, <ph id="ph1">`t`</ph> has no mode.</source>
          <target state="translated">Quando esegue l'azione, <ph id="ph1">`t`</ph> non possiede alcuna modalità.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The special case where <ph id="ph1">`t`</ph> is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</source>
          <target state="translated">(Il caso speciale in cui <ph id="ph1">`t`</ph> è in modalità aggiornabile è descritto nella piè di pagina di tabella.) La riga superiore descrive lo stato inizio del blocco.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The cells describe what happens to the thread, and show changes to the lock state in parentheses.</source>
          <target state="translated">Le celle viene descritto cosa succede al thread e visualizzare le modifiche apportate allo stato di blocco tra parentesi.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered (N)</source>
          <target state="translated">Nessun accesso (N)</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read (R)</source>
          <target state="translated">Read (R)</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade (U)</source>
          <target state="translated">Aggiornamento (U)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write (W)</source>
          <target state="translated">Scrittura (S)</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters read mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> passa alla modalità di lettura</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (R).</source>
          <target state="translated"><ph id="ph1">`t`</ph> immette (R).</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.</source>
          <target state="translated"><ph id="ph1">`t`</ph> viene bloccato se i thread sono in attesa per la modalità scrittura; in caso contrario, <ph id="ph2">`t`</ph> immette.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> viene bloccato se i thread sono in attesa per la modalità scrittura; in caso contrario, <ph id="ph2">`t`</ph> immette.<bpt id="p1">&lt;sup&gt;</bpt> 1<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blocchi.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters upgradeable mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> passa alla modalità aggiornabile</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> immette (U).</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode or upgrade mode; otherwise, <ph id="ph2">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> viene bloccato se i thread sono in attesa per la modalità di scrittura o la modalità di aggiornamento; in caso contrario, <ph id="ph2">`t`</ph> immette (U).</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blocchi.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blocchi.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters write mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> passa alla modalità di scrittura</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (W).</source>
          <target state="translated"><ph id="ph1">`t`</ph> immette (W).</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blocchi.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> blocchi. <bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> blocchi.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it enters read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> se <ph id="ph1">`t`</ph> inizia la disconnessione in modalità aggiornabile, passa alla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This action never blocks.</source>
          <target state="translated">Blocca mai questa azione.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state does not change.</source>
          <target state="translated">Non modifica lo stato del blocco.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</source>
          <target state="translated">(Il thread può quindi completare un downgrade alla modalità di lettura per disattivare la modalità aggiornabile.)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it blocks if there are threads in read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> se <ph id="ph1">`t`</ph> viene avviato in modalità aggiornabile, si blocca se sono presenti thread in modalità lettura.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise it upgrades to write mode.</source>
          <target state="translated">In caso contrario si effettua l'aggiornamento alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state changes to Write (W).</source>
          <target state="translated">Le modifiche di stato di blocco per scrittura (S).</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If <ph id="ph1">`t`</ph> blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</source>
          <target state="translated">Se <ph id="ph1">`t`</ph> blocca perché sono presenti thread in modalità lettura, passa alla modalità di scrittura non appena l'ultimo thread esce dalla modalità di lettura, anche se sono presenti thread in attesa di accedere alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</source>
          <target state="translated">Quando una modifica dello stato si verifica perché un thread termina il blocco, il successivo thread che riattivati viene selezionato come segue:</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</source>
          <target state="translated">Innanzitutto, un thread in attesa di modalità di scrittura ed è già in modalità aggiornabile (possono essere presenti al massimo un thread di questo tipo).</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for write mode.</source>
          <target state="translated">Mancanza, un thread in attesa per la modalità scrittura.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for upgradeable mode.</source>
          <target state="translated">Mancanza, un thread in attesa per la modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, all threads that are waiting for read mode.</source>
          <target state="translated">Mancanza, tutti i thread in attesa per la modalità lettura.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</source>
          <target state="translated">Lo stato del blocco successivo è sempre scrittura (S) del primo di due casi e aggiornamento (U) nel terzo caso, indipendentemente dallo stato del blocco quando il thread in fase di chiusura è attivato il cambiamento di stato.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</source>
          <target state="translated">Nell'ultimo caso, lo stato del blocco è aggiornamento (U) se non vi è un thread in modalità aggiornabile dopo la modifica dello stato e Read (R) in caso contrario, indipendentemente dallo stato precedente.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">Nell'esempio seguente viene illustrato una semplice cache sincronizzata contenente stringhe con chiavi di interi.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">Un'istanza di <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> viene utilizzato per sincronizzare l'accesso per il <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> che funge da cache interna.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">L'esempio include metodi semplici per aggiungere alla cache, eliminare dalla cache e leggere dalla cache.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">Per illustrare i timeout, l'esempio include un metodo che viene aggiunto alla cache solo se è possibile eseguire questa operazione all'interno di un timeout specificato.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Per dimostrare la modalità aggiornabile, l'esempio include un metodo che recupera il valore associato alla chiave e lo confronta con un nuovo valore.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Se il valore è stata modificata, viene aggiornata.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">La modalità aggiornabile consente al thread di eseguire l'aggiornamento da accesso in lettura all'accesso in scrittura in base alle necessità, senza il rischio di deadlock.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">L'esempio include un'enumerazione nidificata che specifica i valori restituiti per il metodo che illustra la modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">L'esempio Usa il costruttore predefinito per creare il blocco, quindi non è consentita la ricorsione.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programmazione di <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> è più semplice e meno soggetto a errori quando il blocco non consente la ricorsione.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">Il codice seguente usa quindi il <ph id="ph1">`SynchronizedCache`</ph> oggetto usato per archiviare un dizionario di nomi ortaggi.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It creates three tasks.</source>
          <target state="translated">Crea tre attività.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Il primo vengono scritti i nomi di verdure archiviate in una matrice a un <ph id="ph1">`SynchronizedCache`</ph> istanza.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">L'attività di seconda e terza visualizzare i nomi di verdura, il primo in senso crescente (da bassa indice indice massimo), il secondo in ordine decrescente.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">L'attività finale cerca la stringa "cucumber" e, quando viene trovata, chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> metodo per sostituire la stringa "verde bean".</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type is thread safe.</source>
          <target state="translated">Questo tipo è thread-safe.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class with default property values.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> con i valori predefiniti delle proprietà.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that is initialized with this constructor does not allow recursion.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> che viene inizializzato con questo costruttore non consente la ricorsione.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>That is, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property returns <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Quindi la proprietà <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> restituisce <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Per ulteriori informazioni sui criteri di ricorsione e i relativi effetti, vedere il <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumerazione e la <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">Nell'esempio seguente viene illustrato una semplice cache sincronizzata contenente stringhe con chiavi di interi.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">Un'istanza di <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> viene utilizzato per sincronizzare l'accesso per il <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> che funge da cache interna.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The parameterless constructor is used to create the lock.</source>
          <target state="translated">Il costruttore senza parametri viene utilizzato per creare il blocco.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">L'esempio include metodi semplici per aggiungere alla cache, eliminare dalla cache e leggere dalla cache.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">Per illustrare i timeout, l'esempio include un metodo che viene aggiunto alla cache solo se è possibile eseguire questa operazione all'interno di un timeout specificato.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Per dimostrare la modalità aggiornabile, l'esempio include un metodo che recupera il valore associato alla chiave e lo confronta con un nuovo valore.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Se il valore è stata modificata, viene aggiornata.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">La modalità aggiornabile consente al thread di eseguire l'aggiornamento da accesso in lettura all'accesso in scrittura in base alle necessità, senza il rischio di deadlock.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">L'esempio include un'enumerazione nidificata che specifica i valori restituiti per il metodo che illustra la modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">L'esempio Usa il costruttore predefinito per creare il blocco, quindi non è consentita la ricorsione.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programmazione di <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> è più semplice e meno soggetto a errori quando il blocco non consente la ricorsione.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">Il codice seguente usa quindi il <ph id="ph1">`SynchronizedCache`</ph> oggetto usato per archiviare un dizionario di nomi ortaggi.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It creates three tasks.</source>
          <target state="translated">Crea tre attività.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Il primo vengono scritti i nomi di verdure archiviate in una matrice a un <ph id="ph1">`SynchronizedCache`</ph> istanza.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">L'attività di seconda e terza visualizzare i nomi di verdura, il primo in senso crescente (da bassa indice indice massimo), il secondo in ordine decrescente.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">L'attività finale cerca la stringa "cucumber" e, quando viene trovata, chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> metodo per sostituire la stringa "verde bean".</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class, specifying the lock recursion policy.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>, specificando i criteri di ricorsione del blocco.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">Criteri di ricorsione determinano le restrizioni sui thread che accedono al blocco più volte.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">Ad esempio, se un blocco è stato creato con <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> e un thread è stato attivato il blocco in modalità lettura <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> viene generata se il thread tenta di accedere nuovamente al blocco in modalità lettura.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Similarly, if a thread has entered the lock in write mode, <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in any mode.</source>
          <target state="translated">Analogamente, se un thread è stato attivato il blocco in modalità scrittura <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> viene generata se il thread tenta di accedere nuovamente al blocco in qualsiasi modalità.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o downgrade alla modalità indipendentemente dall'impostazione di criteri di ricorsione di blocco di lettura.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Indipendentemente dal fatto di criteri di ricorsione, un thread che immesso inizialmente lettura modalità non è consentita eseguire l'aggiornamento in modalità aggiornabile o in modalità di scrittura, perché tale modello crea una forte probabilità di deadlock.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Per ulteriori informazioni sui criteri di ricorsione e i relativi effetti, vedere il <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumerazione e la <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">L'esempio seguente mostra due scenari di eccezione, che varia a seconda di <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> impostazione e l'altro no.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</source>
          <target state="translated">Nel primo scenario, il thread passa alla modalità di lettura e quindi tenta di accedere in modo ricorsivo alla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> viene creato utilizzando il costruttore predefinito, che imposta i criteri di ricorsione per <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> is used to create the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Se <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> viene utilizzato per creare il <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the second scenario, the thread enters read mode and then tries to enter write mode.</source>
          <target state="translated">Nel secondo scenario, il thread passa alla modalità di lettura e quindi tenta di accedere alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> viene generata un'eccezione indipendentemente dai criteri di ricorsione del blocco.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">Il codice seguente usa quindi il <ph id="ph1">`SynchronizedCache`</ph> oggetto usato per archiviare un dizionario di nomi ortaggi.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>It creates three tasks.</source>
          <target state="translated">Crea tre attività.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">Il primo vengono scritti i nomi di verdure archiviate in una matrice a un <ph id="ph1">`SynchronizedCache`</ph> istanza.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">L'attività di seconda e terza visualizzare i nomi di verdura, il primo in senso crescente (da bassa indice indice massimo), il secondo in ordine decrescente.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">L'attività finale cerca la stringa "cucumber" e, quando viene trovata, chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> metodo per sostituire la stringa "verde bean".</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Gets the total number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">Ottiene il numero complessivo di thread univoci per i quali è stato attivato il blocco in modalità lettura.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">Numero di thread univoci per i quali è stato attivato il blocco in modalità lettura.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</source>
          <target state="translated">Un thread viene conteggiato una sola volta, anche se il blocco consente la ricorsione e il thread è in modalità lettura più volte.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">I risultati possono cambiare come che sono state calcolate.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph> proprietà per generare una voce del registro eventi se il numero di thread in modalità lettura supera una soglia.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated">Rilascia tutte le risorse usate dall'istanza corrente della classe <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated">Chiamare il metodo <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> dopo aver terminato di utilizzare l'oggetto <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in an unusable state.</source>
          <target state="translated">Il metodo <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> lascia l'oggetto <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in una condizione di inutilizzabilità.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>After calling <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> was occupying.</source>
          <target state="translated">Dopo la chiamata <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, è necessario rilasciare tutti i riferimenti al <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in modo che il garbage collector può recuperare la memoria che di <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> occupata.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni, vedere <bpt id="p1">[</bpt>la pulizia di risorse non gestite<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> e <bpt id="p2">[</bpt>implementazione di un metodo Dispose<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Always call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> object.</source>
          <target state="translated">Chiamare sempre il metodo <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> prima di rilasciare l'ultimo riferimento al <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> è maggiore di zero.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> è maggiore di zero.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> è maggiore di zero.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Tries to enter the lock in read mode.</source>
          <target state="translated">Prova ad attivare il blocco in modalità lettura.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Questo metodo si blocca fino a quando il thread chiamante accede al blocco e pertanto potrebbe non essere mai restituito.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> modalità di lettura per blocco per un intervallo specificato e quindi restituire se il thread chiamante non ha immesso durante l'intervallo.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">Più thread possono accedere in modalità di lettura nello stesso momento.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> metodo si blocca fino a quando non avere tali thread timeout o in modalità di scrittura e quindi sia terminato da esso.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità lettura possibile immettere in modo ricorsivo modalità lettura, anche se altri thread in attesa di passare alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>At most one thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Al massimo un thread può essere in modalità aggiornabile, mentre altri thread è in modalità lettura.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Se i thread aggiuntivi sono in attesa di attivazione della modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, thread che chiamano il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> metodo passare immediatamente alla modalità di lettura e non vengono bloccati.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method to enter the lock in read mode.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> metodo per attivare il blocco in modalità lettura.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">Il metodo illustrato nell'esempio recupera il valore associato alla chiave.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Se la chiave non viene trovata, l'eccezione generata dall'interno <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> può terminare il metodo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">Oggetto <ph id="ph1">`finally`</ph> blocco viene utilizzato per eseguire il <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> (metodo), assicurando che il chiamante esca dalla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The current thread cannot acquire the write lock when it holds the read lock.</source>
          <target state="translated">Il thread corrente non è in grado di acquisire il blocco di scrittura quando contiene il blocco di lettura.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the read lock.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di lettura.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the write lock.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha tentato di acquisire il blocco di lettura quando contiene già il blocco di scrittura.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Il numero di ricorsioni supererebbe la capacità del contatore.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This limit is so large that applications should never encounter this exception.</source>
          <target state="translated">Questo limite è talmente elevato che questa eccezione non dovrebbe essere mai riscontrata.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Tries to enter the lock in upgradeable mode.</source>
          <target state="translated">Prova ad attivare il blocco in modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Questo metodo si blocca fino a quando il thread chiamante accede al blocco e pertanto potrebbe non essere mai restituito.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> metodo di blocco per un intervallo specificato e restituire quindi se il thread chiamante non ha passato in modalità aggiornabile durante l'intervallo.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Utilizzare la modalità aggiornabile quando un thread è in genere accede alla risorsa protetta dal <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in modalità di lettura, ma potrebbe essere necessario passare alla modalità di scrittura, se vengono soddisfatte determinate condizioni.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</source>
          <target state="translated">Un thread in modalità aggiornabile può downgrade alla modalità di lettura o l'aggiornamento alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Only one thread can enter upgradeable mode at any given time.</source>
          <target state="translated">Solo un thread può accedere alla modalità aggiornabile in qualsiasi momento.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Se un thread è in modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, un numero qualsiasi di altri thread può passare alla modalità lettura, anche se sono presenti thread in attesa di attivazione della modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> metodo si blocca fino a quando non avere tali thread timeout o in modalità di scrittura e quindi sia terminato da esso.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità aggiornabile può accedere in modo ricorsivo in modalità aggiornabile, anche se altri thread in attesa di passare alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method to enter the lock in upgradeable mode.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> metodo per attivare il blocco in modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">Oggetto <ph id="ph1">`finally`</ph> blocco viene utilizzato per eseguire il <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> (metodo), assicurando che il chiamante esca dalla modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Il metodo illustrato nell'esempio recupera il valore associato alla chiave e lo confronta con un nuovo valore.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Se il valore è stata modificata, viene aggiornata.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">La modalità aggiornabile consente al thread di aggiornare il blocco di lettura in base alle necessità, senza il rischio di deadlock.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">L'esempio Usa il costruttore predefinito per creare il blocco, quindi non è consentita la ricorsione.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programmazione di <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> è più semplice e meno soggetto a errori quando il blocco non consente la ricorsione.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha già acceduto al blocco in tutte le modalità.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Il thread corrente ha acceduto alla modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Il numero di ricorsioni supererebbe la capacità del contatore.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Tries to enter the lock in write mode.</source>
          <target state="translated">Prova ad attivare il blocco in modalità scrittura.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">Questo metodo si blocca fino a quando il thread chiamante accede al blocco e pertanto potrebbe non essere mai restituito.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</source>
          <target state="translated">Utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> metodo di blocco per un intervallo specificato e restituire quindi se il thread chiamante non ha passato in modalità scrittura durante l'intervallo.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode.</source>
          <target state="translated">Se altri thread è stato attivato il blocco in modalità lettura, un thread che chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> metodo si blocca fino a quando tali thread sono usciti dalla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Quando sono presenti thread in attesa di passare alla modalità di scrittura, gli altri thread che tentano di accedere alla modalità di lettura o di blocco in modalità aggiornabile fino a che i tutti i thread in attesa di passare alla modalità di scrittura verificato il timeout o in modalità di scrittura e quindi sia terminato da esso.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità di scrittura può accedere in modo ricorsivo la modalità di scrittura, anche se altri thread in attesa di passare alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method to enter the lock in write mode.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> metodo per attivare il blocco in modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Il metodo illustrato nell'esempio aggiunge una nuova coppia chiave/valore per la cache sincronizzata.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Se la chiave esiste già nella cache, l'eccezione generata dall'interno <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> può terminare il metodo.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">Oggetto <ph id="ph1">`finally`</ph> blocco viene utilizzato per eseguire il <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> (metodo), assicurando che il chiamante esca dalla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha già acceduto al blocco in tutte le modalità.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</source>
          <target state="translated">Il thread corrente ha acceduto alla modalità di lettura, pertanto il tentativo di accedere al blocco in modalità di scrittura creerebbe la possibilità di un deadlock.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Il numero di ricorsioni supererebbe la capacità del contatore.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</source>
          <target state="translated">Riduce il numero di ricorsioni per la modalità lettura ed esce da questa modalità se il numero risultante è 0 (zero).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Questo metodo non sono riservato all'ordine di ricorsione.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Ad esempio, se un thread entra in un blocco in modalità aggiornabile e successivamente il blocco in modalità lettura, l'ordine in cui le due modalità si esce dal thread non è rilevante.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread può attivare il blocco in modalità di scrittura e quindi in modo ricorsivo in modalità lettura; l'ordine in cui la chiusura del thread in modalità lettura e scrittura non è importante.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">L'uscita dal blocco potrebbe segnalare altri thread in attesa.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare un <ph id="ph1">`finally`</ph> esecuzione del blocco di <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> (metodo), assicurando che il chiamante esca dalla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">Il metodo illustrato nell'esempio recupera il valore associato alla chiave.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Se la chiave non viene trovata, l'eccezione generata dall'interno <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> può terminare il metodo.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method is used to enter read mode.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> metodo viene utilizzato per passare alla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The current thread has not entered the lock in read mode.</source>
          <target state="translated">Il thread corrente non ha acceduto al blocco in modalità di lettura.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</source>
          <target state="translated">Riduce il numero di ricorsioni per la modalità aggiornabile ed esce da questa modalità se il numero risultante è 0 (zero).</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Questo metodo non sono riservato all'ordine di ricorsione.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Ad esempio, se un thread entra in un blocco in modalità aggiornabile e successivamente il blocco in modalità di scrittura, l'ordine in cui le due modalità si esce dal thread non è rilevante.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread può attivare il blocco in modalità di scrittura e quindi in modo ricorsivo in modalità aggiornabile; l'ordine in cui il thread esce da questa modalità di scrittura e di modalità non è rilevante.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">L'uscita dal blocco potrebbe segnalare altri thread in attesa.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare un <ph id="ph1">`finally`</ph> esecuzione del blocco di <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> (metodo), assicurando che il chiamante esca dalla modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">Il metodo illustrato nell'esempio recupera il valore associato alla chiave e lo confronta con un nuovo valore.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">Se il valore viene modificato, il metodo restituisce uno stato che indica nessuna modifica.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">Viene trovato alcun valore per la chiave, viene inserita la coppia chiave/valore.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">Se il valore è stata modificata, viene aggiornata.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">La modalità aggiornabile consente al thread di aggiornare il blocco di lettura in base alle necessità, senza il rischio di deadlock.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">L'esempio Usa il costruttore predefinito per creare il blocco, quindi non è consentita la ricorsione.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">Programmazione di <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> è più semplice e meno soggetto a errori quando il blocco non consente la ricorsione.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The current thread has not entered the lock in upgradeable mode.</source>
          <target state="translated">Il thread corrente non ha acceduto al blocco in modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</source>
          <target state="translated">Riduce il numero di ricorsioni per la modalità scrittura ed esce da questa modalità se il numero risultante è 0 (zero).</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">Questo metodo non sono riservato all'ordine di ricorsione.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">Ad esempio, se un thread entra in un blocco in modalità aggiornabile e successivamente il blocco in modalità di scrittura, l'ordine in cui le due modalità si esce dal thread non è rilevante.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread può attivare il blocco in modalità di scrittura e quindi in modo ricorsivo in modalità lettura; l'ordine in cui la chiusura del thread in modalità lettura e scrittura non è importante.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">L'uscita dal blocco potrebbe segnalare altri thread in attesa.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare un <ph id="ph1">`finally`</ph> esecuzione del blocco di <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> (metodo), assicurando che il chiamante esca dalla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Il metodo illustrato nell'esempio aggiunge una nuova coppia chiave/valore per la cache sincronizzata.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Se la chiave esiste già nella cache, l'eccezione generata dall'interno <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> può terminare il metodo.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method is used to enter the lock in write mode.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> metodo viene utilizzato per attivare il blocco in modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The current thread has not entered the lock in write mode.</source>
          <target state="translated">Il thread corrente non ha acceduto al blocco in modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in read mode.</source>
          <target state="translated">Ottiene un valore che indica se per il thread corrente è stato attivato il blocco in modalità lettura.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered read mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se per il thread corrente è stata attivata la modalità lettura; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Questa proprietà deve essere utilizzata nelle asserzioni o per altri scopi di debug.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Non utilizzarlo per controllare il flusso dell'esecuzione del programma.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered read mode unexpectedly.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph> proprietà per generare un'asserzione se il thread corrente è passato alla modalità di lettura in modo imprevisto.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</source>
          <target state="translated">Ottiene un valore che indica se per il thread corrente è stato attivato il blocco in modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered upgradeable mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il thread corrente ha acceduto alla modalità aggiornabile; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Questa proprietà deve essere utilizzata nelle asserzioni o per altri scopi di debug.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Non utilizzarlo per controllare il flusso dell'esecuzione del programma.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph> proprietà per generare un'asserzione se il thread corrente è in modalità aggiornabile in modo imprevisto.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in write mode.</source>
          <target state="translated">Ottiene un valore che indica se per il thread corrente è stato attivato il blocco in modalità scrittura.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered write mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il thread corrente ha acceduto alla modalità di scrittura; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">Questa proprietà deve essere utilizzata nelle asserzioni o per altri scopi di debug.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">Non utilizzarlo per controllare il flusso dell'esecuzione del programma.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered write mode unexpectedly.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph> proprietà per generare un'asserzione se il thread corrente è in modalità scrittura in modo imprevisto.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Gets a value that indicates the recursion policy for the current <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object.</source>
          <target state="translated">Ottiene un valore che indica i criteri di ricorsione per l'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> corrente.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">Uno dei valori di enumerazione che specifica i criteri di ricorsione del blocco.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">Criteri di ricorsione determinano le restrizioni sui thread che accedono al blocco più volte.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">Ad esempio, se un blocco è stato creato con <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> e un thread è stato attivato il blocco in modalità lettura <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> viene generata se il thread tenta di accedere nuovamente al blocco in modalità lettura.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o downgrade alla modalità indipendentemente dall'impostazione di criteri di ricorsione di blocco di lettura.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">Indipendentemente dal fatto di criteri di ricorsione, un thread che immesso inizialmente lettura modalità non è consentita eseguire l'aggiornamento in modalità aggiornabile o in modalità di scrittura, perché tale modello crea una forte probabilità di deadlock.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Per ulteriori informazioni sui criteri di ricorsione e i relativi effetti, vedere il <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumerazione e la <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</source>
          <target state="translated">Ottiene il numero di volte in cui per il thread corrente è stato attivato il blocco in modalità lettura, come indicazione della ricorsione.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered the lock recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0 (zero) se il thread corrente non è stata attivata la modalità lettura, 1 se il thread è in modalità lettura ma non in modo ricorsivo o <bpt id="p1">*</bpt>n<ept id="p1">*</ept> se il thread è stato attivato il blocco in modo ricorsivo <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 volte.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">I risultati possono cambiare come che sono state calcolate.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</source>
          <target state="translated">Ottiene il numero di volte in cui per il thread corrente è stato attivato il blocco in modalità aggiornabile, come indicazione della ricorsione.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered upgradeable mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0 se il thread corrente non è stata attivata la modalità aggiornabile, 1 se il thread è in modalità aggiornabile ma non è stata attivata, in modo ricorsivo, o <bpt id="p1">*</bpt>n<ept id="p1">*</ept> se il thread è stata attivata la modalità aggiornabile in modo ricorsivo <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 volte.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">I risultati possono cambiare come che sono state calcolate.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</source>
          <target state="translated">Ottiene il numero di volte in cui per il thread corrente è stato attivato il blocco in modalità scrittura, come indicazione della ricorsione.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered write mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0 se il thread corrente non è stata attivata la modalità scrittura, 1 se il thread è stata attivata la modalità scrittura ma non in modo ricorsivo o <bpt id="p1">*</bpt>n<ept id="p1">*</ept> se il thread è stata attivata la modalità di scrittura in modo ricorsivo <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 volte.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">I risultati possono cambiare come che sono state calcolate.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">Prova ad attivare il blocco in modalità lettura con un timeout facoltativo.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Tries to enter the lock in read mode, with an optional integer time-out.</source>
          <target state="translated">Prova ad attivare il blocco in modalità lettura con un timeout intero facoltativo.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il thread chiamante è passato in modalità lettura; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Se <ph id="ph1">`millisecondsTimeout`</ph> è 0 (zero), questo metodo controlla lo stato di blocco e restituisce <ph id="ph2">`false`</ph> immediatamente se lo stato desiderato non è disponibile.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">Più thread possono accedere in modalità di lettura nello stesso momento.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metodo si blocca fino a quando tali thread dispone di timeout o in modalità di scrittura e quindi sia terminato da esso o fino alla scadenza dell'intervallo di timeout del thread chiamante.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità lettura possibile immettere in modo ricorsivo modalità lettura, anche se altri thread in attesa di passare alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Un thread può essere in modalità aggiornabile, mentre altri thread è in modalità lettura.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Se i thread aggiuntivi sono in attesa di attivazione della modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, thread che chiamano il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metodo passare immediatamente alla modalità di lettura e non vengono bloccati.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha già acceduto al blocco.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Il numero di ricorsioni supererebbe la capacità del contatore.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è negativo, ma non è uguale a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), ovvero l'unico valore negativo consentito.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Intervallo di attesa oppure -1 millisecondi per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">Prova ad attivare il blocco in modalità lettura con un timeout facoltativo.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il thread chiamante è passato in modalità lettura; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Se <ph id="ph1">`timeout`</ph> è 0 (zero), questo metodo controlla lo stato di blocco e restituisce <ph id="ph2">`false`</ph> immediatamente se lo stato desiderato non è disponibile.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Multiple threads can enter the lock in read mode at the same time.</source>
          <target state="translated">Più thread può accedere al blocco in modalità di lettura nello stesso momento.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If one or more threads are queued to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Se uno o più thread sono in coda per passare alla modalità di scrittura, un thread che chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metodo si blocca fino a quando tali thread dispone di timeout o in modalità di scrittura e quindi sia terminato da esso o fino alla scadenza dell'intervallo di timeout del thread chiamante.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità lettura possibile immettere in modo ricorsivo modalità lettura, anche se altri thread in attesa di passare alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">Un thread può essere in modalità aggiornabile, mentre altri thread è in modalità lettura.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">Se i thread aggiuntivi sono in attesa di attivazione della modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, thread che chiamano il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> metodo passare immediatamente alla modalità di lettura e non vengono bloccati.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha già acceduto al blocco.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Il numero di ricorsioni supererebbe la capacità del contatore.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è superiore a <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> millisecondi.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Prova ad attivare il blocco in modalità aggiornabile con un timeout facoltativo.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Prova ad attivare il blocco in modalità aggiornabile con un timeout facoltativo.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Se <ph id="ph1">`millisecondsTimeout`</ph> è 0 (zero), questo metodo controlla lo stato di blocco e restituisce <ph id="ph2">`false`</ph> immediatamente se lo stato desiderato non è disponibile.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Utilizzare la modalità aggiornabile quando un thread è in genere accede alla risorsa protetta dal <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in modalità di lettura, ma potrebbe essere necessario passare alla modalità di scrittura, se vengono soddisfatte determinate condizioni.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o downgrade alla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">Solo un thread può accedere un blocco in modalità aggiornabile in qualsiasi momento.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Se un thread è in modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, un numero qualsiasi di altri thread può passare alla modalità lettura, anche se sono presenti thread in attesa di attivazione della modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> metodo si blocca fino a quando tali thread dispone di timeout o in modalità di scrittura e quindi sia terminato da esso o fino alla scadenza dell'intervallo di timeout del thread chiamante.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità aggiornabile può accedere in modo ricorsivo in modalità aggiornabile, anche se altri thread in attesa di passare alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha già acceduto al blocco.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Il numero di ricorsioni supererebbe la capacità del contatore.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è negativo, ma non è uguale a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), ovvero l'unico valore negativo consentito.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Intervallo di attesa oppure -1 millisecondi per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">Prova ad attivare il blocco in modalità aggiornabile con un timeout facoltativo.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il thread chiamante ha acceduto alla modalità aggiornabile; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Se <ph id="ph1">`timeout`</ph> è 0 (zero), questo metodo controlla lo stato di blocco e restituisce <ph id="ph2">`false`</ph> immediatamente se lo stato desiderato non è disponibile.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Use upgradeable mode when a thread usually accesses the resource protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">Utilizzare la modalità aggiornabile quando un thread è in genere accedere alla risorsa protetta dal <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in modalità di lettura, ma potrebbe essere necessario passare alla modalità di scrittura, se vengono soddisfatte determinate condizioni.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">Un thread in modalità aggiornabile è possibile eseguire l'aggiornamento alla modalità di scrittura o downgrade alla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">Solo un thread può accedere un blocco in modalità aggiornabile in qualsiasi momento.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">Se un thread è in modalità aggiornabile e non sono presenti thread in attesa di passare alla modalità di scrittura, un numero qualsiasi di altri thread può passare alla modalità lettura, anche se sono presenti thread in attesa di attivazione della modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">Se uno o più thread sono in attesa di attivazione della modalità di scrittura, un thread che chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> metodo si blocca fino a quando tali thread dispone di timeout o in modalità di scrittura e quindi sia terminato da esso o fino alla scadenza dell'intervallo di timeout del thread chiamante.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità aggiornabile può accedere in modo ricorsivo in modalità aggiornabile, anche se altri thread in attesa di passare alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha già acceduto al blocco.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità aggiornabile creerebbe la possibilità di un deadlock.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Il numero di ricorsioni supererebbe la capacità del contatore.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è superiore a <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> millisecondi.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Prova ad attivare il blocco in modalità scrittura con un timeout facoltativo.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">Numero di millisecondi di attesa oppure -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Prova ad attivare il blocco in modalità scrittura con un timeout facoltativo.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Se <ph id="ph1">`millisecondsTimeout`</ph> è 0 (zero), questo metodo controlla lo stato di blocco e restituisce <ph id="ph2">`false`</ph> immediatamente se lo stato desiderato non è disponibile.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">Se altri thread è stato attivato il blocco in modalità lettura, un thread che chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> metodo si blocca fino a quando tali thread sono usciti modalità lettura o fino a quando non è trascorso l'intervallo di timeout.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Mentre i thread sono bloccati in attesa di passare alla modalità di scrittura, gli altri thread che tentano di accedere alla modalità di lettura o in modalità aggiornabile bloccata fino a quando tutti i thread in attesa di accedere alla modalità di scrittura sono uno timeout o in modalità di scrittura e quindi sia terminato da esso.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità di scrittura può accedere in modo ricorsivo la modalità di scrittura, anche se altri thread in attesa di passare alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> metodo per attivare il blocco in modalità scrittura con un timeout. Il metodo illustrato nell'esempio aggiunge una nuova coppia chiave/valore per la cache sincronizzata.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the specified time-out interval elapses before the thread enters the lock, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Se l'intervallo di timeout specificato scade prima che il thread viene inserito il blocco, il metodo restituisce <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The method returns <ph id="ph1">`true`</ph> if the key/value pair is added.</source>
          <target state="translated">Il metodo restituisce <ph id="ph1">`true`</ph> se si aggiunge la coppia chiave/valore.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">Se la chiave esiste già nella cache, l'eccezione generata dall'interno <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> può terminare il metodo.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits the lock.</source>
          <target state="translated">Oggetto <ph id="ph1">`finally`</ph> blocco viene utilizzato per eseguire il <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> metodo, assicurando che il chiamante viene chiuso il blocco.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">Questo codice è parte di un esempio più esaustivo disponibile per la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha già acceduto al blocco.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Il numero di ricorsioni supererebbe la capacità del contatore.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> è negativo, ma non è uguale a <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), ovvero l'unico valore negativo consentito.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Intervallo di attesa oppure -1 millisecondi per un'attesa indefinita.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">Prova ad attivare il blocco in modalità scrittura con un timeout facoltativo.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il thread chiamante ha acceduto alla modalità di scrittura; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">Se <ph id="ph1">`timeout`</ph> è 0 (zero), questo metodo controlla lo stato di blocco e restituisce <ph id="ph2">`false`</ph> immediatamente se lo stato desiderato non è disponibile.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">Se altri thread è stato attivato il blocco in modalità lettura, un thread che chiama il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> metodo si blocca fino a quando tali thread sono usciti modalità lettura o fino a quando non è trascorso l'intervallo di timeout.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">Mentre i thread sono bloccati in attesa di passare alla modalità di scrittura, gli altri thread che tentano di accedere alla modalità di lettura o in modalità aggiornabile bloccata fino a quando tutti i thread in attesa di accedere alla modalità di scrittura sono uno timeout o in modalità di scrittura e quindi sia terminato da esso.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">Se un blocco consente la ricorsione, un thread che ha attivato il blocco in modalità di scrittura può accedere in modo ricorsivo la modalità di scrittura, anche se altri thread in attesa di passare alla modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated">La proprietà <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> è <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> e il thread corrente ha già acceduto al blocco.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">Il thread corrente ha inizialmente acceduto al blocco in modalità di lettura, pertanto il tentativo di accedere alla modalità di scrittura creerebbe la possibilità di un deadlock.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">Il numero di ricorsioni supererebbe la capacità del contatore.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">Il limite è talmente elevato che le applicazioni non dovrebbero mai raggiungerlo.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è negativo, ma non è uguale a -1 millisecondi, ovvero l'unico valore negativo consentito.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated">Il valore di <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> è superiore a <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> millisecondi.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Gets the total number of threads that are waiting to enter the lock in read mode.</source>
          <target state="translated">Ottiene il numero complessivo di thread in attesa di attivazione del blocco in modalità lettura.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The total number of threads that are waiting to enter read mode.</source>
          <target state="translated">Numero complessivo di thread in attesa di attivazione della modalità lettura.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">I risultati possono cambiare come che sono state calcolate.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph> proprietà per generare una voce del registro eventi se il numero di thread bloccati, in attesa di attivazione della modalità di lettura, supera una soglia.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</source>
          <target state="translated">Ottiene il numero complessivo di thread in attesa di attivazione del blocco in modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The total number of threads that are waiting to enter upgradeable mode.</source>
          <target state="translated">Numero complessivo di thread in attesa di attivazione della modalità aggiornabile.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">I risultati possono cambiare come che sono state calcolate.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph> proprietà per generare una voce del registro eventi se il numero di thread bloccati, in attesa di attivazione della modalità aggiornabile, supera una soglia.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Gets the total number of threads that are waiting to enter the lock in write mode.</source>
          <target state="translated">Ottiene il numero complessivo di thread in attesa di attivazione del blocco in modalità scrittura.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The total number of threads that are waiting to enter write mode.</source>
          <target state="translated">Numero complessivo di thread in attesa di attivazione della modalità scrittura.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">Utilizzare questa proprietà solo per il debug, il profiling e registrazione e non per controllare il comportamento di un algoritmo.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">I risultati possono cambiare come che sono state calcolate.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">Pertanto, non è consigliabile prendere decisioni in base a questa proprietà.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</source>
          <target state="translated">Nell'esempio seguente viene illustrato come utilizzare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph> proprietà per generare una voce del registro eventi se il numero di thread bloccati, in attesa di attivazione della modalità di scrittura, supera una soglia.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>