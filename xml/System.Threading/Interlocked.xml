<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2c4ca68eab5cab83362bc1249915513f4de221da" />
    <Meta Name="ms.sourcegitcommit" Value="d71cc71109ed3cbcf3406a10a3cd7ac7e30f5e0c" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/10/2018" />
    <Meta Name="ms.locfileid" Value="51525775" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="c50bf-101">Consente di eseguire operazioni atomiche per variabili condivise da più thread.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c50bf-101">Provides atomic operations for variables that are shared by multiple threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-102">I metodi di questa classe di proteggersi da errori che possono verificarsi quando l'utilità di pianificazione passa i contesti, mentre un thread sta aggiornando una variabile cui è possibile accedere da altri thread o quando due thread sono in esecuzione simultaneamente su processori separati.</span><span class="sxs-lookup"><span data-stu-id="c50bf-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="c50bf-103">I membri di questa classe non generano eccezioni.</span><span class="sxs-lookup"><span data-stu-id="c50bf-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="c50bf-104">Il <xref:System.Threading.Interlocked.Increment%2A> e <xref:System.Threading.Interlocked.Decrement%2A> metodi incrementare o decrementare una variabile e archiviare il valore risultante in un'unica operazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="c50bf-105">Nella maggior parte dei computer, una variabile di incremento non è un'operazione atomica, che richiede i passaggi seguenti:</span><span class="sxs-lookup"><span data-stu-id="c50bf-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="c50bf-106">Caricare un valore da una variabile di istanza in un registro.</span><span class="sxs-lookup"><span data-stu-id="c50bf-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="c50bf-107">Aumentare o diminuire il valore.</span><span class="sxs-lookup"><span data-stu-id="c50bf-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="c50bf-108">Store il valore nella variabile di istanza.</span><span class="sxs-lookup"><span data-stu-id="c50bf-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="c50bf-109">Se non si usa <xref:System.Threading.Interlocked.Increment%2A> e <xref:System.Threading.Interlocked.Decrement%2A>, un thread potesse venire interrotto dopo l'esecuzione i primi due passaggi.</span><span class="sxs-lookup"><span data-stu-id="c50bf-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="c50bf-110">Un altro thread può quindi eseguire tutti i tre passaggi.</span><span class="sxs-lookup"><span data-stu-id="c50bf-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="c50bf-111">Quando il primo thread riprende l'esecuzione, sovrascrive il valore nella variabile di istanza e l'effetto dell'incremento o decremento eseguite da quest'ultimo viene perso.</span><span class="sxs-lookup"><span data-stu-id="c50bf-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  

 <span data-ttu-id="c50bf-112">Il <xref:System.Threading.Interlocked.Add%2A> metodo aggiunge un valore integer a una variabile integer in modo atomico e restituisce il nuovo valore della variabile.</span><span class="sxs-lookup"><span data-stu-id="c50bf-112">The <xref:System.Threading.Interlocked.Add%2A> method atomically adds an integer value to an integer variable and returns the new value of the variable.</span></span>  
  
 <span data-ttu-id="c50bf-113">Il <xref:System.Threading.Interlocked.Exchange%2A> metodo in modo atomico Scambia i valori delle variabili specificate.</span><span class="sxs-lookup"><span data-stu-id="c50bf-113">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="c50bf-114">Il <xref:System.Threading.Interlocked.CompareExchange%2A> metodo vengono combinate due operazioni: confronto tra due valori e la memorizzazione di un terzo valore in una delle variabili, in base al risultato del confronto.</span><span class="sxs-lookup"><span data-stu-id="c50bf-114">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="c50bf-115">Vengono eseguite le operazioni di confronto e scambio come operazione atomica.</span><span class="sxs-lookup"><span data-stu-id="c50bf-115">The compare and exchange operations are performed as an atomic operation.</span></span>  

 <span data-ttu-id="c50bf-116">Assicurarsi che qualsiasi accesso in lettura a una variabile condivisa o scrittura siano atomica.</span><span class="sxs-lookup"><span data-stu-id="c50bf-116">Ensure that any write or read access to a shared variable is atomic.</span></span> <span data-ttu-id="c50bf-117">In caso contrario, i dati potrebbero essere danneggiati o valore caricato potrebbe non essere corretto.</span><span class="sxs-lookup"><span data-stu-id="c50bf-117">Otherwise, the data might be corrupted or the loaded value might be incorrect.</span></span>    
   
  
## Examples  
 <span data-ttu-id="c50bf-118">Esempio di codice seguente illustra un meccanismo di blocco di risorse di thread-safe.</span><span class="sxs-lookup"><span data-stu-id="c50bf-118">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="c50bf-119">Questo tipo è thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="c50bf-119">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="c50bf-120">Threading gestito</span>
      <span class="sxs-lookup">
        <span data-stu-id="c50bf-120">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
      <span data-ttu-id="c50bf-121">Interlocked</span>
      <span class="sxs-lookup">
        <span data-stu-id="c50bf-121">Interlocked</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c50bf-122">Somma due interi e sostituisce il primo intero con la somma, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-122">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-123">Variabile contenente il primo valore da sommare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-123">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="c50bf-124">La somma dei due valori viene archiviata in <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-124">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-125">Valore da sommare all'intero in corrispondenza di <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-125">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-126">Somma due interi a 32 bit e sostituisce il primo intero con la somma, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-126">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-127">Nuovo valore memorizzato in <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-127">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-128">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se il valore in corrispondenza `location1` viene <xref:System.Int32.MaxValue?displayProperty=nameWithType> e `value` è 1, il risultato sarà <xref:System.Int32.MinValue?displayProperty=nameWithType>; se `value` è 2, il risultato è (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1) e così via.</span><span class="sxs-lookup"><span data-stu-id="c50bf-128">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="c50bf-129">Non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-129">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-130">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-130">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-131">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-131">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-132">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-132">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-133">Variabile contenente il primo valore da sommare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-133">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="c50bf-134">La somma dei due valori viene archiviata in <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-134">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-135">Valore da sommare all'intero in corrispondenza di <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-135">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-136">Somma due interi a 64 bit e sostituisce il primo intero con la somma, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-136">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-137">Nuovo valore memorizzato in <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-137">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-138">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se il valore in corrispondenza `location1` viene <xref:System.Int64.MaxValue?displayProperty=nameWithType> e `value` è 1, il risultato sarà <xref:System.Int64.MinValue?displayProperty=nameWithType>; se `value` è 2, il risultato è (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1) e così via.</span><span class="sxs-lookup"><span data-stu-id="c50bf-138">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="c50bf-139">Non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-139">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-140">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-140">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-141">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-141">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-142">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-142">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c50bf-143">Confronta due valori per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-143">Compares two values for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-144">Destinazione il cui valore viene confrontato con <c>comparand</c> ed eventualmente sostituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-144">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-145">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-145">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="c50bf-146">Valore confrontato con il valore in corrispondenza di <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-146">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-147">Confronta due numeri a virgola mobile e precisione doppia per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-147">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-148">Valore originale in <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-148">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-149">Se `comparand` e il valore in `location1` sono uguali, quindi `value` viene archiviato in `location1`.</span><span class="sxs-lookup"><span data-stu-id="c50bf-149">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="c50bf-150">In caso contrario, non viene eseguita alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-150">Otherwise, no operation is performed.</span></span> <span data-ttu-id="c50bf-151">Vengono eseguite le operazioni di confronto e scambio come operazione atomica.</span><span class="sxs-lookup"><span data-stu-id="c50bf-151">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="c50bf-152">Il valore restituito di <xref:System.Threading.Interlocked.CompareExchange%2A> è il valore originale in `location1`, indipendentemente dal fatto di exchange ha luogo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-152">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c50bf-153">Esempio di codice seguente viene illustrato un metodo thread-safe che accumula un totale parziale di <xref:System.Double> valori.</span><span class="sxs-lookup"><span data-stu-id="c50bf-153">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="c50bf-154">Due thread aggiungono una serie di <xref:System.Double> i valori usando il metodo thread-safe e inoltre ordinari, e quando i thread vengono completati i totali vengono confrontati.</span><span class="sxs-lookup"><span data-stu-id="c50bf-154">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="c50bf-155">In un computer a processore, è presente una differenza significativa nei totali.</span><span class="sxs-lookup"><span data-stu-id="c50bf-155">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="c50bf-156">Nel metodo thread-safe, il valore iniziale del totale parziale viene salvato e quindi il <xref:System.Threading.Interlocked.CompareExchange%2A> metodo viene utilizzato per scambiare il totale appena calcolato con il totale precedente.</span><span class="sxs-lookup"><span data-stu-id="c50bf-156">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="c50bf-157">Se il valore restituito non è uguale a quello salvato del totale parziale, quindi un altro thread ha aggiornato il totale nel frattempo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-157">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="c50bf-158">In tal caso, deve essere ripetuto il tentativo di aggiornare il totale parziale.</span><span class="sxs-lookup"><span data-stu-id="c50bf-158">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-159">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-159">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-160">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-160">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-161">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-161">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-162">Destinazione il cui valore viene confrontato con <c>comparand</c> ed eventualmente sostituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-162">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-163">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-163">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="c50bf-164">Valore confrontato con il valore in corrispondenza di <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-164">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-165">Confronta due interi con segno a 32 bit per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-165">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-166">Valore originale in <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-166">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-167">Se `comparand` e il valore in `location1` sono uguali, quindi `value` viene archiviato in `location1`.</span><span class="sxs-lookup"><span data-stu-id="c50bf-167">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="c50bf-168">In caso contrario, non viene eseguita alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-168">Otherwise, no operation is performed.</span></span> <span data-ttu-id="c50bf-169">Vengono eseguite le operazioni di confronto e scambio come operazione atomica.</span><span class="sxs-lookup"><span data-stu-id="c50bf-169">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="c50bf-170">Il valore restituito di <xref:System.Threading.Interlocked.CompareExchange%2A> è il valore originale in `location1`, indipendentemente dal fatto di exchange ha luogo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-170">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c50bf-171">Esempio di codice seguente viene illustrato un metodo thread-safe che accumula un totale parziale.</span><span class="sxs-lookup"><span data-stu-id="c50bf-171">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="c50bf-172">Il valore iniziale del totale parziale viene salvato e quindi il <xref:System.Threading.Interlocked.CompareExchange%2A> metodo viene utilizzato per scambiare il totale appena calcolato con il totale precedente.</span><span class="sxs-lookup"><span data-stu-id="c50bf-172">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="c50bf-173">Se il valore restituito non è uguale a quello salvato del totale parziale, quindi un altro thread ha aggiornato il totale nel frattempo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-173">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="c50bf-174">In tal caso, deve essere ripetuto il tentativo di aggiornare il totale parziale.</span><span class="sxs-lookup"><span data-stu-id="c50bf-174">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c50bf-175">Il <xref:System.Threading.Interlocked.Add%2A> metodo, introdotto nella versione 2.0 di .NET Framework, offre un modo più pratico per accumulare i totali parziali thread-safe per i numeri interi.</span><span class="sxs-lookup"><span data-stu-id="c50bf-175">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-176">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-176">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-177">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-177">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-178">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-178">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-179">Destinazione il cui valore viene confrontato con <c>comparand</c> ed eventualmente sostituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-179">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-180">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-180">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="c50bf-181">Valore confrontato con il valore in corrispondenza di <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-181">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-182">Confronta due interi con segno a 64 bit per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-182">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-183">Valore originale in <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-183">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-184">Se `comparand` e il valore in `location1` sono uguali, quindi `value` viene archiviato in `location1`.</span><span class="sxs-lookup"><span data-stu-id="c50bf-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="c50bf-185">In caso contrario, non viene eseguita alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="c50bf-186">Vengono eseguite le operazioni di confronto e scambio come operazione atomica.</span><span class="sxs-lookup"><span data-stu-id="c50bf-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="c50bf-187">Il valore restituito di <xref:System.Threading.Interlocked.CompareExchange%2A> è il valore originale in `location1`, indipendentemente dal fatto di exchange ha luogo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-187">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-188">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-188">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-189">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-189">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-190">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-190">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-191">
            <see cref="T:System.IntPtr" /> di destinazione, il cui valore viene confrontato con il valore di <c>comparand</c> e, se possibile, sostituito da <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-191">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <c>comparand</c> and possibly replaced by <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-192">
            <see cref="T:System.IntPtr" /> che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-192">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="c50bf-193">
            <see cref="T:System.IntPtr" /> confrontato con il valore in <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-193">The <see cref="T:System.IntPtr" /> that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-194">Confronta due puntatori o handle specifici della piattaforma per verificarne l'uguaglianza; se sono uguali, sostituisce il primo elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-194">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-195">Valore originale in <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-195">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-196">Se `comparand` e il valore in `location1` sono uguali, quindi `value` viene archiviato in `location1`.</span><span class="sxs-lookup"><span data-stu-id="c50bf-196">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="c50bf-197">In caso contrario, non viene eseguita alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-197">Otherwise, no operation is performed.</span></span> <span data-ttu-id="c50bf-198">Vengono eseguite le operazioni di confronto e scambio come operazione atomica.</span><span class="sxs-lookup"><span data-stu-id="c50bf-198">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="c50bf-199">Il valore restituito di questo metodo è il valore originale nel `location1`, indipendentemente dal fatto di exchange ha luogo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-199">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c50bf-200"><xref:System.IntPtr> è un tipo specifico della piattaforma.</span><span class="sxs-lookup"><span data-stu-id="c50bf-200"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-201">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-201">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-202">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-202">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-203">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-203">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-204">Oggetto di destinazione confrontato per riferimento con <c>comparand</c> e, se possibile, sostituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-204">The destination object that is compared by reference with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-205">Oggetto che sostituisce l'oggetto di destinazione se il confronto dei riferimenti rileva l'uguaglianza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-205">The object that replaces the destination object if the reference comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="c50bf-206">Oggetto confrontato per riferimento con l'oggetto in <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-206">The object that is compared by reference to the object at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-207">Confronta due oggetti per verificarne l'uguaglianza dei riferimenti; se sono uguali, sostituisce il primo oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-207">Compares two objects for reference equality and, if they are equal, replaces the first object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-208">Valore originale in <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-208">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="c50bf-209">A partire da .NET Framework 2.0, il <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%29> overload del metodo fornisce un'alternativa type-safe per i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="c50bf-209">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="c50bf-210">È consigliabile che si chiama invece l'overload.</span><span class="sxs-lookup"><span data-stu-id="c50bf-210">We recommend that you call it instead of this overload.</span></span>

<span data-ttu-id="c50bf-211">Se `comparand` e dall'oggetto `location1` sono uguali per riferimento, quindi `value` viene archiviato in `location1`.</span><span class="sxs-lookup"><span data-stu-id="c50bf-211">If `comparand` and the object in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="c50bf-212">In caso contrario, non viene eseguita alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-212">Otherwise, no operation is performed.</span></span> <span data-ttu-id="c50bf-213">Vengono eseguite le operazioni di confronto e scambio come operazione atomica.</span><span class="sxs-lookup"><span data-stu-id="c50bf-213">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="c50bf-214">Il valore restituito di <xref:System.Threading.Interlocked.CompareExchange%2A> è il valore originale in `location1`, indipendentemente dal fatto di exchange ha luogo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-214">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  

> [!NOTE]
>  <span data-ttu-id="c50bf-215">Gli oggetti vengono confrontati per verificarne l'uguaglianza di riferimento anziché l'uguaglianza di valori.</span><span class="sxs-lookup"><span data-stu-id="c50bf-215">The objects are compared for reference equality rather than value equality.</span></span> <span data-ttu-id="c50bf-216">Di conseguenza, due boxed istanze dello stesso tipo di valore (ad esempio, il valore intero 3) sempre sembra non uguali e viene eseguita alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-216">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal and no operation is performed.</span></span> <span data-ttu-id="c50bf-217">Non utilizzare questo overload con i tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="c50bf-217">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c50bf-218">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-218">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-219">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-219">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-220">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-220">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-221">Destinazione il cui valore viene confrontato con <c>comparand</c> ed eventualmente sostituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-221">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-222">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-222">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="c50bf-223">Valore confrontato con il valore in corrispondenza di <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-223">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-224">Confronta due numeri a virgola mobile e precisione singola per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-224">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-225">Valore originale in <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-225">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-226">Se `comparand` e il valore in `location1` sono uguali, quindi `value` viene archiviato in `location1`.</span><span class="sxs-lookup"><span data-stu-id="c50bf-226">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="c50bf-227">In caso contrario, non viene eseguita alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-227">Otherwise, no operation is performed.</span></span> <span data-ttu-id="c50bf-228">Vengono eseguite le operazioni di confronto e scambio come operazione atomica.</span><span class="sxs-lookup"><span data-stu-id="c50bf-228">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="c50bf-229">Il valore restituito di <xref:System.Threading.Interlocked.CompareExchange%2A> è il valore originale in `location1`, indipendentemente dal fatto di exchange ha luogo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-229">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c50bf-230">Esempio di codice seguente viene illustrato un metodo thread-safe che accumula un totale parziale di <xref:System.Single> valori.</span><span class="sxs-lookup"><span data-stu-id="c50bf-230">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="c50bf-231">Due thread aggiungono una serie di <xref:System.Single> i valori usando il metodo thread-safe e inoltre ordinari, e quando i thread vengono completati i totali vengono confrontati.</span><span class="sxs-lookup"><span data-stu-id="c50bf-231">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="c50bf-232">In un computer a processore, è presente una differenza significativa nei totali.</span><span class="sxs-lookup"><span data-stu-id="c50bf-232">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="c50bf-233">Nel metodo thread-safe, il valore iniziale del totale parziale viene salvato e quindi il <xref:System.Threading.Interlocked.CompareExchange%2A> metodo viene utilizzato per scambiare il totale appena calcolato con il totale precedente.</span><span class="sxs-lookup"><span data-stu-id="c50bf-233">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="c50bf-234">Se il valore restituito non è uguale a quello salvato del totale parziale, quindi un altro thread ha aggiornato il totale nel frattempo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-234">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="c50bf-235">In tal caso, deve essere ripetuto il tentativo di aggiornare il totale parziale.</span><span class="sxs-lookup"><span data-stu-id="c50bf-235">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-236">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-236">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-237">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-237">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-238">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-238">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="c50bf-239">Il tipo da utilizzare per <c>location1</c>, <c>valore</c>, e <c>comparando</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-239">The type to be used for <c>location1</c>, <c>value</c>, and <c>comparand</c>.</span>
          </span>
          <span data-ttu-id="c50bf-240">Questo tipo deve essere un tipo di riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-240">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="c50bf-241">Destinazione il cui valore viene confrontato per riferimento con <c>comparand</c> ed eventualmente sostituito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-241">The destination, whose value is compared by reference with <c>comparand</c> and possibly replaced.</span>
          </span>
          <span data-ttu-id="c50bf-242">Rappresenta un parametro di riferimento (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-242">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-243">Valore che sostituisce il valore di destinazione se il confronto dei riferimenti rileva l'uguaglianza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-243">The value that replaces the destination value if the comparison by reference results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="c50bf-244">Valore confrontato per riferimento con il valore in <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-244">The value that is compared by reference to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-245">Confronta due istanze del tipo di riferimento <paramref name="T" /> specificato per verificarne l'uguaglianza dei riferimenti. Se sono uguali, sostituisce la prima istanza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-245">Compares two instances of the specified reference type <paramref name="T" /> for reference equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-246">Valore originale in <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-246">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-247">Se `comparand` e il valore in `location1` sono uguali per riferimento, quindi `value` viene archiviato in `location1`.</span><span class="sxs-lookup"><span data-stu-id="c50bf-247">If `comparand` and the value in `location1` are equal by reference, then `value` is stored in `location1`.</span></span> <span data-ttu-id="c50bf-248">In caso contrario, non viene eseguita alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-248">Otherwise, no operation is performed.</span></span> <span data-ttu-id="c50bf-249">Il confronto e lo scambio vengono eseguiti come operazione atomica.</span><span class="sxs-lookup"><span data-stu-id="c50bf-249">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="c50bf-250">Il valore restituito di questo metodo è il valore originale nel `location1`, indipendentemente dal fatto di exchange ha luogo.</span><span class="sxs-lookup"><span data-stu-id="c50bf-250">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="c50bf-251">Questo metodo supporta solo i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="c50bf-251">This method only supports reference types.</span></span> <span data-ttu-id="c50bf-252">Esistono overload del <xref:System.Threading.Interlocked.CompareExchange%2A> metodo per i tipi di valore <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, e <xref:System.Double>, ma non è disponibile alcun supporto per altri tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="c50bf-252">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c50bf-253">Questo overload del metodo è preferibile il <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> overload del metodo, perché quest'ultimo richiede l'oggetto di destinazione a cui accedere con associazione tardiva.</span><span class="sxs-lookup"><span data-stu-id="c50bf-253">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-254">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-254">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c50bf-255">Diminuisce una variabile specificata e archivia il risultato, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-255">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="c50bf-256">Variabile il cui valore deve essere diminuito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-256">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-257">Diminuisce una variabile specificata e archivia il risultato, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-257">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-258">Valore diminuito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-258">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-259">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se `location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c50bf-259">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c50bf-260">Non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-260">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c50bf-261">Nell'esempio seguente determina quanti numeri casuali compresi tra 0 a 1.000 necessari per generare numeri casuali 1.000 con un valore del punto centrale.</span><span class="sxs-lookup"><span data-stu-id="c50bf-261">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="c50bf-262">Per tenere traccia del numero di valori punto intermedio, una variabile, `midpointCount`, viene impostato uguali a 1.000 e decrementato ogni volta che il generatore di numeri casuali restituisce un valore del punto centrale.</span><span class="sxs-lookup"><span data-stu-id="c50bf-262">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="c50bf-263">Poiché i tre thread generano numeri casuali, le <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> viene chiamato per garantire che più thread non aggiornano `midpointCount` contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="c50bf-263">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="c50bf-264">Si noti che un blocco viene inoltre usato per proteggere il generatore di numeri casuali e che un <xref:System.Threading.CountdownEvent> oggetto viene usato per verificare che il `Main` metodo non viene completata l'esecuzione prima i tre thread.</span><span class="sxs-lookup"><span data-stu-id="c50bf-264">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="c50bf-265">Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che usi il <xref:System.Threading.Tasks.Task> classe invece di una routine del thread per generare numeri interi casuali punto medio 50.000.</span><span class="sxs-lookup"><span data-stu-id="c50bf-265">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="c50bf-266">In questo esempio, un'espressione lambda sostituisce il `GenerateNumbers` routine del thread e la chiamata ai <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo elimina la necessità del <xref:System.Threading.CountdownEvent> oggetto.</span><span class="sxs-lookup"><span data-stu-id="c50bf-266">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c50bf-267">L'indirizzo di <paramref name="location" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-267">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-268">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-268">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-269">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-269">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="c50bf-270">Variabile il cui valore deve essere diminuito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-270">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-271">Diminuisce la variabile specificata e archivia il risultato, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-271">Decrements the specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-272">Valore diminuito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-272">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-273">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se `location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c50bf-273">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c50bf-274">Non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-274">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c50bf-275">L'indirizzo di <paramref name="location" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-275">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-276">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-276">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-277">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-277">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c50bf-278">Imposta una variabile su un valore specificato come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-278">Sets a variable to a specified value as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-279">Variabile da impostare sul valore specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-279">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-280">Valore su cui è impostato il parametro <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-280">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-281">Imposta un numero a virgola mobile e precisione doppia su un valore specificato e restituisce il valore originale, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-281">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-282">Valore originale di <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-282">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-283">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-283">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-284">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-284">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-285">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-285">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-286">Variabile da impostare sul valore specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-286">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-287">Valore su cui è impostato il parametro <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-287">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-288">Imposta un intero con segno a 32 bit su un valore specificato e restituisce il valore originale, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-288">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-289">Valore originale di <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-289">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c50bf-290">Esempio di codice seguente illustra un meccanismo di blocco di risorse di thread-safe.</span><span class="sxs-lookup"><span data-stu-id="c50bf-290">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c50bf-291">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-291">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-292">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-292">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-293">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-293">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-294">Variabile da impostare sul valore specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-294">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-295">Valore su cui è impostato il parametro <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-295">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-296">Imposta un intero con segno a 64 bit su un valore specificato e restituisce il valore originale, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-296">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-297">Valore originale di <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-297">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-298">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-298">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-299">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-299">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-300">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-300">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-301">Variabile da impostare sul valore specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-301">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-302">Valore su cui è impostato il parametro <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-302">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-303">Imposta un puntatore o un handle specifico della piattaforma su un valore specificato e restituisce il valore originale, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-303">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-304">Valore originale di <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-304">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-305">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-305">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-306">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-306">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-307">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-307">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-308">Variabile da impostare sul valore specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-308">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-309">Valore su cui è impostato il parametro <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-309">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-310">Imposta un oggetto su un valore specificato e restituisce un riferimento all'oggetto originale, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-310">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-311">Valore originale di <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-311">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!IMPORTANT]
> <span data-ttu-id="c50bf-312">A partire da .NET Framework 2.0, il <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> overload del metodo fornisce un'alternativa type-safe per i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="c50bf-312">Beginning with .NET Framework 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span> <span data-ttu-id="c50bf-313">È consigliabile che si chiama invece l'overload.</span><span class="sxs-lookup"><span data-stu-id="c50bf-313">We recommend that you call it instead of this overload.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c50bf-314">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-314">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-315">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-315">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-316">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-316">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="c50bf-317">Variabile da impostare sul valore specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-317">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-318">Valore su cui è impostato il parametro <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-318">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-319">Imposta un numero a virgola mobile e precisione singola su un valore specificato e restituisce il valore originale, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-319">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-320">Valore originale di <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-320">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-321">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-321">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-322">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-322">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-323">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-323">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="c50bf-324">Il tipo da utilizzare per <c>location1</c> e <c>valore</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-324">The type to be used for <c>location1</c> and <c>value</c>.</span>
          </span>
          <span data-ttu-id="c50bf-325">Questo tipo deve essere un tipo di riferimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-325">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="c50bf-326">Variabile da impostare sul valore specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-326">The variable to set to the specified value.</span>
          </span>
          <span data-ttu-id="c50bf-327">Rappresenta un parametro di riferimento (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-327">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="c50bf-328">Valore su cui è impostato il parametro <c>location1</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-328">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-329">Imposta una variabile del tipo <paramref name="T" /> indicato sul valore specificato e restituisce il valore originale, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-329">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-330">Valore originale di <paramref name="location1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-330">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-331">Questo metodo supporta solo i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="c50bf-331">This method only supports reference types.</span></span> <span data-ttu-id="c50bf-332">Esistono overload del <xref:System.Threading.Interlocked.Exchange%2A> metodo per il <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, e <xref:System.Double> i tipi di valore, ma non esiste alcun supporto per altri tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="c50bf-332">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c50bf-333">Questo overload del metodo è preferibile il <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> overload del metodo, perché quest'ultimo richiede l'accesso con associazione tardiva all'oggetto di destinazione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-333">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-334">L'indirizzo di <paramref name="location1" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-334">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c50bf-335">Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-335">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="c50bf-336">Variabile il cui valore deve essere aumentato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-336">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-337">Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-337">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-338">Valore aumentato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-338">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-339">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se `location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c50bf-339">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c50bf-340">Non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-340">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c50bf-341">Nell'esempio seguente determina quanti numeri casuali compresi tra 0 a 1.000 necessari per generare numeri casuali 1.000 con un valore del punto centrale.</span><span class="sxs-lookup"><span data-stu-id="c50bf-341">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="c50bf-342">Per tenere traccia del numero di valori punto intermedio, una variabile, `midpointCount`, è uguale a 0 e incrementato ogni volta che il generatore di numeri casuali restituisce un valore del punto centrale finché non raggiunge 10.000.</span><span class="sxs-lookup"><span data-stu-id="c50bf-342">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="c50bf-343">Poiché i tre thread generano numeri casuali, le <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> viene chiamato per garantire che più thread non aggiornano `midpointCount` contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="c50bf-343">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="c50bf-344">Si noti che un blocco viene inoltre usato per proteggere il generatore di numeri casuali e che un <xref:System.Threading.CountdownEvent> oggetto viene usato per verificare che il `Main` metodo non viene completata l'esecuzione prima i tre thread.</span><span class="sxs-lookup"><span data-stu-id="c50bf-344">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="c50bf-345">Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che usi il <xref:System.Threading.Tasks.Task> classe invece di una routine del thread per generare numeri interi casuali punto medio 50.000.</span><span class="sxs-lookup"><span data-stu-id="c50bf-345">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="c50bf-346">In questo esempio, un'espressione lambda sostituisce il `GenerateNumbers` routine del thread e la chiamata ai <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo elimina la necessità del <xref:System.Threading.CountdownEvent> oggetto.</span><span class="sxs-lookup"><span data-stu-id="c50bf-346">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-347">L'indirizzo di <paramref name="location" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-347">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-348">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-348">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-349">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-349">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="c50bf-350">Variabile il cui valore deve essere aumentato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-350">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-351">Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-351">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-352">Valore aumentato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-352">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-353">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se `location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c50bf-353">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c50bf-354">Non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="c50bf-354">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="c50bf-355">L'indirizzo di <paramref name="location" /> è un puntatore Null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-355">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-356">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-356">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-357">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-357">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c50bf-358">Sincronizza l'accesso della memoria nel modo descritto di seguito. Il processore che esegue il thread corrente non può riordinare istruzioni in modo che gli accessi alla memoria prima della chiamata al metodo <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> vengano eseguiti dopo quelli successivi alla chiamata al metodo <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-358">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-359">Questo metodo è stato aggiunto per il <xref:System.Threading.Interlocked> classe il [!INCLUDE[net_v45](~/includes/net-v45-md.md)] per maggiore praticità; è un wrapper per il <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="c50bf-359">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c50bf-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> è necessario solo nei sistemi multiprocessore che hanno un ordinamento di memoria debole (ad esempio, un sistema che utilizza più processori Intel Itanium).</span><span class="sxs-lookup"><span data-stu-id="c50bf-360"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="c50bf-361">Maggior parte dei casi, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione o il <xref:System.Threading.Monitor> classe offre metodi più semplici per sincronizzare i dati.</span><span class="sxs-lookup"><span data-stu-id="c50bf-361">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read :  -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="c50bf-362">Valore a 64 bit da caricare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-362">The 64-bit value to be loaded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c50bf-363">Restituisce un valore a 64 bit, caricato come operazione atomica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-363">Returns a 64-bit value, loaded as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c50bf-364">Valore caricato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-364">The loaded value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c50bf-365">Il <xref:System.Threading.Interlocked.Read%2A> (metodo) non è necessario nei sistemi a 64 bit, perché le operazioni di lettura a 64 bit sono già atomiche.</span><span class="sxs-lookup"><span data-stu-id="c50bf-365">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="c50bf-366">Nei sistemi a 32 bit, le operazioni di lettura a 64 bit non sono atomiche, a meno che non eseguite usando <xref:System.Threading.Interlocked.Read%2A>.</span><span class="sxs-lookup"><span data-stu-id="c50bf-366">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="c50bf-367">Threading gestito</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-367">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="c50bf-368">Interlocked</span>
          <span class="sxs-lookup">
            <span data-stu-id="c50bf-368">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>