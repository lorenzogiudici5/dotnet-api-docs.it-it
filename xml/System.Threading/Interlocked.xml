<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Interlocked.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-b857fe3" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2eccf4de-4b1c-4706-8cb3-f46682ccfb724c2592cbe53cf2462457e64a6a4dfa2cd110de24.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4c2592cbe53cf2462457e64a6a4dfa2cd110de24</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b15b8cf0f6dbc1504057c88969d9ef4b790891fe</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/11/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Provides atomic operations for variables that are shared by multiple threads.</source>
          <target state="translated">Consente di eseguire operazioni atomiche per variabili condivise da più thread.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</source>
          <target state="translated">I metodi di questa classe consentono di proteggersi da errori che possono verificarsi quando l'utilità di pianificazione attiva contesti, mentre un thread sta aggiornando una variabile a cui è possibile accedere da altri thread o quando due thread sono in esecuzione contemporaneamente su processori separati.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The members of this class do not throw exceptions.</source>
          <target state="translated">I membri di questa classe non generano eccezioni.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph> methods increment or decrement a variable and store the resulting value in a single operation.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph> metodi incrementare o decrementare una variabile e archiviare il valore risultante in un'unica operazione.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</source>
          <target state="translated">Nella maggior parte dei computer, si incrementa una variabile non è un'operazione atomica, che richiede i passaggi seguenti:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Load a value from an instance variable into a register.</source>
          <target state="translated">Caricare un valore dalla variabile di istanza in un registro.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Increment or decrement the value.</source>
          <target state="translated">Aumentare o diminuire il valore.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Store the value in the instance variable.</source>
          <target state="translated">Archiviare il valore nella variabile di istanza.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, a thread can be preempted after executing the first two steps.</source>
          <target state="translated">Se non si utilizza <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, un thread può venire interrotto dopo avere eseguito i primi due passaggi.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>Another thread can then execute all three steps.</source>
          <target state="translated">Un altro thread può quindi eseguire tutti i tre passaggi.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</source>
          <target state="translated">Quando il primo thread riprende l'esecuzione, sovrascrive il valore nella variabile di istanza e l'effetto dell'incremento o decremento eseguita dal secondo thread viene perso.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method atomically exchanges the values of the specified variables.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> metodo scambio atomico dei valori delle variabili specificate.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> metodo vengono combinate due operazioni: confronto tra due valori e la memorizzazione di un terzo valore in una delle variabili, in base al risultato del confronto.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Le operazioni di confronto e scambio vengono eseguite come operazione atomica.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>The following code example shows a thread-safe resource locking mechanism.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un meccanismo di blocco risorse thread-safe.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Interlocked">
          <source>This type is thread safe.</source>
          <target state="translated">Questo tipo è thread-safe.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Adds two integers and replaces the first integer with the sum, as an atomic operation.</source>
          <target state="translated">Somma due interi e sostituisce il primo intero con la somma, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>A variable containing the first value to be added.</source>
          <target state="translated">Variabile contenente il primo valore da sommare.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The sum of the two values is stored in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">La somma dei due valori viene archiviata in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The value to be added to the integer at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valore da sommare all'intero in corrispondenza di <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</source>
          <target state="translated">Somma due interi a 32 bit e sostituisce il primo intero con la somma, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The new value stored at <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Nuovo valore memorizzato in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>This method handles an overflow condition by wrapping: if the value at <ph id="ph1">`location1`</ph> is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`value`</ph> is 1, the result is <ph id="ph4">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>; if <ph id="ph5">`value`</ph> is 2, the result is (<ph id="ph6">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> + 1); and so on.</source>
          <target state="translated">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se il valore in <ph id="ph1">`location1`</ph> è <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">`value`</ph> è 1, il risultato è <ph id="ph4">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>; se <ph id="ph5">`value`</ph> è 2, il risultato è (<ph id="ph6">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph> + 1) e così via.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>A variable containing the first value to be added.</source>
          <target state="translated">Variabile contenente il primo valore da sommare.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The sum of the two values is stored in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">La somma dei due valori viene archiviata in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The value to be added to the integer at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valore da sommare all'intero in corrispondenza di <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</source>
          <target state="translated">Somma due interi a 64 bit e sostituisce il primo intero con la somma, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The new value stored at <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Nuovo valore memorizzato in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>This method handles an overflow condition by wrapping: if the value at <ph id="ph1">`location1`</ph> is <ph id="ph2">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`value`</ph> is 1, the result is <ph id="ph4">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>; if <ph id="ph5">`value`</ph> is 2, the result is (<ph id="ph6">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph> + 1); and so on.</source>
          <target state="translated">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se il valore in <ph id="ph1">`location1`</ph> è <ph id="ph2">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">`value`</ph> è 1, il risultato è <ph id="ph4">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>; se <ph id="ph5">`value`</ph> è 2, il risultato è (<ph id="ph6">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph> + 1) e così via.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> (metodo) e gli overload a 64 bit del <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> metodi sono veramente atomici solo nei sistemi in cui un <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> è 64 bit.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">In altri sistemi, questi metodi sono atomici l'uno rispetto a altro, ma non rispetto ad altri mezzi di accesso ai dati.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">Di conseguenza, per essere thread-safe nei sistemi a 32 bit, qualsiasi accesso a un valore a 64 bit deve essere effettuato tramite i membri del <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Compares two values for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">Confronta due valori per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated">Destinazione il cui valore viene confrontato con <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> ed eventualmente sostituito.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valore confrontato con il valore in corrispondenza di <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">Confronta due numeri a virgola mobile e precisione doppia per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparand`</ph> e il valore in <ph id="ph2">`location1`</ph> sono uguali, <ph id="ph3">`value`</ph> viene archiviato in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">In caso contrario, non viene eseguita alcuna operazione.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Le operazioni di confronto e scambio vengono eseguite come operazione atomica.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Il valore restituito di <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> è il valore originale in <ph id="ph2">`location1`</ph>, scambio o meno.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The following code example demonstrates a thread-safe method that accumulates a running total of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un metodo di thread-safe che accumula un totale parziale di <ph id="ph1">&lt;xref:System.Double&gt;</ph> valori.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>Two threads add a series of <ph id="ph1">&lt;xref:System.Double&gt;</ph> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</source>
          <target state="translated">Due thread aggiungono una serie di <ph id="ph1">&lt;xref:System.Double&gt;</ph> valori utilizzando il metodo thread-safe e inoltre comune, e quando i thread vengono completati vengono confrontati i totali.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>On a dual-processor computer, there is a significant difference in the totals.</source>
          <target state="translated">In un computer con processore doppio, sussiste una differenza significativa nei totali.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>In the thread-safe method, the initial value of the running total is saved, and then the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is used to exchange the newly computed total with the old total.</source>
          <target state="translated">Nel metodo thread-safe, il valore iniziale del totale parziale viene salvato, quindi il <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> metodo viene utilizzato per scambiare il totale appena elaborato con il totale precedente.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</source>
          <target state="translated">Se il valore restituito non è uguale al valore del totale parziale salvato, quindi un altro thread ha aggiornato il totale nel frattempo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>In that case, the attempt to update the running total must be repeated.</source>
          <target state="translated">In tal caso, il tentativo di aggiornare il totale parziale deve essere ripetuto.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated">Destinazione il cui valore viene confrontato con <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> ed eventualmente sostituito.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valore confrontato con il valore in corrispondenza di <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">Confronta due interi con segno a 32 bit per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparand`</ph> e il valore in <ph id="ph2">`location1`</ph> sono uguali, <ph id="ph3">`value`</ph> viene archiviato in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">In caso contrario, non viene eseguita alcuna operazione.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Le operazioni di confronto e scambio vengono eseguite come operazione atomica.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Il valore restituito di <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> è il valore originale in <ph id="ph2">`location1`</ph>, scambio o meno.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The following code example demonstrates a thread-safe method that accumulates a running total.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un metodo di thread-safe che accumula un totale parziale.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The initial value of the running total is saved, and then the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is used to exchange the newly computed total with the old total.</source>
          <target state="translated">Il valore iniziale del totale parziale viene salvato, quindi il <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> metodo viene utilizzato per scambiare il totale appena elaborato con il totale precedente.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</source>
          <target state="translated">Se il valore restituito non è uguale al valore del totale parziale salvato, quindi un altro thread ha aggiornato il totale nel frattempo.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>In that case, the attempt to update the running total must be repeated.</source>
          <target state="translated">In tal caso, il tentativo di aggiornare il totale parziale deve essere ripetuto.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> metodo, introdotto nella versione 2.0 di .NET Framework, offre un modo più pratico per accumulare i totali parziali thread-safe per interi.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated">Destinazione il cui valore viene confrontato con <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> ed eventualmente sostituito.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valore confrontato con il valore in corrispondenza di <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">Confronta due interi con segno a 64 bit per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparand`</ph> e il valore in <ph id="ph2">`location1`</ph> sono uguali, <ph id="ph3">`value`</ph> viene archiviato in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">In caso contrario, non viene eseguita alcuna operazione.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Le operazioni di confronto e scambio vengono eseguite come operazione atomica.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Il valore restituito di <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> è il valore originale in <ph id="ph2">`location1`</ph>, scambio o meno.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The destination <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>, whose value is compared with the value of <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced by <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> di destinazione, il cui valore viene confrontato con il valore di <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> e, se possibile, sostituito da <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that replaces the destination value if the comparison results in equality.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> confrontato con il valore in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</source>
          <target state="translated">Confronta due puntatori o handle specifici della piattaforma per verificarne l'uguaglianza; se sono uguali, sostituisce il primo elemento.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparand`</ph> e il valore in <ph id="ph2">`location1`</ph> sono uguali, <ph id="ph3">`value`</ph> viene archiviato in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">In caso contrario, non viene eseguita alcuna operazione.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Le operazioni di confronto e scambio vengono eseguite come operazione atomica.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The return value of this method is the original value in <ph id="ph1">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Il valore restituito di questo metodo è il valore originale in <ph id="ph1">`location1`</ph>, scambio o meno.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> is a platform-specific type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> è un tipo specifico della piattaforma.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The destination object that is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated">Oggetto di destinazione confrontato con <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> e, se possibile, sostituito.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The object that replaces the destination object if the comparison results in equality.</source>
          <target state="translated">Oggetto che sostituisce l'oggetto di destinazione se il confronto rileva l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The object that is compared to the object at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Oggetto confrontato con l'oggetto in <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Compares two objects for reference equality and, if they are equal, replaces the first object.</source>
          <target state="translated">Confronta due oggetti per verificarne l'uguaglianza dei riferimenti; se sono uguali, sostituisce il primo oggetto.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>If <ph id="ph1">`comparand`</ph> and the object in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparand`</ph> e l'oggetto in <ph id="ph2">`location1`</ph> sono uguali, <ph id="ph3">`value`</ph> viene archiviato in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">In caso contrario, non viene eseguita alcuna operazione.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Le operazioni di confronto e scambio vengono eseguite come operazione atomica.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Il valore restituito di <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> è il valore originale in <ph id="ph2">`location1`</ph>, scambio o meno.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Beginning with .NET Framework version 2.0, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29&gt;</ph> method overload provides a type-safe alternative for reference types.</source>
          <target state="translated">A partire da .NET Framework versione 2.0, il <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29&gt;</ph> overload del metodo costituisce un'alternativa indipendente dai tipi per i tipi di riferimento.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The objects are compared for reference equality, rather than <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Gli oggetti vengono confrontati per verificarne l'uguaglianza di riferimento, anziché <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed.</source>
          <target state="translated">Di conseguenza, due istanze boxed dello stesso tipo di valore (ad esempio, il valore intero 3) sempre sembrano uguali, e viene eseguita alcuna operazione.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>Do not use this overload with value types.</source>
          <target state="translated">Non utilizzare questo overload con tipi di valore.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated">Destinazione il cui valore viene confrontato con <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> ed eventualmente sostituito.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valore confrontato con il valore in corrispondenza di <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</source>
          <target state="translated">Confronta due numeri a virgola mobile e precisione singola per verificarne l'uguaglianza; se sono uguali, sostituisce il primo valore.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparand`</ph> e il valore in <ph id="ph2">`location1`</ph> sono uguali, <ph id="ph3">`value`</ph> viene archiviato in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">In caso contrario, non viene eseguita alcuna operazione.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The compare and exchange operations are performed as an atomic operation.</source>
          <target state="translated">Le operazioni di confronto e scambio vengono eseguite come operazione atomica.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> is the original value in <ph id="ph2">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Il valore restituito di <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> è il valore originale in <ph id="ph2">`location1`</ph>, scambio o meno.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The following code example demonstrates a thread-safe method that accumulates a running total of <ph id="ph1">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un metodo di thread-safe che accumula un totale parziale di <ph id="ph1">&lt;xref:System.Single&gt;</ph> valori.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>Two threads add a series of <ph id="ph1">&lt;xref:System.Single&gt;</ph> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</source>
          <target state="translated">Due thread aggiungono una serie di <ph id="ph1">&lt;xref:System.Single&gt;</ph> valori utilizzando il metodo thread-safe e inoltre comune, e quando i thread vengono completati vengono confrontati i totali.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>On a dual-processor computer, there is a significant difference in the totals.</source>
          <target state="translated">In un computer con processore doppio, sussiste una differenza significativa nei totali.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>In the thread-safe method, the initial value of the running total is saved, and then the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method is used to exchange the newly computed total with the old total.</source>
          <target state="translated">Nel metodo thread-safe, il valore iniziale del totale parziale viene salvato, quindi il <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> metodo viene utilizzato per scambiare il totale appena elaborato con il totale precedente.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</source>
          <target state="translated">Se il valore restituito non è uguale al valore del totale parziale salvato, quindi un altro thread ha aggiornato il totale nel frattempo.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>In that case, the attempt to update the running total must be repeated.</source>
          <target state="translated">In tal caso, il tentativo di aggiornare il totale parziale deve essere ripetuto.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The type to be used for <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>, <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>, and <bpt id="p3">&lt;c&gt;</bpt>comparand<ept id="p3">&lt;/c&gt;</ept>.</source>
          <target state="translated">Il tipo da utilizzare per <bpt id="p1">&lt;c&gt;</bpt>receivelocation1<ept id="p1">&lt;/c&gt;</ept>, <bpt id="p2">&lt;c&gt;</bpt>valore<ept id="p2">&lt;/c&gt;</ept>, e <bpt id="p3">&lt;c&gt;</bpt>comparand<ept id="p3">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This type must be a reference type.</source>
          <target state="translated">Questo tipo deve essere un tipo di riferimento.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The destination, whose value is compared with <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> and possibly replaced.</source>
          <target state="translated">Destinazione il cui valore viene confrontato con <bpt id="p1">&lt;c&gt;</bpt>comparand<ept id="p1">&lt;/c&gt;</ept> ed eventualmente sostituito.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This is a reference parameter (<ph id="ph1">&lt;see langword="ref" /&gt;</ph> in C#, <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Rappresenta un parametro di riferimento (<ph id="ph1">&lt;see langword="ref" /&gt;</ph> in C#, <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The value that replaces the destination value if the comparison results in equality.</source>
          <target state="translated">Valore che sostituisce il valore di destinazione se il confronto rileva l'uguaglianza.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The value that is compared to the value at <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Valore confrontato con il valore in corrispondenza di <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>Compares two instances of the specified reference type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> for equality and, if they are equal, replaces the first one.</source>
          <target state="translated">Confronta due istanze del tipo di riferimento <ph id="ph1">&lt;paramref name="T" /&gt;</ph> specificato per verificarne l'uguaglianza. Se sono uguali, sostituisce la prima istanza.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The original value in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale in <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>If <ph id="ph1">`comparand`</ph> and the value in <ph id="ph2">`location1`</ph> are equal, then <ph id="ph3">`value`</ph> is stored in <ph id="ph4">`location1`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`comparand`</ph> e il valore in <ph id="ph2">`location1`</ph> sono uguali, <ph id="ph3">`value`</ph> viene archiviato in <ph id="ph4">`location1`</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>Otherwise, no operation is performed.</source>
          <target state="translated">In caso contrario, non viene eseguita alcuna operazione.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The comparison and the exchange are performed as an atomic operation.</source>
          <target state="translated">Il confronto e scambio vengono eseguite come operazione atomica.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The return value of this method is the original value in <ph id="ph1">`location1`</ph>, whether or not the exchange takes place.</source>
          <target state="translated">Il valore restituito di questo metodo è il valore originale in <ph id="ph1">`location1`</ph>, scambio o meno.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This method only supports reference types.</source>
          <target state="translated">Questo metodo supporta solo i tipi di riferimento.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>There are overloads of the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> method for the value types <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, and <ph id="ph6">&lt;xref:System.Double&gt;</ph>, but there is no support for other value types.</source>
          <target state="translated">Sono presenti overload del <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%2A&gt;</ph> metodo per i tipi di valore <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, e <ph id="ph6">&lt;xref:System.Double&gt;</ph>, ma non esiste alcun supporto per altri tipi di valore.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>This method overload is preferable to the <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29&gt;</ph> method overload, because the latter requires the destination object to be accessed late-bound.</source>
          <target state="translated">Questo overload del metodo è preferibile il <ph id="ph1">&lt;xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29&gt;</ph> overload del metodo, perché quest'ultimo richiede l'oggetto di destinazione per accedere ad associazione tardiva.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Decrements a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">Diminuisce una variabile specificata e archivia il risultato, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The variable whose value is to be decremented.</source>
          <target state="translated">Variabile il cui valore deve essere diminuito.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>Decrements a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">Diminuisce una variabile specificata e archivia il risultato, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The decremented value.</source>
          <target state="translated">Valore diminuito.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>This method handles an overflow condition by wrapping: If <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</source>
          <target state="translated">Nell'esempio seguente determina quanti numeri casuali compresi tra 0 e 1.000 necessari per generare numeri casuali 1.000 con un valore del punto centrale.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>To keep track of the number of midpoint values, a variable, <ph id="ph1">`midpointCount`</ph>, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</source>
          <target state="translated">Per tenere traccia del numero di valori punto intermedio, una variabile, <ph id="ph1">`midpointCount`</ph>, sia uguale a 1.000 e decrementato ogni volta che il generatore di numeri casuali restituisce un valore del punto centrale.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>Because three threads generate the random numbers, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29&gt;</ph> method is called to ensure that multiple threads don't update <ph id="ph2">`midpointCount`</ph> concurrently.</source>
          <target state="translated">Poiché tre thread generare numeri casuali, il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29&gt;</ph> metodo viene chiamato per garantire che più thread non aggiorna <ph id="ph2">`midpointCount`</ph> contemporaneamente.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>Note that a lock is also used to protect the random number generator, and that a <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object is used to ensure that the <ph id="ph2">`Main`</ph> method doesn't finish execution before the three threads.</source>
          <target state="translated">Si noti che un blocco viene inoltre utilizzato per proteggere il generatore di numeri casuali e che un <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> oggetto viene utilizzato per verificare che il <ph id="ph2">`Main`</ph> metodo non viene completata l'esecuzione prima di tre thread.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</source>
          <target state="translated">Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che usa l'anziché una procedura thread per generare numeri interi casuali punto centrale di 50.000.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>In this example, a lambda expression replaces the <ph id="ph1">`GenerateNumbers`</ph> thread procedure, and the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method eliminates the need for the <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">In questo esempio, un'espressione lambda sostituisce il <ph id="ph1">`GenerateNumbers`</ph> routine del thread e la chiamata al <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> metodo elimina la necessità per il <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int32@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The variable whose value is to be decremented.</source>
          <target state="translated">Variabile il cui valore deve essere diminuito.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>Decrements the specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">Diminuisce la variabile specificata e archivia il risultato, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The decremented value.</source>
          <target state="translated">Valore diminuito.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>This method handles an overflow condition by wrapping: if <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> - 1 = <ph id="ph5">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> (metodo) e gli overload a 64 bit del <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> metodi sono veramente atomici solo nei sistemi in cui un <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> è 64 bit.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">In altri sistemi, questi metodi sono atomici l'uno rispetto a altro, ma non rispetto ad altri mezzi di accesso ai dati.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">Di conseguenza, per essere thread-safe nei sistemi a 32 bit, qualsiasi accesso a un valore a 64 bit deve essere effettuato tramite i membri del <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Decrement(System.Int64@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Sets a variable to a specified value as an atomic operation.</source>
          <target state="translated">Imposta una variabile su un valore specificato come operazione atomica.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">Variabile da impostare sul valore specificato.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated">Valore su cui è impostato il parametro <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">Imposta un numero a virgola mobile e precisione doppia su un valore specificato e restituisce il valore originale, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">Variabile da impostare sul valore specificato.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated">Valore su cui è impostato il parametro <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">Imposta un intero con segno a 32 bit su un valore specificato e restituisce il valore originale, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The following code example shows a thread-safe resource locking mechanism.</source>
          <target state="translated">Esempio di codice seguente viene illustrato un meccanismo di blocco risorse thread-safe.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">Variabile da impostare sul valore specificato.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated">Valore su cui è impostato il parametro <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">Imposta un intero con segno a 64 bit su un valore specificato e restituisce il valore originale, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">Variabile da impostare sul valore specificato.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated">Valore su cui è impostato il parametro <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">Imposta un puntatore o un handle specifico della piattaforma su un valore specificato e restituisce il valore originale, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">Variabile da impostare sul valore specificato.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated">Valore su cui è impostato il parametro <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</source>
          <target state="translated">Imposta un oggetto su un valore specificato e restituisce un riferimento all'oggetto originale, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>Beginning with .NET Framework version 2.0, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29&gt;</ph> method overload provides a type-safe alternative for reference types.</source>
          <target state="translated">A partire da .NET Framework versione 2.0, il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29&gt;</ph> overload del metodo costituisce un'alternativa indipendente dai tipi per i tipi di riferimento.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">Variabile da impostare sul valore specificato.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated">Valore su cui è impostato il parametro <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">Imposta un numero a virgola mobile e precisione singola su un valore specificato e restituisce il valore originale, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The type to be used for <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> and <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Il tipo da utilizzare per <bpt id="p1">&lt;c&gt;</bpt>receivelocation1<ept id="p1">&lt;/c&gt;</ept> e <bpt id="p2">&lt;c&gt;</bpt>valore<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This type must be a reference type.</source>
          <target state="translated">Questo tipo deve essere un tipo di riferimento.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The variable to set to the specified value.</source>
          <target state="translated">Variabile da impostare sul valore specificato.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This is a reference parameter (<ph id="ph1">&lt;see langword="ref" /&gt;</ph> in C#, <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">Rappresenta un parametro di riferimento (<ph id="ph1">&lt;see langword="ref" /&gt;</ph> in C#, <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The value to which the <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept> parameter is set.</source>
          <target state="translated">Valore su cui è impostato il parametro <bpt id="p1">&lt;c&gt;</bpt>location1<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>Sets a variable of the specified type <ph id="ph1">&lt;paramref name="T" /&gt;</ph> to a specified value and returns the original value, as an atomic operation.</source>
          <target state="translated">Imposta una variabile del tipo <ph id="ph1">&lt;paramref name="T" /&gt;</ph> indicato sul valore specificato e restituisce il valore originale, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The original value of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</source>
          <target state="translated">Valore originale di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This method only supports reference types.</source>
          <target state="translated">Questo metodo supporta solo i tipi di riferimento.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>There are overloads of the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> method for the <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, and <ph id="ph6">&lt;xref:System.Double&gt;</ph> value types, but there is no support for other value types.</source>
          <target state="translated">Sono presenti overload del <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%2A&gt;</ph> metodo per il <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, <ph id="ph3">&lt;xref:System.Int64&gt;</ph>, <ph id="ph4">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph5">&lt;xref:System.Single&gt;</ph>, e <ph id="ph6">&lt;xref:System.Double&gt;</ph> i tipi di valore, ma non esiste alcun supporto per altri tipi di valore.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>This method overload is preferable to the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29&gt;</ph> method overload, because the latter requires late-bound access to the destination object .</source>
          <target state="translated">Questo overload del metodo è preferibile il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29&gt;</ph> overload del metodo, poiché quest'ultimo richiede l'accesso ad associazione tardiva nell'oggetto di destinazione.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
          <source>The address of <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location1" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="T:System.Threading.Interlocked">
          <source>Increments a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The variable whose value is to be incremented.</source>
          <target state="translated">Variabile il cui valore deve essere aumentato.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>Increments a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The incremented value.</source>
          <target state="translated">Valore aumentato.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>This method handles an overflow condition by wrapping: if <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int32.MinValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</source>
          <target state="translated">Nell'esempio seguente determina quanti numeri casuali compresi tra 0 e 1.000 necessari per generare numeri casuali 1.000 con un valore del punto centrale.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>To keep track of the number of midpoint values, a variable, <ph id="ph1">`midpointCount`</ph>, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</source>
          <target state="translated">Per tenere traccia del numero di valori punto intermedio, una variabile, <ph id="ph1">`midpointCount`</ph>, è uguale a 0 e incrementato ogni volta che il generatore di numeri casuali restituisce il valore del punto centrale finché raggiunge 10.000.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>Because three threads generate the random numbers, the <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%28System.Int32%40%29&gt;</ph> method is called to ensure that multiple threads don't update <ph id="ph2">`midpointCount`</ph> concurrently.</source>
          <target state="translated">Poiché tre thread generare numeri casuali, il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Increment%28System.Int32%40%29&gt;</ph> metodo viene chiamato per garantire che più thread non aggiorna <ph id="ph2">`midpointCount`</ph> contemporaneamente.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>Note that a lock is also used to protect the random number generator, and that a <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object is used to ensure that the <ph id="ph2">`Main`</ph> method doesn't finish execution before the three threads.</source>
          <target state="translated">Si noti che un blocco viene inoltre utilizzato per proteggere il generatore di numeri casuali e che un <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> oggetto viene utilizzato per verificare che il <ph id="ph2">`Main`</ph> metodo non viene completata l'esecuzione prima di tre thread.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers.</source>
          <target state="translated">Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che usa l'anziché una procedura thread per generare numeri interi casuali punto centrale di 50.000.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>In this example, a lambda expression replaces the <ph id="ph1">`GenerateNumbers`</ph> thread procedure, and the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method eliminates the need for the <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">In questo esempio, un'espressione lambda sostituisce il <ph id="ph1">`GenerateNumbers`</ph> routine del thread e la chiamata al <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> metodo elimina la necessità per il <ph id="ph3">&lt;xref:System.Threading.CountdownEvent&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int32@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The variable whose value is to be incremented.</source>
          <target state="translated">Variabile il cui valore deve essere aumentato.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>Increments a specified variable and stores the result, as an atomic operation.</source>
          <target state="translated">Aumenta una variabile specificata e archivia il risultato, come operazione atomica.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The incremented value.</source>
          <target state="translated">Valore aumentato.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>This method handles an overflow condition by wrapping: if <ph id="ph1">`location`</ph><ph id="ph2"> = </ph><ph id="ph3">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Questo metodo gestisce una condizione di overflow eseguendo il wrapping: se <ph id="ph1">`location`</ph> <ph id="ph2"> = </ph> <ph id="ph3">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">`location`</ph> + 1 = <ph id="ph5">&lt;xref:System.Int64.MinValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>No exception is thrown.</source>
          <target state="translated">Non viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> (metodo) e gli overload a 64 bit del <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> metodi sono veramente atomici solo nei sistemi in cui un <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> è 64 bit.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">In altri sistemi, questi metodi sono atomici l'uno rispetto a altro, ma non rispetto ad altri mezzi di accesso ai dati.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">Di conseguenza, per essere thread-safe nei sistemi a 32 bit, qualsiasi accesso a un valore a 64 bit deve essere effettuato tramite i membri del <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Increment(System.Int64@)">
          <source>The address of <ph id="ph1">&lt;paramref name="location" /&gt;</ph> is a null pointer.</source>
          <target state="translated">L'indirizzo di <ph id="ph1">&lt;paramref name="location" /&gt;</ph> è un puntatore Null.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source>Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <ph id="ph1">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph> execute after memory accesses that follow the call to <ph id="ph2">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph>.</source>
          <target state="translated">Sincronizza l'accesso della memoria nel modo descritto di seguito. Il processore che esegue il thread corrente non può riordinare istruzioni in modo che gli accessi alla memoria prima della chiamata al metodo <ph id="ph1">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph> vengano eseguiti dopo quelli successivi alla chiamata al metodo <ph id="ph2">&lt;see cref="M:System.Threading.Interlocked.MemoryBarrier" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source>This method was added to the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class in the <ph id="ph2">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> as a convenience; it's a wrapper for the <ph id="ph3">&lt;xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Questo metodo è stato aggiunto al <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> classe il <ph id="ph2">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> praticità; è un wrapper per il <ph id="ph3">&lt;xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source><ph id="ph1">&lt;xref:System.Threading.Interlocked.MemoryBarrier%2A&gt;</ph> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Interlocked.MemoryBarrier%2A&gt;</ph> è necessario solo nei sistemi multiprocessori che hanno un ordinamento memoria debole (ad esempio, un sistema che utilizza più processori Intel Itanium).</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.MemoryBarrier">
          <source>For most purposes, the C# <ph id="ph1">`lock`</ph> statement, the Visual Basic <ph id="ph2">`SyncLock`</ph> statement, or the <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> class provide easier ways to synchronize data.</source>
          <target state="translated">Per la maggior parte dei casi, in c# <ph id="ph1">`lock`</ph> istruzione, Visual Basic <ph id="ph2">`SyncLock`</ph> istruzione o <ph id="ph3">&lt;xref:System.Threading.Monitor&gt;</ph> classe fornisce un modo semplice per sincronizzare i dati.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The 64-bit value to be loaded.</source>
          <target state="translated">Valore a 64 bit da caricare.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>Returns a 64-bit value, loaded as an atomic operation.</source>
          <target state="translated">Restituisce un valore a 64 bit, caricato come operazione atomica.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The loaded value.</source>
          <target state="translated">Valore caricato.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> (metodo) non è necessario nei sistemi a 64 bit, poiché le operazioni di lettura a 64 bit sono già atomiche.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>On 32-bit systems, 64-bit read operations are not atomic unless performed using <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph>.</source>
          <target state="translated">Nei sistemi a 32 bit, le operazioni di lettura a 64 bit non sono atomiche, a meno che non eseguita utilizzando <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> method and the 64-bit overloads of the <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> methods are truly atomic only on systems where a <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> is 64 bits long.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Interlocked.Read%2A&gt;</ph> (metodo) e gli overload a 64 bit del <ph id="ph2">&lt;xref:System.Threading.Interlocked.Increment%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Threading.Interlocked.Decrement%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Threading.Interlocked.Add%2A&gt;</ph> metodi sono veramente atomici solo nei sistemi in cui un <ph id="ph5">&lt;xref:System.IntPtr?displayProperty=nameWithType&gt;</ph> è 64 bit.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</source>
          <target state="translated">In altri sistemi, questi metodi sono atomici l'uno rispetto a altro, ma non rispetto ad altri mezzi di accesso ai dati.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source>Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> class.</source>
          <target state="translated">Di conseguenza, per essere thread-safe nei sistemi a 32 bit, qualsiasi accesso a un valore a 64 bit deve essere effettuato tramite i membri del <ph id="ph1">&lt;xref:System.Threading.Interlocked&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Interlocked.Read(System.Int64@)">
          <source><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> is a platform-specific type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IntPtr&gt;</ph> è un tipo specifico della piattaforma.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>