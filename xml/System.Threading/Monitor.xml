<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cfafcfe91d4ef6eba6ebbbbe6d7101119c93823a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531375" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce un meccanismo che sincronizza l'accesso agli oggetti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Monitor> classe consente di sincronizzare l'accesso a un'area di codice accettando e rilasciando un blocco su un determinato oggetto chiamando il <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, e <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metodi. I blocchi di oggetti consentono di limitare l'accesso a un blocco di codice, comunemente denominato sezione critica. Mentre un thread proprietario del blocco per un oggetto, nessun altro thread può acquisire il blocco. È inoltre possibile utilizzare il <xref:System.Threading.Monitor> codice della classe per garantire che nessun altro thread possa accedere a una sezione dell'applicazione viene eseguita dal proprietario del blocco, a meno che l'altro thread è in esecuzione il codice utilizzando un diverso oggetto bloccato.  
  
 Contenuto dell'articolo:  
  
 [La classe di monitoraggio: Panoramica](#Overview)   
 [Oggetto di blocco](#Lock)   
 [La sezione critica](#CriticalSection)   
 [Attesa Pulse e PulseAll](#Pulse)   
 [Monitoraggi e gli handle di attesa](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>La classe di monitoraggio: Panoramica  
 <xref:System.Threading.Monitor> presenta le seguenti funzionalità:  
  
-   È associata a un oggetto su richiesta.  
  
-   È non associato, vale a dire che può essere chiamato direttamente da qualsiasi contesto.  
  
-   Un'istanza di <xref:System.Threading.Monitor> classe non può essere creata; i metodi del <xref:System.Threading.Monitor> classe sono tutti statici. Ogni metodo viene passato l'oggetto sincronizzato che controlla l'accesso alla sezione critica.  
  
> [!NOTE]
>  Utilizzare il <xref:System.Threading.Monitor> classe per bloccare gli oggetti diversi da stringhe (ovvero, tipi di riferimento diverso da <xref:System.String>), i tipi di valore non. Per informazioni dettagliate, vedere gli overload di <xref:System.Threading.Monitor.Enter%2A> (metodo) e [dell'oggetto di blocco](#Lock) sezione più avanti in questo articolo.  
  
 Nella tabella seguente descrive le azioni che possono essere eseguite dal thread che accedono a oggetti sincronizzati:  
  
|Operazione|Descrizione|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Acquisisce un blocco per un oggetto. Inoltre, questa azione contrassegna l'inizio di una sezione critica. Nessun altro thread può accedere alla sezione critica, a meno che non è in esecuzione le istruzioni nella sezione critica utilizzando un diverso oggetto bloccato.|  
|<xref:System.Threading.Monitor.Wait%2A>|Rilascia il blocco su un oggetto per consentire ad altri thread per bloccare e accedere all'oggetto. Il thread chiamante attende l'oggetto accede a un altro thread. Segnali Pulse vengono utilizzati per notificare il thread in attesa sulle modifiche apportate allo stato di un oggetto.|  
|<xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A>|Invia un segnale a uno o più thread in attesa. Il segnale di notifica a un thread in attesa che lo stato dell'oggetto bloccato è cambiato e il proprietario del blocco è pronto per rilasciare il blocco. Il thread in attesa viene inserito nella coda di pronto dell'oggetto in modo che possa infine ricevere il blocco per l'oggetto. Una volta che il thread ha il blocco, è possibile verificare il nuovo stato dell'oggetto per vedere se è stato raggiunto lo stato obbligatorio.|  
|<xref:System.Threading.Monitor.Exit%2A>|Rilascia il blocco su un oggetto. Inoltre, questa azione contrassegna la fine di una sezione critica protetta dall'oggetto bloccato.|  
  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], sono disponibili due set di overload per il <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.TryEnter%2A> metodi. Un set di overload è un `ref` (in c#) o `ByRef` (in Visual Basic) <xref:System.Boolean> parametro che è impostato in modo atomico `true` se viene acquisito il blocco, anche se viene generata un'eccezione durante l'acquisizione del blocco. Usare questi overload se è fondamentale per rilasciare il blocco in tutti i casi, anche quando le risorse che di blocco per la protezione potrebbero non essere in uno stato coerente.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Oggetto di blocco  
 La classe di monitoraggio è costituita `static` (in c#) o `Shared` (in Visual Basic) metodi che operano su un oggetto che controlla l'accesso alla sezione critica.  Per ogni oggetto sincronizzato, vengono gestite le informazioni seguenti:  
  
-   Un riferimento al thread che attualmente contiene il blocco.  
  
-   Un riferimento a una coda pronto, che contiene i thread pronti ottenere il blocco.  
  
-   Un riferimento a una coda di attesa, che contiene i thread in attesa per la notifica di una modifica nello stato dell'oggetto bloccato.  
  
 <xref:System.Threading.Monitor> blocca gli oggetti, ovvero i tipi di riferimento, non i tipi di valore. Anche se è possibile passare un tipo di valore a <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A>, ogni valore viene sottoposto a boxing separatamente per ogni chiamata. Poiché ogni chiamata crea un oggetto separato, <xref:System.Threading.Monitor.Enter%2A> non si blocca mai e non sincronizza realmente il codice che dovrebbe proteggere. L'oggetto passato a <xref:System.Threading.Monitor.Exit%2A>, inoltre, è diverso dall'oggetto passato a <xref:System.Threading.Monitor.Enter%2A>, quindi <xref:System.Threading.Monitor> genera un'eccezione <xref:System.Threading.SynchronizationLockException> con il messaggio "Il metodo di sincronizzazione dell'oggetto è stato chiamato da un blocco di codice non sincronizzato".  
  
 L'esempio seguente illustra questo problema. Avvia dieci attività, ognuna delle quali rimane semplicemente inattiva per 250 millisecondi. Ogni attività aggiorna quindi una variabile del contatore, `nTasks`, in modo da contare il numero di attività effettivamente avviate ed eseguite. Poiché `nTasks` è una variabile globale che può essere aggiornata da più attività contemporaneamente, viene usato un oggetto monitor per proteggerla dalla modifica simultanea da parte di più attività. Tuttavia, come illustrato dall'output dell'esempio, ogni attività genera un'eccezione <xref:System.Threading.SynchronizationLockException>.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 Ogni attività genera un'eccezione <xref:System.Threading.SynchronizationLockException>, poiché la variabile `nTasks` viene sottoposta a boxing prima della chiamata al metodo <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> in ogni attività. In altri termini, una variabile separata, indipendente dalle altre, viene passata a ogni chiamata al metodo. `nTasks` viene sottoposto di nuovo a boxing nella chiamata al metodo <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. Ancora una volta, ciò crea dieci nuove variabili di tipo boxed, indipendenti le une dalle altre, `nTasks` e le dieci variabili di tipo boxed create nella chiamata al metodo <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>. L'eccezione viene generata, quindi, poiché il codice sta tentando di rilasciare un blocco su una variabile appena creata non bloccata in precedenza.  
  
 Anche se è possibile sottoporre a boxing una variabile di tipo valore prima di chiamare <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A>, come illustrato nell'esempio seguente, e passare lo stesso oggetto di tipo boxed a entrambi i metodi, ciò non presenta alcun vantaggio. Le modifiche alla variabile di tipo unboxed non sono riflesse nella copia di tipo boxed e non è possibile modificare il valore della copia di tipo boxed.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 Quando si seleziona un oggetto su cui eseguire la sincronizzazione, è necessario bloccare solo per gli oggetti interni o privati. Il blocco degli oggetti esterni potrebbe causare deadlock, perché il codice correlato può scegliere gli stessi oggetti di blocco per scopi diversi.  
  
 Si noti che è possibile sincronizzare su un oggetto in più domini applicazione se l'oggetto utilizzato per il blocco deriva da <xref:System.MarshalByRefObject>.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>La sezione critica  
 Utilizzare il <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> metodi per contrassegnare l'inizio e alla fine di una sezione critica.  
  
> [!NOTE]
>  La funzionalità fornita dal <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> metodi è identico a quello fornito dal [blocco](~/docs/csharp/language-reference/keywords/lock-statement.md) istruzione in c# e [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) istruzione in Visual Basic, con la differenza che il a capo automatico di costrutti di linguaggio di <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> overload del metodo e <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metodo in un `try`...`finally` blocco per garantire che il monitoraggio venga rilasciato.  
  
 Se la sezione critica è un set di istruzioni contigue, quindi il blocco acquisito dal <xref:System.Threading.Monitor.Enter%2A> metodo garantisce che solo un singolo thread possa eseguire il codice incluso nell'oggetto bloccato. In questo caso, si consiglia di posizionare che il codice che un `try` bloccare e inserire la chiamata al <xref:System.Threading.Monitor.Exit%2A> metodo in un `finally` blocco. Ciò assicura che il blocco venga rilasciato anche se si verifica un'eccezione. Frammento di codice seguente viene illustrato questo modello.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 Questa funzionalità viene in genere utilizzata per sincronizzare l'accesso a un valore statico o il metodo di istanza di una classe.  
  
 Se una sezione critica occupa un intero metodo, è possano utilizzare le funzionalità di blocco inserendo il <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> sul metodo, specificando il <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> valore nel costruttore della <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>. Quando si usa questo attributo, il <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> chiamate al metodo non sono necessari. Frammento di codice seguente viene illustrato questo modello:  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 Si noti che l'attributo, il thread corrente contenere il blocco finché il metodo restituisce; Se il blocco può essere rilasciato prima, utilizzare il <xref:System.Threading.Monitor> classe c# [blocco](~/docs/csharp/language-reference/keywords/lock-statement.md) istruzione o Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) istruzione all'interno del metodo anziché l'attributo.  
  
 Sebbene sia possibile per il <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> le istruzioni che bloccare e rilasciare un determinato oggetto superino membro o i limiti di classe, questa procedura non consigliata.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Attesa Pulse e PulseAll  
 Una volta che un thread proprietario del blocco e ha attivato la sezione critica che protegge il blocco, è possibile chiamare il <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, e <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> metodi.  
  
 <xref:System.Threading.Monitor.Wait%2A> rilascia il blocco viene mantenuto, consente a un thread in attesa o thread per ottenere il blocco e accedere alla sezione critica e attende la notifica da una chiamata al <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> o <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> metodo. Quando <xref:System.Threading.Monitor.Wait%2A> riceve la notifica, restituisce e ottiene di nuovo il blocco.  
  
 Sia <xref:System.Threading.Monitor.Pulse%2A> che <xref:System.Threading.Monitor.PulseAll%2A> segnalano al thread successivo della coda di attesa di continuare.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>Monitoraggi e gli handle di attesa  
 È importante notare la distinzione tra l'utilizzo del <xref:System.Threading.Monitor> classe e <xref:System.Threading.WaitHandle> oggetti.  
  
-   La <xref:System.Threading.Monitor> classe è semplicemente gestiti e completamente portabili e potrebbero essere più efficiente in termini di requisiti di risorse del sistema operativo.  
  
-   Gli oggetti <xref:System.Threading.WaitHandle> rappresentano oggetti awaitable del sistema operativo, sono utili per la sincronizzazione tra codice gestito e non gestito ed espongono alcune funzionalità avanzate del sistema operativo, ad esempio la capacità di rimanere in attesa di più oggetti contemporaneamente.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.Monitor> classe per sincronizzare l'accesso a una singola istanza di un generatore di numeri casuali rappresentato dalla <xref:System.Random> classe. L'esempio crea dieci attività, ognuno dei quali esegue in modo asincrono in un pool di thread. Ogni attività genera numeri casuali 10.000, viene calcolata la media e aggiorna due variabili a livello di stored procedure che gestiscono un totale parziale del numero di numeri casuali generati e la somma. Dopo avranno eseguito tutte le attività, questi due valori vengono quindi utilizzati per calcolare la media globale.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 Poiché è possibile accedervi da qualsiasi attività in esecuzione in un pool di thread, accedere alle variabili `total` e `n` devono anche essere sincronizzati. Il <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> metodo viene utilizzato per questo scopo.  
  
 Nell'esempio seguente illustra l'uso combinato del <xref:System.Threading.Monitor> classe (implementata con il `lock` o `SyncLock` costrutto di linguaggio), il <xref:System.Threading.Interlocked> (classe) e <xref:System.Threading.AutoResetEvent> classe. Definisce due `internal` (in c#) o `Friend` (in Visual Basic), classi `SyncResource` e `UnSyncResource`, che forniscono rispettivamente l'accesso sincronizzato e non sincronizzato a una risorsa. Per assicurarsi che nell'esempio viene illustrata la differenza tra l'accesso sincronizzato e non sincronizzato (che può essere il caso se ogni chiamata al metodo viene completata rapidamente), il metodo include un ritardo casuale: per i thread la cui <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> proprietà è pari, il chiamate al metodo <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> per introdurre un ritardo di 2000 millisecondi. Si noti che, in quanto la `SyncResource` classe non è pubblica, nessuna parte del codice client acquisisce un blocco sulla risorsa sincronizzata: la classe interna ad acquisisce il blocco. Ciò impedisce l'acquisizione di un blocco su un oggetto pubblico da parte di codice dannoso.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 Nell'esempio viene definita una variabile, `numOps`, che definisce il numero di thread che tenta di accedere alla risorsa. Il thread dell'applicazione chiama il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> metodo per sincronizzato e non sincronizzato l'accesso cinque volte ciascun. Il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> metodo ha un solo parametro, un delegato che non accetta parametri e non restituisce alcun valore. Per l'accesso sincronizzato, richiama il `SyncUpdateResource` metodo; per l'accesso non sincronizzato, richiama il `UnSyncUpdateResource` metodo. Dopo ogni set di chiamate al metodo, il thread dell'applicazione chiama il [AutoResetEvent. WaitOne](xref:System.Threading.WaitHandle.WaitOne*) metodo in modo che si blocchi finché la <xref:System.Threading.AutoResetEvent> istanza viene segnalata.  
  
 Ogni chiamata al `SyncUpdateResource` metodo chiama interno `SyncResource.Access` (metodo) e quindi chiama il <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodo per decrementare il `numOps` contatore. Il <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodo viene utilizzato per decrementare il contatore, perché in caso contrario è possibile essere certi che un secondo thread acceda al valore prima che un primo thread decrementato valore sia stato archiviato nella variabile. Quando l'ultimo lavoro thread sincronizzato decrementa il contatore a zero, indicando che tutti i thread sincronizzati hanno completato l'accesso alla risorsa, il `SyncUpdateResource` chiamate al metodo di <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> metodo, che segnala al thread principale di continuare esecuzione.  
  
 Ogni chiamata al `UnSyncUpdateResource` metodo chiama interno `UnSyncResource.Access` (metodo) e quindi chiama il <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodo per decrementare il `numOps` contatore. In questo caso, il <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodo viene utilizzato per decrementare il contatore per garantire che un secondo thread acceda al valore prima valore decrementato di un primo thread sia stato assegnato alla variabile. Quando l'ultimo non sincronizzato decrementa di thread di lavoro il contatore a zero, che indica che non consentono più thread non sincronizzati necessario accedere alla risorsa, il `UnSyncUpdateResource` chiamate al metodo di <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> metodo, che segnala al thread principale di continuare l'esecuzione .  
  
 Come mostra il risultato dell'esempio, l'accesso sincronizzato garantisce che il thread di chiamata esca dalla risorsa protetta prima che un altro thread possa accedervi; ogni thread attende il suo predecessore. D'altra parte, senza il blocco, il `UnSyncResource.Access` metodo viene chiamato nell'ordine in cui i thread lo raggiungono.  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acquisisce un blocco esclusivo su un oggetto specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sui cui acquisire il blocco del monitoraggio.</param>
        <summary>Acquisisce un blocco esclusivo sull'oggetto specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare `Enter` di acquisire il <xref:System.Threading.Monitor> per l'oggetto passato come parametro. Se un altro thread ha eseguito un `Enter` sull'oggetto, ma non è ancora eseguita corrispondente <xref:System.Threading.Monitor.Exit%2A>, il thread corrente verrà bloccata finché l'altro thread rilascia l'oggetto. È consentito per lo stesso thread richiamare `Enter` più volte senza causarne; tuttavia, un numero uguale di `Exit` chiamate devono essere richiamate prima di altri thread in attesa per l'oggetto Sblocca.  
  
 Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (ovvero, i tipi di riferimento), non i tipi di valore. Quando si passa una variabile di tipo di valore a `Enter`, viene sottoposto a boxing come oggetto. Se si passa la stessa variabile a `Enter` , viene sottoposto a boxing come oggetto separato e non blocca il thread. In questo caso, il codice che `Monitor` è in realtà non è protetto. Inoltre, quando si passa la variabile `Exit`, viene creato anche un altro oggetto distinto. Poiché l'oggetto passato a `Exit` è diverso dall'oggetto passato a `Enter`, `Monitor` genera <xref:System.Threading.SynchronizationLockException>. Per ulteriori informazioni, vedere l'argomento concettuale [monitoraggi](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> può interrompere thread in attesa di acquisire un `Monitor` su un oggetto. Oggetto <xref:System.Threading.ThreadInterruptedException> verrà generata.  
  
 Usare c# `try`...`finally` blocco (`Try`...`Finally` in Visual Basic) per garantire il rilascio del monitor oppure utilizzare il linguaggio c# `lock` istruzione (`SyncLock` istruzione in Visual Basic), che esegue il wrapping di <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> metodi in un `try`...`finally` blocco.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del metodo `Enter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.  
  
 Nota   Se non si verifica alcuna eccezione, l'output di questo metodo è sempre <see langword="true" />.</param>
        <summary>Acquisisce un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare `Enter` di acquisire il <xref:System.Threading.Monitor> per l'oggetto passato come il `obj` parametro. Se un altro thread ha eseguito un `Enter` sull'oggetto, ma non è ancora eseguita corrispondente <xref:System.Threading.Monitor.Exit%2A>, il thread corrente verrà bloccata finché l'altro thread rilascia l'oggetto. È consentito per lo stesso thread richiamare `Enter` più volte senza causarne; tuttavia, un numero uguale di `Exit` chiamate devono essere richiamate prima di altri thread in attesa per l'oggetto Sblocca.  
  
 Se il blocco non è stato creato perché è stata generata un'eccezione, la variabile specificata per il `lockTaken` parametro `false` dopo che questo metodo termina. In questo modo il programma determinare, in tutti i casi, se è necessario rilasciare il blocco. Se questo metodo viene restituito senza generare un'eccezione, la variabile specificata per il `lockTaken` parametro è sempre `true`, e non è necessario eseguirne il test.  
  
 Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (ovvero, i tipi di riferimento), non i tipi di valore. Quando si passa una variabile di tipo di valore a `Enter`, viene sottoposto a boxing come oggetto. Se si passa la stessa variabile a `Enter` , viene sottoposto a boxing come oggetto separato e non blocca il thread. In questo caso, il codice che `Monitor` è in realtà non è protetto. Inoltre, quando si passa la variabile `Exit`, viene creato un altro oggetto distinto. Poiché l'oggetto passato a `Exit` è diverso dall'oggetto passato a `Enter`, `Monitor` genera <xref:System.Threading.SynchronizationLockException>. Per ulteriori informazioni, vedere l'argomento concettuale [monitoraggi](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> può interrompere thread in attesa di acquisire un `Monitor` su un oggetto. Oggetto <xref:System.Threading.ThreadInterruptedException> verrà generata.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato il modello di base per l'utilizzo di <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> overload del metodo. Questo overload imposta sempre il valore della variabile che viene passato per il `ref` parametro (`ByRef` in Visual Basic) `lockTaken`, anche se il metodo genera un'eccezione, pertanto il valore della variabile è un modo affidabile per verificare se il blocco deve essere rilasciato.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale rilasciare il blocco.</param>
        <summary>Viene rilasciato un blocco esclusivo sull'oggetto specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il thread chiamante deve proprietario del blocco di `obj` parametro. Se il thread chiamante possiede il blocco sull'oggetto specificato e ha un numero uguale di `Exit` e <xref:System.Threading.Monitor.Enter%2A> chiama il metodo per l'oggetto, il blocco viene rilasciato. Se il thread chiamante non ha richiamato `Exit` tante volte quanti `Enter`, il blocco non viene rilasciato.  
  
 Se il blocco viene rilasciato e altri thread presenti nella coda pronta per l'oggetto, uno dei thread acquisisce il blocco. Se altri thread è in coda in attesa di acquisire il blocco, non vengono automaticamente spostati nella coda pronti quando il proprietario del blocco chiama `Exit`. Per spostare uno o più thread in attesa nella coda degli elementi pronti, chiamare <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> prima di richiamare `Exit`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del metodo `Exit`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il blocco per l'oggetto specificato non è di proprietà del thread corrente.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da testare.</param>
        <summary>Determina se il thread corrente specificato contiene il blocco sull'oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se il thread corrente è responsabile del blocco su <paramref name="obj" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona solo per i blocchi acquisiti utilizzando i metodi del <xref:System.Threading.Monitor> , classe o l'uso di c# `lock` istruzione o Visual Basic `SyncLock` istruzione in cui vengono implementate con <xref:System.Threading.Monitor>.  
  
 Utilizzare questo metodo con strumenti di diagnostica, ad esempio il <xref:System.Diagnostics.Debug.Assert%2A> (metodo) e <xref:System.Diagnostics.Contracts.Contract> (classe), eseguire il debug di problemi di blocco che comportano la <xref:System.Threading.Monitor> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto atteso da un thread.</param>
        <summary>Notifica a un thread della coda di attesa che lo stato dell'oggetto bloccato è stato modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo il proprietario corrente del blocco può segnalare un oggetto in attesa utilizzando `Pulse`.  
  
 Questo metodo per segnalare al thread successivo della riga per il blocco viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato. Dopo aver ricevuto l'impulso, viene spostato il thread in attesa nella coda pronti. Quando il thread che ha richiamato `Pulse` rilascia il blocco, il thread successivo nella coda degli elementi pronti (che non è necessariamente il thread che ha ricevuto l'impulso) acquisisce il blocco.  
  
> [!IMPORTANT]
>  Il <xref:System.Threading.Monitor> classe mantiene lo stato che indica che il <xref:System.Threading.Monitor.Pulse%2A> metodo è stato chiamato. Pertanto, se si chiama <xref:System.Threading.Monitor.Pulse%2A> quando non sono thread in attesa, il successivo thread che chiama <xref:System.Threading.Monitor.Wait%2A> blocchi come se <xref:System.Threading.Monitor.Pulse%2A> non fosse mai stato chiamato. Se due thread utilizzano <xref:System.Threading.Monitor.Pulse%2A> e <xref:System.Threading.Monitor.Wait%2A> per interagire, ciò potrebbe causare un deadlock. Si differenzia dal comportamento del <xref:System.Threading.AutoResetEvent> classe: se indicano un <xref:System.Threading.AutoResetEvent> chiamando il relativo <xref:System.Threading.EventWaitHandle.Set%2A> (metodo) e non sono presenti thread in attesa, il <xref:System.Threading.AutoResetEvent> rimane in stato segnalato fino a quando un thread chiama <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, o <xref:System.Threading.WaitHandle.WaitAll%2A>. Il <xref:System.Threading.AutoResetEvent> rilascia il thread e torna allo stato segnalato.  
  
 Si noti che un oggetto sincronizzato contiene diversi riferimenti, un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronti, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, tra cui contiene i thread in attesa per la notifica di modifica dello stato dell'oggetto.  
  
 Il `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, e <xref:System.Threading.Monitor.Wait%2A> metodi devono essere richiamati dall'interno di un blocco sincronizzato di codice.  
  
 Per segnalare più thread, utilizzare il <xref:System.Threading.Monitor.PulseAll%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto che invia l'impulso.</param>
        <summary>Notifica a tutti i thread in attesa che lo stato dell'oggetto è stato modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo per segnalare tutti i thread in attesa di acquisire il blocco sull'oggetto viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato. Una volta inviato il segnale, vengono spostati i thread in attesa nella coda pronti. Quando il thread che ha richiamato `PulseAll` rilascia il blocco, il thread successivo nella coda degli elementi pronti acquisisce il blocco.  
  
 Si noti che un oggetto sincronizzato contiene diversi riferimenti, un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronti, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, tra cui contiene i thread in attesa per la notifica di modifica dello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, e <xref:System.Threading.Monitor.Wait%2A> metodi devono essere richiamati dall'interno di un blocco sincronizzato di codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo spiegare cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando è in attesa alcun thread.  
  
 Per segnalare un thread singolo, utilizzare il `Pulse` metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova ad acquisire un blocco esclusivo sull'oggetto specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <summary>Prova ad acquisire un blocco esclusivo sull'oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se ha esito positivo, questo metodo acquisisce un blocco esclusivo sul `obj` parametro. Questo metodo restituisce immediatamente, il blocco è disponibile o meno.  
  
 Questo metodo è simile a <xref:System.Threading.Monitor.Enter%2A>, ma non viene mai interrotto il thread corrente. Se il thread non è possibile immettere senza blocco, il metodo restituisce `false,`.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (ovvero, i tipi di riferimento), non i tipi di valore. Per informazioni dettagliate, vedere il <xref:System.Threading.Monitor> articolo.  
  
 Per garantire che il thread non immette la sezione critica, è necessario esaminare il valore restituito del metodo ed eseguire codice nella sezione critica solo se il valore restituito è `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come utilizzare il metodo `TryEnter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
        <summary>Prova ad acquisire un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se ha esito positivo, questo metodo acquisisce un blocco esclusivo sul `obj` parametro. Questo metodo restituisce immediatamente, il blocco è disponibile o meno.  
  
 Se il blocco non è stato creato perché è stata generata un'eccezione, la variabile specificata per il `lockTaken` parametro `false` dopo che questo metodo termina. In questo modo il programma determinare, in tutti i casi, se è necessario rilasciare il blocco.  
  
 Questo metodo è simile a <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, ma non viene mai interrotto il thread corrente. Se il thread non è possibile immettere senza blocco, il `lockTaken` argomento è impostato su `false` quando il metodo restituisce.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (ovvero, i tipi di riferimento), non i tipi di valore. Per ulteriori informazioni, vedere l'articolo <xref:System.Threading.Monitor>.  
  
 Per garantire che il thread non di accedere alla sezione critica, è necessario esaminare il valore di `lockTaken` ed eseguire il codice nella sezione critica solo se il valore è `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 Nel codice seguente viene illustrato il modello di base per l'utilizzo di <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> overload del metodo. Questo overload imposta sempre il valore della variabile che viene passato per il `ref` parametro (`ByRef` in Visual Basic) `lockTaken`, anche se il metodo genera un'eccezione, pertanto il valore della variabile è un modo affidabile per verificare se il blocco deve essere rilasciato.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="millisecondsTimeout">Tempo di attesa espresso in millisecondi prima che si verifichi il blocco.</param>
        <summary>Viene eseguito, per un numero specificato di millisecondi, il tentativo di acquisire un blocco esclusivo sull'oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `millisecondsTimeout` parametro è uguale a <xref:System.Threading.Timeout.Infinite>, questo metodo equivale a <xref:System.Threading.Monitor.Enter%2A>. Se `millisecondsTimeout` è uguale a 0, questo metodo equivale a <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (ovvero, i tipi di riferimento), non i tipi di valore. Per informazioni dettagliate, vedere il <xref:System.Threading.Monitor> articolo.  
  
 Per garantire che il thread non immette la sezione critica, è necessario esaminare il valore restituito del metodo ed eseguire codice nella sezione critica solo se il valore restituito è `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è negativo e diverso da <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta la durata di attesa del blocco. Un valore di –1 millisecondo specifica un'attesa infinita.</param>
        <summary>Viene eseguito, per una quantità di tempo specificata, il tentativo di acquisire un blocco esclusivo sull'oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore di `timeout` parametro convertito in millisecondi è uguale a -1, questo metodo equivale a <xref:System.Threading.Monitor.Enter%2A>. Se il valore di `timeout` è uguale a 0, questo metodo equivale a <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (ovvero, i tipi di riferimento), non i tipi di valore. Per informazioni dettagliate, vedere il <xref:System.Threading.Monitor> argomento relativo alla classe.  
  
 Per garantire che il thread non immette la sezione critica, è necessario esaminare il valore restituito del metodo ed eseguire codice nella sezione critica solo se il valore restituito è `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> in millisecondi è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="millisecondsTimeout">Tempo di attesa espresso in millisecondi prima che si verifichi il blocco.</param>
        <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
        <summary>Prova ad acquisire, per il numero di millisecondi specificato, un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `millisecondsTimeout` parametro è uguale a <xref:System.Threading.Timeout.Infinite>, questo metodo equivale a <xref:System.Threading.Monitor.Enter%28System.Object%29>. Se `millisecondsTimeout` è uguale a 0, questo metodo equivale a <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Se il blocco non è stato creato perché è stata generata un'eccezione, la variabile specificata per il `lockTaken` parametro `false` dopo che questo metodo termina. In questo modo il programma determinare, in tutti i casi, se è necessario rilasciare il blocco.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (ovvero, i tipi di riferimento), non i tipi di valore. Per ulteriori informazioni, vedere il <xref:System.Threading.Monitor> argomento relativo alla classe.  
  
 Per garantire che il thread non di accedere alla sezione critica, è necessario esaminare il valore di `lockTaken` ed eseguire il codice nella sezione critica solo se il valore è `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 Nel codice seguente viene illustrato il modello di base per l'utilizzo di <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> overload del metodo. Questo overload imposta sempre il valore della variabile che viene passato per il `ref` parametro (`ByRef` in Visual Basic) `lockTaken`, anche se il metodo genera un'eccezione, pertanto il valore della variabile è un modo affidabile per verificare se il blocco deve essere rilasciato.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è negativo e diverso da <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="timeout">Quantità di tempo che rappresenta la durata di attesa del blocco. Un valore di –1 millisecondo specifica un'attesa infinita.</param>
        <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
        <summary>Prova ad acquisire, per la quantità di tempo specificata, un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore di `timeout` parametro convertito in millisecondi è uguale a -1, questo metodo equivale a <xref:System.Threading.Monitor.Enter%28System.Object%29>. Se il valore di `timeout` è uguale a 0, questo metodo equivale a <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Se il blocco non è stato creato perché è stata generata un'eccezione, la variabile specificata per il `lockTaken` parametro `false` dopo che questo metodo termina. In questo modo il programma determinare, in tutti i casi, se è necessario rilasciare il blocco.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (ovvero, i tipi di riferimento), non i tipi di valore. Per ulteriori informazioni, vedere il <xref:System.Threading.Monitor> argomento relativo alla classe.  
  
 Per garantire che il thread non di accedere alla sezione critica, è necessario esaminare il valore di `lockTaken` ed eseguire il codice nella sezione critica solo se il valore è `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> in millisecondi è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco.</summary>
        <returns>
          Viene restituito <see langword="true" /> se la chiamata è stata restituita perché il chiamante ha riacquisito il blocco per l'oggetto specificato. Non viene restituito alcun valore se il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato durante l'attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Quando un thread chiama `Wait`, rilascia il blocco sull'oggetto e inserito nella coda in attesa dell'oggetto. Il thread successivo nella coda di pronto dell'oggetto (se presente) acquisisce il blocco e ha l'utilizzo esclusivo dell'oggetto. Tutti i thread che chiamano `Wait` rimangono nella coda di attesa finché ricevono un segnale da <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>, inviato dal proprietario del blocco. Se `Pulse` viene inviato solo il thread all'inizio della coda di attesa è interessato. Se `PulseAll` viene inviato, sono interessati tutti i thread in attesa per l'oggetto. Quando viene ricevuto il segnale, uno o più thread lascia la coda di attesa e inseriti nella coda pronta. Un thread nella coda degli elementi pronti può riacquisire il blocco.  
  
 Questo metodo restituisce quando il thread chiamante riacquisisce il blocco sull'oggetto. Si noti che questo metodo in modo indefinito se il proprietario del blocco non chiama `Pulse` o `PulseAll`.  
  
 Il chiamante esegue `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di chiamate `Enter` sull'oggetto e richiama `Exit` come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama `Enter` il numero di volte in base alle esigenze salvato `Enter` conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
 Si noti che un oggetto sincronizzato contiene diversi riferimenti, un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronti, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, tra cui contiene i thread in attesa per la notifica di modifica dello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato di codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo spiegare cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando è in attesa alcun thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi da attendere prima che il thread venga inserito nella coda di thread pronti.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non restituisce finché riacquisisce il blocco esclusivo sul `obj` parametro.  
  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato durante l'attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Il timeout assicura che il thread corrente non bloccarsi in modo indefinito se un altro thread rilascia il blocco senza chiamare prima il <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo. Inoltre, si sposta il thread nella coda pronti, ignorando gli altri thread prima la coda di attesa, in modo che è possibile riacquisire il blocco prima. Il thread può verificare il valore restituito di <xref:System.Threading.Monitor.Wait%2A> metodo per determinare se ha riacquisito il blocco prima del timeout. Il thread è possibile valutare le condizioni che hanno causato lo stato di attesa, se necessario, chiamare il <xref:System.Threading.Monitor.Wait%2A> nuovo metodo.  
  
 Quando un thread chiama `Wait`, rilascia il blocco sull'oggetto e inserito nella coda in attesa dell'oggetto. Il thread successivo nella coda di pronto dell'oggetto (se presente) acquisisce il blocco e ha l'utilizzo esclusivo dell'oggetto. Il thread che ha richiamato `Wait` richiama un thread che contiene il blocco rimane nella coda di attesa fino a quando non <xref:System.Threading.Monitor.PulseAll%2A>, o è il successivo nella coda e un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.Pulse%2A>. Tuttavia, se `millisecondsTimeout` deve trascorrere prima che un altro thread richiama l'oggetto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> (metodo), il thread originale viene spostato nella coda degli elementi pronti per riacquisire il blocco.  
  
> [!NOTE]
>  Se <xref:System.Threading.Timeout.Infinite> specificato per il `millisecondsTimeout` parametro, questo metodo in modo indefinito, a meno che il proprietario del blocco chiama <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Se `millisecondsTimeout` è uguale a 0, il thread che chiama `Wait` rilascia il blocco e viene inserito immediatamente nella coda degli elementi pronti per riacquisire il blocco.  
  
 Il chiamante esegue `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di chiamate <xref:System.Threading.Monitor.Enter%2A> sull'oggetto e richiama <xref:System.Threading.Monitor.Exit%2A> come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama <xref:System.Threading.Monitor.Enter%2A> il numero di volte in base alle esigenze salvato <xref:System.Threading.Monitor.Enter%2A> conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
> [!NOTE]
>  Un oggetto sincronizzato contiene diversi riferimenti, incluso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronti, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene il thread in attesa per la notifica di modifica dello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato di codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo spiegare cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando è in attesa alcun thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il tempo di attesa prima che il thread venga inserito nella coda di thread pronti.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non restituisce finché riacquisisce il blocco esclusivo sul `obj` parametro.  
  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato durante l'attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Il timeout assicura che il thread corrente non bloccarsi in modo indefinito se un altro thread rilascia il blocco senza chiamare prima il <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo. Inoltre, si sposta il thread nella coda pronti, ignorando gli altri thread prima la coda di attesa, in modo che è possibile riacquisire il blocco prima. Il thread può verificare il valore restituito di <xref:System.Threading.Monitor.Wait%2A> metodo per determinare se ha riacquisito il blocco prima del timeout. Il thread è possibile valutare le condizioni che hanno causato lo stato di attesa, se necessario, chiamare il <xref:System.Threading.Monitor.Wait%2A> nuovo metodo.  
  
 Quando un thread chiama `Wait`, rilascia il blocco sull'oggetto e inserito nella coda in attesa dell'oggetto. Il thread successivo nella coda di pronto dell'oggetto (se presente) acquisisce il blocco e ha l'utilizzo esclusivo dell'oggetto. Il thread che ha richiamato `Wait` richiama un thread che contiene il blocco rimane nella coda di attesa fino a quando non <xref:System.Threading.Monitor.PulseAll%2A>, o è il successivo nella coda e un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.Pulse%2A>. Tuttavia, se `timeout` deve trascorrere prima che un altro thread richiama l'oggetto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> (metodo), il thread originale viene spostato nella coda degli elementi pronti per riacquisire il blocco.  
  
> [!NOTE]
>  Se un <xref:System.TimeSpan> – 1 millisecondo specificato per il `timeout` parametro, questo metodo in modo indefinito, a meno che il proprietario del blocco chiama <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Se `timeout` è pari a 0 millisecondi, il thread che chiama `Wait` rilascia il blocco e viene inserito immediatamente nella coda degli elementi pronti per riacquisire il blocco.  
  
 Il chiamante esegue `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di chiamate <xref:System.Threading.Monitor.Enter%2A> sull'oggetto e richiama <xref:System.Threading.Monitor.Exit%2A> come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama <xref:System.Threading.Monitor.Enter%2A> il numero di volte in base alle esigenze salvato <xref:System.Threading.Monitor.Enter%2A> conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
> [!NOTE]
>  Un oggetto sincronizzato contiene diversi riferimenti, incluso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronti, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene il thread in attesa per la notifica di modifica dello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato di codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo spiegare cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando è in attesa alcun thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="timeout" /> in millisecondi è negativo e non rappresenta <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi da attendere prima che il thread venga inserito nella coda di thread pronti.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire e riacquisire il dominio di sincronizzazione per il contesto, se si trova in un contesto sincronizzato, prima dell'attesa; in caso contrario, <see langword="false" />.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti. Questo metodo consente anche di specificare se il dominio di sincronizzazione per il contesto, qualora si trovi in un contesto di sincronizzazione, viene terminato prima dell'attesa e riacquisito in un secondo momento.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non restituisce finché riacquisisce il blocco esclusivo sul `obj` parametro.  
  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato durante l'attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Il timeout assicura che il thread corrente non bloccarsi in modo indefinito se un altro thread rilascia il blocco senza chiamare prima il <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo. Inoltre, si sposta il thread nella coda pronti, ignorando gli altri thread prima la coda di attesa, in modo che è possibile riacquisire il blocco prima. Il thread può verificare il valore restituito di <xref:System.Threading.Monitor.Wait%2A> metodo per determinare se ha riacquisito il blocco prima del timeout. Il thread è possibile valutare le condizioni che hanno causato lo stato di attesa, se necessario, chiamare il <xref:System.Threading.Monitor.Wait%2A> nuovo metodo.  
  
 Quando un thread chiama `Wait`, rilascia il blocco e viene inserito nella coda di attesa. A questo punto, il thread successivo nella coda degli elementi pronti (se presente) è consentito di assumere il controllo del blocco. Il thread che ha richiamato `Wait` richiama un thread che contiene il blocco rimane nella coda di attesa fino a quando non <xref:System.Threading.Monitor.PulseAll%2A>, o è il successivo nella coda e un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.Pulse%2A>. Tuttavia, se `millisecondsTimeout` deve trascorrere prima che un altro thread richiama l'oggetto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> (metodo), il thread originale viene spostato nella coda degli elementi pronti per riacquisire il blocco.  
  
> [!NOTE]
>  Se <xref:System.Threading.Timeout.Infinite> specificato per il `millisecondsTimeout` parametro, questo metodo in modo indefinito, a meno che il proprietario del blocco chiama <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Se `millisecondsTimeout` è uguale a 0, il thread che chiama `Wait` rilascia il blocco e viene inserito immediatamente nella coda degli elementi pronti per riacquisire il blocco.  
  
 Il chiamante esegue `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di chiamate <xref:System.Threading.Monitor.Enter%2A> sull'oggetto e richiama <xref:System.Threading.Monitor.Exit%2A> come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama <xref:System.Threading.Monitor.Enter%2A> il numero di volte in base alle esigenze salvato <xref:System.Threading.Monitor.Enter%2A> conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
> [!NOTE]
>  Un oggetto sincronizzato contiene diversi riferimenti, incluso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronti, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene il thread in attesa per la notifica di modifica dello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato di codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo spiegare cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando è in attesa alcun thread.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il`exitContext` parametro ha effetto solo se il <xref:System.Threading.Monitor.Wait%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se attualmente un metodo in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.Monitor.Wait%2A> metodo. Restituisce il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.Monitor.Wait%2A> metodo viene completato.  
  
 Può essere utile quando la classe associata al contesto non dispone di <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attributo applicato. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.Monitor.Wait%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.Monitor.Wait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> non viene richiamato dall'interno di un blocco di codice sincronizzato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il tempo di attesa prima che il thread venga inserito nella coda di thread pronti.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire e riacquisire il dominio di sincronizzazione per il contesto, se si trova in un contesto sincronizzato, prima dell'attesa; in caso contrario, <see langword="false" />.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti. Esce eventualmente dal dominio di sincronizzazione per il contesto di sincronizzazione prima dell'attesa e riacquisisce il dominio in un secondo momento.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non restituisce finché riacquisisce il blocco esclusivo sul `obj` parametro.  
  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato durante l'attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Il timeout assicura che il thread corrente non bloccarsi in modo indefinito se un altro thread rilascia il blocco senza chiamare prima il <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo. Inoltre, si sposta il thread nella coda pronti, ignorando gli altri thread prima la coda di attesa, in modo che è possibile riacquisire il blocco prima. Il thread può verificare il valore restituito di <xref:System.Threading.Monitor.Wait%2A> metodo per determinare se ha riacquisito il blocco prima del timeout. Il thread è possibile valutare le condizioni che hanno causato lo stato di attesa, se necessario, chiamare il <xref:System.Threading.Monitor.Wait%2A> nuovo metodo.  
  
 Quando un thread chiama `Wait`, rilascia il blocco e viene inserito nella coda di attesa. A questo punto, il thread successivo nella coda degli elementi pronti (se presente) è consentito di assumere il controllo del blocco. Il thread che ha richiamato `Wait` richiama un thread che contiene il blocco rimane nella coda di attesa fino a quando non <xref:System.Threading.Monitor.PulseAll%2A>, o è il successivo nella coda e un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.Pulse%2A>. Tuttavia, se `timeout` trascorre prima che un altro thread richiama l'oggetto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> (metodo), il thread originale viene spostato nella coda degli elementi pronti per riacquisire il blocco.  
  
> [!NOTE]
>  Se un <xref:System.TimeSpan> specificato che rappresenta-1 millisecondi per il `timeout` parametro, questo metodo in modo indefinito, a meno che il proprietario del blocco chiama <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Se `timeout` è pari a 0 millisecondi, il thread che chiama `Wait` rilascia il blocco e viene inserito immediatamente nella coda degli elementi pronti per riacquisire il blocco.  
  
 Il chiamante esegue `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di chiamate <xref:System.Threading.Monitor.Enter%2A> sull'oggetto e richiama <xref:System.Threading.Monitor.Exit%2A> come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama <xref:System.Threading.Monitor.Enter%2A> il numero di volte in base alle esigenze salvato <xref:System.Threading.Monitor.Enter%2A> conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
> [!NOTE]
>  Un oggetto sincronizzato contiene diversi riferimenti, incluso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronti, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene il thread in attesa per la notifica di modifica dello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato di codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo spiegare cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando è in attesa alcun thread.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il`exitContext` parametro ha effetto solo se il <xref:System.Threading.Monitor.Wait%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se attualmente un metodo in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.Monitor.Wait%2A> metodo. Restituisce il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.Monitor.Wait%2A> metodo viene completato.  
  
 Può essere utile quando la classe associata al contesto non dispone di <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attributo applicato. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.Monitor.Wait%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.Monitor.Wait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> non viene richiamato dall'interno di un blocco di codice sincronizzato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato Wait viene interrotto più tardi dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="timeout" /> è negativo e non rappresenta <see cref="F:System.Threading.Timeout.Infinite" /> (– 1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
  </Members>
</Type>