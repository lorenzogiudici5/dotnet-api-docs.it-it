<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="04c73d8d6d8c0205db70235fd1bb85ce866c6212" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36606689" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce un meccanismo che sincronizza l'accesso agli oggetti.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Monitor> classe consente di sincronizzare l'accesso a un'area di codice accettando e rilasciando un blocco su un determinato oggetto chiamando il <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, e <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metodi. I blocchi di oggetti consentono di limitare l'accesso a un blocco di codice, più comunemente, una sezione critica. Mentre un thread proprietario del blocco per un oggetto, nessun altro thread può acquisire il blocco. È anche possibile usare il <xref:System.Threading.Monitor> codice della classe per garantire che nessun altro thread possa accedere a una sezione dell'applicazione viene eseguita dal proprietario del blocco, a meno che l'altro thread è in esecuzione il codice che usa un diverso oggetto bloccato.  
  
 Contenuto dell'articolo:  
  
 [La classe di monitoraggio: Panoramica](#Overview)   
 [Oggetto di blocco](#Lock)   
 [La sezione critica](#CriticalSection)   
 [Pulse PulseAll e attesa](#Pulse)   
 [Monitoraggi e gli handle di attesa](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>La classe di monitoraggio: Panoramica  
 <xref:System.Threading.Monitor> presenta le seguenti funzionalità:  
  
-   È associata a un oggetto su richiesta.  
  
-   È non associato, vale a dire che può essere chiamato direttamente da qualsiasi contesto.  
  
-   Un'istanza del <xref:System.Threading.Monitor> classe non può essere creata; i metodi del <xref:System.Threading.Monitor> classe sono tutti statici. Ogni metodo viene passato l'oggetto sincronizzato che controlla l'accesso alla sezione critica.  
  
> [!NOTE]
>  Utilizzare il <xref:System.Threading.Monitor> classe per bloccare gli oggetti diversi da stringhe (vale a dire, tipi di riferimento diverso da <xref:System.String>), non i tipi di valore. Per informazioni dettagliate, vedere gli overload del <xref:System.Threading.Monitor.Enter%2A> (metodo) e [oggetto di blocco](#Lock) sezione più avanti in questo articolo.  
  
 Nella tabella seguente vengono descritte le azioni che possono essere eseguite da thread che accedono a oggetti sincronizzati:  
  
|Operazione|Descrizione|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Acquisisce un blocco per un oggetto. Inoltre, questa azione contrassegna l'inizio di una sezione critica. Nessun altro thread può accedere alla sezione critica, a meno che non è in esecuzione le istruzioni nella sezione critica utilizzando un diverso oggetto bloccato.|  
|<xref:System.Threading.Monitor.Wait%2A>|Rilascia il blocco su un oggetto per consentire ad altri thread per bloccare e accedere all'oggetto. Il thread chiamante attenda mentre un altro thread accede all'oggetto. Segnali Pulse vengono utilizzati per notificare i thread in attesa sulle modifiche allo stato dell'oggetto.|  
|<xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A>|Invia un segnale a uno o più thread in attesa. Il segnale di notifica a un thread in attesa che lo stato dell'oggetto bloccato è cambiato e il proprietario del blocco è pronto per rilasciare il blocco. Il thread in attesa viene inserito nella coda di pronto dell'oggetto in modo che possa infine ricevere il blocco per l'oggetto. Una volta che il thread ha il blocco, è possibile verificare il nuovo stato dell'oggetto per vedere se è stato raggiunto lo stato obbligatorio.|  
|<xref:System.Threading.Monitor.Exit%2A>|Rilascia il blocco su un oggetto. Inoltre, questa azione contrassegna la fine di una sezione critica protetta da oggetto bloccato.|  
  
 Iniziano con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], sono disponibili due set di overload per il <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.TryEnter%2A> metodi. Un set di overload è un `ref` (in c#) o `ByRef` (in Visual Basic) <xref:System.Boolean> parametro che viene impostato in modo atomico `true` se viene acquisito il blocco, anche se viene generata un'eccezione quando l'acquisizione del blocco. Usare questi overload se è fondamentale per rilasciare il blocco in tutti i casi, anche quando le risorse che di blocco per la protezione potrebbero non essere in uno stato coerente.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Oggetto di blocco  
 La classe di monitoraggio è costituita `static` (in c#) o `Shared` (in Visual Basic) i metodi che operano su un oggetto che controlla l'accesso alla sezione critica.  Per ogni oggetto sincronizzato vengono mantenute le informazioni seguenti:  
  
-   Un riferimento al thread che attualmente contiene il blocco.  
  
-   Un riferimento a una coda pronto, che contiene i thread pronti ottenere il blocco.  
  
-   Un riferimento a una coda in attesa, che contiene i thread in attesa per la notifica di una modifica nello stato dell'oggetto bloccato.  
  
 <xref:System.Threading.Monitor> blocca gli oggetti, ovvero i tipi di riferimento, non i tipi di valore. Anche se è possibile passare un tipo di valore a <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A>, ogni valore viene sottoposto a boxing separatamente per ogni chiamata. Poiché ogni chiamata crea un oggetto separato, <xref:System.Threading.Monitor.Enter%2A> non si blocca mai e non sincronizza realmente il codice che dovrebbe proteggere. L'oggetto passato a <xref:System.Threading.Monitor.Exit%2A>, inoltre, è diverso dall'oggetto passato a <xref:System.Threading.Monitor.Enter%2A>, quindi <xref:System.Threading.Monitor> genera un'eccezione <xref:System.Threading.SynchronizationLockException> con il messaggio "Il metodo di sincronizzazione dell'oggetto è stato chiamato da un blocco di codice non sincronizzato".  
  
 L'esempio seguente illustra questo problema. Avvia dieci attività, ognuna delle quali rimane semplicemente inattiva per 250 millisecondi. Ogni attività aggiorna quindi una variabile del contatore, `nTasks`, in modo da contare il numero di attività effettivamente avviate ed eseguite. Poiché `nTasks` è una variabile globale che può essere aggiornata da più attività contemporaneamente, viene usato un oggetto monitor per proteggerla dalla modifica simultanea da parte di più attività. Tuttavia, come illustrato dall'output dell'esempio, ogni attività genera un'eccezione <xref:System.Threading.SynchronizationLockException>.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 Ogni attività genera un'eccezione <xref:System.Threading.SynchronizationLockException>, poiché la variabile `nTasks` viene sottoposta a boxing prima della chiamata al metodo <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> in ogni attività. In altri termini, una variabile separata, indipendente dalle altre, viene passata a ogni chiamata al metodo. `nTasks` viene sottoposto di nuovo a boxing nella chiamata al metodo <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. Ancora una volta, ciò crea dieci nuove variabili di tipo boxed, indipendenti le une dalle altre, `nTasks` e le dieci variabili di tipo boxed create nella chiamata al metodo <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>. L'eccezione viene generata, quindi, poiché il codice sta tentando di rilasciare un blocco su una variabile appena creata non bloccata in precedenza.  
  
 Anche se è possibile sottoporre a boxing una variabile di tipo valore prima di chiamare <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A>, come illustrato nell'esempio seguente, e passare lo stesso oggetto di tipo boxed a entrambi i metodi, ciò non presenta alcun vantaggio. Le modifiche alla variabile di tipo unboxed non sono riflesse nella copia di tipo boxed e non è possibile modificare il valore della copia di tipo boxed.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 Quando si seleziona un oggetto su cui eseguire la sincronizzazione, è necessario bloccare solo sugli oggetti interni o privati. Il blocco degli oggetti esterni potrebbe comportare i deadlock, in quanto il codice correlato può scegliere gli stessi oggetti di blocco per scopi diversi.  
  
 Si noti che è possibile sincronizzare su un oggetto in più domini applicazione se l'oggetto utilizzato per il blocco deriva da <xref:System.MarshalByRefObject>.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>La sezione critica  
 Usare la <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> metodi per contrassegnare l'inizio e alla fine di una sezione critica.  
  
> [!NOTE]
>  La funzionalità fornita dal <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> metodi è identico a quello fornito dal [blocco](~/docs/csharp/language-reference/keywords/lock-statement.md) istruzione nel linguaggio c# e il [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) istruzione in Visual Basic, con la differenza che il incapsulamento di costrutti di linguaggio il <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> overload del metodo e la <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metodo in un `try`...`finally` blocco da verificare che il monitoraggio venga rilasciato.  
  
 Se la sezione critica è un set di istruzioni contigue, quindi il blocco acquisito dal <xref:System.Threading.Monitor.Enter%2A> metodo garantisce che solo un singolo thread possa eseguire il codice incluso nell'oggetto bloccato. In questo caso, si consiglia di posizionare il codice in un `try` bloccarsi e inserire la chiamata ai <xref:System.Threading.Monitor.Exit%2A> metodo in un `finally` blocco. Ciò assicura che il blocco venga rilasciato anche se si verifica un'eccezione. Frammento di codice seguente illustra questo modello.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 Questa funzionalità viene in genere usata per sincronizzare l'accesso a un valore statico o il metodo di istanza di una classe.  
  
 Se una sezione critica si estende un intero metodo, è possano utilizzare le funzionalità di blocco inserendo il <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> al metodo e specificando la <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> valore nel costruttore della <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>. Quando si usa questo attributo, il <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> chiamate al metodo non sono necessari. Il frammento di codice seguente illustra questo modello:  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 Si noti che l'attributo fa sì che il thread corrente contenere il blocco fino a quando il metodo restituisce; Se il blocco può essere rilasciato prima, usare il <xref:System.Threading.Monitor> classe c# [blocco](~/docs/csharp/language-reference/keywords/lock-statement.md) istruzione o Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) istruzione all'interno del metodo anziché l'attributo.  
  
 Sebbene sia possibile per il <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> le istruzioni che bloccare e rilasciare un oggetto specifico da intersecare membro o i limiti di classe, questa procedura non consigliata.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse PulseAll e attesa  
 Una volta che un thread proprietario del blocco e ha attivato la sezione critica che protegge il blocco, è possibile chiamare il <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, e <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> metodi.  
  
 <xref:System.Threading.Monitor.Wait%2A> rilascia il blocco se viene mantenuto, consente a un thread in attesa o thread per ottenere il blocco e la parte critica e attende la notifica da una chiamata ai <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> o <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> metodo. Quando <xref:System.Threading.Monitor.Wait%2A> riceve la notifica, restituisce e ottiene di nuovo il blocco.  
  
 Sia <xref:System.Threading.Monitor.Pulse%2A> che <xref:System.Threading.Monitor.PulseAll%2A> segnalano al thread successivo della coda di attesa di continuare.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>Monitoraggi e gli handle di attesa  
 È importante notare la distinzione tra l'uso del <xref:System.Threading.Monitor> classe e <xref:System.Threading.WaitHandle> oggetti.  
  
-   Il <xref:System.Threading.Monitor> classe è semplicemente gestiti e completamente portabili e potrebbero essere più efficiente in termini di requisiti di risorse del sistema operativo.  
  
-   Gli oggetti <xref:System.Threading.WaitHandle> rappresentano oggetti awaitable del sistema operativo, sono utili per la sincronizzazione tra codice gestito e non gestito ed espongono alcune funzionalità avanzate del sistema operativo, ad esempio la capacità di rimanere in attesa di più oggetti contemporaneamente.  
  
   
  
## Examples  
 Nell'esempio seguente viene utilizzata la <xref:System.Threading.Monitor> classe per sincronizzare l'accesso a una singola istanza di un generatore di numeri casuali rappresentato dal <xref:System.Random> classe. L'esempio crea dieci attività, ognuno dei quali esegue in modo asincrono in un pool di thread. Ogni attività genera numeri casuali 10.000, calcola la media e aggiorna due variabili a livello di stored procedure che gestiscono un totale parziale del numero di numeri casuali generati e la somma. Dopo avranno eseguito tutte le attività, questi due valori vengono quindi utilizzati per calcolare la media globale.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 Poiché è possibile accedervi da qualsiasi attività in esecuzione in un pool di thread, accedere alle variabili `total` e `n` devono anche essere sincronizzati. Il <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> metodo viene utilizzato per questo scopo.  
  
 Nell'esempio seguente illustra l'uso combinato del <xref:System.Threading.Monitor> classe (implementata con il `lock` o `SyncLock` costrutto di linguaggio), il <xref:System.Threading.Interlocked> (classe) e il <xref:System.Threading.AutoResetEvent> (classe). Definisce due `internal` (in c#) o `Friend` (in Visual Basic), classi `SyncResource` e `UnSyncResource`, che forniscono rispettivamente l'accesso sincronizzato e a una risorsa. Per assicurarsi che nell'esempio viene illustrata la differenza tra l'accesso sincronizzato e non sincronizzato (che può essere il caso se ogni chiamata al metodo viene completata rapidamente), il metodo include un ritardo casuale: per i thread la cui <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> proprietà è pari, il le chiamate al metodo <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> per introdurre un ritardo di 2000 millisecondi. Si noti che, in quanto il `SyncResource` classe non è pubblica, nessuna parte del codice client acquisisce un blocco sulla risorsa sincronizzata: è la classe interna ad acquisire il blocco. Ciò impedisce l'acquisizione di un blocco su un oggetto pubblico da parte di codice dannoso.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 Nell'esempio viene definita una variabile, `numOps`, che definisce il numero di thread che proverà ad accedere alla risorsa. Il thread dell'applicazione chiama il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> metodo per sincronizzato e non sincronizzato l'accesso cinque volte ciascun. Il <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> metodo presenta un singolo parametro, un delegato che non accetta parametri e non restituisce alcun valore. Per l'accesso sincronizzato, richiama il `SyncUpdateResource` metodo; per l'accesso non sincronizzato, richiama il `UnSyncUpdateResource` metodo. Dopo ogni set di chiamate al metodo, il thread dell'applicazione chiama il [AutoResetEvent. WaitOne](xref:System.Threading.WaitHandle.WaitOne*) metodo in modo che si blocchi finché la <xref:System.Threading.AutoResetEvent> istanza viene segnalata.  
  
 Ogni chiamata ai `SyncUpdateResource` metodo chiama l'interno `SyncResource.Access` (metodo) e quindi chiama il <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodo per decrementare il `numOps` contatore. Il <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodo viene utilizzato per decrementare il contatore, perché in caso contrario, è possibile essere certi che un secondo thread acceda al valore prima un primo thread decrementato valore sia stato archiviato nella variabile. Quando l'ultimo worker thread sincronizzato decrementa il contatore a zero, indicando che tutti i thread sincronizzati hanno completato l'accesso alla risorsa, il `SyncUpdateResource` chiamate al metodo il <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> (metodo), che segnala al thread principale di continuare esecuzione.  
  
 Ogni chiamata ai `UnSyncUpdateResource` metodo chiama l'interno `UnSyncResource.Access` (metodo) e quindi chiama il <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodo per decrementare il `numOps` contatore. Ancora una volta, il <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> metodo viene utilizzato per decrementare il contatore per garantire che un secondo thread acceda al valore prima valore decrementato di un primo thread sia stato assegnato alla variabile. Quando l'ultimo non sincronizzato decrementa di thread di lavoro il contatore a zero, che indica che non consentono più thread non sincronizzati necessario accedere alla risorsa, il `UnSyncUpdateResource` chiamate al metodo il <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> (metodo), che segnala al thread principale di continuare l'esecuzione .  
  
 Come mostra il risultato dell'esempio, l'accesso sincronizzato garantisce che il thread di chiamata esca dalla risorsa protetta prima che un altro thread possa accedervi; ogni thread attende il suo predecessore. D'altra parte, senza il blocco, il `UnSyncResource.Access` metodo viene chiamato nell'ordine in cui i thread lo raggiungono.  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acquisisce un blocco esclusivo su un oggetto specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sui cui acquisire il blocco del monitoraggio.</param>
        <summary>Acquisisce un blocco esclusivo sull'oggetto specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uso `Enter` per acquisire il <xref:System.Threading.Monitor> per l'oggetto passato come parametro. Se un altro thread ha eseguito un' `Enter` sull'oggetto, ma non è ancora eseguita corrispondente <xref:System.Threading.Monitor.Exit%2A>, bloccherà il thread corrente finché l'altro thread rilascia l'oggetto. È consentito per il thread stesso richiamare `Enter` più volte senza causarne; tuttavia, un numero uguale di `Exit` chiamate devono essere richiamate prima che venga sblocca altri thread in attesa per l'oggetto.  
  
 Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (vale a dire, i tipi di riferimento), non i tipi di valore. Quando si passa una variabile di tipo valore per `Enter`, viene sottoposto a boxing come oggetto. Se si passa la stessa variabile a `Enter` anche in questo caso viene sottoposto a boxing come oggetto separato e non blocca il thread. In questo caso, il codice che `Monitor` è in realtà non è protetta. Inoltre, quando si passa la variabile `Exit`, viene creato anche un altro oggetto distinto. Poiché l'oggetto passato a `Exit` è diverso dall'oggetto passato a `Enter`, `Monitor` genera <xref:System.Threading.SynchronizationLockException>. Per altre informazioni, vedere l'argomento concettuale [monitoraggi](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> può interrompere thread in attesa di immettere un `Monitor` su un oggetto. Oggetto <xref:System.Threading.ThreadInterruptedException> verrà generata.  
  
 Utilizzare il linguaggio c# `try`...`finally` blocco (`Try`...`Finally` in Visual Basic) per assicurarsi di rilascio del monitor oppure utilizzare il linguaggio c# `lock` istruzione (`SyncLock` istruzione in Visual Basic), che esegue il wrapping di <xref:System.Threading.Monitor.Enter%2A> e <xref:System.Threading.Monitor.Exit%2A> metodi in un `try`...`finally` blocco.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del metodo `Enter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.  Nota   Se non si verifica alcuna eccezione, l'output di questo metodo è sempre <see langword="true" />.</param>
        <summary>Acquisisce un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uso `Enter` per acquisire il <xref:System.Threading.Monitor> sull'oggetto passato come il `obj` parametro. Se un altro thread ha eseguito un' `Enter` sull'oggetto, ma non è ancora eseguita corrispondente <xref:System.Threading.Monitor.Exit%2A>, bloccherà il thread corrente finché l'altro thread rilascia l'oggetto. È consentito per il thread stesso richiamare `Enter` più volte senza causarne; tuttavia, un numero uguale di `Exit` chiamate devono essere richiamate prima che venga sblocca altri thread in attesa per l'oggetto.  
  
 Se il blocco non è stato creato perché è stata generata un'eccezione, la variabile specificata per il `lockTaken` parametro `false` dopo che questo metodo termina. Ciò consente al programma di stabilire, in tutti i casi, se è necessario rilasciare il blocco. Se questo metodo viene restituito senza generare un'eccezione, la variabile specificata per il `lockTaken` parametro è sempre `true`, e non è necessario eseguirne il test.  
  
 Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (vale a dire, i tipi di riferimento), non i tipi di valore. Quando si passa una variabile di tipo valore per `Enter`, viene sottoposto a boxing come oggetto. Se si passa la stessa variabile a `Enter` anche in questo caso viene sottoposto a boxing come oggetto separato e non blocca il thread. In questo caso, il codice che `Monitor` è in realtà non è protetta. Inoltre, quando si passa la variabile `Exit`, viene creato un altro oggetto distinto. Poiché l'oggetto passato a `Exit` è diverso dall'oggetto passato a `Enter`, `Monitor` genera <xref:System.Threading.SynchronizationLockException>. Per altre informazioni, vedere l'argomento concettuale [monitoraggi](xref:System.Threading.Monitor).  
  
 <xref:System.Threading.Thread.Interrupt%2A> può interrompere thread in attesa di immettere un `Monitor` su un oggetto. Oggetto <xref:System.Threading.ThreadInterruptedException> verrà generata.  
  
   
  
## Examples  
 Nel codice seguente viene illustrato il modello di base per l'utilizzo di <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> overload del metodo. Questo overload imposta sempre il valore della variabile che viene passato per il `ref` parametro (`ByRef` in Visual Basic) `lockTaken`, anche se il metodo genera un'eccezione, pertanto il valore della variabile è un modo affidabile per verificare se il blocco deve essere rilasciato.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale rilasciare il blocco.</param>
        <summary>Viene rilasciato un blocco esclusivo sull'oggetto specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il thread chiamante deve essere proprietaria del blocco nel `obj` parametro. Se il thread chiamante possiede il blocco sull'oggetto specificato e ha eseguito un numero uguale di `Exit` e <xref:System.Threading.Monitor.Enter%2A> chiama il metodo per l'oggetto, il blocco viene rilasciato. Se il thread chiamante non ha richiamato `Exit` tante volte quanti `Enter`, il blocco non viene rilasciato.  
  
 Se il blocco viene rilasciato e altri thread si trovano nella coda degli elementi pronto per l'oggetto, uno dei thread acquisisce il blocco. Se altri thread è in coda in attesa di acquisire il blocco, non vengono automaticamente spostati nella coda pronti quando il proprietario del blocco chiama `Exit`. Per spostare uno o più thread in attesa nella coda degli elementi pronto, chiamare <xref:System.Threading.Monitor.Pulse%2A> oppure <xref:System.Threading.Monitor.PulseAll%2A> prima di richiamare `Exit`.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del metodo `Exit`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il blocco per l'oggetto specificato non è di proprietà del thread corrente.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto da testare.</param>
        <summary>Determina se il thread corrente specificato contiene il blocco sull'oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se il thread corrente è responsabile del blocco su <paramref name="obj" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo funziona solo per i blocchi acquisiti utilizzando i metodi del <xref:System.Threading.Monitor> classe oppure usando il linguaggio c# `lock` istruzione o Visual Basic `SyncLock` istruzione in cui vengono implementate con <xref:System.Threading.Monitor>.  
  
 Utilizzare questo metodo con strumenti di diagnostica, ad esempio il <xref:System.Diagnostics.Debug.Assert%2A> metodo e il <xref:System.Diagnostics.Contracts.Contract> (classe), eseguire il debug di problemi di blocco che coinvolgono la <xref:System.Threading.Monitor> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto atteso da un thread.</param>
        <summary>Notifica a un thread della coda di attesa che lo stato dell'oggetto bloccato è stato modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo il proprietario corrente del blocco può segnalare un oggetto di attesa utilizzando `Pulse`.  
  
 Questo metodo per segnalare al thread successivo della riga per il blocco viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato. Dopo aver ricevuto l'andamento, il thread in attesa viene spostato nella coda pronta. Quando il thread che ha richiamato `Pulse` rilascia il blocco, il thread successivo nella coda degli elementi pronto (che non è necessariamente il thread che ha ricevuto l'impulso) acquisisce il blocco.  
  
> [!IMPORTANT]
>  Il <xref:System.Threading.Monitor> classe non mantengono lo stato che indica che il <xref:System.Threading.Monitor.Pulse%2A> metodo è stato chiamato. Pertanto, se si chiama <xref:System.Threading.Monitor.Pulse%2A> quando non sono thread in attesa, il successivo thread che chiama <xref:System.Threading.Monitor.Wait%2A> blocchi come se <xref:System.Threading.Monitor.Pulse%2A> non fosse mai stato chiamato. Se utilizza due thread <xref:System.Threading.Monitor.Pulse%2A> e <xref:System.Threading.Monitor.Wait%2A> per interagire, ciò potrebbe causare un deadlock. Ciò si differenzia il comportamento del <xref:System.Threading.AutoResetEvent> classe: se indicano un' <xref:System.Threading.AutoResetEvent> chiamando relativo <xref:System.Threading.EventWaitHandle.Set%2A> metodo e non sono presenti thread in attesa, il <xref:System.Threading.AutoResetEvent> rimane in stato segnalato fino a quando un thread chiama <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, o <xref:System.Threading.WaitHandle.WaitAll%2A>. Il <xref:System.Threading.AutoResetEvent> rilascia il thread e torna allo stato segnalato.  
  
 Si noti che un oggetto sincronizzato contiene più riferimenti, compreso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronto, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene i thread in attesa per la notifica di una modifica nello stato dell'oggetto.  
  
 Il `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, e <xref:System.Threading.Monitor.Wait%2A> metodi devono essere richiamati dall'interno di un blocco sincronizzato del codice.  
  
 Per segnalare più thread, utilizzare il <xref:System.Threading.Monitor.PulseAll%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto che invia l'impulso.</param>
        <summary>Notifica a tutti i thread in attesa che lo stato dell'oggetto è stato modificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo per segnalare tutti i thread in attesa di acquisire il blocco sull'oggetto viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato. Una volta inviato il segnale, vengono spostati i thread in attesa nella coda pronti. Quando il thread che ha richiamato `PulseAll` rilascia il blocco, il thread successivo nella coda degli elementi pronto acquisisce il blocco.  
  
 Si noti che un oggetto sincronizzato contiene più riferimenti, compreso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronto, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene i thread in attesa per la notifica di una modifica nello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, e <xref:System.Threading.Monitor.Wait%2A> metodi devono essere richiamati dall'interno di un blocco sincronizzato del codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo viene descritto cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando nessun thread è in attesa.  
  
 Per segnalare un thread singolo, utilizzare il `Pulse` metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prova ad acquisire un blocco esclusivo sull'oggetto specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <summary>Prova ad acquisire un blocco esclusivo sull'oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se ha esito positivo, questo metodo acquisisce un blocco esclusivo sul `obj` parametro. Questo metodo restituisce immediatamente, il blocco è disponibile o meno.  
  
 Questo metodo è simile a <xref:System.Threading.Monitor.Enter%2A>, ma non viene mai interrotto il thread corrente. Se il thread non è possibile immettere senza blocco, il metodo restituisce `false,`.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (vale a dire, i tipi di riferimento), non i tipi di valore. Per informazioni dettagliate, vedere il <xref:System.Threading.Monitor> articolo.  
  
 Per garantire che il thread non immette la sezione critica, è consigliabile esaminare il valore restituito del metodo ed eseguire codice nella sezione critica solo se il valore restituito sarà `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come utilizzare il metodo `TryEnter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
        <summary>Prova ad acquisire un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se ha esito positivo, questo metodo acquisisce un blocco esclusivo sul `obj` parametro. Questo metodo restituisce immediatamente, il blocco è disponibile o meno.  
  
 Se il blocco non è stato creato perché è stata generata un'eccezione, la variabile specificata per il `lockTaken` parametro `false` dopo che questo metodo termina. Ciò consente al programma di stabilire, in tutti i casi, se è necessario rilasciare il blocco.  
  
 Questo metodo è simile a <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, ma non viene mai interrotto il thread corrente. Se il thread non è possibile immettere senza blocco, il `lockTaken` argomento è impostato su `false` quando restituito dal metodo.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (vale a dire, i tipi di riferimento), non i tipi di valore. Per ulteriori informazioni, vedere l'articolo <xref:System.Threading.Monitor>.  
  
 Per garantire che il thread non di accedere alla sezione critica, è consigliabile esaminare il valore di `lockTaken` ed eseguendo il codice nella sezione critica solo se il relativo valore è `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 Nel codice seguente viene illustrato il modello di base per l'utilizzo di <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> overload del metodo. Questo overload imposta sempre il valore della variabile che viene passato per il `ref` parametro (`ByRef` in Visual Basic) `lockTaken`, anche se il metodo genera un'eccezione, pertanto il valore della variabile è un modo affidabile per verificare se il blocco deve essere rilasciato.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="millisecondsTimeout">Tempo di attesa espresso in millisecondi prima che si verifichi il blocco.</param>
        <summary>Viene eseguito, per un numero specificato di millisecondi, il tentativo di acquisire un blocco esclusivo sull'oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `millisecondsTimeout` parametro uguale <xref:System.Threading.Timeout.Infinite>, questo metodo equivale a <xref:System.Threading.Monitor.Enter%2A>. Se `millisecondsTimeout` è uguale a 0, questo metodo equivale a <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (vale a dire, i tipi di riferimento), non i tipi di valore. Per informazioni dettagliate, vedere il <xref:System.Threading.Monitor> articolo.  
  
 Per garantire che il thread non immette la sezione critica, è consigliabile esaminare il valore restituito del metodo ed eseguire codice nella sezione critica solo se il valore restituito sarà `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è negativo e diverso da <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta la durata di attesa del blocco. Un valore di –1 millisecondo specifica un'attesa infinita.</param>
        <summary>Viene eseguito, per una quantità di tempo specificata, il tentativo di acquisire un blocco esclusivo sull'oggetto specificato.</summary>
        <returns>
          <see langword="true" /> se il thread corrente acquisisce il blocco; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore di `timeout` parametro convertito in millisecondi è uguale a -1, questo metodo equivale a <xref:System.Threading.Monitor.Enter%2A>. Se il valore di `timeout` è uguale a 0, questo metodo equivale a <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (vale a dire, i tipi di riferimento), non i tipi di valore. Per informazioni dettagliate, vedere il <xref:System.Threading.Monitor> argomento relativo alla classe.  
  
 Per garantire che il thread non immette la sezione critica, è consigliabile esaminare il valore restituito del metodo ed eseguire codice nella sezione critica solo se il valore restituito sarà `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> in millisecondi è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="millisecondsTimeout">Tempo di attesa espresso in millisecondi prima che si verifichi il blocco.</param>
        <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
        <summary>Prova ad acquisire, per il numero di millisecondi specificato, un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il `millisecondsTimeout` parametro uguale <xref:System.Threading.Timeout.Infinite>, questo metodo equivale a <xref:System.Threading.Monitor.Enter%28System.Object%29>. Se `millisecondsTimeout` è uguale a 0, questo metodo equivale a <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Se il blocco non è stato creato perché è stata generata un'eccezione, la variabile specificata per il `lockTaken` parametro `false` dopo che questo metodo termina. Ciò consente al programma di stabilire, in tutti i casi, se è necessario rilasciare il blocco.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (vale a dire, i tipi di riferimento), non i tipi di valore. Per altre informazioni, vedere il <xref:System.Threading.Monitor> argomento relativo alla classe.  
  
 Per garantire che il thread non di accedere alla sezione critica, è consigliabile esaminare il valore di `lockTaken` ed eseguendo il codice nella sezione critica solo se il relativo valore è `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 Nel codice seguente viene illustrato il modello di base per l'utilizzo di <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> overload del metodo. Questo overload imposta sempre il valore della variabile che viene passato per il `ref` parametro (`ByRef` in Visual Basic) `lockTaken`, anche se il metodo genera un'eccezione, pertanto il valore della variabile è un modo affidabile per verificare se il blocco deve essere rilasciato.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è negativo e diverso da <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto sul quale acquisire il blocco.</param>
        <param name="timeout">Quantità di tempo che rappresenta la durata di attesa del blocco. Un valore di –1 millisecondo specifica un'attesa infinita.</param>
        <param name="lockTaken">Risultato del tentativo di acquisizione del blocco passato dal riferimento. L'input deve essere <see langword="false" />. L'output è <see langword="true" /> se il blocco viene acquisito; in caso contrario, l'output è <see langword="false" />. L'output viene impostato anche se si verifica un'eccezione durante il tentativo di acquisire il blocco.</param>
        <summary>Prova ad acquisire, per la quantità di tempo specificata, un blocco esclusivo sull'oggetto specificato e imposta atomicamente un valore che indica se il blocco è stato ottenuto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il valore di `timeout` parametro convertito in millisecondi è uguale a -1, questo metodo equivale a <xref:System.Threading.Monitor.Enter%28System.Object%29>. Se il valore di `timeout` è uguale a 0, questo metodo equivale a <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Se il blocco non è stato creato perché è stata generata un'eccezione, la variabile specificata per il `lockTaken` parametro `false` dopo che questo metodo termina. Ciò consente al programma di stabilire, in tutti i casi, se è necessario rilasciare il blocco.  
  
> [!NOTE]
>  Utilizzare <xref:System.Threading.Monitor> per bloccare gli oggetti (vale a dire, i tipi di riferimento), non i tipi di valore. Per altre informazioni, vedere il <xref:System.Threading.Monitor> argomento relativo alla classe.  
  
 Per garantire che il thread non di accedere alla sezione critica, è consigliabile esaminare il valore di `lockTaken` ed eseguendo il codice nella sezione critica solo se il relativo valore è `true`. Frammento di codice seguente viene illustrato il motivo usato per chiamare questo metodo. Si noti che è necessario chiamare <xref:System.Threading.Monitor.Exit%2A> in un `finally` blocco per garantire che il thread chiamante rilascia il blocco su una sezione critica se si verifica un'eccezione.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L'input per <paramref name="lockTaken" /> è <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> in millisecondi è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco.</summary>
        <returns>Viene restituito <see langword="true" /> se la chiamata è stata restituita perché il chiamante ha riacquisito il blocco per l'oggetto specificato. Non viene restituito alcun valore se il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato mentre è in attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Quando un thread chiama `Wait`, rilascia il blocco sull'oggetto e inserito nella coda di attesa dell'oggetto. Il thread successivo della coda di pronto dell'oggetto (se presente) acquisisce il blocco e ha l'utilizzo esclusivo dell'oggetto. Tutti i thread che chiamano `Wait` rimangono nella coda di attesa finché non ricevono un segnale da <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>, inviato dal proprietario del blocco. Se `Pulse` viene inviato solo il thread all'inizio della coda di attesa è interessato. Se `PulseAll` viene inviato, tutti i thread in attesa per l'oggetto sono interessati. Quando viene ricevuto il segnale, uno o più thread lascia la coda di attesa e inseriti nella coda pronta. È consentito un thread nella coda degli elementi pronto per riacquisire il blocco.  
  
 Questo metodo viene restituito quando il thread chiamante riacquisisce il blocco sull'oggetto. Si noti che questo metodo in modo indefinito se il proprietario del blocco non chiama `Pulse` o `PulseAll`.  
  
 Il chiamante viene eseguito `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di volte in cui il chiamante richiamato `Enter` sull'oggetto e richiama `Exit` come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama `Enter` molte volte necessario per ripristinare il salvato `Enter` conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato, solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
 Si noti che un oggetto sincronizzato contiene più riferimenti, compreso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronto, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene i thread in attesa per la notifica di una modifica nello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato del codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo viene descritto cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando nessun thread è in attesa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi da attendere prima che il thread venga inserito nella coda di thread pronti.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non restituisce finché riacquisisce il blocco esclusivo sul `obj` parametro.  
  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato mentre è in attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Il timeout assicura che il thread corrente non bloccarsi in modo indefinito se un altro thread rilascia il blocco senza chiamare prima il <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo. Inoltre, vengono spostati il thread per la coda degli elementi pronto, ignorando gli altri thread anticipo nella coda di attesa, in modo che è possibile riacquisire il blocco prima. Il thread può verificare il valore restituito del <xref:System.Threading.Monitor.Wait%2A> metodo per determinare se ha riacquisito il blocco prima del timeout. Il thread può valutare le condizioni che hanno causato lo stato di attesa, se necessario, chiamare il <xref:System.Threading.Monitor.Wait%2A> metodo nuovamente.  
  
 Quando un thread chiama `Wait`, rilascia il blocco sull'oggetto e inserito nella coda di attesa dell'oggetto. Il thread successivo della coda di pronto dell'oggetto (se presente) acquisisce il blocco e ha l'utilizzo esclusivo dell'oggetto. Il thread che ha richiamato `Wait` rimane nella coda di attesa fino a un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.PulseAll%2A>, o è in attesa nella coda e un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.Pulse%2A>. Tuttavia, se `millisecondsTimeout` scade prima che un altro thread richiama l'oggetto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo, il thread originale viene spostato nella coda degli elementi pronto per riacquisire il blocco.  
  
> [!NOTE]
>  Se <xref:System.Threading.Timeout.Infinite> specificato per il `millisecondsTimeout` parametro, questo metodo mantiene il blocco per un periodo illimitato, a meno che il proprietario del blocco chiama <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Se `millisecondsTimeout` è uguale a 0, il thread che chiama `Wait` rilascia il blocco e viene quindi immediatamente inserito nella coda pronta per riacquisire il blocco.  
  
 Il chiamante viene eseguito `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di volte in cui il chiamante richiamato <xref:System.Threading.Monitor.Enter%2A> sull'oggetto e richiama <xref:System.Threading.Monitor.Exit%2A> come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama <xref:System.Threading.Monitor.Enter%2A> molte volte necessario per ripristinare il salvato <xref:System.Threading.Monitor.Enter%2A> conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato, solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
> [!NOTE]
>  Un oggetto sincronizzato contiene più riferimenti, compreso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronto, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene il thread in attesa per la notifica di una modifica nello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato del codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo viene descritto cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando nessun thread è in attesa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il tempo di attesa prima che il thread venga inserito nella coda di thread pronti.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non restituisce finché riacquisisce il blocco esclusivo sul `obj` parametro.  
  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato mentre è in attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Il timeout assicura che il thread corrente non bloccarsi in modo indefinito se un altro thread rilascia il blocco senza chiamare prima il <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo. Inoltre, vengono spostati il thread per la coda degli elementi pronto, ignorando gli altri thread anticipo nella coda di attesa, in modo che è possibile riacquisire il blocco prima. Il thread può verificare il valore restituito del <xref:System.Threading.Monitor.Wait%2A> metodo per determinare se ha riacquisito il blocco prima del timeout. Il thread può valutare le condizioni che hanno causato lo stato di attesa, se necessario, chiamare il <xref:System.Threading.Monitor.Wait%2A> metodo nuovamente.  
  
 Quando un thread chiama `Wait`, rilascia il blocco sull'oggetto e inserito nella coda di attesa dell'oggetto. Il thread successivo della coda di pronto dell'oggetto (se presente) acquisisce il blocco e ha l'utilizzo esclusivo dell'oggetto. Il thread che ha richiamato `Wait` rimane nella coda di attesa fino a un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.PulseAll%2A>, o è in attesa nella coda e un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.Pulse%2A>. Tuttavia, se `timeout` scade prima che un altro thread richiama l'oggetto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo, il thread originale viene spostato nella coda degli elementi pronto per riacquisire il blocco.  
  
> [!NOTE]
>  Se un <xref:System.TimeSpan> – 1 millisecondo specificato per il `timeout` parametro, questo metodo mantiene il blocco per un periodo illimitato, a meno che il proprietario del blocco chiama <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Se `timeout` è pari a 0 millisecondi, il thread che chiama `Wait` rilascia il blocco e viene quindi immediatamente inserito nella coda pronta per riacquisire il blocco.  
  
 Il chiamante viene eseguito `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di volte in cui il chiamante richiamato <xref:System.Threading.Monitor.Enter%2A> sull'oggetto e richiama <xref:System.Threading.Monitor.Exit%2A> come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama <xref:System.Threading.Monitor.Enter%2A> molte volte necessario per ripristinare il salvato <xref:System.Threading.Monitor.Enter%2A> conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato, solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
> [!NOTE]
>  Un oggetto sincronizzato contiene più riferimenti, compreso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronto, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene il thread in attesa per la notifica di una modifica nello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato del codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo viene descritto cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando nessun thread è in attesa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Il thread chiamante non è il proprietario del blocco per l'oggetto specificato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="timeout" /> in millisecondi è negativo e non rappresenta <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="millisecondsTimeout">Numero di millisecondi da attendere prima che il thread venga inserito nella coda di thread pronti.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire e riacquisire il dominio di sincronizzazione per il contesto, se si trova in un contesto sincronizzato, prima dell'attesa; in caso contrario, <see langword="false" />.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti. Questo metodo consente anche di specificare se il dominio di sincronizzazione per il contesto, qualora si trovi in un contesto di sincronizzazione, viene terminato prima dell'attesa e riacquisito in un secondo momento.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non restituisce finché riacquisisce il blocco esclusivo sul `obj` parametro.  
  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato mentre è in attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Il timeout assicura che il thread corrente non bloccarsi in modo indefinito se un altro thread rilascia il blocco senza chiamare prima il <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo. Inoltre, vengono spostati il thread per la coda degli elementi pronto, ignorando gli altri thread anticipo nella coda di attesa, in modo che è possibile riacquisire il blocco prima. Il thread può verificare il valore restituito del <xref:System.Threading.Monitor.Wait%2A> metodo per determinare se ha riacquisito il blocco prima del timeout. Il thread può valutare le condizioni che hanno causato lo stato di attesa, se necessario, chiamare il <xref:System.Threading.Monitor.Wait%2A> metodo nuovamente.  
  
 Quando un thread chiama `Wait`, rilascia il blocco e viene inserito nella coda di attesa. A questo punto, il thread successivo nella coda degli elementi pronto (se presente) è consentito di assumere il controllo del blocco. Il thread che ha richiamato `Wait` rimane nella coda di attesa fino a un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.PulseAll%2A>, o è in attesa nella coda e un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.Pulse%2A>. Tuttavia, se `millisecondsTimeout` scade prima che un altro thread richiama l'oggetto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo, il thread originale viene spostato nella coda degli elementi pronto per riacquisire il blocco.  
  
> [!NOTE]
>  Se <xref:System.Threading.Timeout.Infinite> specificato per il `millisecondsTimeout` parametro, questo metodo mantiene il blocco per un periodo illimitato, a meno che il proprietario del blocco chiama <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Se `millisecondsTimeout` è uguale a 0, il thread che chiama `Wait` rilascia il blocco e viene quindi immediatamente inserito nella coda pronta per riacquisire il blocco.  
  
 Il chiamante viene eseguito `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di volte in cui il chiamante richiamato <xref:System.Threading.Monitor.Enter%2A> sull'oggetto e richiama <xref:System.Threading.Monitor.Exit%2A> come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama <xref:System.Threading.Monitor.Enter%2A> molte volte necessario per ripristinare il salvato <xref:System.Threading.Monitor.Enter%2A> conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato, solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
> [!NOTE]
>  Un oggetto sincronizzato contiene più riferimenti, compreso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronto, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene il thread in attesa per la notifica di una modifica nello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato del codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo viene descritto cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando nessun thread è in attesa.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il`exitContext` parametro non ha alcun effetto a meno che non la <xref:System.Threading.Monitor.Wait%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se attualmente un metodo in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinite, specificando `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, a cui passare il contesto predefinito) prima di eseguire il <xref:System.Threading.Monitor.Wait%2A> (metodo). Restituisce il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.Monitor.Wait%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto non dispone di <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attributo applicato. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.Monitor.Wait%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.Monitor.Wait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> non viene richiamato dall'interno di un blocco di codice sincronizzato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato <see langword="Wait" /> viene interrotto in seguito dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">Oggetto per il quale attendere.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il tempo di attesa prima che il thread venga inserito nella coda di thread pronti.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire e riacquisire il dominio di sincronizzazione per il contesto, se si trova in un contesto sincronizzato, prima dell'attesa; in caso contrario, <see langword="false" />.</param>
        <summary>Rilascia il blocco su un oggetto e interrompe il thread corrente finché riacquisisce il blocco. Allo scadere dell'intervallo di timeout specificato, il thread viene inserito nella coda di thread pronti. Esce eventualmente dal dominio di sincronizzazione per il contesto di sincronizzazione prima dell'attesa e riacquisisce il dominio in un secondo momento.</summary>
        <returns>
          <see langword="true" /> se il blocco è stato riacquisito prima che sia trascorso il tempo specificato; <see langword="false" /> se il blocco è stato riacquisito dopo che è trascorso il tempo specificato. Il metodo non restituisce alcun valore finché il blocco non viene riacquisito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non restituisce finché riacquisisce il blocco esclusivo sul `obj` parametro.  
  
 Questo metodo viene richiamato dal thread che attualmente possiede il blocco sull'oggetto specificato per il rilascio dell'oggetto in modo che un altro thread possa accedervi. Il chiamante è bloccato mentre è in attesa per riacquisire il blocco. Questo metodo viene chiamato quando il chiamante deve attendere una modifica dello stato che si verificherà in seguito a operazioni di un altro thread.  
  
 Il timeout assicura che il thread corrente non bloccarsi in modo indefinito se un altro thread rilascia il blocco senza chiamare prima il <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo. Inoltre, vengono spostati il thread per la coda degli elementi pronto, ignorando gli altri thread anticipo nella coda di attesa, in modo che è possibile riacquisire il blocco prima. Il thread può verificare il valore restituito del <xref:System.Threading.Monitor.Wait%2A> metodo per determinare se ha riacquisito il blocco prima del timeout. Il thread può valutare le condizioni che hanno causato lo stato di attesa, se necessario, chiamare il <xref:System.Threading.Monitor.Wait%2A> metodo nuovamente.  
  
 Quando un thread chiama `Wait`, rilascia il blocco e viene inserito nella coda di attesa. A questo punto, il thread successivo nella coda degli elementi pronto (se presente) è consentito di assumere il controllo del blocco. Il thread che ha richiamato `Wait` rimane nella coda di attesa fino a un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.PulseAll%2A>, o è in attesa nella coda e un thread che è responsabile del blocco richiama <xref:System.Threading.Monitor.Pulse%2A>. Tuttavia, se `timeout` trascorre prima che un altro thread richiama l'oggetto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> metodo, il thread originale viene spostato nella coda degli elementi pronto per riacquisire il blocco.  
  
> [!NOTE]
>  Se un <xref:System.TimeSpan> che rappresenta-1 millisecondi specificato per il `timeout` parametro, questo metodo mantiene il blocco per un periodo illimitato, a meno che il proprietario del blocco chiama <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>. Se `timeout` è pari a 0 millisecondi, il thread che chiama `Wait` rilascia il blocco e viene quindi immediatamente inserito nella coda pronta per riacquisire il blocco.  
  
 Il chiamante viene eseguito `Wait` una volta, indipendentemente dal numero di volte in cui <xref:System.Threading.Monitor.Enter%2A> è stato richiamato per l'oggetto specificato. Concettualmente, la `Wait` metodo archivia il numero di volte in cui il chiamante richiamato <xref:System.Threading.Monitor.Enter%2A> sull'oggetto e richiama <xref:System.Threading.Monitor.Exit%2A> come numero di volte necessario per ottenere il rilascio dell'oggetto bloccato. Il chiamante viene bloccato durante l'attesa di riacquisizione dell'oggetto. Quando il chiamante riacquisisce il blocco, il sistema chiama <xref:System.Threading.Monitor.Enter%2A> molte volte necessario per ripristinare il salvato <xref:System.Threading.Monitor.Enter%2A> conteggio per il chiamante. La chiamata `Wait` rilascia il blocco per l'oggetto specificato, solo se il chiamante è il proprietario di blocchi su altri oggetti, tali blocchi non vengono rilasciati.  
  
> [!NOTE]
>  Un oggetto sincronizzato contiene più riferimenti, compreso un riferimento al thread che attualmente contiene il blocco, un riferimento alla coda degli elementi pronto, che contiene i thread pronti ottenere il blocco, e un riferimento alla coda di attesa, che contiene il thread in attesa per la notifica di una modifica nello stato dell'oggetto.  
  
 Il <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, e `Wait` metodi devono essere richiamati dall'interno di un blocco sincronizzato del codice.  
  
 La sezione Osservazioni per il <xref:System.Threading.Monitor.Pulse%2A> metodo viene descritto cosa accade se <xref:System.Threading.Monitor.Pulse%2A> viene chiamato quando nessun thread è in attesa.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il`exitContext` parametro non ha alcun effetto a meno che non la <xref:System.Threading.Monitor.Wait%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se attualmente un metodo in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinite, specificando `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, a cui passare il contesto predefinito) prima di eseguire il <xref:System.Threading.Monitor.Wait%2A> (metodo). Restituisce il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.Monitor.Wait%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto non dispone di <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attributo applicato. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.Monitor.Wait%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.Monitor.Wait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="obj" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see langword="Wait" /> non viene richiamato dall'interno di un blocco di codice sincronizzato.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread da cui è stato richiamato Wait viene interrotto più tardi dallo stato di attesa. L'interruzione si verifica quando il metodo <see cref="M:System.Threading.Thread.Interrupt" /> di questo thread viene chiamato da un altro thread.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="timeout" /> è negativo e non rappresenta <see cref="F:System.Threading.Timeout.Infinite" /> (– 1 millisecondo) oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
      </Docs>
    </Member>
  </Members>
</Type>