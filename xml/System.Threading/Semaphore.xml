<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530945" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limita il numero di thread che possono accedere simultaneamente a una risorsa o a un pool di risorse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.Threading.Semaphore> classe per controllare l'accesso a un pool di risorse. Thread di accedono al semaforo chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo), che viene ereditata dal <xref:System.Threading.WaitHandle> classe e rilasciare il semaforo chiamando il <xref:System.Threading.Semaphore.Release%2A> (metodo).  
  
 Il numero su un semaforo viene decrementato ogni volta che un thread accede al semaforo e incrementato quando un thread rilascia il semaforo. Quando il conteggio è zero, le richieste successive bloccata fino a quando non altri thread rilasciano il semaforo. Quando tutti i thread hanno rilasciato il semaforo, il numero viene raggiunto il valore massimo specificato quando è stato creato il semaforo.  
  
 Non è garantito alcun ordine, ad esempio FIFO o LIFO, in cui i thread bloccati al semaforo.  
  
 Un thread può accedere al semaforo più volte, chiamando la <xref:System.Threading.WaitHandle.WaitOne%2A> metodo ripetutamente. Per rilasciare alcune o tutte queste voci, il thread può chiamare senza parametri <xref:System.Threading.Semaphore.Release> overload del metodo più volte oppure è possibile chiamare il <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo che specifica il numero di voci da rilasciare.  
  
 Il <xref:System.Threading.Semaphore> classe non impone l'identità del thread nelle chiamate a <xref:System.Threading.WaitHandle.WaitOne%2A> o <xref:System.Threading.Semaphore.Release%2A>. È responsabilità del programmatore garantire che i thread non rilasciano il semaforo troppe volte. Ad esempio, si consideri un semaforo con un conteggio massimo di due e il thread A e B accedano entrambi al semaforo. Se un errore di programmazione nel thread B fa sì che la chiamata a <xref:System.Threading.Semaphore.Release%2A> due volte, entrambe le chiamate hanno esito positivo. Il conteggio sul semaforo è completo e quando il thread A alla fine chiama <xref:System.Threading.Semaphore.Release%2A>, viene generata un'eccezione <xref:System.Threading.SemaphoreFullException>.  
  
 Sono disponibili due tipi: semafori locali e i semafori di sistema denominato. Se si crea un <xref:System.Threading.Semaphore> utilizzando un costruttore che accetta un nome, dell'oggetto è associato a un semaforo di sistema operativo di tale nome. Di sistema sono visibili in tutto il sistema operativo, i semafori e possono essere usati per sincronizzare le attività dei processi denominati. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema denominato ed è possibile utilizzare il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo per aprire un oggetto esistente denominato semaforo di sistema.  
  
 Un semaforo locale esiste solo all'interno del processo. Può essere usato da qualsiasi thread nel processo che abbia un riferimento all'oggetto <xref:System.Threading.Semaphore> locale. Ogni <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo locale distinto.  
  
   
  
## Examples  
 L'esempio di codice seguente viene creato un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero. Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo. Il thread principale utilizza i <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo. Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo del semaforo traccia messaggi console. L'intervallo di lavoro simulato viene leggermente incrementato per ogni thread, per rendere più facile da leggere l'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
        <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un semaforo senza nome. Tutti i thread che utilizzano un'istanza di tale semaforo devono disporre di riferimenti all'istanza.  
  
 Se `initialCount` è minore di `maximumCount`, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte. Se non si desidera riservare le voci per il thread che crea il semaforo, utilizzare lo stesso numero per `maximumCount` e `initialCount`.  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero. Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo. Il thread principale utilizza i <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo. Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo del semaforo traccia messaggi console. L'intervallo di lavoro simulato viene leggermente incrementato per ogni thread, per rendere più facile da leggere l'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> è minore di 1.  
  
 oppure  
  
 <paramref name="initialCount" /> è minore di 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
        <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</param>
        <param name="name">Nome di un oggetto semaforo di sistema denominato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, nonché indicando facoltativamente il nome di un oggetto semaforo di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con il conteggio iniziale e conteggio massimo specificati da `initialCount` e `maximumCount`. Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono utilizzati anche se i valori non validi comunque causano eccezioni. Se è necessario determinare se è stato creato un semaforo di sistema denominato, utilizzare il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> overload del costruttore.  
  
> [!IMPORTANT]
>  Quando si utilizza questo overload del costruttore, la procedura consigliata consiste nello specificare lo stesso numero per `initialCount` e `maximumCount`. Se `initialCount` è minore di `maximumCount`e viene creato un semaforo di sistema denominato, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte. Tuttavia, con questo overload del costruttore non è possibile determinare se è stato creato un semaforo di sistema denominato.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore.  
  
 Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
 Se si desidera verificare l'esistenza di un semaforo di sistema denominato, utilizzare il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo. Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire un semaforo denominato esistente e genera un'eccezione se il semaforo di sistema non esiste.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato. Nell'esempio viene creato un semaforo denominato con un conteggio massimo di cinque e un conteggio iniziale pari a cinque. Il programma effettua tre chiamate per il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo. Pertanto, se si esegue l'esempio compilato da due finestre di comando, la seconda copia verrà bloccata la terza chiamata a <xref:System.Threading.WaitHandle.WaitOne%2A>. Rilasciare una o più voci nella prima copia del programma per sbloccare la seconda.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> è minore di 1.  
  
 oppure  
  
 <paramref name="initialCount" /> è minore di 0.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
        <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
        <param name="name">Nome di un oggetto semaforo di sistema denominato.</param>
        <param name="createdNew">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un semaforo locale (ovvero, se il valore di <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato. <see langword="false" /> se il semaforo di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema e specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con il conteggio iniziale e conteggio massimo specificati da `initialCount` e `maximumCount`. Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono utilizzati anche se i valori non validi comunque causano eccezioni. Utilizzare `createdNew` per determinare se è stato creato il semaforo di sistema.  
  
 Se `initialCount` è minore di `maximumCount`, e `createdNew` è `true`, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore. In questo caso, `createdNew` è sempre `true`.  
  
 Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato. Nell'esempio viene creato un semaforo denominato con un conteggio massimo di cinque e un conteggio iniziale di due. Vale a dire si riserva tre voci per il thread che chiama il costruttore. Se `createNew` è `false`, il programma effettua tre chiamate per il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo. Pertanto, se si esegue l'esempio compilato da due finestre di comando, la seconda copia verrà bloccata la terza chiamata a <xref:System.Threading.WaitHandle.WaitOne%2A>. Rilasciare una o più voci nella prima copia del programma per sbloccare la seconda.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> è minore di 1.  
  
 oppure  
  
 <paramref name="initialCount" /> è minore di 0.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
        <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
        <param name="name">Nome di un oggetto semaforo di sistema denominato.</param>
        <param name="createdNew">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un semaforo locale (ovvero, se il valore di <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato. <see langword="false" /> se il semaforo di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <param name="semaphoreSecurity">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare al semaforo di sistema denominato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero iniziale di accessi e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema, specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema e specificando la sicurezza del controllo di accesso per il semaforo di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per applicare del controllo di accesso per un semaforo di sistema denominato quando viene creato, impedendo che Assumi il controllo del semaforo di altro codice.  
  
 Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con la sicurezza del controllo di accesso specificato. Se il semaforo denominato esiste, la sicurezza del controllo di accesso specificato viene ignorata.  
  
> [!NOTE]
>  Il chiamante ha il controllo completo su appena creato <xref:System.Threading.Semaphore> oggetto anche se `semaphoreSecurity` nega o non concede alcuni diritti di accesso per l'utente corrente. Tuttavia, se l'utente corrente tenta di ottenere un altro <xref:System.Threading.Semaphore> per rappresentare lo stesso semaforo denominato, utilizzando un costruttore dell'oggetto o <xref:System.Threading.Semaphore.OpenExisting%2A> (metodo), viene applicata la sicurezza del controllo di accesso di Windows.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con il conteggio iniziale e conteggio massimo specificati da `initialCount` e `maximumCount`. Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono utilizzati anche se i valori non validi comunque causano eccezioni. Utilizzare il `createdNew` parametro per determinare se il semaforo di sistema è stato creato da questo costruttore.  
  
 Se `initialCount` è minore di `maximumCount`, e `createdNew` è `true`, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore. In questo caso, `createdNew` è sempre `true`.  
  
 Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato. Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo. Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> è minore di 1.  
  
 oppure  
  
 <paramref name="initialCount" /> è minore di 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene la sicurezza del controllo di accesso per un semaforo di sistema denominato.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> che rappresenta la sicurezza del controllo di accesso per il semaforo di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Semaphore.GetAccessControl%2A> metodo utilizza la seguente combinazione di flag (combinati mediante un'operazione OR bit per bit) per cercare le autorizzazioni: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e il semaforo devono essere aperto con <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> diritti.  
  
 Su un semaforo locale, del controllo di accesso è irrilevante. Se il <xref:System.Threading.Semaphore> oggetto non rappresenta un semaforo di sistema denominato, questo metodo restituisce un <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto che concede tutti i diritti a qualsiasi utente.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzo del semaforo, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni. La sicurezza del controllo di accesso per il semaforo di sistema viene ottenuta utilizzando il <xref:System.Threading.Semaphore.GetAccessControl%2A> metodo.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <see cref="T:System.Threading.Semaphore" /> corrente rappresenta un semaforo di sistema denominato e l'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.Semaphore" /> corrente rappresenta un semaforo di sistema denominato e non è stato aperto con diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Non supportato per Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un semaforo denominato specificato, se esistente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome del semaforo di sistema da aprire.</param>
        <summary>Apre il semaforo denominato specificato, se esistente.</summary>
        <returns>Oggetto che rappresenta il semaforo di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire il semaforo denominato specificato. Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema. Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.Semaphore.OpenExisting%2A> overload del metodo e specificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti, combinati utilizzando l'operazione OR bit per bit.  
  
 Specifica il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag consente a un thread di accedere al semaforo e specificando il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag consente a un thread di chiamare il <xref:System.Threading.Semaphore.Release%2A> metodo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e lo rilascia. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per aprire un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">Nome del semaforo di sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <summary>Apre il semaforo denominato specificato, se esistente, con l'accesso di sicurezza desiderato.</summary>
        <returns>Oggetto che rappresenta il semaforo di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread di accedere al semaforo e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.Semaphore.Release%2A> metodo.  
  
 Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire un semaforo denominato esistente. Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema. Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzo del semaforo, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e lo rilascia. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dei diritti di accesso di sicurezza desiderati.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esce dal semaforo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esce dal semaforo e restituisce il conteggio precedente.</summary>
        <returns>Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In genere, i thread utilizzano il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo immettere in genere il semaforo e utilizzare questo overload del metodo per uscire dall'installazione.  
  
 Se un <xref:System.Threading.SemaphoreFullException> viene generata dal <xref:System.Threading.Semaphore.Release%2A> (metodo), non indica necessariamente un problema con il thread chiamante. Tale thread uscite dal semaforo più volte di viene immesso potrebbe essere causato da un errore di programmazione in un altro thread.  
  
 Se l'oggetto corrente <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti e il semaforo deve essere aperto con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti.  
  
   
  
## Examples  
 L'esempio di codice seguente viene creato un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero. Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo. Il thread principale utilizza i <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.  
  
 Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo del semaforo traccia messaggi console. L'intervallo di lavoro simulato viene leggermente incrementato per ogni thread, per rendere più facile da leggere l'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Il conteggio del semaforo ha già raggiunto il valore massimo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore Win32 relativo a un semaforo denominato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
 oppure  
  
 Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Numero di uscite dal semaforo.</param>
        <summary>Esce dal semaforo il numero di volte specificato e restituisce il conteggio precedente.</summary>
        <returns>Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un thread ha immesso il semaforo più volte, overload di questo metodo consente il conteggio del semaforo intero deve essere ripristinato con un'unica chiamata.  
  
 Se un <xref:System.Threading.SemaphoreFullException> viene generata dal <xref:System.Threading.Semaphore.Release%2A> (metodo), non indica necessariamente un problema con il thread chiamante. Tale thread uscite dal semaforo più volte di viene immesso potrebbe essere causato da un errore di programmazione in un altro thread.  
  
 Se l'oggetto corrente <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti e il semaforo deve essere aperto con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti.  
  
   
  
## Examples  
 L'esempio di codice seguente viene creato un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero. Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo. Il thread principale utilizza i <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.  
  
 Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo del semaforo traccia messaggi console. L'intervallo di lavoro simulato viene leggermente incrementato per ogni thread, per rendere più facile da leggere l'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> è minore di 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Il conteggio del semaforo ha già raggiunto il valore massimo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore Win32 relativo a un semaforo denominato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
 oppure  
  
 Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con i diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare al semaforo di sistema denominato.</param>
        <summary>Imposta la sicurezza del controllo di accesso per un semaforo di sistema denominato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile impostare la sicurezza del controllo di accesso solo su <xref:System.Threading.Semaphore> gli oggetti che rappresentano i semafori di sistema denominato.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e il semaforo devono essere aperto con <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> diritti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, utilizzando il <xref:System.Threading.Semaphore.SetAccessControl%2A> (metodo), il semaforo viene aperto con i diritti necessari per immettere e di rilascio. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.  
  
 oppure  
  
 Il semaforo non è stato aperto con i diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">L'oggetto <see cref="T:System.Threading.Semaphore" /> corrente non rappresenta un semaforo di sistema denominato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un semaforo denominato specificato, se già esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome del semaforo di sistema da aprire.</param>
        <param name="result">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <see cref="T:System.Threading.Semaphore" /> che rappresenta il semaforo denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre il semaforo denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
        <returns>
          <see langword="true" /> se l'apertura del semaforo denominato è riuscita; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il semaforo denominato non esiste, questo metodo non crearlo. Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi dell'esistenza di un semaforo denominato, utilizzare questo overload del metodo anziché il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo che genera un'eccezione se il semaforo non esiste.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.Semaphore.TryOpenExisting%2A> overload del metodo e specificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti, combinati utilizzando l'operazione OR bit per bit. Specifica il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag consente a un thread di accedere al semaforo e specificando il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag consente a un thread di chiamare il <xref:System.Threading.Semaphore.Release%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome del semaforo di sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <param name="result">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <see cref="T:System.Threading.Semaphore" /> che rappresenta il semaforo denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre il semaforo denominato specificato, se esistente, con l'accesso di sicurezza desiderato, e restituisce un valore che indica se l'operazione è riuscita.</summary>
        <returns>
          <see langword="true" /> se l'apertura del semaforo denominato è riuscita; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il semaforo denominato non esiste, questo metodo non crearlo. Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi dell'esistenza di un semaforo denominato, utilizzare questo overload del metodo anziché il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo che genera un'eccezione se il semaforo non esiste.  
  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread di accedere al semaforo e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.Semaphore.Release%2A> metodo.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
      </Docs>
    </Member>
  </Members>
</Type>