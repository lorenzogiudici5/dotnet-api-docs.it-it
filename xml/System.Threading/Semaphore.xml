<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Semaphore.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">589fcf34edfc4ff1eb1c243acad8b5ad0d3cd911</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Limits the number of threads that can access a resource or pool of resources concurrently.</source>
          <target state="translated">Limita il numero di thread che possono accedere simultaneamente a una risorsa o a un pool di risorse.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class to control access to a pool of resources.</source>
          <target state="translated">Utilizzare la <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> classe per controllare l'accesso a un pool di risorse.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Threads enter the semaphore by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method, which is inherited from the <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> class, and release the semaphore by calling the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Thread di accedono al semaforo chiamando il <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (metodo), che viene ereditata dal <ph id="ph2">&lt;xref:System.Threading.WaitHandle&gt;</ph> classe e rilasciare il semaforo chiamando il <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> (metodo).</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</source>
          <target state="translated">Il numero su un semaforo viene decrementato ogni volta che un thread accede al semaforo e incrementato quando un thread rilascia il semaforo.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When the count is zero, subsequent requests block until other threads release the semaphore.</source>
          <target state="translated">Quando il conteggio è zero, le richieste successive bloccata fino a quando non altri thread rilasciano il semaforo.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</source>
          <target state="translated">Quando tutti i thread hanno rilasciato il semaforo, il numero viene raggiunto il valore massimo specificato quando è stato creato il semaforo.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</source>
          <target state="translated">Non è garantito alcun ordine, ad esempio FIFO o LIFO, in cui i thread bloccati al semaforo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A thread can enter the semaphore multiple times, by calling the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method repeatedly.</source>
          <target state="translated">Un thread può accedere al semaforo più volte, chiamando la <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metodo ripetutamente.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>To release some or all of these entries, the thread can call the parameterless <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload multiple times, or it can call the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload that specifies the number of entries to be released.</source>
          <target state="translated">Per rilasciare alcune o tutte queste voci, il thread può chiamare senza parametri <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> overload del metodo più volte oppure è possibile chiamare il <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> overload del metodo che specifica il numero di voci da rilasciare.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity on calls to <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> classe non impone l'identità del thread nelle chiamate a <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</source>
          <target state="translated">È responsabilità del programmatore garantire che i thread non rilasciano il semaforo troppe volte.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</source>
          <target state="translated">Ad esempio, si consideri un semaforo con un conteggio massimo di due e il thread A e B accedano entrambi al semaforo.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If a programming error in thread B causes it to call <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> twice, both calls succeed.</source>
          <target state="translated">Se un errore di programmazione nel thread B fa sì che la chiamata a <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> due volte, entrambe le chiamate hanno esito positivo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The count on the semaphore is full, and when thread A eventually calls <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>, a <ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown.</source>
          <target state="translated">Il conteggio sul semaforo è completo e quando il thread A alla fine chiama <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>, viene generata un'eccezione <ph id="ph2">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Semaphores are of two types: local semaphores and named system semaphores.</source>
          <target state="translated">Sono disponibili due tipi: semafori locali e i semafori di sistema denominato.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>If you create a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</source>
          <target state="translated">Se si crea un <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> utilizzando un costruttore che accetta un nome, dell'oggetto è associato a un semaforo di sistema operativo di tale nome.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</source>
          <target state="translated">Di sistema sono visibili in tutto il sistema operativo, i semafori e possono essere usati per sincronizzare le attività dei processi denominati.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore, and you can use the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method to open an existing named system semaphore.</source>
          <target state="translated">È possibile creare più <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> gli oggetti che rappresentano lo stesso semaforo di sistema denominato ed è possibile utilizzare il <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> metodo per aprire un oggetto esistente denominato semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>A local semaphore exists only within your process.</source>
          <target state="translated">Un semaforo locale esiste solo all'interno del processo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>It can be used by any thread in your process that has a reference to the local <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object.</source>
          <target state="translated">Può essere usato da qualsiasi thread nel processo che abbia un riferimento all'oggetto <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> locale.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object is a separate local semaphore.</source>
          <target state="translated">Ogni <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> oggetto rappresenta un semaforo locale distinto.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">L'esempio di codice seguente viene creato un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">Il thread principale utilizza i <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Ogni thread Usa la <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> overload del metodo per rilasciare il semaforo.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Utilizzo del semaforo traccia messaggi console.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">L'intervallo di lavoro simulato viene leggermente incrementato per ogni thread, per rendere più facile da leggere l'output.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Semaphore">
          <source>This type is thread safe.</source>
          <target state="translated">Questo tipo è thread-safe.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>This constructor initializes an unnamed semaphore.</source>
          <target state="translated">Questo costruttore inizializza un semaforo senza nome.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>All threads that use an instance of such a semaphore must have references to the instance.</source>
          <target state="translated">Tutti i thread che utilizzano un'istanza di tale semaforo devono disporre di riferimenti all'istanza.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">Se <ph id="ph1">`initialCount`</ph> è minore di <ph id="ph2">`maximumCount`</ph>, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> meno <ph id="ph5">`initialCount`</ph>) volte.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for <ph id="ph1">`maximumCount`</ph> and <ph id="ph2">`initialCount`</ph>.</source>
          <target state="translated">Se non si desidera riservare le voci per il thread che crea il semaforo, utilizzare lo stesso numero per <ph id="ph1">`maximumCount`</ph> e <ph id="ph2">`initialCount`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The following example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">Nell'esempio seguente viene creato un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">Il thread principale utilizza i <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Ogni thread Usa la <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> overload del metodo per rilasciare il semaforo.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Utilizzo del semaforo traccia messaggi console.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">L'intervallo di lavoro simulato viene leggermente incrementato per ogni thread, per rendere più facile da leggere l'output.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> è minore di 1.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> è minore di 0.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The initial number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The maximum number of requests for the semaphore that can be granted concurrently.</source>
          <target state="translated">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">Nome di un oggetto semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, nonché indicando facoltativamente il nome di un oggetto semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">Questo costruttore inizializza un <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> oggetto che rappresenta un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">È possibile creare più <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> gli oggetti che rappresentano lo stesso semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Se il semaforo di sistema denominato non esiste, viene creato con il conteggio iniziale e conteggio massimo specificati da <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">Se il semaforo di sistema denominato esiste già, <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph> non vengono utilizzati anche se i valori non validi comunque causano eccezioni.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you need to determine whether or not a named system semaphore was created, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor overload instead.</source>
          <target state="translated">Se è necessario determinare se è stato creato un semaforo di sistema denominato, utilizzare il <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> overload del costruttore.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>When you use this constructor overload, the recommended practice is to specify the same number for <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Quando si utilizza questo overload del costruttore, la procedura consigliata consiste nello specificare lo stesso numero per <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and a named system semaphore is created, the effect is the same as if the current thread had called <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> minus <ph id="ph5">`initialCount`</ph>) times.</source>
          <target state="translated">Se <ph id="ph1">`initialCount`</ph> è minore di <ph id="ph2">`maximumCount`</ph>e viene creato un semaforo di sistema denominato, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph4">`maximumCount`</ph> meno <ph id="ph5">`initialCount`</ph>) volte.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>However, with this constructor overload there is no way to determine whether a named system semaphore was created.</source>
          <target state="translated">Tuttavia, con questo overload del costruttore non è possibile determinare se è stato creato un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">Se si specifica <ph id="ph1">`null`</ph> o una stringa vuota per <ph id="ph2">`name`</ph>, viene creato un semaforo locale, come se fosse stato chiamato il <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> overload del costruttore.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti di processo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>If you want to find out whether a named system semaphore exists, use the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method.</source>
          <target state="translated">Se si desidera verificare l'esistenza di un semaforo di sistema denominato, utilizzare il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> metodo tenta di aprire un semaforo denominato esistente e genera un'eccezione se il semaforo di sistema non esiste.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of five.</source>
          <target state="translated">Nell'esempio viene creato un semaforo denominato con un conteggio massimo di cinque e un conteggio iniziale pari a cinque.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The program makes three calls to the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">Il programma effettua tre chiamate per il <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">Pertanto, se si esegue l'esempio compilato da due finestre di comando, la seconda copia verrà bloccata la terza chiamata a <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">Rilasciare una o più voci nella prima copia del programma per sbloccare la seconda.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> supera i 260 caratteri.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> è minore di 1.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> è minore di 0.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Errore Win32.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">per chiamare codice non gestito per creare un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">Nome di un oggetto semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">Quando questo metodo viene restituito, contiene <ph id="ph1">&lt;see langword="true" /&gt;</ph> se è stato creato un semaforo locale (ovvero, se il valore di <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato. <ph id="ph3">&lt;see langword="false" /&gt;</ph> se il semaforo di sistema denominato specificato è già esistente.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Questo parametro viene passato non inizializzato.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema e specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">Questo costruttore inizializza un <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> oggetto che rappresenta un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">È possibile creare più <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> gli oggetti che rappresentano lo stesso semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Se il semaforo di sistema denominato non esiste, viene creato con il conteggio iniziale e conteggio massimo specificati da <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">Se il semaforo di sistema denominato esiste già, <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph> non vengono utilizzati anche se i valori non validi comunque causano eccezioni.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Use <ph id="ph1">`createdNew`</ph> to determine whether the system semaphore was created.</source>
          <target state="translated">Utilizzare <ph id="ph1">`createdNew`</ph> per determinare se è stato creato il semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">Se <ph id="ph1">`initialCount`</ph> è minore di <ph id="ph2">`maximumCount`</ph>, e <ph id="ph3">`createdNew`</ph> è <ph id="ph4">`true`</ph>, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> meno <ph id="ph7">`initialCount`</ph>) volte.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">Se si specifica <ph id="ph1">`null`</ph> o una stringa vuota per <ph id="ph2">`name`</ph>, viene creato un semaforo locale, come se fosse stato chiamato il <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> overload del costruttore.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">In questo caso, <ph id="ph1">`createdNew`</ph> è sempre <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti di processo.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore.</source>
          <target state="translated">Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The example creates a named semaphore with a maximum count of five and an initial count of two.</source>
          <target state="translated">Nell'esempio viene creato un semaforo denominato con un conteggio massimo di cinque e un conteggio iniziale di due.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>That is, it reserves three entries for the thread that calls the constructor.</source>
          <target state="translated">Vale a dire si riserva tre voci per il thread che chiama il costruttore.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>If <ph id="ph1">`createNew`</ph> is <ph id="ph2">`false`</ph>, the program makes three calls to the <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`createNew`</ph> è <ph id="ph2">`false`</ph>, il programma effettua tre chiamate per il <ph id="ph3">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">Pertanto, se si esegue l'esempio compilato da due finestre di comando, la seconda copia verrà bloccata la terza chiamata a <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Release one or more entries in the first copy of the program to unblock the second.</source>
          <target state="translated">Rilasciare una o più voci nella prima copia del programma per sbloccare la seconda.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> supera i 260 caratteri.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> è minore di 1.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> è minore di 0.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Errore Win32.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">per chiamare codice non gestito per creare un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The initial number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The maximum number of requests for the semaphore that can be satisfied concurrently.</source>
          <target state="translated">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The name of a named system semaphore object.</source>
          <target state="translated">Nome di un oggetto semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>When this method returns, contains <ph id="ph1">&lt;see langword="true" /&gt;</ph> if a local semaphore was created (that is, if <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty string) or if the specified named system semaphore was created; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the specified named system semaphore already existed.</source>
          <target state="translated">Quando questo metodo viene restituito, contiene <ph id="ph1">&lt;see langword="true" /&gt;</ph> se è stato creato un semaforo locale (ovvero, se il valore di <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> è <ph id="ph2">&lt;see langword="null" /&gt;</ph> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato. <ph id="ph3">&lt;see langword="false" /&gt;</ph> se il semaforo di sistema denominato specificato è già esistente.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This parameter is passed uninitialized.</source>
          <target state="translated">Questo parametro viene passato non inizializzato.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> che rappresenta la sicurezza del controllo di accesso da applicare al semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph>, specificando il numero iniziale di accessi e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema, specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema e specificando la sicurezza del controllo di accesso per il semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</source>
          <target state="translated">Utilizzare questo costruttore per applicare del controllo di accesso per un semaforo di sistema denominato quando viene creato, impedendo che Assumi il controllo del semaforo di altro codice.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>This constructor initializes a <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.</source>
          <target state="translated">Questo costruttore inizializza un <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> oggetto che rappresenta un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can create multiple <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.</source>
          <target state="translated">È possibile creare più <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> gli oggetti che rappresentano lo stesso semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the specified access control security.</source>
          <target state="translated">Se il semaforo di sistema denominato non esiste, viene creato con la sicurezza del controllo di accesso specificato.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named semaphore exists, the specified access control security is ignored.</source>
          <target state="translated">Se il semaforo denominato esiste, la sicurezza del controllo di accesso specificato viene ignorata.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The caller has full control over the newly created <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object even if <ph id="ph2">`semaphoreSecurity`</ph> denies or fails to grant some access rights to the current user.</source>
          <target state="translated">Il chiamante ha il controllo completo su appena creato <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> oggetto anche se <ph id="ph2">`semaphoreSecurity`</ph> nega o non concede alcuni diritti di accesso per l'utente corrente.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>However, if the current user attempts to get another <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object to represent the same named semaphore, using either a constructor or the <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.</source>
          <target state="translated">Tuttavia, se l'utente corrente tenta di ottenere un altro <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> per rappresentare lo stesso semaforo denominato, utilizzando un costruttore dell'oggetto o <ph id="ph2">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> (metodo), viene applicata la sicurezza del controllo di accesso di Windows.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph>.</source>
          <target state="translated">Se il semaforo di sistema denominato non esiste, viene creato con il conteggio iniziale e conteggio massimo specificati da <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the named system semaphore already exists, <ph id="ph1">`initialCount`</ph> and <ph id="ph2">`maximumCount`</ph> are not used, although invalid values still cause exceptions.</source>
          <target state="translated">Se il semaforo di sistema denominato esiste già, <ph id="ph1">`initialCount`</ph> e <ph id="ph2">`maximumCount`</ph> non vengono utilizzati anche se i valori non validi comunque causano eccezioni.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Use the <ph id="ph1">`createdNew`</ph> parameter to determine whether the system semaphore was created by this constructor.</source>
          <target state="translated">Utilizzare il <ph id="ph1">`createdNew`</ph> parametro per determinare se il semaforo di sistema è stato creato da questo costruttore.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If <ph id="ph1">`initialCount`</ph> is less than <ph id="ph2">`maximumCount`</ph>, and <ph id="ph3">`createdNew`</ph> is <ph id="ph4">`true`</ph>, the effect is the same as if the current thread had called <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> minus <ph id="ph7">`initialCount`</ph>) times.</source>
          <target state="translated">Se <ph id="ph1">`initialCount`</ph> è minore di <ph id="ph2">`maximumCount`</ph>, e <ph id="ph3">`createdNew`</ph> è <ph id="ph4">`true`</ph>, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <ph id="ph5">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id="ph6">`maximumCount`</ph> meno <ph id="ph7">`initialCount`</ph>) volte.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you specify <ph id="ph1">`null`</ph> or an empty string for <ph id="ph2">`name`</ph>, a local semaphore is created, as if you had called the <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.</source>
          <target state="translated">Se si specifica <ph id="ph1">`null`</ph> o una stringa vuota per <ph id="ph2">`name`</ph>, viene creato un semaforo locale, come se fosse stato chiamato il <ph id="ph3">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> overload del costruttore.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>In this case, <ph id="ph1">`createdNew`</ph> is always <ph id="ph2">`true`</ph>.</source>
          <target state="translated">In questo caso, <ph id="ph1">`createdNew`</ph> è sempre <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</source>
          <target state="translated">Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti di processo.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> overload del metodo per verificare l'esistenza di un semaforo denominato.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">L'eccezione viene intercettata e nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> è maggiore di <ph id="ph2">&lt;paramref name="maximumCount" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> supera i 260 caratteri.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maximumCount" /&gt;</ph> è minore di 1.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="initialCount" /&gt;</ph> è minore di 0.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore exists and has access control security, and the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</source>
          <target state="translated">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Errore Win32.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</source>
          <target state="translated">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">per chiamare codice non gestito per creare un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Gets the access control security for a named system semaphore.</source>
          <target state="translated">Ottiene la sicurezza del controllo di accesso per un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security for the named system semaphore.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> che rappresenta la sicurezza del controllo di accesso per il semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> metodo utilizza la seguente combinazione di flag (combinati mediante un'operazione OR bit per bit) per cercare le autorizzazioni: <ph id="ph2">&lt;xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType&gt;</ph>, e <ph id="ph4">&lt;xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">L'utente deve disporre <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> diritti per chiamare questo metodo e il semaforo devono essere aperto con <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType&gt;</ph> diritti.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>On a local semaphore, access control security is irrelevant.</source>
          <target state="translated">Su un semaforo locale, del controllo di accesso è irrilevante.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object does not represent a named system semaphore, this method returns a <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object that grants all rights to any user.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> oggetto non rappresenta un semaforo di sistema denominato, questo metodo restituisce un <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> oggetto che concede tutti i diritti a qualsiasi utente.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> overload del metodo per verificare l'esistenza di un semaforo denominato.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzo del semaforo, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">L'eccezione viene intercettata e nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The access control security for the system semaphore is obtained using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method.</source>
          <target state="translated">La sicurezza del controllo di accesso per il semaforo di sistema viene ottenuta utilizzando il <ph id="ph1">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore, and the user does not have <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> corrente rappresenta un semaforo di sistema denominato e l'utente non dispone di diritti <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object represents a named system semaphore and was not opened with <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph> rights.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> corrente rappresenta un semaforo di sistema denominato e non è stato aperto con diritti <ph id="ph2">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.GetAccessControl">
          <source>Not supported for Windows 98 or Windows Millennium Edition.</source>
          <target state="translated">Non supportato per Windows 98 o Windows Millennium Edition.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists.</source>
          <target state="translated">Apre un semaforo denominato specificato, se esistente.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">Nome del semaforo di sistema da aprire.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Opens the specified named semaphore, if it already exists.</source>
          <target state="translated">Apre il semaforo denominato specificato, se esistente.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">Oggetto che rappresenta il semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open the specified named semaphore.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> metodo tenta di aprire il semaforo denominato specificato.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> costruttori che dispone di un <ph id="ph2">`name`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">Più chiamate al metodo che utilizzano lo stesso valore per <ph id="ph1">`name`</ph> non restituiscono necessariamente lo stesso <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Questo overload del metodo è equivalente alla chiamata di <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> overload del metodo e specificando <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> diritti, combinati utilizzando l'operazione OR bit per bit.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Specifica il <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag consente a un thread di accedere al semaforo e specificando il <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag consente a un thread di chiamare il <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> overload del metodo per verificare l'esistenza di un semaforo denominato.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload.</source>
          <target state="translated">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> overload del metodo.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">L'eccezione viene intercettata e nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e lo rilascia.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è una stringa vuota.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> supera i 260 caratteri.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">Il semaforo denominato non esiste.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Errore Win32.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>for calling unmanaged code to open a named system semaphore.</source>
          <target state="translated">per chiamare codice non gestito per aprire un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">Nome del semaforo di sistema da aprire.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access.</source>
          <target state="translated">Apre il semaforo denominato specificato, se esistente, con l'accesso di sicurezza desiderato.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>An object that represents the named system semaphore.</source>
          <target state="translated">Oggetto che rappresenta il semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">`rights`</ph> parametro deve includere il <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag per consentire ai thread di accedere al semaforo e <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag per consentire ai thread di chiamare il <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open an existing named semaphore.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> metodo tenta di aprire un semaforo denominato esistente.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</source>
          <target state="translated">Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> costruttori che dispone di un <ph id="ph2">`name`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">Più chiamate al metodo che utilizzano lo stesso valore per <ph id="ph1">`name`</ph> non restituiscono necessariamente lo stesso <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> overload del metodo per verificare l'esistenza di un semaforo denominato.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzo del semaforo, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">L'eccezione viene intercettata e nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</source>
          <target state="translated">Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e lo rilascia.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è una stringa vuota.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> supera i 260 caratteri.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore does not exist.</source>
          <target state="translated">Il semaforo denominato non esiste.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Errore Win32.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>The named semaphore exists, but the user does not have the desired security access rights.</source>
          <target state="translated">Il semaforo denominato esiste, ma l'utente non dispone dei diritti di accesso di sicurezza desiderati.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>for calling unmanaged code to create a named system semaphore.</source>
          <target state="translated">per chiamare codice non gestito per creare un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Enumerazione associata: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)">
          <source>Security action: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</source>
          <target state="translated">Azione di sicurezza: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Exits the semaphore.</source>
          <target state="translated">Esce dal semaforo.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>Exits the semaphore and returns the previous count.</source>
          <target state="translated">Esce dal semaforo e restituisce il conteggio precedente.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated">Conteggio del semaforo prima della chiamata del metodo <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Threads typically use the <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method to enter the semaphore, and they typically use this method overload to exit.</source>
          <target state="translated">In genere, i thread utilizzano il <ph id="ph1">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> metodo immettere in genere il semaforo e utilizzare questo overload del metodo per uscire dall'installazione.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">Se un <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> viene generata dal <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> (metodo), non indica necessariamente un problema con il thread chiamante.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">Tale thread uscite dal semaforo più volte di viene immesso potrebbe essere causato da un errore di programmazione in un altro thread.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">Se l'oggetto corrente <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> diritti e il semaforo deve essere aperto con <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> diritti.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">L'esempio di codice seguente viene creato un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">Il thread principale utilizza i <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Ogni thread Usa la <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> overload del metodo per rilasciare il semaforo.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Utilizzo del semaforo traccia messaggi console.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">L'intervallo di lavoro simulato viene leggermente incrementato per ogni thread, per rendere più facile da leggere l'output.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">Il conteggio del semaforo ha già raggiunto il valore massimo.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">Si è verificato un errore Win32 relativo a un semaforo denominato.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</source>
          <target state="translated">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The number of times to exit the semaphore.</source>
          <target state="translated">Numero di uscite dal semaforo.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Exits the semaphore a specified number of times and returns the previous count.</source>
          <target state="translated">Esce dal semaforo il numero di volte specificato e restituisce il conteggio precedente.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The count on the semaphore before the <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph> method was called.</source>
          <target state="translated">Conteggio del semaforo prima della chiamata del metodo <ph id="ph1">&lt;see cref="Overload:System.Threading.Semaphore.Release" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</source>
          <target state="translated">Se un thread ha immesso il semaforo più volte, overload di questo metodo consente il conteggio del semaforo intero deve essere ripristinato con un'unica chiamata.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.</source>
          <target state="translated">Se un <ph id="ph1">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> viene generata dal <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> (metodo), non indica necessariamente un problema con il thread chiamante.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</source>
          <target state="translated">Tale thread uscite dal semaforo più volte di viene immesso potrebbe essere causato da un errore di programmazione in un altro thread.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>If the current <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights and the semaphore must have been opened with <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">Se l'oggetto corrente <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> diritti e il semaforo deve essere aperto con <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> diritti.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The following code example creates a semaphore with a maximum count of three and an initial count of zero.</source>
          <target state="translated">L'esempio di codice seguente viene creato un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The example starts five threads, which block waiting for the semaphore.</source>
          <target state="translated">Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The main thread uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</source>
          <target state="translated">Il thread principale utilizza i <ph id="ph1">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each thread uses the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to wait for one second, to simulate work, and then calls the <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload to release the semaphore.</source>
          <target state="translated">Ogni thread Usa la <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <ph id="ph2">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> overload del metodo per rilasciare il semaforo.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Each time the semaphore is released, the previous semaphore count is displayed.</source>
          <target state="translated">Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>Console messages track semaphore use.</source>
          <target state="translated">Utilizzo del semaforo traccia messaggi console.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The simulated work interval is increased slightly for each thread, to make the output easier to read.</source>
          <target state="translated">L'intervallo di lavoro simulato viene leggermente incrementato per ogni thread, per rendere più facile da leggere l'output.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph> is less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="releaseCount" /&gt;</ph> è minore di 1.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The semaphore count is already at the maximum value.</source>
          <target state="translated">Il conteggio del semaforo ha già raggiunto il valore massimo.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>A Win32 error occurred with a named semaphore.</source>
          <target state="translated">Si è verificato un errore Win32 relativo a un semaforo denominato.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but the user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di diritti <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.Release(System.Int32)">
          <source>The current semaphore represents a named system semaphore, but it was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph> rights.</source>
          <target state="translated">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con i diritti <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> object that represents the access control security to be applied to the named system semaphore.</source>
          <target state="translated">Oggetto <ph id="ph1">&lt;see cref="T:System.Security.AccessControl.SemaphoreSecurity" /&gt;</ph> che rappresenta la sicurezza del controllo di accesso da applicare al semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>Sets the access control security for a named system semaphore.</source>
          <target state="translated">Imposta la sicurezza del controllo di accesso per un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>You can set access control security only on <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent named system semaphores.</source>
          <target state="translated">È possibile impostare la sicurezza del controllo di accesso solo su <ph id="ph1">&lt;xref:System.Threading.Semaphore&gt;</ph> gli oggetti che rappresentano i semafori di sistema denominato.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user must have <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> rights.</source>
          <target state="translated">L'utente deve disporre <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> diritti per chiamare questo metodo e il semaforo devono essere aperto con <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType&gt;</ph> diritti.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</source>
          <target state="translated">Esempio di codice seguente viene illustrato il comportamento tra più processi di un semaforo denominato con sicurezza del controllo di accesso.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload to test for the existence of a named semaphore.</source>
          <target state="translated">Nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> overload del metodo per verificare l'esistenza di un semaforo denominato.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</source>
          <target state="translated">Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method.</source>
          <target state="translated">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata al <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The exception is caught, and the example uses the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload to open the semaphore with the rights needed to read and change the permissions.</source>
          <target state="translated">L'eccezione viene intercettata e nell'esempio viene utilizzato il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>After the permissions are changed, using the <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph> method, the semaphore is opened with the rights required to enter and release.</source>
          <target state="translated">Dopo la modifica delle autorizzazioni, utilizzando il <ph id="ph1">&lt;xref:System.Threading.Semaphore.SetAccessControl%2A&gt;</ph> (metodo), il semaforo viene aperto con i diritti necessari per immettere e di rilascio.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>If you run the compiled example from a third command window, it runs using the new permissions.</source>
          <target state="translated">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="semaphoreSecurity" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The user does not have <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">L'utente non dispone di diritti <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The semaphore was not opened with <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph> rights.</source>
          <target state="translated">Il semaforo non è stato aperto con i diritti <ph id="ph1">&lt;see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object does not represent a named system semaphore.</source>
          <target state="translated">L'oggetto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> corrente non rappresenta un semaforo di sistema denominato.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="T:System.Threading.Semaphore">
          <source>Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Apre un semaforo denominato specificato, se già esistente, e restituisce un valore che indica se l'operazione è riuscita.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">Nome del semaforo di sistema da aprire.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> che rappresenta il semaforo denominato se la chiamata è riuscita o <ph id="ph2">&lt;see langword="null" /&gt;</ph> se la chiamata non è riuscita.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Questo parametro viene trattato come non inizializzato.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Apre il semaforo denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'apertura del semaforo denominato è riuscita; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">Se il semaforo denominato non esiste, questo metodo non crearlo.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> costruttori che dispone di un <ph id="ph2">`name`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">Se non si è certi dell'esistenza di un semaforo denominato, utilizzare questo overload del metodo anziché il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> overload del metodo che genera un'eccezione se il semaforo non esiste.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>This method overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> method overload and specifying <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> rights, combined by using the bitwise OR operation.</source>
          <target state="translated">Questo overload del metodo è equivalente alla chiamata di <ph id="ph1">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> overload del metodo e specificando <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> diritti, combinati utilizzando l'operazione OR bit per bit.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>Specifying the <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag allows a thread to enter the semaphore, and specifying the   <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag allows a thread to call the <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Specifica il <ph id="ph1">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag consente a un thread di accedere al semaforo e specificando il <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag consente a un thread di chiamare il <ph id="ph3">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è una stringa vuota.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> supera i 260 caratteri.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Errore Win32.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The name of the system semaphore to open.</source>
          <target state="translated">Nome del semaforo di sistema da aprire.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A bitwise combination of the enumeration values that represent the desired security access.</source>
          <target state="translated">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>When this method returns, contains a <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the call failed.</source>
          <target state="translated">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <ph id="ph1">&lt;see cref="T:System.Threading.Semaphore" /&gt;</ph> che rappresenta il semaforo denominato se la chiamata è riuscita o <ph id="ph2">&lt;see langword="null" /&gt;</ph> se la chiamata non è riuscita.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>This parameter is treated as uninitialized.</source>
          <target state="translated">Questo parametro viene trattato come non inizializzato.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</source>
          <target state="translated">Apre il semaforo denominato specificato, se esistente, con l'accesso di sicurezza desiderato, e restituisce un valore che indica se l'operazione è riuscita.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the named semaphore was opened successfully; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se l'apertura del semaforo denominato è riuscita; in caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If the named semaphore does not exist, this method does not create it.</source>
          <target state="translated">Se il semaforo denominato non esiste, questo metodo non crearlo.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>To create the system semaphore when it does not already exist, use one of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id="ph2">`name`</ph> parameter.</source>
          <target state="translated">Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <ph id="ph1">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> costruttori che dispone di un <ph id="ph2">`name`</ph> parametro.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.</source>
          <target state="translated">Se non si è certi dell'esistenza di un semaforo denominato, utilizzare questo overload del metodo anziché il <ph id="ph1">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> overload del metodo che genera un'eccezione se il semaforo non esiste.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The <ph id="ph1">`rights`</ph> parameter must include the <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag to allow threads to call the <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.</source>
          <target state="translated">Il <ph id="ph1">`rights`</ph> parametro deve includere il <ph id="ph2">&lt;xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType&gt;</ph> flag per consentire ai thread di accedere al semaforo e <ph id="ph3">&lt;xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType&gt;</ph> flag per consentire ai thread di chiamare il <ph id="ph4">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>Multiple calls to this method that use the same value for <ph id="ph1">`name`</ph> do not necessarily return the same <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.</source>
          <target state="translated">Più chiamate al metodo che utilizzano lo stesso valore per <ph id="ph1">`name`</ph> non restituiscono necessariamente lo stesso <ph id="ph2">&lt;xref:System.Threading.Semaphore&gt;</ph> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is an empty string.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="name" /&gt;</ph> è una stringa vuota.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>-or-</source>
          <target state="translated">oppure</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is longer than 260 characters.</source>
          <target state="translated">La lunghezza di <ph id="ph1">&lt;paramref name="name" /&gt;</ph> supera i 260 caratteri.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>A Win32 error occurred.</source>
          <target state="translated">Errore Win32.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)">
          <source>The named semaphore exists, but the user does not have the security access required to use it.</source>
          <target state="translated">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>