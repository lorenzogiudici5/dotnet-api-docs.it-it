<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e87fa180884985d655430f6614104ea2d1020256" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39804427" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="aa942-101">Limita il numero di thread che possono accedere simultaneamente a una risorsa o a un pool di risorse.</span>
      <span class="sxs-lookup">
        <span data-stu-id="aa942-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-102">Usare il <xref:System.Threading.Semaphore> classe per controllare l'accesso a un pool di risorse.</span><span class="sxs-lookup"><span data-stu-id="aa942-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="aa942-103">Thread di accedono al semaforo chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo, che viene ereditato dal <xref:System.Threading.WaitHandle> classe e rilasciare il semaforo chiamando il <xref:System.Threading.Semaphore.Release%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="aa942-104">Il conteggio sul semaforo viene decrementato ogni volta che un thread accede al semaforo e incrementato quando un thread rilascia il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="aa942-105">Quando il conteggio è zero, le richieste successive blocca fino a quando gli altri thread rilasciano il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="aa942-106">Quando tutti i thread hanno rilasciato il semaforo, il conteggio viene raggiunto il valore massimo specificato quando è stato creato il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="aa942-107">Non vi è alcun ordine garantito, ad esempio FIFO o LIFO, in cui i thread bloccati al semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="aa942-108">Un thread può accedere al semaforo più volte, chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo più volte.</span><span class="sxs-lookup"><span data-stu-id="aa942-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="aa942-109">Per rilasciare alcune o tutte queste voci, è possibile chiamare il thread senza parametri <xref:System.Threading.Semaphore.Release> overload del metodo più volte o è possibile chiamare il <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo che specifica il numero di voci da rilasciare.</span><span class="sxs-lookup"><span data-stu-id="aa942-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="aa942-110">Il <xref:System.Threading.Semaphore> classe non impone l'identità del thread nelle chiamate a <xref:System.Threading.WaitHandle.WaitOne%2A> o <xref:System.Threading.Semaphore.Release%2A>.</span><span class="sxs-lookup"><span data-stu-id="aa942-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="aa942-111">È responsabilità del programmatore garantire che i thread non rilasciano il semaforo troppe volte.</span><span class="sxs-lookup"><span data-stu-id="aa942-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="aa942-112">Ad esempio, si consideri un semaforo con un conteggio massimo di due e il thread A e B accedano entrambi al semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="aa942-113">Se un errore di programmazione nel thread B fa sì che venga chiamato <xref:System.Threading.Semaphore.Release%2A> due volte, entrambe le chiamate abbia esito positivo.</span><span class="sxs-lookup"><span data-stu-id="aa942-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="aa942-114">Il conteggio sul semaforo è completo e quando il thread A alla fine chiama <xref:System.Threading.Semaphore.Release%2A>, viene generata un'eccezione <xref:System.Threading.SemaphoreFullException>.</span><span class="sxs-lookup"><span data-stu-id="aa942-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="aa942-115">Sono disponibili due tipi: i semafori locali e i semafori denominati di sistema.</span><span class="sxs-lookup"><span data-stu-id="aa942-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="aa942-116">Se si crea un <xref:System.Threading.Semaphore> usando un costruttore che accetta un nome dell'oggetto è associato a un semaforo di sistema operativo di tale nome.</span><span class="sxs-lookup"><span data-stu-id="aa942-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="aa942-117">I semafori sono visibili in tutto il sistema operativo e possono essere utilizzati per sincronizzare le attività dei processi di sistema denominati.</span><span class="sxs-lookup"><span data-stu-id="aa942-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="aa942-118">È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema denominato ed è possibile usare il <xref:System.Threading.Semaphore.OpenExisting%2A> semaforo di sistema denominato metodo per aprire un oggetto esistente.</span><span class="sxs-lookup"><span data-stu-id="aa942-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="aa942-119">Un semaforo locale esiste solo all'interno del processo.</span><span class="sxs-lookup"><span data-stu-id="aa942-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="aa942-120">Può essere usato da qualsiasi thread nel processo che abbia un riferimento all'oggetto <xref:System.Threading.Semaphore> locale.</span><span class="sxs-lookup"><span data-stu-id="aa942-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="aa942-121">Ogni <xref:System.Threading.Semaphore> oggetto è un semaforo locale separato.</span><span class="sxs-lookup"><span data-stu-id="aa942-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-122">Esempio di codice seguente crea un semaforo con un numero massimo di tre e un conteggio iniziale pari a zero.</span><span class="sxs-lookup"><span data-stu-id="aa942-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="aa942-123">L'esempio avviati cinque thread, che bloccherà in attesa per il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="aa942-124">Utilizzate dal thread principale di <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo sul valore massimo, consentendo a tre thread di accedere al semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="aa942-125">Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="aa942-126">Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente.</span><span class="sxs-lookup"><span data-stu-id="aa942-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="aa942-127">Utilizzo di semaforo track messaggi della console.</span><span class="sxs-lookup"><span data-stu-id="aa942-127">Console messages track semaphore use.</span></span> <span data-ttu-id="aa942-128">L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per semplificare la lettura dell'output.</span><span class="sxs-lookup"><span data-stu-id="aa942-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="aa942-129">Questo tipo è thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="aa942-129">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="aa942-130">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-130">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="aa942-131">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-131">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="aa942-132">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-132">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-133">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-133">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-134">Questo costruttore inizializza un semaforo senza nome.</span><span class="sxs-lookup"><span data-stu-id="aa942-134">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="aa942-135">Tutti i thread che usano un'istanza di un semaforo di questo tipo devono avere i riferimenti all'istanza.</span><span class="sxs-lookup"><span data-stu-id="aa942-135">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="aa942-136">Se `initialCount` è minore di `maximumCount`, l'effetto è lo stesso come se avesse chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.</span><span class="sxs-lookup"><span data-stu-id="aa942-136">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="aa942-137">Se non si desidera riservare tutte le voci per il thread che crea il semaforo, usare lo stesso numero per `maximumCount` e `initialCount`.</span><span class="sxs-lookup"><span data-stu-id="aa942-137">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-138">L'esempio seguente crea un semaforo con un numero massimo di tre elementi e un conteggio iniziale pari a zero.</span><span class="sxs-lookup"><span data-stu-id="aa942-138">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="aa942-139">L'esempio avviati cinque thread, che bloccherà in attesa per il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-139">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="aa942-140">Utilizzate dal thread principale di <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo sul valore massimo, consentendo a tre thread di accedere al semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-140">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="aa942-141">Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-141">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="aa942-142">Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente.</span><span class="sxs-lookup"><span data-stu-id="aa942-142">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="aa942-143">Utilizzo di semaforo track messaggi della console.</span><span class="sxs-lookup"><span data-stu-id="aa942-143">Console messages track semaphore use.</span></span> <span data-ttu-id="aa942-144">L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per semplificare la lettura dell'output.</span><span class="sxs-lookup"><span data-stu-id="aa942-144">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aa942-145">
            <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-145">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aa942-146">
            <paramref name="maximumCount" /> è minore di 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-146">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="aa942-147">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-147">-or-</span>
          </span>
          <span data-ttu-id="aa942-148">
            <paramref name="initialCount" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-148">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="aa942-149">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-149">The initial number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="aa942-150">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-150">The maximum number of requests for the semaphore that can be granted concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="aa942-151">Nome di un oggetto semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-151">The name of a named system semaphore object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-152">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, nonché indicando facoltativamente il nome di un oggetto semaforo di sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-152">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-153">Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-153">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="aa942-154">È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-154">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="aa942-155">Se il semaforo di sistema denominato non esiste, viene creato con il numero iniziale e conteggio massimo specificato da `initialCount` e `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="aa942-155">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="aa942-156">Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono usati, anche se i valori non validi causano eccezioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-156">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="aa942-157">Se è necessario determinare se è stato creato un semaforo di sistema denominato, usare il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> overload del costruttore.</span><span class="sxs-lookup"><span data-stu-id="aa942-157">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="aa942-158">Quando si utilizza questo overload del costruttore, la procedura consigliata consiste nello specificare lo stesso numero per `initialCount` e `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="aa942-158">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="aa942-159">Se `initialCount` è minore di `maximumCount`e viene creato un semaforo di sistema denominato, l'effetto è lo stesso come se avesse chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.</span><span class="sxs-lookup"><span data-stu-id="aa942-159">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="aa942-160">Tuttavia, con questo overload del costruttore non è un modo per determinare se è stato creato un semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-160">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="aa942-161">Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore.</span><span class="sxs-lookup"><span data-stu-id="aa942-161">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="aa942-162">Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti dei processi.</span><span class="sxs-lookup"><span data-stu-id="aa942-162">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="aa942-163">Se si desidera verificare l'esistenza di un semaforo di sistema denominato, usare il <xref:System.Threading.Semaphore.OpenExisting%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-163">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="aa942-164">Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire un semaforo denominato esistente e genera un'eccezione se il semaforo di sistema non esiste.</span><span class="sxs-lookup"><span data-stu-id="aa942-164">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-165">Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-165">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="aa942-166">Nell'esempio viene creato un semaforo denominato con un numero massimo di cinque e un conteggio iniziale pari a cinque.</span><span class="sxs-lookup"><span data-stu-id="aa942-166">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="aa942-167">Il programma effettua tre chiamate per il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-167">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="aa942-168">Di conseguenza, se si esegue l'esempio compilato in due finestre di comando, la seconda copia bloccherà la terza chiamata a <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="aa942-168">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="aa942-169">Rilasciare una o più voci nella prima copia del programma per sbloccare il secondo.</span><span class="sxs-lookup"><span data-stu-id="aa942-169">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aa942-170">
            <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-170">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="aa942-171">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-171">-or-</span>
          </span>
          <span data-ttu-id="aa942-172">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-172">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aa942-173">
            <paramref name="maximumCount" /> è minore di 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-173">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="aa942-174">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-174">-or-</span>
          </span>
          <span data-ttu-id="aa942-175">
            <paramref name="initialCount" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-175">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="aa942-176">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-176">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-177">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-177">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="aa942-178">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-178">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="aa942-179">per chiamare codice non gestito per creare un semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-179">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="aa942-180">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-180">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="aa942-181">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-181">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="aa942-182">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-182">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="aa942-183">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-183">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="aa942-184">Nome di un oggetto semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-184">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="aa942-185">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un semaforo locale (ovvero, se il valore di <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato. <see langword="false" /> se il semaforo di sistema denominato specificato è già esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-185">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="aa942-186">Questo parametro viene passato non inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-186">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-187">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema e specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-187">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-188">Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-188">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="aa942-189">È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-189">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="aa942-190">Se il semaforo di sistema denominato non esiste, viene creato con il numero iniziale e conteggio massimo specificato da `initialCount` e `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="aa942-190">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="aa942-191">Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono usati, anche se i valori non validi causano eccezioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-191">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="aa942-192">Usare `createdNew` per determinare se è stato creato il semaforo di sistema.</span><span class="sxs-lookup"><span data-stu-id="aa942-192">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="aa942-193">Se `initialCount` è minore di `maximumCount`, e `createdNew` viene `true`, l'effetto è lo stesso come se avesse chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.</span><span class="sxs-lookup"><span data-stu-id="aa942-193">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="aa942-194">Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore.</span><span class="sxs-lookup"><span data-stu-id="aa942-194">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="aa942-195">In questo caso `createdNew` è sempre `true`.</span><span class="sxs-lookup"><span data-stu-id="aa942-195">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="aa942-196">Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti dei processi.</span><span class="sxs-lookup"><span data-stu-id="aa942-196">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-197">Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-197">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="aa942-198">Nell'esempio viene creato un semaforo denominato con un numero massimo di cinque e un conteggio iniziale di due.</span><span class="sxs-lookup"><span data-stu-id="aa942-198">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="aa942-199">Vale a dire, sono riservati e tre le voci per il thread che chiama il costruttore.</span><span class="sxs-lookup"><span data-stu-id="aa942-199">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="aa942-200">Se `createNew` viene `false`, il programma effettua tre chiamate per il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-200">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="aa942-201">Di conseguenza, se si esegue l'esempio compilato in due finestre di comando, la seconda copia bloccherà la terza chiamata a <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="aa942-201">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="aa942-202">Rilasciare una o più voci nella prima copia del programma per sbloccare il secondo.</span><span class="sxs-lookup"><span data-stu-id="aa942-202">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aa942-203">
            <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-203">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="aa942-204">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-204">-or-</span>
          </span>
          <span data-ttu-id="aa942-205">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-205">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aa942-206">
            <paramref name="maximumCount" /> è minore di 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-206">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="aa942-207">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-207">-or-</span>
          </span>
          <span data-ttu-id="aa942-208">
            <paramref name="initialCount" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-208">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="aa942-209">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-209">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-210">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-210">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="aa942-211">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-211">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="aa942-212">per chiamare codice non gestito per creare un semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-212">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="aa942-213">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-213">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="aa942-214">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-214">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">
          <span data-ttu-id="aa942-215">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-215">The initial number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="maximumCount">
          <span data-ttu-id="aa942-216">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-216">The maximum number of requests for the semaphore that can be satisfied concurrently.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="aa942-217">Nome di un oggetto semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-217">The name of a named system semaphore object.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="aa942-218">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un semaforo locale (ovvero, se il valore di <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato. <see langword="false" /> se il semaforo di sistema denominato specificato è già esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-218">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span>
          </span>
          <span data-ttu-id="aa942-219">Questo parametro viene passato non inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-219">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="semaphoreSecurity">
          <span data-ttu-id="aa942-220">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare al semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-220">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-221">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero iniziale di accessi e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema, specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema e specificando la sicurezza del controllo di accesso per il semaforo di sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-221">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-222">Utilizzare questo costruttore per applicare la sicurezza del controllo di accesso a un semaforo di sistema denominato al momento della creazione, impedendo ad altro codice di assumere il controllo del semaforo di.</span><span class="sxs-lookup"><span data-stu-id="aa942-222">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="aa942-223">Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-223">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="aa942-224">È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-224">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="aa942-225">Se il semaforo di sistema denominato non esiste, viene creato con la sicurezza del controllo di accesso specificato.</span><span class="sxs-lookup"><span data-stu-id="aa942-225">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="aa942-226">Se il semaforo denominato esiste, la sicurezza del controllo di accesso specificato viene ignorata.</span><span class="sxs-lookup"><span data-stu-id="aa942-226">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="aa942-227">Il chiamante dispone di controllo completo sull'oggetto appena creato <xref:System.Threading.Semaphore> oggetto anche se `semaphoreSecurity` nega o non riesce a concedere alcuni diritti di accesso per l'utente corrente.</span><span class="sxs-lookup"><span data-stu-id="aa942-227">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="aa942-228">Tuttavia, se l'utente corrente tenta di ottenere un'altra <xref:System.Threading.Semaphore> per rappresentare lo stesso semaforo denominato, usando un costruttore dell'oggetto o il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo, viene applicata la sicurezza del controllo di accesso di Windows.</span><span class="sxs-lookup"><span data-stu-id="aa942-228">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="aa942-229">Se il semaforo di sistema denominato non esiste, viene creato con il numero iniziale e conteggio massimo specificato da `initialCount` e `maximumCount`.</span><span class="sxs-lookup"><span data-stu-id="aa942-229">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="aa942-230">Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono usati, anche se i valori non validi causano eccezioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-230">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="aa942-231">Usare il `createdNew` parametro per determinare se il semaforo di sistema è stato creato da questo costruttore.</span><span class="sxs-lookup"><span data-stu-id="aa942-231">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="aa942-232">Se `initialCount` è minore di `maximumCount`, e `createdNew` viene `true`, l'effetto è lo stesso come se avesse chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.</span><span class="sxs-lookup"><span data-stu-id="aa942-232">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="aa942-233">Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore.</span><span class="sxs-lookup"><span data-stu-id="aa942-233">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="aa942-234">In questo caso `createdNew` è sempre `true`.</span><span class="sxs-lookup"><span data-stu-id="aa942-234">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="aa942-235">Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti dei processi.</span><span class="sxs-lookup"><span data-stu-id="aa942-235">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-236">Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi.</span><span class="sxs-lookup"><span data-stu-id="aa942-236">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="aa942-237">Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-237">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="aa942-238">Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso che nega il diritto di utilizzare il semaforo l'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-238">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="aa942-239">Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-239">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="aa942-240">Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-240">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="aa942-241">Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare.</span><span class="sxs-lookup"><span data-stu-id="aa942-241">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="aa942-242">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-242">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aa942-243">
            <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-243">
              <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span>
          </span>
          <span data-ttu-id="aa942-244">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-244">-or-</span>
          </span>
          <span data-ttu-id="aa942-245">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-245">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aa942-246">
            <paramref name="maximumCount" /> è minore di 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-246">
              <paramref name="maximumCount" /> is less than 1.</span>
          </span>
          <span data-ttu-id="aa942-247">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-247">-or-</span>
          </span>
          <span data-ttu-id="aa942-248">
            <paramref name="initialCount" /> è minore di 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-248">
              <paramref name="initialCount" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-249">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-249">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="aa942-250">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-250">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="aa942-251">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-251">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="aa942-252">per chiamare codice non gestito per creare un semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-252">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="aa942-253">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-253">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="aa942-254">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-254">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="aa942-255">Ottiene la sicurezza del controllo di accesso per un semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-255">Gets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aa942-256">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> che rappresenta la sicurezza del controllo di accesso per il semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-256">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-257">Il <xref:System.Threading.Semaphore.GetAccessControl%2A> metodo utilizza la seguente combinazione di flag (combinati mediante un'operazione OR bit per bit) per cercare le autorizzazioni: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="aa942-257">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="aa942-258">L'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> diritti di chiamare questo metodo e il semaforo necessario sia stato aperto con <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> diritti.</span><span class="sxs-lookup"><span data-stu-id="aa942-258">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="aa942-259">Su un semaforo locale, controllo degli accessi è irrilevante.</span><span class="sxs-lookup"><span data-stu-id="aa942-259">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="aa942-260">Se il <xref:System.Threading.Semaphore> oggetto non rappresenta un semaforo di sistema denominato, questo metodo restituisce un <xref:System.Security.AccessControl.SemaphoreSecurity> che concessa tutti i diritti a tutti gli utenti.</span><span class="sxs-lookup"><span data-stu-id="aa942-260">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-261">Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi.</span><span class="sxs-lookup"><span data-stu-id="aa942-261">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="aa942-262">Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-262">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="aa942-263">Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso che nega il diritto di utilizzare il semaforo l'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-263">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="aa942-264">Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-264">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="aa942-265">Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-265">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="aa942-266">La sicurezza del controllo di accesso per il semaforo di sistema viene ottenuta usando la <xref:System.Threading.Semaphore.GetAccessControl%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-266">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="aa942-267">Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare.</span><span class="sxs-lookup"><span data-stu-id="aa942-267">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="aa942-268">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-268">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-269">L'oggetto <see cref="T:System.Threading.Semaphore" /> corrente rappresenta un semaforo di sistema denominato e l'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-269">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
          <span data-ttu-id="aa942-270">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-270">-or-</span>
          </span>
          <span data-ttu-id="aa942-271">L'oggetto <see cref="T:System.Threading.Semaphore" /> corrente rappresenta un semaforo di sistema denominato e non è stato aperto con diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-271">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="aa942-272">Non supportato per Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-272">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="aa942-273">Apre un semaforo denominato specificato, se esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-273">Opens a specified named semaphore, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="aa942-274">Nome del semaforo di sistema da aprire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-274">The name of the system semaphore to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-275">Apre il semaforo denominato specificato, se esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-275">Opens the specified named semaphore, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aa942-276">Oggetto che rappresenta il semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-276">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-277">Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire il semaforo denominato specificato.</span><span class="sxs-lookup"><span data-stu-id="aa942-277">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="aa942-278">Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema.</span><span class="sxs-lookup"><span data-stu-id="aa942-278">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="aa942-279">Per creare il semaforo di sistema quando non esiste già, usare uno dei <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.</span><span class="sxs-lookup"><span data-stu-id="aa942-279">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="aa942-280">Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-280">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="aa942-281">Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.Semaphore.OpenExisting%2A> overload del metodo e specificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit.</span><span class="sxs-lookup"><span data-stu-id="aa942-281">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="aa942-282">Specificando il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag consente di entrare nel semaforo, un thread e specificando le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-282">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-283">Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi.</span><span class="sxs-lookup"><span data-stu-id="aa942-283">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="aa942-284">Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-284">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="aa942-285">Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso dell'utente corrente che nega il diritto di utilizzare il semaforo, ma che concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-285">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="aa942-286">Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="aa942-286">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="aa942-287">Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-287">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="aa942-288">Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciarlo.</span><span class="sxs-lookup"><span data-stu-id="aa942-288">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="aa942-289">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-289">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aa942-290">Il parametro <paramref name="name" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-290">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="aa942-291">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-291">-or-</span>
          </span>
          <span data-ttu-id="aa942-292">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-292">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aa942-293">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-293">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="aa942-294">Il semaforo denominato non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-294">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="aa942-295">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-295">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-296">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-296">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="aa942-297">per chiamare codice non gestito per aprire un semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-297">for calling unmanaged code to open a named system semaphore.</span>
          </span>
          <span data-ttu-id="aa942-298">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="aa942-299">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-299">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="aa942-300">Nome del semaforo di sistema da aprire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-300">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="aa942-301">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-301">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-302">Apre il semaforo denominato specificato, se esistente, con l'accesso di sicurezza desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-302">Opens the specified named semaphore, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aa942-303">Oggetto che rappresenta il semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-303">An object that represents the named system semaphore.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-304">Il `rights` parametro deve includere il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread di accedere al semaforo e il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag per consentire ai thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-304">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="aa942-305">Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire un semaforo denominato esistente.</span><span class="sxs-lookup"><span data-stu-id="aa942-305">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="aa942-306">Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema.</span><span class="sxs-lookup"><span data-stu-id="aa942-306">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="aa942-307">Per creare il semaforo di sistema quando non esiste già, usare uno dei <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.</span><span class="sxs-lookup"><span data-stu-id="aa942-307">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="aa942-308">Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-308">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-309">Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi.</span><span class="sxs-lookup"><span data-stu-id="aa942-309">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="aa942-310">Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-310">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="aa942-311">Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso che nega il diritto di utilizzare il semaforo l'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-311">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="aa942-312">Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-312">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="aa942-313">Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-313">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="aa942-314">Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciarlo.</span><span class="sxs-lookup"><span data-stu-id="aa942-314">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="aa942-315">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-315">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aa942-316">Il parametro <paramref name="name" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-316">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="aa942-317">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-317">-or-</span>
          </span>
          <span data-ttu-id="aa942-318">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-318">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aa942-319">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-319">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="aa942-320">Il semaforo denominato non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-320">The named semaphore does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="aa942-321">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-321">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-322">Il semaforo denominato esiste, ma l'utente non dispone dei diritti di accesso di sicurezza desiderati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-322">The named semaphore exists, but the user does not have the desired security access rights.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="aa942-323">per chiamare codice non gestito per creare un semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-323">for calling unmanaged code to create a named system semaphore.</span>
          </span>
          <span data-ttu-id="aa942-324">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-324">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
          <span data-ttu-id="aa942-325">Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-325">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="aa942-326">Esce dal semaforo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-326">Exits the semaphore.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="aa942-327">Esce dal semaforo e restituisce il conteggio precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-327">Exits the semaphore and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aa942-328">Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-328">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-329">Thread usano in genere il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo per immettere il semaforo che in genere utilizzare questo overload del metodo per uscire.</span><span class="sxs-lookup"><span data-stu-id="aa942-329">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="aa942-330">Se un <xref:System.Threading.SemaphoreFullException> generata dal <xref:System.Threading.Semaphore.Release%2A> metodo, non indica necessariamente un problema con il thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="aa942-330">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="aa942-331">Un errore di programmazione in un altro thread potrebbe aver causato tale thread uscite dal semaforo più volte rispetto agli accessi.</span><span class="sxs-lookup"><span data-stu-id="aa942-331">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="aa942-332">Se l'oggetto corrente <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti e il semaforo necessario sia stato aperto con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti.</span><span class="sxs-lookup"><span data-stu-id="aa942-332">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-333">Esempio di codice seguente crea un semaforo con un numero massimo di tre e un conteggio iniziale pari a zero.</span><span class="sxs-lookup"><span data-stu-id="aa942-333">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="aa942-334">L'esempio avviati cinque thread, che bloccherà in attesa per il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-334">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="aa942-335">Utilizzate dal thread principale di <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo sul valore massimo, consentendo a tre thread di accedere al semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-335">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="aa942-336">Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-336">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="aa942-337">Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente.</span><span class="sxs-lookup"><span data-stu-id="aa942-337">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="aa942-338">Utilizzo di semaforo track messaggi della console.</span><span class="sxs-lookup"><span data-stu-id="aa942-338">Console messages track semaphore use.</span></span> <span data-ttu-id="aa942-339">L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per semplificare la lettura dell'output.</span><span class="sxs-lookup"><span data-stu-id="aa942-339">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="aa942-340">Il conteggio del semaforo ha già raggiunto il valore massimo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-340">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="aa942-341">Si è verificato un errore Win32 relativo a un semaforo denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-341">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-342">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-342">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
          <span data-ttu-id="aa942-343">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-343">-or-</span>
          </span>
          <span data-ttu-id="aa942-344">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-344">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">
          <span data-ttu-id="aa942-345">Numero di uscite dal semaforo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-345">The number of times to exit the semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-346">Esce dal semaforo il numero di volte specificato e restituisce il conteggio precedente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-346">Exits the semaphore a specified number of times and returns the previous count.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aa942-347">Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-347">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-348">Se un thread ha acceduto al semaforo più volte, questo overload del metodo consente il conteggio del semaforo intero deve essere ripristinato con una sola chiamata.</span><span class="sxs-lookup"><span data-stu-id="aa942-348">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="aa942-349">Se un <xref:System.Threading.SemaphoreFullException> generata dal <xref:System.Threading.Semaphore.Release%2A> metodo, non indica necessariamente un problema con il thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="aa942-349">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="aa942-350">Un errore di programmazione in un altro thread potrebbe aver causato tale thread uscite dal semaforo più volte rispetto agli accessi.</span><span class="sxs-lookup"><span data-stu-id="aa942-350">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="aa942-351">Se l'oggetto corrente <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti e il semaforo necessario sia stato aperto con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti.</span><span class="sxs-lookup"><span data-stu-id="aa942-351">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-352">Esempio di codice seguente crea un semaforo con un numero massimo di tre e un conteggio iniziale pari a zero.</span><span class="sxs-lookup"><span data-stu-id="aa942-352">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="aa942-353">L'esempio avviati cinque thread, che bloccherà in attesa per il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-353">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="aa942-354">Utilizzate dal thread principale di <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo sul valore massimo, consentendo a tre thread di accedere al semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-354">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="aa942-355">Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-355">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="aa942-356">Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente.</span><span class="sxs-lookup"><span data-stu-id="aa942-356">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="aa942-357">Utilizzo di semaforo track messaggi della console.</span><span class="sxs-lookup"><span data-stu-id="aa942-357">Console messages track semaphore use.</span></span> <span data-ttu-id="aa942-358">L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per semplificare la lettura dell'output.</span><span class="sxs-lookup"><span data-stu-id="aa942-358">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="aa942-359">
            <paramref name="releaseCount" /> è minore di 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-359">
              <paramref name="releaseCount" /> is less than 1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SemaphoreFullException">
          <span data-ttu-id="aa942-360">Il conteggio del semaforo ha già raggiunto il valore massimo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-360">The semaphore count is already at the maximum value.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="aa942-361">Si è verificato un errore Win32 relativo a un semaforo denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-361">A Win32 error occurred with a named semaphore.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-362">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-362">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
          <span data-ttu-id="aa942-363">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-363">-or-</span>
          </span>
          <span data-ttu-id="aa942-364">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con i diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-364">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">
          <span data-ttu-id="aa942-365">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare al semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-365">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-366">Imposta la sicurezza del controllo di accesso per un semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-366">Sets the access control security for a named system semaphore.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-367">È possibile impostare la sicurezza del controllo di accesso solo su <xref:System.Threading.Semaphore> gli oggetti che rappresentano i semafori denominati di sistema.</span><span class="sxs-lookup"><span data-stu-id="aa942-367">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="aa942-368">L'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> diritti di chiamare questo metodo e il semaforo necessario sia stato aperto con <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> diritti.</span><span class="sxs-lookup"><span data-stu-id="aa942-368">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="aa942-369">Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi.</span><span class="sxs-lookup"><span data-stu-id="aa942-369">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="aa942-370">Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-370">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="aa942-371">Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso che nega il diritto di utilizzare il semaforo l'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.</span><span class="sxs-lookup"><span data-stu-id="aa942-371">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="aa942-372">Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-372">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="aa942-373">Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-373">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="aa942-374">Dopo la modifica delle autorizzazioni, usando il <xref:System.Threading.Semaphore.SetAccessControl%2A> metodo, il semaforo viene aperto con i diritti necessari per immettere e rilasciare.</span><span class="sxs-lookup"><span data-stu-id="aa942-374">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="aa942-375">Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="aa942-375">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aa942-376">
            <paramref name="semaphoreSecurity" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-376">
              <paramref name="semaphoreSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-377">L'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-377">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
          <span data-ttu-id="aa942-378">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-378">-or-</span>
          </span>
          <span data-ttu-id="aa942-379">Il semaforo non è stato aperto con i diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-379">The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="aa942-380">L'oggetto <see cref="T:System.Threading.Semaphore" /> corrente non rappresenta un semaforo di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-380">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="aa942-381">Apre un semaforo denominato specificato, se già esistente, e restituisce un valore che indica se l'operazione è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-381">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="aa942-382">Nome del semaforo di sistema da aprire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-382">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="aa942-383">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <see cref="T:System.Threading.Semaphore" /> che rappresenta il semaforo denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-383">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="aa942-384">Questo parametro viene trattato come non inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-384">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-385">Apre il semaforo denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-385">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aa942-386">
            <see langword="true" /> se l'apertura del semaforo denominato è riuscita; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-386">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-387">Se il semaforo denominato non esiste, questo metodo non crearla.</span><span class="sxs-lookup"><span data-stu-id="aa942-387">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="aa942-388">Per creare il semaforo di sistema quando non esiste già, usare uno dei <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.</span><span class="sxs-lookup"><span data-stu-id="aa942-388">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="aa942-389">Se non si è certi se un semaforo denominato esiste, utilizzare questo overload del metodo anziché il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo che genera un'eccezione se il semaforo denominato non esiste.</span><span class="sxs-lookup"><span data-stu-id="aa942-389">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="aa942-390">Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.Semaphore.TryOpenExisting%2A> overload del metodo e specificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit.</span><span class="sxs-lookup"><span data-stu-id="aa942-390">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="aa942-391">Specificando il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag consente di entrare nel semaforo, un thread e specificando le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-391">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aa942-392">Il parametro <paramref name="name" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-392">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="aa942-393">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-393">-or-</span>
          </span>
          <span data-ttu-id="aa942-394">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-394">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aa942-395">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-395">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="aa942-396">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-396">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-397">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-397">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="aa942-398">Nome del semaforo di sistema da aprire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-398">The name of the system semaphore to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="aa942-399">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-399">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="aa942-400">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <see cref="T:System.Threading.Semaphore" /> che rappresenta il semaforo denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-400">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="aa942-401">Questo parametro viene trattato come non inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-401">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="aa942-402">Apre il semaforo denominato specificato, se esistente, con l'accesso di sicurezza desiderato, e restituisce un valore che indica se l'operazione è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-402">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="aa942-403">
            <see langword="true" /> se l'apertura del semaforo denominato è riuscita; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-403">
              <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa942-404">Se il semaforo denominato non esiste, questo metodo non crearla.</span><span class="sxs-lookup"><span data-stu-id="aa942-404">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="aa942-405">Per creare il semaforo di sistema quando non esiste già, usare uno dei <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.</span><span class="sxs-lookup"><span data-stu-id="aa942-405">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="aa942-406">Se non si è certi se un semaforo denominato esiste, utilizzare questo overload del metodo anziché il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo che genera un'eccezione se il semaforo denominato non esiste.</span><span class="sxs-lookup"><span data-stu-id="aa942-406">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="aa942-407">Il `rights` parametro deve includere il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread di accedere al semaforo e il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag per consentire ai thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="aa942-407">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="aa942-408">Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="aa942-408">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="aa942-409">Il parametro <paramref name="name" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-409">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="aa942-410">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-410">-or-</span>
          </span>
          <span data-ttu-id="aa942-411">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-411">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="aa942-412">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-412">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="aa942-413">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-413">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="aa942-414">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="aa942-414">The named semaphore exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>