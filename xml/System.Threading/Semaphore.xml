<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="dfd4af5a6146da7c3a1e0bf3e9198f1ae1ef7404" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52214170" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limita il numero di thread che possono accedere simultaneamente a una risorsa o a un pool di risorse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare il <xref:System.Threading.Semaphore> classe per controllare l'accesso a un pool di risorse. Thread di accedono al semaforo chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo, che viene ereditato dal <xref:System.Threading.WaitHandle> classe e rilasciare il semaforo chiamando il <xref:System.Threading.Semaphore.Release%2A> (metodo).  
  
 Il conteggio sul semaforo viene decrementato ogni volta che un thread accede al semaforo e incrementato quando un thread rilascia il semaforo. Quando il conteggio è zero, le richieste successive blocca fino a quando gli altri thread rilasciano il semaforo. Quando tutti i thread hanno rilasciato il semaforo, il conteggio viene raggiunto il valore massimo specificato quando è stato creato il semaforo.  
  
 Non vi è alcun ordine garantito, ad esempio FIFO o LIFO, in cui i thread bloccati al semaforo.  
  
 Un thread può accedere al semaforo più volte, chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo più volte. Per rilasciare alcune o tutte queste voci, è possibile chiamare il thread senza parametri <xref:System.Threading.Semaphore.Release> overload del metodo più volte o è possibile chiamare il <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo che specifica il numero di voci da rilasciare.  
  
 Il <xref:System.Threading.Semaphore> classe non impone l'identità del thread nelle chiamate a <xref:System.Threading.WaitHandle.WaitOne%2A> o <xref:System.Threading.Semaphore.Release%2A>. È responsabilità del programmatore garantire che i thread non rilasciano il semaforo troppe volte. Ad esempio, si consideri un semaforo con un conteggio massimo di due e il thread A e B accedano entrambi al semaforo. Se un errore di programmazione nel thread B fa sì che venga chiamato <xref:System.Threading.Semaphore.Release%2A> due volte, entrambe le chiamate abbia esito positivo. Il conteggio sul semaforo è completo e quando il thread A alla fine chiama <xref:System.Threading.Semaphore.Release%2A>, viene generata un'eccezione <xref:System.Threading.SemaphoreFullException>.  
  
 Sono disponibili due tipi: i semafori locali e i semafori denominati di sistema. Se si crea un <xref:System.Threading.Semaphore> usando un costruttore che accetta un nome dell'oggetto è associato a un semaforo di sistema operativo di tale nome. I semafori sono visibili in tutto il sistema operativo e possono essere utilizzati per sincronizzare le attività dei processi di sistema denominati. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema denominato ed è possibile usare il <xref:System.Threading.Semaphore.OpenExisting%2A> semaforo di sistema denominato metodo per aprire un oggetto esistente.  
  
 Un semaforo locale esiste solo all'interno del processo. Può essere usato da qualsiasi thread nel processo che abbia un riferimento all'oggetto <xref:System.Threading.Semaphore> locale. Ogni <xref:System.Threading.Semaphore> oggetto è un semaforo locale separato.  
  
   
  
## Examples  
 Esempio di codice seguente crea un semaforo con un numero massimo di tre e un conteggio iniziale pari a zero. L'esempio avviati cinque thread, che bloccherà in attesa per il semaforo. Utilizzate dal thread principale di <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo sul valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo. Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo di semaforo track messaggi della console. L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per semplificare la lettura dell'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
        <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un semaforo senza nome. Tutti i thread che usano un'istanza di un semaforo di questo tipo devono avere i riferimenti all'istanza.  
  
 Se `initialCount` è minore di `maximumCount`, l'effetto è lo stesso come se avesse chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte. Se non si desidera riservare tutte le voci per il thread che crea il semaforo, usare lo stesso numero per `maximumCount` e `initialCount`.  
  
   
  
## Examples  
 L'esempio seguente crea un semaforo con un numero massimo di tre elementi e un conteggio iniziale pari a zero. L'esempio avviati cinque thread, che bloccherà in attesa per il semaforo. Utilizzate dal thread principale di <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo sul valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo. Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo di semaforo track messaggi della console. L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per semplificare la lettura dell'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> è minore di 1.  
  
oppure 
 <paramref name="initialCount" /> è minore di 0.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere concesse simultaneamente.</param>
        <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere concesse simultaneamente.</param>
        <param name="name">Nome di un oggetto semaforo di sistema denominato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, nonché indicando facoltativamente il nome di un oggetto semaforo di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema denominato.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con il numero iniziale e conteggio massimo specificato da `initialCount` e `maximumCount`. Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono usati, anche se i valori non validi causano eccezioni. Se è necessario determinare se è stato creato un semaforo di sistema denominato, usare il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> overload del costruttore.  
  
> [!IMPORTANT]
>  Quando si utilizza questo overload del costruttore, la procedura consigliata consiste nello specificare lo stesso numero per `initialCount` e `maximumCount`. Se `initialCount` è minore di `maximumCount`e viene creato un semaforo di sistema denominato, l'effetto è lo stesso come se avesse chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte. Tuttavia, con questo overload del costruttore non è un modo per determinare se è stato creato un semaforo di sistema denominato.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore.  
  
 Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti dei processi.  
  
 Se si desidera verificare l'esistenza di un semaforo di sistema denominato, usare il <xref:System.Threading.Semaphore.OpenExisting%2A> (metodo). Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire un semaforo denominato esistente e genera un'eccezione se il semaforo di sistema non esiste.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato. Nell'esempio viene creato un semaforo denominato con un numero massimo di cinque e un conteggio iniziale pari a cinque. Il programma effettua tre chiamate per il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo). Di conseguenza, se si esegue l'esempio compilato in due finestre di comando, la seconda copia bloccherà la terza chiamata a <xref:System.Threading.WaitHandle.WaitOne%2A>. Rilasciare una o più voci nella prima copia del programma per sbloccare il secondo.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> è minore di 1.  
  
oppure 
 <paramref name="initialCount" /> è minore di 0.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
        <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
        <param name="name">Nome di un oggetto semaforo di sistema denominato.</param>
        <param name="createdNew">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un semaforo locale (ovvero, se il valore di <paramref name="name" /> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato; <see langword="false" /> se il semaforo di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero di accessi iniziale e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema e specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema denominato.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con il numero iniziale e conteggio massimo specificato da `initialCount` e `maximumCount`. Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono usati, anche se i valori non validi causano eccezioni. Usare `createdNew` per determinare se è stato creato il semaforo di sistema.  
  
 Se `initialCount` è minore di `maximumCount`, e `createdNew` viene `true`, l'effetto è lo stesso come se avesse chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore. In questo caso `createdNew` è sempre `true`.  
  
 Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti dei processi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato. Nell'esempio viene creato un semaforo denominato con un numero massimo di cinque e un conteggio iniziale di due. Vale a dire, sono riservati e tre le voci per il thread che chiama il costruttore. Se `createNew` viene `false`, il programma effettua tre chiamate per il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo). Di conseguenza, se si esegue l'esempio compilato in due finestre di comando, la seconda copia bloccherà la terza chiamata a <xref:System.Threading.WaitHandle.WaitOne%2A>. Rilasciare una o più voci nella prima copia del programma per sbloccare il secondo.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> è minore di 1.  
  
oppure 
 <paramref name="initialCount" /> è minore di 0.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">Numero iniziale di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
        <param name="maximumCount">Numero massimo di richieste per il semaforo che possono essere soddisfatte contemporaneamente.</param>
        <param name="name">Nome di un oggetto semaforo di sistema denominato.</param>
        <param name="createdNew">Quando questo metodo viene restituito, contiene <see langword="true" /> se è stato creato un semaforo locale (ovvero, se il valore di <paramref name="name" /> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il semaforo di sistema denominato specificato; <see langword="false" /> se il semaforo di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <param name="semaphoreSecurity">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare al semaforo di sistema denominato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Semaphore" />, specificando il numero iniziale di accessi e il numero massimo di accessi contemporanei, indicando facoltativamente il nome di un oggetto semaforo di sistema, specificando una variabile che riceve un valore che indica se è stato creato un nuovo semaforo di sistema e specificando la sicurezza del controllo di accesso per il semaforo di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per applicare la sicurezza del controllo di accesso a un semaforo di sistema denominato al momento della creazione, impedendo ad altro codice di assumere il controllo del semaforo di.  
  
 Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema denominato.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con la sicurezza del controllo di accesso specificato. Se il semaforo denominato esiste, la sicurezza del controllo di accesso specificato viene ignorata.  
  
> [!NOTE]
>  Il chiamante dispone di controllo completo sull'oggetto appena creato <xref:System.Threading.Semaphore> oggetto anche se `semaphoreSecurity` nega o non riesce a concedere alcuni diritti di accesso per l'utente corrente. Tuttavia, se l'utente corrente tenta di ottenere un'altra <xref:System.Threading.Semaphore> per rappresentare lo stesso semaforo denominato, usando un costruttore dell'oggetto o il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo, viene applicata la sicurezza del controllo di accesso di Windows.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con il numero iniziale e conteggio massimo specificato da `initialCount` e `maximumCount`. Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono usati, anche se i valori non validi causano eccezioni. Usare il `createdNew` parametro per determinare se il semaforo di sistema è stato creato da questo costruttore.  
  
 Se `initialCount` è minore di `maximumCount`, e `createdNew` viene `true`, l'effetto è lo stesso come se avesse chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore. In questo caso `createdNew` è sempre `true`.  
  
 Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti dei processi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato. Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso che nega il diritto di utilizzare il semaforo l'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo. Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (metodo). Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> è maggiore di <paramref name="maximumCount" />.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> è minore di 1.  
  
oppure 
 <paramref name="initialCount" /> è minore di 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene la sicurezza del controllo di accesso per un semaforo di sistema denominato.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> che rappresenta la sicurezza del controllo di accesso per il semaforo di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Semaphore.GetAccessControl%2A> metodo utilizza la seguente combinazione di flag (combinati mediante un'operazione OR bit per bit) per cercare le autorizzazioni: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> diritti di chiamare questo metodo e il semaforo necessario sia stato aperto con <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> diritti.  
  
 Su un semaforo locale, controllo degli accessi è irrilevante. Se il <xref:System.Threading.Semaphore> oggetto non rappresenta un semaforo di sistema denominato, questo metodo restituisce un <xref:System.Security.AccessControl.SemaphoreSecurity> che concessa tutti i diritti a tutti gli utenti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso che nega il diritto di utilizzare il semaforo l'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (metodo). Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni. La sicurezza del controllo di accesso per il semaforo di sistema viene ottenuta usando la <xref:System.Threading.Semaphore.GetAccessControl%2A> (metodo).  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <see cref="T:System.Threading.Semaphore" /> corrente rappresenta un semaforo di sistema denominato e l'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.  
  
oppure 
L'oggetto <see cref="T:System.Threading.Semaphore" /> corrente rappresenta un semaforo di sistema denominato e non è stato aperto con diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Non supportato per Windows 98 o Windows Millennium Edition.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un semaforo denominato specificato, se esistente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome del semaforo di sistema da aprire.</param>
        <summary>Apre il semaforo denominato specificato, se esistente.</summary>
        <returns>Oggetto che rappresenta il semaforo di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire il semaforo denominato specificato. Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema. Per creare il semaforo di sistema quando non esiste già, usare uno dei <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema denominato.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.Semaphore.OpenExisting%2A> overload del metodo e specificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit.  
  
 Specificando il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag consente di entrare nel semaforo, un thread e specificando le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso dell'utente corrente che nega il diritto di utilizzare il semaforo, ma che concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo. Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciarlo. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per aprire un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">Nome del semaforo di sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <summary>Apre il semaforo denominato specificato, se esistente, con l'accesso di sicurezza desiderato.</summary>
        <returns>Oggetto che rappresenta il semaforo di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread di accedere al semaforo e il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag per consentire ai thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).  
  
 Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire un semaforo denominato esistente. Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema. Per creare il semaforo di sistema quando non esiste già, usare uno dei <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema denominato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso che nega il diritto di utilizzare il semaforo l'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (metodo). Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciarlo. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il semaforo denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dei diritti di accesso di sicurezza desiderati.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Esce dal semaforo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esce dal semaforo e restituisce il conteggio precedente.</summary>
        <returns>Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Thread usano in genere il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo per immettere il semaforo che in genere utilizzare questo overload del metodo per uscire.  
  
 Se un <xref:System.Threading.SemaphoreFullException> generata dal <xref:System.Threading.Semaphore.Release%2A> metodo, non indica necessariamente un problema con il thread chiamante. Un errore di programmazione in un altro thread potrebbe aver causato tale thread uscite dal semaforo più volte rispetto agli accessi.  
  
 Se l'oggetto corrente <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti e il semaforo necessario sia stato aperto con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti.  
  
   
  
## Examples  
 Esempio di codice seguente crea un semaforo con un numero massimo di tre e un conteggio iniziale pari a zero. L'esempio avviati cinque thread, che bloccherà in attesa per il semaforo. Utilizzate dal thread principale di <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo sul valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.  
  
 Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo di semaforo track messaggi della console. L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per semplificare la lettura dell'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Il conteggio del semaforo ha già raggiunto il valore massimo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore Win32 relativo a un semaforo denominato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
oppure 
Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Numero di uscite dal semaforo.</param>
        <summary>Esce dal semaforo il numero di volte specificato e restituisce il conteggio precedente.</summary>
        <returns>Conteggio del semaforo prima della chiamata del metodo <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un thread ha acceduto al semaforo più volte, questo overload del metodo consente il conteggio del semaforo intero deve essere ripristinato con una sola chiamata.  
  
 Se un <xref:System.Threading.SemaphoreFullException> generata dal <xref:System.Threading.Semaphore.Release%2A> metodo, non indica necessariamente un problema con il thread chiamante. Un errore di programmazione in un altro thread potrebbe aver causato tale thread uscite dal semaforo più volte rispetto agli accessi.  
  
 Se l'oggetto corrente <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti e il semaforo necessario sia stato aperto con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti.  
  
   
  
## Examples  
 Esempio di codice seguente crea un semaforo con un numero massimo di tre e un conteggio iniziale pari a zero. L'esempio avviati cinque thread, che bloccherà in attesa per il semaforo. Utilizzate dal thread principale di <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo sul valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.  
  
 Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo di semaforo track messaggi della console. L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per semplificare la lettura dell'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> è minore di 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Il conteggio del semaforo ha già raggiunto il valore massimo.</exception>
        <exception cref="T:System.IO.IOException">Si è verificato un errore Win32 relativo a un semaforo denominato.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo corrente rappresenta un semaforo di sistema denominato, ma l'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
oppure 
Il semaforo corrente rappresenta un semaforo di sistema denominato, ma non è stato aperto con i diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Oggetto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare al semaforo di sistema denominato.</param>
        <summary>Imposta la sicurezza del controllo di accesso per un semaforo di sistema denominato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile impostare la sicurezza del controllo di accesso solo su <xref:System.Threading.Semaphore> gli oggetti che rappresentano i semafori denominati di sistema.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> diritti di chiamare questo metodo e il semaforo necessario sia stato aperto con <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> diritti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo denominato non esiste, viene creato con un numero massimo di due e con sicurezza del controllo di accesso che nega il diritto di utilizzare il semaforo l'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> (metodo). Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, usando il <xref:System.Threading.Semaphore.SetAccessControl%2A> metodo, il semaforo viene aperto con i diritti necessari per immettere e rilasciare. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone di diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.  
  
oppure 
Il semaforo non è stato aperto con i diritti <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">L'oggetto <see cref="T:System.Threading.Semaphore" /> corrente non rappresenta un semaforo di sistema denominato.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un semaforo denominato specificato, se già esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome del semaforo di sistema da aprire.</param>
        <param name="result">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <see cref="T:System.Threading.Semaphore" /> che rappresenta il semaforo denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre il semaforo denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
        <returns>
          <see langword="true" /> se l'apertura del semaforo denominato è riuscita; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il semaforo denominato non esiste, questo metodo non crearla. Per creare il semaforo di sistema quando non esiste già, usare uno dei <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se un semaforo denominato esiste, utilizzare questo overload del metodo anziché il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo che genera un'eccezione se il semaforo denominato non esiste.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.Semaphore.TryOpenExisting%2A> overload del metodo e specificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit. Specificando il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag consente di entrare nel semaforo, un thread e specificando le <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome del semaforo di sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <param name="result">Quando viene eseguita la restituzione del metodo, quest'ultimo contiene un oggetto <see cref="T:System.Threading.Semaphore" /> che rappresenta il semaforo denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre il semaforo denominato specificato, se esistente, con l'accesso di sicurezza desiderato, e restituisce un valore che indica se l'operazione è riuscita.</summary>
        <returns>
          <see langword="true" /> se l'apertura del semaforo denominato è riuscita; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il semaforo denominato non esiste, questo metodo non crearla. Per creare il semaforo di sistema quando non esiste già, usare uno dei <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se un semaforo denominato esiste, utilizzare questo overload del metodo anziché il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo che genera un'eccezione se il semaforo denominato non esiste.  
  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread di accedere al semaforo e il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag per consentire ai thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).  
  
 Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso semaforo di sistema denominato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il semaforo denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
      </Docs>
    </Member>
  </Members>
</Type>