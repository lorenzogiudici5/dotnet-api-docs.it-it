<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="47dc3c315c3032983e55c27b5310ada10bd2501f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406833" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limits the number of threads that can access a resource or pool of resources concurrently.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.Threading.Semaphore> classe per controllare l'accesso a un pool di risorse. Thread al semaforo chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo, che viene ereditato dal <xref:System.Threading.WaitHandle> classe e rilasciare il semaforo chiamando il <xref:System.Threading.Semaphore.Release%2A> metodo.  
  
 Il conteggio su un semaforo viene decrementato ogni volta che un thread accede al semaforo e incrementato quando un thread rilascia il semaforo. Quando il conteggio è zero, le successive richieste bloccano finché non altri thread rilasciano il semaforo. Quando tutti i thread hanno rilasciato il semaforo, il numero viene raggiunto il valore massimo specificato quando è stato creato il semaforo.  
  
 Non è garantito alcun ordine, ad esempio FIFO o LIFO, in cui i thread bloccati al semaforo.  
  
 Un thread può accedere al semaforo più volte, chiamando la <xref:System.Threading.WaitHandle.WaitOne%2A> metodo ripetutamente. Per rilasciare alcune o tutte queste voci, il thread può chiamare senza parametri <xref:System.Threading.Semaphore.Release> overload del metodo più volte oppure è possibile chiamare il <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo che specifica il numero di voci da rilasciare.  
  
 Il <xref:System.Threading.Semaphore> classe non impone l'identità del thread nelle chiamate a <xref:System.Threading.WaitHandle.WaitOne%2A> o <xref:System.Threading.Semaphore.Release%2A>. È responsabilità del programmatore garantire che i thread non rilasciano il semaforo troppe volte. Ad esempio, si consideri un semaforo con un conteggio massimo di due e il thread A e B accedano entrambi al semaforo. Se un errore di programmazione nel thread B fa sì che la chiamata a <xref:System.Threading.Semaphore.Release%2A> due volte, entrambe le chiamate hanno esito positivo. Il conteggio sul semaforo è completo e quando il thread A alla fine chiama <xref:System.Threading.Semaphore.Release%2A>, viene generata un'eccezione <xref:System.Threading.SemaphoreFullException>.  
  
 Sono disponibili due tipi: i semafori locali e i semafori di sistema denominato. Se si crea un <xref:System.Threading.Semaphore> usando un costruttore che accetta un nome dell'oggetto è associato a un semaforo di sistema operativo di tale nome. Di sistema sono visibili in tutto il sistema operativo, i semafori e possono essere usati per sincronizzare le attività dei processi denominati. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema ed è possibile utilizzare il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo per aprire un oggetto esistente denominato semaforo di sistema.  
  
 Un semaforo locale esiste solo all'interno del processo. Può essere usato da qualsiasi thread nel processo che abbia un riferimento all'oggetto <xref:System.Threading.Semaphore> locale. Ogni <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo locale distinto.  
  
   
  
## Examples  
 Esempio di codice seguente crea un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero. Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo. Il thread principale utilizza i <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo. Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo del semaforo traccia i messaggi della console. L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per rendere più facile da leggere l'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un semaforo senza nome. Tutti i thread che utilizzano un'istanza di tale semaforo devono disporre di riferimenti all'istanza.  
  
 Se `initialCount` è minore `maximumCount`, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte. Se non si desidera riservare tutte le voci per il thread che crea il semaforo, utilizzare lo stesso numero per `maximumCount` e `initialCount`.  
  
   
  
## Examples  
 Nell'esempio seguente crea un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero. Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo. Il thread principale utilizza i <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo. Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo del semaforo traccia i messaggi della console. L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per rendere più facile da leggere l'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con il numero iniziale e conteggio massimo specificati da `initialCount` e `maximumCount`. Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono utilizzati anche se i valori non validi comunque causano eccezioni. Se è necessario determinare se è stato creato un semaforo di sistema denominato, usare il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> overload del costruttore.  
  
> [!IMPORTANT]
>  Quando si utilizza questo overload del costruttore, la procedura consigliata consiste nello specificare lo stesso numero per `initialCount` e `maximumCount`. Se `initialCount` è minore `maximumCount`e viene creato un semaforo di sistema denominato, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte. Tuttavia, con questo overload del costruttore è un modo per determinare se è stato creato un semaforo di sistema denominato.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore.  
  
 Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
 Se si desidera verificare l'esistenza di una classe semaforo di sistema denominato, usare il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo. Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire un semaforo denominato esistente e genera un'eccezione se il semaforo di sistema non esiste.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato. Nell'esempio viene creato un semaforo denominato con un conteggio massimo di cinque e un conteggio iniziale pari a cinque. Il programma effettua tre chiamate al <xref:System.Threading.WaitHandle.WaitOne%2A> metodo. Pertanto, se si esegue l'esempio compilato da due finestre di comando, la seconda copia verrà bloccata la terza chiamata a <xref:System.Threading.WaitHandle.WaitOne%2A>. Rilasciare una o più voci nella prima copia del programma per sbloccare il secondo.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con il numero iniziale e conteggio massimo specificati da `initialCount` e `maximumCount`. Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono utilizzati anche se i valori non validi comunque causano eccezioni. Utilizzare `createdNew` per determinare se è stato creato il semaforo di sistema.  
  
 Se `initialCount` è minore `maximumCount`, e `createdNew` viene `true`, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore. In questo caso `createdNew` è sempre `true`.  
  
 Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato. Nell'esempio viene creato un semaforo denominato con un conteggio massimo di cinque e un conteggio iniziale di due. Vale a dire, sono riservati e tre le voci per il thread che chiama il costruttore. Se `createNew` viene `false`, il programma effettua tre chiamate al <xref:System.Threading.WaitHandle.WaitOne%2A> metodo. Pertanto, se si esegue l'esempio compilato da due finestre di comando, la seconda copia verrà bloccata la terza chiamata a <xref:System.Threading.WaitHandle.WaitOne%2A>. Rilasciare una o più voci nella prima copia del programma per sbloccare il secondo.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">The initial number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="maximumCount">The maximum number of requests for the semaphore that can be satisfied concurrently.</param>
        <param name="name">The name of a named system semaphore object.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed. This parameter is passed uninitialized.</param>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per applicare un semaforo di sistema denominato sicurezza dall'accesso di controllo al momento della creazione, impedendo ad altro codice di assumere il controllo del semaforo di.  
  
 Questo costruttore inizializza un <xref:System.Threading.Semaphore> oggetto che rappresenta un semaforo di sistema denominato. È possibile creare più <xref:System.Threading.Semaphore> gli oggetti che rappresentano lo stesso semaforo di sistema.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con la sicurezza del controllo di accesso specificato. Se il semaforo denominato esiste, la sicurezza del controllo di accesso specificato viene ignorata.  
  
> [!NOTE]
>  Il chiamante dispone del controllo completo su appena creato <xref:System.Threading.Semaphore> oggetto anche se `semaphoreSecurity` nega o non riesce a concedere alcuni diritti di accesso per l'utente corrente. Tuttavia, se l'utente corrente tenta di ottenere un altro <xref:System.Threading.Semaphore> dell'oggetto per rappresentare lo stesso semaforo denominato, utilizzando un costruttore o <xref:System.Threading.Semaphore.OpenExisting%2A> (metodo), Windows viene applicata la sicurezza del controllo di accesso.  
  
 Se il semaforo di sistema denominato non esiste, viene creato con il numero iniziale e conteggio massimo specificati da `initialCount` e `maximumCount`. Se il semaforo di sistema denominato esiste già, `initialCount` e `maximumCount` non vengono utilizzati anche se i valori non validi comunque causano eccezioni. Utilizzare il `createdNew` parametro per determinare se il semaforo di sistema è stato creato da questo costruttore.  
  
 Se `initialCount` è minore `maximumCount`, e `createdNew` viene `true`, l'effetto è lo stesso come se fosse stato chiamato il thread corrente <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` meno `initialCount`) volte.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un semaforo locale, come se fosse stato chiamato il <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> overload del costruttore. In questo caso `createdNew` è sempre `true`.  
  
 Poiché i semafori denominati sono visibili in tutto il sistema operativo, possono essere utilizzati per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato. Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo. Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> is less than 1.  -or-  <paramref name="initialCount" /> is less than 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the access control security for a named system semaphore.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Semaphore.GetAccessControl%2A> metodo utilizza la seguente combinazione di flag (combinate tramite l'operazione OR bit per bit) per cercare le autorizzazioni: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e il semaforo devono essere aperto con <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> diritti.  
  
 Su un semaforo locale, controllo degli accessi è irrilevante. Se il <xref:System.Threading.Semaphore> oggetto non rappresenta un semaforo di sistema denominato, questo metodo restituisce un <xref:System.Security.AccessControl.SemaphoreSecurity> oggetto che concede tutti i diritti a tutti gli utenti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni. La sicurezza di controllo di accesso per il semaforo di sistema viene ottenuta utilizzando il <xref:System.Threading.Semaphore.GetAccessControl%2A> metodo.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e rilasciare. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.  -or-  The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named semaphore, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <summary>Opens the specified named semaphore, if it already exists.</summary>
        <returns>An object that represents the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire il semaforo denominato specificato. Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema. Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non necessariamente restituire lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti sono restituiti rappresentano lo stesso semaforo di sistema.  
  
 Overload di questo metodo è equivalente alla chiamata di <xref:System.Threading.Semaphore.OpenExisting%2A> overload del metodo e specificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit.  
  
 Specifica il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag consente a un thread di accedere al semaforo e specificando il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che la negazione dell'utente corrente il diritto di utilizzare il semaforo, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e lo rilascia. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per aprire un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named semaphore, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system semaphore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread di accedere al semaforo e il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.Semaphore.Release%2A> metodo.  
  
 Il <xref:System.Threading.Semaphore.OpenExisting%2A> metodo tenta di aprire un semaforo denominato esistente. Se il semaforo di sistema non esiste, questo metodo genera un'eccezione anziché creare il semaforo di sistema. Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non necessariamente restituire lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti sono restituiti rappresentano lo stesso semaforo di sistema.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo, ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, il semaforo viene aperto con i diritti necessari per immettere e lo rilascia. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named semaphore does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the desired security access rights.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per chiamare codice non gestito per creare un semaforo di sistema denominato. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  Azione di sicurezza: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exits the semaphore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exits the semaphore and returns the previous count.</summary>
        <returns>The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I thread usano in genere il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo immettere in genere il semaforo e utilizzare questo overload del metodo per uscire dall'installazione.  
  
 Se un <xref:System.Threading.SemaphoreFullException> viene generata dal <xref:System.Threading.Semaphore.Release%2A> metodo, non indica necessariamente un problema con il thread chiamante. Tale thread uscite dal semaforo più volte di viene immesso potrebbe essere causato da un errore di programmazione in un altro thread.  
  
 Se l'oggetto corrente <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti e il semaforo deve essere aperto con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti.  
  
   
  
## Examples  
 Esempio di codice seguente crea un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero. Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo. Il thread principale utilizza i <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.  
  
 Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo del semaforo traccia i messaggi della console. L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per rendere più facile da leggere l'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">The semaphore count is already at the maximum value.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred with a named semaphore.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  -or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">The number of times to exit the semaphore.</param>
        <summary>Exits the semaphore a specified number of times and returns the previous count.</summary>
        <returns>The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un thread è stato attivato il semaforo più volte, overload di questo metodo consente il conteggio del semaforo intero deve essere ripristinato con un'unica chiamata.  
  
 Se un <xref:System.Threading.SemaphoreFullException> viene generata dal <xref:System.Threading.Semaphore.Release%2A> metodo, non indica necessariamente un problema con il thread chiamante. Tale thread uscite dal semaforo più volte di viene immesso potrebbe essere causato da un errore di programmazione in un altro thread.  
  
 Se l'oggetto corrente <xref:System.Threading.Semaphore> oggetto rappresenta un semaforo di sistema denominato, l'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti e il semaforo deve essere aperto con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti.  
  
   
  
## Examples  
 Esempio di codice seguente crea un semaforo con un conteggio massimo di tre e un conteggio iniziale pari a zero. Nell'esempio viene avviato cinque thread, tra cui bloccare l'attesa per il semaforo. Il thread principale utilizza i <xref:System.Threading.Semaphore.Release%28System.Int32%29> overload del metodo per aumentare il conteggio del semaforo al valore massimo, consentendo a tre thread di accedere al semaforo. Ogni thread Usa la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodo per attendere un secondo, per simulare il funzionamento e quindi chiama il <xref:System.Threading.Semaphore.Release> overload del metodo per rilasciare il semaforo.  
  
 Ogni volta che viene rilasciato il semaforo, viene visualizzato il conteggio del semaforo precedente. Utilizzo del semaforo traccia i messaggi della console. L'intervallo di lavoro simulato viene aumentato leggermente per ogni thread, per rendere più facile da leggere l'output.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> is less than 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">The semaphore count is already at the maximum value.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred with a named semaphore.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.  -or-  The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</param>
        <summary>Sets the access control security for a named system semaphore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È possibile impostare la sicurezza del controllo di accesso solo su <xref:System.Threading.Semaphore> gli oggetti che rappresentano i semafori di sistema denominato.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e il semaforo devono essere aperto con <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> diritti.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un semaforo denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un semaforo denominato.  
  
 Se il semaforo non esiste, viene creato con un conteggio massimo di due e con sicurezza del controllo di accesso che nega l'utente corrente il diritto di utilizzare il semaforo ma concede il diritto di leggere e modificare le autorizzazioni per il semaforo.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata al <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> metodo. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo per aprire il semaforo con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, utilizzando il <xref:System.Threading.Semaphore.SetAccessControl%2A> metodo, il semaforo viene aperto con i diritti necessari per immettere e rilasciare. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.  -or-  The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</exception>
        <exception cref="T:System.NotSupportedException">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il semaforo denominato non esiste, questo metodo non crearlo. Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se esiste già un semaforo denominato, utilizzare questo overload del metodo anziché il <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> overload del metodo che genera un'eccezione se il semaforo non esiste.  
  
 Overload di questo metodo è equivalente alla chiamata di <xref:System.Threading.Semaphore.TryOpenExisting%2A> overload del metodo e specificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit. Specifica il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag consente a un thread di accedere al semaforo e specificando il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.Semaphore.Release%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system semaphore to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il semaforo denominato non esiste, questo metodo non crearlo. Per creare il semaforo di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Semaphore.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se esiste già un semaforo denominato, utilizzare questo overload del metodo anziché il <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> overload del metodo che genera un'eccezione se il semaforo non esiste.  
  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread di accedere al semaforo e il <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.Semaphore.Release%2A> metodo.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non necessariamente restituire lo stesso <xref:System.Threading.Semaphore> dell'oggetto, anche se gli oggetti sono restituiti rappresentano lo stesso semaforo di sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the security access required to use it.</exception>
      </Docs>
    </Member>
  </Members>
</Type>