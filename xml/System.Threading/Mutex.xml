<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="092df8a132c6280f7c2111bcb3ab0226334bc0f4" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407054" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A synchronization primitive that can also be used for interprocess synchronization.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando due o più thread necessario accedere a una risorsa condivisa nello stesso momento, il sistema è necessario un meccanismo di sincronizzazione per assicurarsi che un solo thread alla volta usi la risorsa. <xref:System.Threading.Mutex> è una sincronizzazione primitiva che concede l'accesso esclusivo per la risorsa condivisa a un solo thread. Se un thread acquisisce un mutex, il secondo thread che vuole acquisire il mutex viene sospesa fino a quando il primo thread rilascia il mutex.  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 È possibile utilizzare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metodo che richiede la proprietà di un mutex. Il chiamante thread si blocca fino a quando non si verifica una delle operazioni seguenti:  
  
-   Il mutex viene segnalato per indicare che il proprietario. In questo caso, il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo `true`, e il thread chiamante diventa il proprietario del mutex e accede a risorse protette dal mutex. Quando ha terminato l'accesso alla risorsa, il thread è necessario chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo per rilasciare la proprietà del mutex. Il primo esempio nella sezione esempi viene illustrato questo modello.  
  
-   L'intervallo di timeout specificato nella chiamata a un <xref:System.Threading.WaitHandle.WaitOne%2A> metodo con un `millisecondsTimeout` o `timeout` è trascorso il parametro. In questo caso, il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo `false`, e il thread chiamante non effettua altri tentativi di acquisire la proprietà del mutex. In questo caso, è consigliabile strutturare il codice in modo che nel thread chiamante viene negato l'accesso alla risorsa che protette dal mutex. Perché il thread non acquisito mai la proprietà del mutex, non deve chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo. Questo modello è illustrato nel secondo esempio nella sezione esempi.  
  
 Il <xref:System.Threading.Mutex> classe impone l'identità del thread, in modo che un mutex può essere rilasciato solo dal thread che ha acquisito. Al contrario, il <xref:System.Threading.Semaphore> classe non impone l'identità del thread. Un mutex può anche essere passato attraverso i limiti del dominio applicazione.  
  
 Il thread che possiede un mutex può richiedere lo stesso mutex nelle chiamate ripetute a <xref:System.Threading.WaitHandle.WaitOne%2A> senza bloccare l'esecuzione. Tuttavia, è necessario chiamare il thread di <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo lo stesso numero di volte per rilasciare la proprietà del mutex.  
  
 Poiché il <xref:System.Threading.Mutex> classe eredita da <xref:System.Threading.WaitHandle>, è inoltre possibile chiamare il metodo statico <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metodi per sincronizzare l'accesso a una risorsa protetta.  
  
 Se un thread termina pur proprietario un mutex, il mutex è detto venga abbandonata. Lo stato del mutex è impostato su segnalato, e il successivo thread in attesa Ottiene la proprietà. Partire dalla versione 2.0 di .NET Framework, un <xref:System.Threading.AbandonedMutexException> viene generata nel thread successivo che acquisisce il mutex abbandonato. Prima della versione 2.0 di .NET Framework, è stata generata alcuna eccezione.  
  
> [!CAUTION]
>  Un mutex abbandonato indica spesso un errore grave nel codice. Quando un thread esce senza rilasciare il mutex, le strutture di dati protette dal mutex non sia in uno stato coerente. Il successivo thread che richiede la proprietà del mutex può gestire questa eccezione e continuare, se è possibile verificare l'integrità delle strutture di dati.  
  
 Nel caso di un mutex di sistema, un mutex abbandonato potrebbe indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).  
  
 Sono disponibili due tipi: mutex locali, che sono denominati e non denominati mutex di sistema. Un mutex locale esiste solo all'interno del processo. E può essere utilizzato da qualsiasi thread del processo che contiene un riferimento al <xref:System.Threading.Mutex> oggetto che rappresenta il mutex. Ogni senza nome <xref:System.Threading.Mutex> oggetto rappresenta un mutex locale separato.  
  
 System sono visibili in tutto il sistema operativo e può essere usato per sincronizzare le attività dei processi, i mutex denominato. È possibile creare un <xref:System.Threading.Mutex> oggetto che rappresenta un mutex di sistema denominato usando un costruttore che accetta un nome. L'oggetto sistema operativo può essere creato nello stesso momento, o può esistere già prima della creazione del <xref:System.Threading.Mutex> oggetto. È possibile creare più oggetti <xref:System.Threading.Mutex> che rappresentano lo stesso mutex di sistema denominato ed è possibile usare il metodo <xref:System.Threading.Mutex.OpenExisting%2A> per aprire un mutex di sistema denominato esistente.  
  
> [!NOTE]
>  In un server che esegue Servizi Terminal, un mutex di sistema denominato può avere due livelli di visibilità. Se il nome inizia con il prefisso "Global\\", il mutex è visibile in tutte le sessioni di terminal server. Se il nome inizia con il prefisso "locale\\", il mutex è visibile solo nella sessione del server terminal in cui è stato creato. In tal caso, un mutex separato con lo stesso nome può esistere in ognuna delle altre sessioni di terminal server nel server. Se quando si crea un mutex denominato non si specifica un prefisso, questa ha il prefisso "locale\\". All'interno di una sessione di terminal server, due mutex i cui nomi differiscono solo per i relativi prefissi sono separati i mutex ed entrambi sono visibili a tutti i processi nella sessione del server terminal. Vale a dire, i nomi di prefisso "Global\\" e "locale\\" descrivono l'ambito del nome del mutex rispetto alla sessioni di terminal server, non al processi.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 Questo esempio viene illustrato come locale <xref:System.Threading.Mutex> oggetto viene usato per sincronizzare l'accesso a una risorsa protetta. Poiché ogni thread chiamante è bloccato fino a quando non si acquisisce la proprietà del mutex, è necessario chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo per rilasciare la proprietà del thread.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 Nell'esempio seguente, ogni thread chiama il <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> metodo per acquisire il mutex. Se l'intervallo di timeout scade, il metodo restituisce `false`, e il thread non acquisisce il mutex né riesce ad accedere alla risorsa consente di proteggere il mutex. Il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo viene chiamato solo dal thread che acquisisce il mutex.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamata a questo overload del costruttore equivale a chiamare il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> overload del costruttore e specificando `false` per la proprietà iniziale del mutex. Vale a dire, il thread chiamante non è proprietario del mutex.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come locale <xref:System.Threading.Mutex> oggetto viene usato per sincronizzare l'accesso a una risorsa protetta. Il thread che crea il mutex non è proprietario viene inizialmente.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come locale <xref:System.Threading.Mutex> oggetto viene usato per sincronizzare l'accesso a una risorsa protetta. Il thread che crea il <xref:System.Threading.Mutex> appartiene inizialmente.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the <see cref="T:System.Threading.Mutex" />. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` non è `null` e `initiallyOwned` è `true`, il thread chiamante proprietario del mutex solo se il mutex di sistema denominato è stato creato come risultato di questa chiamata. Poiché non esiste un meccanismo per determinare se è stato creato il mutex di sistema denominato, è consigliabile specificare `false` per `initiallyOwned` quando si chiama l'overload del costruttore. È possibile utilizzare il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> costruttore se è necessario determinare la proprietà iniziale.  
  
 Questo costruttore inizializza un <xref:System.Threading.Mutex> oggetto che rappresenta un mutex di sistema denominato. È possibile creare più <xref:System.Threading.Mutex> gli oggetti che rappresentano lo stesso mutex di sistema denominato.  
  
 Se il mutex denominato è già stato creato con sicurezza del controllo di accesso e il chiamante non dispone <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, viene generata un'eccezione. Per aprire un mutex denominato esistente quando si dispone solo delle autorizzazioni necessarie per sincronizzare le attività dei thread, vedere il <xref:System.Threading.Mutex.OpenExisting%2A> metodo.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un mutex locale, come se fosse stato chiamato il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> costruttore. In questo caso `createdNew` è sempre `true`.  
  
 Perché sono a livello di sistema, i mutex denominati è utilizzabile per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
> [!NOTE]
>  In un server che esegue Servizi Terminal, un mutex di sistema denominato può avere due livelli di visibilità. Se il nome inizia con il prefisso "Global\\", il mutex è visibile in tutte le sessioni di terminal server. Se il nome inizia con il prefisso "locale\\", il mutex è visibile solo nella sessione del server terminal in cui è stato creato. In tal caso, un mutex separato con lo stesso nome può esistere in ognuna delle altre sessioni di terminal server nel server. Se quando si crea un mutex denominato non si specifica un prefisso, questa ha il prefisso "locale\\". All'interno di una sessione di terminal server, due mutex i cui nomi differiscono solo per i relativi prefissi sono separati i mutex ed entrambi sono visibili a tutti i processi nella sessione del server terminal. Vale a dire, i nomi di prefisso "Global\\" e "locale\\" descrivono l'ambito del nome del mutex rispetto alla sessioni di terminal server, non al processi.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 Nell'esempio seguente viene illustrato come un mutex denominato viene utilizzato per segnalare tra i thread in esecuzione in due processi distinti.  
  
 Eseguire il programma da due o più finestre di comando. Ogni processo crea un <xref:System.Threading.Mutex> oggetto che rappresenta il mutex denominato `MyMutex`. Il mutex denominato è un oggetto di sistema la cui durata è vincolata dalla durata del <xref:System.Threading.Mutex> gli oggetti che rappresentano. Il mutex denominato viene creato quando si crea il primo processo relativo <xref:System.Threading.Mutex> l'oggetto; in questo esempio, il mutex denominato è di proprietà per il primo processo che esegue il programma. Il mutex denominato viene eliminato definitivamente quando tutti i <xref:System.Threading.Mutex> sono stati rilasciati gli oggetti che rappresentano il.  
  
 L'overload del costruttore utilizzato in questo esempio non è possibile indicare il thread chiamante se è stata concessa la proprietà iniziale del mutex denominato. Utilizzare questo costruttore non richiedere la proprietà iniziale a meno che non è possibile essere certi che il thread verrà creato il mutex denominato.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the <see cref="T:System.Threading.Mutex" />. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <param name="createdNew">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` non è `null` e `initiallyOwned` viene `true`, il thread chiamante è proprietario solo se il mutex denominato `createdNew` è `true` dopo la chiamata. In caso contrario, il thread può richiedere il mutex chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo.  
  
 Questo costruttore inizializza un <xref:System.Threading.Mutex> oggetto che rappresenta un mutex di sistema denominato. È possibile creare più <xref:System.Threading.Mutex> gli oggetti che rappresentano lo stesso mutex di sistema denominato.  
  
 Se il mutex denominato è già stato creato con sicurezza del controllo di accesso e il chiamante non dispone <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> diritti, viene generata un'eccezione. Per aprire un mutex denominato esistente quando si dispone solo delle autorizzazioni necessarie per sincronizzare le attività dei thread, vedere il <xref:System.Threading.Mutex.OpenExisting%2A> metodo.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un mutex locale, come se fosse stato chiamato il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> costruttore. In questo caso `createdNew` è sempre `true`.  
  
 Perché sono a livello di sistema, i mutex denominati è utilizzabile per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
> [!NOTE]
>  In un server che esegue Servizi Terminal, un mutex di sistema denominato può avere due livelli di visibilità. Se il nome inizia con il prefisso "Global\\", il mutex è visibile in tutte le sessioni di terminal server. Se il nome inizia con il prefisso "locale\\", il mutex è visibile solo nella sessione del server terminal in cui è stato creato. In tal caso, un mutex separato con lo stesso nome può esistere in ognuna delle altre sessioni di terminal server nel server. Se quando si crea un mutex denominato non si specifica un prefisso, questa ha il prefisso "locale\\". All'interno di una sessione di terminal server, due mutex i cui nomi differiscono solo per i relativi prefissi sono separati i mutex ed entrambi sono visibili a tutti i processi nella sessione del server terminal. Vale a dire, i nomi di prefisso "Global\\" e "locale\\" descrivono l'ambito del nome del mutex rispetto alla sessioni di terminal server, non al processi.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 Esempio di codice seguente viene illustrato come un mutex denominato viene utilizzato per la segnalazione tra processi o thread. Eseguire il programma da due o più finestre di comando. Ogni processo crea un <xref:System.Threading.Mutex> oggetto che rappresenta il mutex denominato "MyMutex". Il mutex denominato è un oggetto di sistema. In questo esempio, la relativa durata è vincolata dalla durata del <xref:System.Threading.Mutex> gli oggetti che rappresentano. Il mutex denominato viene creato quando il primo processo crea relativo locale <xref:System.Threading.Mutex> dell'oggetto ed eliminati quando tutti i <xref:System.Threading.Mutex> sono stati rilasciati gli oggetti che rappresentano il. Il primo processo inizialmente appartiene il mutex denominato. Il secondo processo e tutti i processi successivi attendono che i processi precedenti rilasciare il mutex denominato.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</param>
        <param name="name">The name of the system mutex. If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</param>
        <param name="createdNew">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed. This parameter is passed uninitialized.</param>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` non è `null` e `initiallyOwned` viene `true`, il thread chiamante è proprietario solo se il mutex denominato `createdNew` è `true` dopo la chiamata. In caso contrario, il thread può richiedere il mutex chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo.  
  
 Utilizzare questo costruttore per applicare un mutex di sistema denominato sicurezza dall'accesso di controllo al momento della creazione, impedendo ad altro codice di assumere il controllo del mutex.  
  
 Questo costruttore inizializza un <xref:System.Threading.Mutex> oggetto che rappresenta un mutex di sistema denominato. È possibile creare più <xref:System.Threading.Mutex> gli oggetti che rappresentano lo stesso mutex di sistema denominato.  
  
 Se il mutex di sistema denominato non esiste, viene creato con la sicurezza del controllo di accesso specificato. Se il mutex denominato esiste, la sicurezza del controllo di accesso specificato viene ignorata.  
  
> [!NOTE]
>  Il chiamante dispone del controllo completo su appena creato <xref:System.Threading.Mutex> oggetto anche se `mutexSecurity` nega o non riesce a concedere alcuni diritti di accesso per l'utente corrente. Tuttavia, se l'utente corrente tenta di ottenere un altro <xref:System.Threading.Mutex> dell'oggetto per rappresentare lo stesso mutex denominato, utilizzando un costruttore o <xref:System.Threading.Mutex.OpenExisting%2A> (metodo), Windows viene applicata la sicurezza del controllo di accesso.  
  
 Se il mutex denominato è già stato creato con sicurezza del controllo di accesso e il chiamante non dispone <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, viene generata un'eccezione. Per aprire un mutex denominato esistente quando si dispone solo delle autorizzazioni necessarie per sincronizzare le attività dei thread, vedere il <xref:System.Threading.Mutex.OpenExisting%2A> metodo.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un mutex locale, come se fosse stato chiamato il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> costruttore. In questo caso `createdNew` è sempre `true`.  
  
 Perché sono a livello di sistema, i mutex denominati è utilizzabile per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
> [!NOTE]
>  In un server che esegue Servizi Terminal, un mutex di sistema denominato può avere due livelli di visibilità. Se il nome inizia con il prefisso "Global\\", il mutex è visibile in tutte le sessioni di terminal server. Se il nome inizia con il prefisso "locale\\", il mutex è visibile solo nella sessione del server terminal in cui è stato creato. In tal caso, un mutex separato con lo stesso nome può esistere in ognuna delle altre sessioni di terminal server nel server. Se quando si crea un mutex denominato non si specifica un prefisso, questa ha il prefisso "locale\\". All'interno di una sessione di terminal server, due mutex i cui nomi differiscono solo per i relativi prefissi sono separati i mutex ed entrambi sono visibili a tutti i processi nella sessione del server terminal. Vale a dire, i nomi di prefisso "Global\\" e "locale\\" descrivono l'ambito del nome del mutex rispetto alla sessioni di terminal server, non al processi.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e lo rilascia. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</summary>
        <returns>A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Mutex.GetAccessControl%2A> metodo utilizza la seguente combinazione di flag (combinate tramite l'operazione OR bit per bit) per cercare le autorizzazioni: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> per chiamare questo metodo e il mutex necessario sia stato aperto con <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzata la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni, utilizzando il <xref:System.Threading.Mutex.GetAccessControl%2A> e <xref:System.Threading.Mutex.SetAccessControl%2A> metodi.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e lo rilascia. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  -or-  The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named mutex, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <summary>Opens the specified named mutex, if it already exists.</summary>
        <returns>An object that represents the named system mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Mutex.OpenExisting%2A> metodo tenta di aprire il mutex di sistema denominato. Se il mutex di sistema non esiste, questo metodo genera un'eccezione anziché creare l'oggetto di sistema. Per creare il mutex di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Mutex.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non necessariamente restituire lo stesso <xref:System.Threading.Mutex> dell'oggetto, anche se gli oggetti sono restituiti rappresentano lo stesso mutex di sistema denominato.  
  
 Overload di questo metodo è equivalente alla chiamata di <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo e specificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit.  
  
 Specifica il <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa del mutex e specificando la <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> (metodo).  
  
 Questo metodo non viene richiesta la proprietà del mutex.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e lo rilascia. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named mutex, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system mutex.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa del mutex e il <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo.  
  
 Il <xref:System.Threading.Mutex.OpenExisting%2A> metodo tenta di aprire un mutex denominato esistente. Se il mutex di sistema non esiste, questo metodo genera un'eccezione anziché creare l'oggetto di sistema. Per creare il mutex di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Mutex.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non necessariamente restituire lo stesso <xref:System.Threading.Mutex> dell'oggetto, anche se gli oggetti sono restituiti rappresentano lo stesso mutex di sistema denominato.  
  
 Questo metodo non viene richiesta la proprietà del mutex.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e lo rilascia. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named mutex does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the <see cref="T:System.Threading.Mutex" /> once.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni volta che un thread acquisisce un mutex (ad esempio chiamando relativo <xref:System.Threading.WaitHandle.WaitOne%2A> metodo), deve chiamare successivamente <xref:System.Threading.Mutex.ReleaseMutex%2A> lasciare la proprietà del mutex e sbloccare altri thread che sta tentando di ottenere la proprietà del mutex. Se il tentativo di ottenere la proprietà del mutex non riesce (ad esempio, quando una chiamata ai <xref:System.Threading.WaitHandle.WaitOne%2A> metodo con un `millisecondsTimeout` o una `timeout` parametro restituisce `false` perché la richiesta scade), il thread non deve chiamare <xref:System.Threading.Mutex.ReleaseMutex%2A>, In questo i casi, il thread dovrebbe non essere consentito anche di accedere alla risorsa protetta per il mutex, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Un thread che possiede un mutex può specificare lo stesso mutex in attesa ripetute chiamate di funzione senza bloccare l'esecuzione. Il numero di chiamate viene mantenuto da common language runtime. Il thread deve chiamare <xref:System.Threading.Mutex.ReleaseMutex%2A> lo stesso numero di volte per rilasciare la proprietà del mutex.  
  
 Se un thread termina pur proprietario un mutex, il mutex è detto venga abbandonata. Lo stato del mutex è impostato su segnalato e il successivo thread in attesa Ottiene la proprietà. Se nessun altro proprietario del mutex, viene segnalato lo stato del mutex. Partire dalla versione 2.0 di .NET Framework, un <xref:System.Threading.AbandonedMutexException> viene generata nel thread successivo che acquisisce il mutex. Prima della versione 2.0 di .NET Framework, è stata generata alcuna eccezione.  
  
> [!CAUTION]
>  Un mutex abbandonato indica spesso un errore grave nel codice. Quando un thread esce senza rilasciare il mutex, le strutture di dati protette dal mutex non sia in uno stato coerente. Il successivo thread che richiede la proprietà del mutex può gestire questa eccezione e continuare, se è possibile verificare l'integrità delle strutture di dati.  
  
 Nel caso di un mutex di sistema, un mutex abbandonato potrebbe indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come locale <xref:System.Threading.Mutex> oggetto viene usato per sincronizzare l'accesso a una risorsa protetta. Il thread che crea il mutex non è proprietario viene inizialmente. Il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo viene utilizzato per rilasciare il mutex quando non è più necessario.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">The calling thread does not own the mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">The current instance has already been disposed.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</param>
        <summary>Sets the access control security for a named system mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'utente deve disporre <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e il mutex necessario sia stato aperto con <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzata la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni, utilizzando il <xref:System.Threading.Mutex.GetAccessControl%2A> e <xref:System.Threading.Mutex.SetAccessControl%2A> metodi.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e lo rilascia. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  -or-  The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il mutex denominato non esiste, questo metodo non crearlo. Per creare il mutex di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Mutex.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se un mutex denominato esiste già, utilizzare questo overload del metodo anziché il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo che genera un'eccezione se il mutex non esiste.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non necessariamente restituire lo stesso <xref:System.Threading.Mutex> dell'oggetto, anche se gli oggetti sono restituiti rappresentano lo stesso mutex di sistema denominato.  
  
 Overload di questo metodo è equivalente alla chiamata di <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> overload del metodo e specificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit. Specifica il <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa del mutex e specificando la <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> (metodo).  
  
 Questo metodo non viene richiesta la proprietà del mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede attendibilità totale per il chiamante immediato. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system mutex to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il mutex denominato non esiste, questo metodo non crearlo. Per creare il mutex di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Mutex.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se un mutex denominato esiste già, utilizzare questo overload del metodo anziché il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo che genera un'eccezione se il mutex non esiste.  
  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa del mutex e il <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non necessariamente restituire lo stesso <xref:System.Threading.Mutex> dell'oggetto, anche se gli oggetti sono restituiti rappresentano lo stesso mutex di sistema denominato.  
  
 Questo metodo non viene richiesta la proprietà del mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede attendibilità totale per il chiamante immediato. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
  </Members>
</Type>