<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6bce0feaf14f66f8608164cfa777620d7f3b329f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530995" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Primitiva di sincronizzazione che può essere utilizzata anche per la sincronizzazione interprocesso.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando è necessario accedere a una risorsa condivisa contemporaneamente due o più thread, il sistema è necessario un meccanismo di sincronizzazione per garantire che un solo thread alla volta utilizza la risorsa. <xref:System.Threading.Mutex> è una sincronizzazione primitiva che concede l'accesso esclusivo alla risorsa condivisa a un solo thread. Se un thread acquisisce un mutex, il secondo thread che si desidera acquisire il mutex viene sospesa fino a quando il primo thread rilascia il mutex.  
  
> [!IMPORTANT]
>  Questo tipo implementa il <xref:System.IDisposable> interfaccia. Dopo aver utilizzato il tipo, è necessario eliminarlo direttamente o indirettamente. Per eliminare direttamente il tipo, chiamare il relativo <xref:System.IDisposable.Dispose%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 È possibile utilizzare il <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> metodo per richiedere la proprietà di un mutex. Il chiamante thread si blocca fino a quando non si verifica una delle operazioni seguenti:  
  
-   Il mutex viene segnalato per indicare che il proprietario. In questo caso, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituisce `true`, e il thread chiamante si presuppone che la proprietà del mutex e accede alla risorsa protetta dal mutex. Dopo aver terminato l'accesso alla risorsa, è necessario chiamare il thread di <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo per rilasciare la proprietà del mutex. Nel primo esempio nella sezione esempi viene illustrato questo modello.  
  
-   L'intervallo di timeout specificato nella chiamata a un <xref:System.Threading.WaitHandle.WaitOne%2A> metodo che presenta un `millisecondsTimeout` o `timeout` parametro trascorsa. In questo caso, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituisce `false`, e il thread chiamante non effettua altri tentativi di acquisire la proprietà del mutex. In questo caso, è necessario strutturare il codice in modo che l'accesso alla risorsa protetta da mutex negato per il thread chiamante. Perché il thread non acquisito mai la proprietà del mutex, non deve chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo. Questo modello è illustrato nel secondo esempio nella sezione esempi.  
  
 La <xref:System.Threading.Mutex> classe impone l'identità del thread, in modo che un mutex può essere rilasciato solo dal thread che ha acquisito. Al contrario, la <xref:System.Threading.Semaphore> classe non impone l'identità del thread. Un mutex, inoltre, può essere passato attraverso i limiti del dominio applicazione.  
  
 Il thread che possiede un mutex può richiedere lo stesso mutex in chiamate ripetute a <xref:System.Threading.WaitHandle.WaitOne%2A> senza interrompere l'esecuzione. Tuttavia, è necessario chiamare il thread di <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo lo stesso numero di volte per rilasciare la proprietà del mutex.  
  
 Poiché il <xref:System.Threading.Mutex> classe eredita da <xref:System.Threading.WaitHandle>, è inoltre possibile chiamare il metodo statico <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metodi per sincronizzare l'accesso a una risorsa protetta.  
  
 Se termina un thread durante il proprietario di un mutex, viene definito mutex abbandonato. Lo stato del mutex è impostato su segnalato, e il successivo thread in attesa Ottiene la proprietà. A partire dalla versione 2.0 di .NET Framework, un <xref:System.Threading.AbandonedMutexException> viene generata nel thread successivo che acquisisce il mutex abbandonato. Prima della versione 2.0 di .NET Framework, è stata generata alcuna eccezione.  
  
> [!CAUTION]
>  Un mutex abbandonato indica spesso un errore grave nel codice. Quando un thread esce senza rilasciare il mutex, le strutture di dati protette dal mutex potrebbero non essere in uno stato coerente. Il successivo thread che richiede la proprietà del mutex può gestire questa eccezione e continuare, se è possibile verificare l'integrità delle strutture di dati.  
  
 Nel caso di un mutex di sistema, un mutex abbandonato potrebbe indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).  
  
 Sono disponibili due tipi: mutex locali, che sono denominati e non denominati mutex di sistema. Un mutex locale esiste solo all'interno del processo. E può essere utilizzato da qualsiasi thread del processo che ha un riferimento di <xref:System.Threading.Mutex> oggetto che rappresenta il mutex. Ogni senza nome <xref:System.Threading.Mutex> oggetto rappresenta un mutex locale distinto.  
  
 Di sistema sono visibili in tutto il sistema operativo, i mutex e possono essere usati per sincronizzare le attività dei processi denominati. È possibile creare un <xref:System.Threading.Mutex> oggetto che rappresenta un mutex di sistema denominato usando un costruttore che accetta un nome. L'oggetto del sistema operativo può essere creato nello stesso momento, o può esistere già prima della creazione del <xref:System.Threading.Mutex> oggetto. È possibile creare più oggetti <xref:System.Threading.Mutex> che rappresentano lo stesso mutex di sistema denominato ed è possibile usare il metodo <xref:System.Threading.Mutex.OpenExisting%2A> per aprire un mutex di sistema denominato esistente.  
  
> [!NOTE]
>  In un server che esegue Servizi Terminal, un mutex di sistema denominato può avere due livelli di visibilità. Se il nome inizia con il prefisso "Global\\", il mutex è visibile in tutte le sessioni di terminal server. Se il nome inizia con il prefisso "locale\\", il mutex è visibile solo nella sessione del server terminal in cui è stato creato. In tal caso, un mutex separato con lo stesso nome può esistere in ognuna delle altre sessioni di terminal server nel server. Se non si specifica un prefisso quando si crea un mutex denominato, ha il prefisso "locale\\". All'interno di una sessione di terminal server, due mutex i cui nomi si differenziano solo per i prefissi sono considerati distinti ed entrambi sono visibili a tutti i processi nella sessione del server terminal. Ovvero, i nomi di prefisso "Global\\" e "locale\\" descrivono l'ambito del nome del mutex relativo sessioni di terminal server, non relativo ai processi.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 Questo esempio viene illustrato come una variabile locale <xref:System.Threading.Mutex> oggetto viene usato per sincronizzare l'accesso a una risorsa protetta. Poiché ogni thread chiamante è bloccato fino all'acquisizione di proprietà del mutex, è necessario chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo per rilasciare la proprietà del thread.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 Nell'esempio seguente, ogni thread chiama il <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> metodo per acquisire il mutex. Se l'intervallo di timeout scade, il metodo restituisce `false`, e il thread non acquisisce il mutex né ottenga l'accesso alla risorsa protegge il mutex. Il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo viene chiamato solo dal thread che acquisisce il mutex.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con le proprietà predefinite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo overload del costruttore è equivale a chiamare il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> overload del costruttore e specificando `false` per la proprietà iniziale del mutex. Vale a dire il thread chiamante non dispone del mutex.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come una variabile locale <xref:System.Threading.Mutex> oggetto viene usato per sincronizzare l'accesso a una risorsa protetta. Il thread che crea il mutex non è proprietario viene inizialmente.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          Viene restituito <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex; in caso contrario, <see langword="false" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come una variabile locale <xref:System.Threading.Mutex> oggetto viene usato per sincronizzare l'accesso a una risorsa protetta. Il thread che crea il <xref:System.Threading.Mutex> appartiene inizialmente.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex di sistema denominato, se questo è stato creato come risultato della chiamata; in caso contrario, <see langword="false" />.</param>
        <param name="name">Nome di <see cref="T:System.Threading.Mutex" />. Se il valore è <see langword="null" />, l'oggetto <see cref="T:System.Threading.Mutex" /> è senza nome.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex e con una stringa che rappresenta il nome del mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` non `null` e `initiallyOwned` è `true`, il thread chiamante è proprietario del mutex solo se il mutex di sistema denominato è stato creato come risultato della chiamata. Poiché non esiste alcun meccanismo per determinare se è stato creato il mutex di sistema denominato, è preferibile specificare `false` per `initiallyOwned` quando si chiama l'overload del costruttore. È possibile utilizzare il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> costruttore se è necessario determinare la proprietà iniziale.  
  
 Questo costruttore inizializza un <xref:System.Threading.Mutex> oggetto che rappresenta un mutex di sistema denominato. È possibile creare più <xref:System.Threading.Mutex> gli oggetti che rappresentano lo stesso mutex di sistema denominato.  
  
 Se il mutex denominato è già stato creato con la sicurezza del controllo di accesso e il chiamante non dispone <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, viene generata un'eccezione. Per aprire un mutex denominato esistente quando si dispone solo delle autorizzazioni necessarie per sincronizzare le attività dei thread, vedere il <xref:System.Threading.Mutex.OpenExisting%2A> metodo.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un mutex locale, come se fosse stato chiamato il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> costruttore. In questo caso, `createdNew` è sempre `true`.  
  
 Poiché sono a livello di sistema, i mutex denominati è utilizzabile per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
> [!NOTE]
>  In un server che esegue Servizi Terminal, un mutex di sistema denominato può avere due livelli di visibilità. Se il nome inizia con il prefisso "Global\\", il mutex è visibile in tutte le sessioni di terminal server. Se il nome inizia con il prefisso "locale\\", il mutex è visibile solo nella sessione del server terminal in cui è stato creato. In tal caso, un mutex separato con lo stesso nome può esistere in ognuna delle altre sessioni di terminal server nel server. Se non si specifica un prefisso quando si crea un mutex denominato, ha il prefisso "locale\\". All'interno di una sessione di terminal server, due mutex i cui nomi si differenziano solo per i prefissi sono considerati distinti ed entrambi sono visibili a tutti i processi nella sessione del server terminal. Ovvero, i nomi di prefisso "Global\\" e "locale\\" descrivono l'ambito del nome del mutex relativo sessioni di terminal server, non relativo ai processi.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 Nell'esempio seguente viene illustrato come utilizzare un mutex denominato per segnalare tra i thread in esecuzione in due processi distinti.  
  
 Eseguire il programma da due o più finestre di comando. Ogni processo crea un <xref:System.Threading.Mutex> oggetto che rappresenta il mutex denominato `MyMutex`. Il mutex denominato è la cui durata è vincolata dalla durata di un oggetto di sistema di <xref:System.Threading.Mutex> gli oggetti che rappresentano. Il mutex denominato viene creato quando si crea il primo processo relativo <xref:System.Threading.Mutex> oggetto; in questo esempio, il mutex denominato è di proprietà per il primo processo che esegue il programma. Il mutex denominato viene eliminato definitivamente quando tutti i <xref:System.Threading.Mutex> sono stati rilasciati gli oggetti che rappresentano.  
  
 L'overload del costruttore utilizzato in questo esempio non è possibile indicare il thread chiamante se è stata concessa la proprietà iniziale del mutex denominato. Utilizzare questo costruttore non richiedere la proprietà iniziale a meno che non è possibile essere certi che il thread verrà creato il mutex denominato.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il mutex denominato non può essere creato, forse perché un handle di attesa di un tipo diverso ha lo stesso nome.</exception>
        <exception cref="T:System.ArgumentException">
          La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex di sistema denominato, se questo è stato creato come risultato della chiamata; in caso contrario, <see langword="false" />.</param>
        <param name="name">Nome di <see cref="T:System.Threading.Mutex" />. Se il valore è <see langword="null" />, l'oggetto <see cref="T:System.Threading.Mutex" /> è senza nome.</param>
        <param name="createdNew">Quando questo metodo viene restituito, contiene un valore booleano che è <see langword="true" /> se è stato creato un mutex locale (ovvero, se il valore di <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il mutex di sistema denominato specificato. <see langword="false" /> se il mutex di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex, con una stringa che rappresenta il nome del mutex e con un valore booleano che, quando il metodo viene restituito, indichi se al thread chiamante era stata concessa la proprietà iniziale del mutex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` non `null` e `initiallyOwned` è `true`, il thread chiamante è proprietario solo se il mutex denominato `createdNew` è `true` dopo la chiamata. In caso contrario il thread può richiedere il mutex chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo.  
  
 Questo costruttore inizializza un <xref:System.Threading.Mutex> oggetto che rappresenta un mutex di sistema denominato. È possibile creare più <xref:System.Threading.Mutex> gli oggetti che rappresentano lo stesso mutex di sistema denominato.  
  
 Se il mutex denominato è già stato creato con la sicurezza del controllo di accesso e il chiamante non dispone <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> diritti, che viene generata un'eccezione. Per aprire un mutex denominato esistente quando si dispone solo delle autorizzazioni necessarie per sincronizzare le attività dei thread, vedere il <xref:System.Threading.Mutex.OpenExisting%2A> metodo.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un mutex locale, come se fosse stato chiamato il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> costruttore. In questo caso, `createdNew` è sempre `true`.  
  
 Poiché sono a livello di sistema, i mutex denominati è utilizzabile per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
> [!NOTE]
>  In un server che esegue Servizi Terminal, un mutex di sistema denominato può avere due livelli di visibilità. Se il nome inizia con il prefisso "Global\\", il mutex è visibile in tutte le sessioni di terminal server. Se il nome inizia con il prefisso "locale\\", il mutex è visibile solo nella sessione del server terminal in cui è stato creato. In tal caso, un mutex separato con lo stesso nome può esistere in ognuna delle altre sessioni di terminal server nel server. Se non si specifica un prefisso quando si crea un mutex denominato, ha il prefisso "locale\\". All'interno di una sessione di terminal server, due mutex i cui nomi si differenziano solo per i prefissi sono considerati distinti ed entrambi sono visibili a tutti i processi nella sessione del server terminal. Ovvero, i nomi di prefisso "Global\\" e "locale\\" descrivono l'ambito del nome del mutex relativo sessioni di terminal server, non relativo ai processi.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo di un mutex denominato per la segnalazione tra processi o thread. Eseguire il programma da due o più finestre di comando. Ogni processo crea un <xref:System.Threading.Mutex> oggetto che rappresenta il mutex denominato "MyMutex". Il mutex denominato è un oggetto di sistema. In questo esempio, la relativa durata è vincolata dalla durata del <xref:System.Threading.Mutex> gli oggetti che rappresentano. Il mutex denominato viene creato quando il primo processo crea il relativo locale <xref:System.Threading.Mutex> dell'oggetto ed eliminati definitivamente quando tutti i <xref:System.Threading.Mutex> sono stati rilasciati gli oggetti che rappresentano il. Il primo processo inizialmente appartiene il mutex denominato. Il secondo processo e tutti i processi successivi attendono che i processi precedenti rilasciare il mutex denominato.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il mutex denominato non può essere creato, forse perché un handle di attesa di un tipo diverso ha lo stesso nome.</exception>
        <exception cref="T:System.ArgumentException">
          La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">
          <see langword="true" /> per concedere al thread chiamante la proprietà iniziale del mutex di sistema denominato, se questo è stato creato come risultato della chiamata; in caso contrario, <see langword="false" />.</param>
        <param name="name">Nome del mutex di sistema. Se il valore è <see langword="null" />, l'oggetto <see cref="T:System.Threading.Mutex" /> è senza nome.</param>
        <param name="createdNew">Quando questo metodo viene restituito, contiene un valore booleano che è <see langword="true" /> se è stato creato un mutex locale (ovvero, se il valore di <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato il mutex di sistema denominato specificato. <see langword="false" /> se il mutex di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <param name="mutexSecurity">Oggetto <see cref="T:System.Security.AccessControl.MutexSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare al mutex di sistema denominato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Mutex" /> con un valore booleano che indica se il thread chiamante deve avere la proprietà iniziale del mutex, con una stringa che rappresenta il nome del mutex, con una variabile Boolean che, quando il metodo viene restituito, indichi se al thread chiamante era stata concessa la proprietà iniziale del mutex e con la sicurezza del controllo di accesso da applicare al mutex denominato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` non `null` e `initiallyOwned` è `true`, il thread chiamante è proprietario solo se il mutex denominato `createdNew` è `true` dopo la chiamata. In caso contrario il thread può richiedere il mutex chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo.  
  
 Utilizzare questo costruttore per applicare del controllo di accesso a un mutex di sistema denominato quando viene creato, impedendo che altro codice al controllo del mutex.  
  
 Questo costruttore inizializza un <xref:System.Threading.Mutex> oggetto che rappresenta un mutex di sistema denominato. È possibile creare più <xref:System.Threading.Mutex> gli oggetti che rappresentano lo stesso mutex di sistema denominato.  
  
 Se il mutex di sistema denominato non esiste, viene creato con la sicurezza del controllo di accesso specificato. Se il mutex denominato esiste, la sicurezza del controllo di accesso specificato viene ignorata.  
  
> [!NOTE]
>  Il chiamante ha il controllo completo su appena creato <xref:System.Threading.Mutex> oggetto anche se `mutexSecurity` nega o non concede alcuni diritti di accesso per l'utente corrente. Tuttavia, se l'utente corrente tenta di ottenere un altro <xref:System.Threading.Mutex> per rappresentare lo stesso mutex denominato, utilizzando un costruttore dell'oggetto o <xref:System.Threading.Mutex.OpenExisting%2A> (metodo), viene applicata la sicurezza del controllo di accesso di Windows.  
  
 Se il mutex denominato è già stato creato con la sicurezza del controllo di accesso e il chiamante non dispone <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, viene generata un'eccezione. Per aprire un mutex denominato esistente quando si dispone solo delle autorizzazioni necessarie per sincronizzare le attività dei thread, vedere il <xref:System.Threading.Mutex.OpenExisting%2A> metodo.  
  
 Se si specifica `null` o una stringa vuota per `name`, viene creato un mutex locale, come se fosse stato chiamato il <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> costruttore. In questo caso, `createdNew` è sempre `true`.  
  
 Poiché sono a livello di sistema, i mutex denominati è utilizzabile per coordinare l'utilizzo delle risorse attraverso i limiti di processo.  
  
> [!NOTE]
>  In un server che esegue Servizi Terminal, un mutex di sistema denominato può avere due livelli di visibilità. Se il nome inizia con il prefisso "Global\\", il mutex è visibile in tutte le sessioni di terminal server. Se il nome inizia con il prefisso "locale\\", il mutex è visibile solo nella sessione del server terminal in cui è stato creato. In tal caso, un mutex separato con lo stesso nome può esistere in ognuna delle altre sessioni di terminal server nel server. Se non si specifica un prefisso quando si crea un mutex denominato, ha il prefisso "locale\\". All'interno di una sessione di terminal server, due mutex i cui nomi si differenziano solo per i prefissi sono considerati distinti ed entrambi sono visibili a tutti i processi nella sessione del server terminal. Ovvero, i nomi di prefisso "Global\\" e "locale\\" descrivono l'ambito del nome del mutex relativo sessioni di terminal server, non relativo ai processi.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e rilasciarlo. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste e ha accesso alla sicurezza controllo, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il mutex denominato non può essere creato, forse perché un handle di attesa di un tipo diverso ha lo stesso nome.</exception>
        <exception cref="T:System.ArgumentException">
          La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.MutexSecurity" /> che rappresenta la sicurezza del controllo di accesso per il mutex denominato.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.MutexSecurity" /> che rappresenta la sicurezza del controllo di accesso per il mutex denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Mutex.GetAccessControl%2A> metodo utilizza la seguente combinazione di flag (combinati mediante un'operazione OR bit per bit) per cercare le autorizzazioni: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> per chiamare questo metodo e il mutex necessario sia stato aperto con <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni, utilizzando il <xref:System.Threading.Mutex.GetAccessControl%2A> e <xref:System.Threading.Mutex.SetAccessControl%2A> metodi.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e rilasciarlo. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <see cref="T:System.Threading.Mutex" /> corrente rappresenta un mutex di sistema denominato, ma l'utente non dispone di <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.Mutex" /> corrente rappresenta un mutex di sistema denominato e non è stato aperto con <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Non supportato per Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un mutex denominato specificato, se esistente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome del mutex di sistema da aprire.</param>
        <summary>Apre il mutex denominato specificato, se esistente.</summary>
        <returns>Oggetto che rappresenta il mutex di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Mutex.OpenExisting%2A> metodo tenta di aprire il mutex di sistema denominato. Se il mutex di sistema non esiste, questo metodo genera un'eccezione anziché creare l'oggetto di sistema. Per creare il mutex di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Mutex.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.Mutex> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso mutex di sistema denominato.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo e specificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> diritti, combinati utilizzando l'operazione OR bit per bit.  
  
 Specifica il <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa del mutex e specificando il <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag consente a un thread di chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo.  
  
 Questo metodo non viene richiesta la proprietà del mutex.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e rilasciarlo. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il mutex denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">Nome del mutex di sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <summary>Apre il mutex denominato specificato, se esistente, con l'accesso di sicurezza desiderato.</summary>
        <returns>Oggetto che rappresenta il mutex di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa del mutex e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo.  
  
 Il <xref:System.Threading.Mutex.OpenExisting%2A> metodo tenta di aprire un mutex denominato esistente. Se il mutex di sistema non esiste, questo metodo genera un'eccezione anziché creare l'oggetto di sistema. Per creare il mutex di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Mutex.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.Mutex> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso mutex di sistema denominato.  
  
 Questo metodo non viene richiesta la proprietà del mutex.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e rilasciarlo. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Il mutex denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia l'oggetto <see cref="T:System.Threading.Mutex" /> una volta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ogni volta che un thread acquisisce un mutex (ad esempio, chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo)), successivamente, è necessario chiamare <xref:System.Threading.Mutex.ReleaseMutex%2A> lasciare la proprietà del mutex e sbloccare gli altri thread che sta tentando di ottenere la proprietà del mutex. Se il tentativo di ottenere la proprietà del mutex ha esito negativo (ad esempio, quando una chiamata al <xref:System.Threading.WaitHandle.WaitOne%2A> metodo con un `millisecondsTimeout` o `timeout` parametro restituisce `false` perché la richiesta scade), il thread non deve chiamare <xref:System.Threading.Mutex.ReleaseMutex%2A>, In questo i casi, il thread deve inoltre non essere consentito per accedere alla risorsa protetta dal mutex, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Un thread che possiede un mutex è possibile specificare lo stesso mutex in chiamate senza interrompere l'esecuzione. Il numero di chiamate viene mantenuto da common language runtime. Il thread deve chiamare <xref:System.Threading.Mutex.ReleaseMutex%2A> lo stesso numero di volte per rilasciare la proprietà del mutex.  
  
 Se termina un thread durante il proprietario di un mutex, viene definito mutex abbandonato. Lo stato del mutex è impostato su segnalato e il successivo thread in attesa Ottiene la proprietà. Se nessun altro proprietario del mutex, viene segnalato lo stato del mutex. A partire dalla versione 2.0 di .NET Framework, un <xref:System.Threading.AbandonedMutexException> viene generata nel thread successivo che acquisisce il mutex. Prima della versione 2.0 di .NET Framework, è stata generata alcuna eccezione.  
  
> [!CAUTION]
>  Un mutex abbandonato indica spesso un errore grave nel codice. Quando un thread esce senza rilasciare il mutex, le strutture di dati protette dal mutex potrebbero non essere in uno stato coerente. Il successivo thread che richiede la proprietà del mutex può gestire questa eccezione e continuare, se è possibile verificare l'integrità delle strutture di dati.  
  
 Nel caso di un mutex di sistema, un mutex abbandonato potrebbe indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come una variabile locale <xref:System.Threading.Mutex> oggetto viene usato per sincronizzare l'accesso a una risorsa protetta. Il thread che crea il mutex non è proprietario viene inizialmente. Il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo viene utilizzato per rilasciare il mutex quando non è più necessario.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Il thread di chiamata non è il proprietario del mutex.</exception>
        <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Oggetto <see cref="T:System.Security.AccessControl.MutexSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare al mutex di sistema denominato.</param>
        <summary>Imposta la sicurezza del controllo di accesso per un mutex di sistema denominato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'utente deve disporre <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e il mutex devono essere aperto con <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un mutex denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un mutex denominato.  
  
 Se il mutex non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzo del mutex, ma concede il diritto di leggere e modificare le autorizzazioni per il mutex.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo per aprire il mutex con i diritti necessari per leggere e modificare le autorizzazioni, utilizzando il <xref:System.Threading.Mutex.GetAccessControl%2A> e <xref:System.Threading.Mutex.SetAccessControl%2A> metodi.  
  
 Dopo la modifica delle autorizzazioni, viene aperto il mutex con i diritti necessari per immettere e rilasciarlo. Se si esegue l'esempio compilato da una terza finestra di comando, viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mutexSecurity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone di <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
 oppure  
  
 Il mutex non è stato aperto con <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">L'oggetto <see cref="T:System.Threading.Mutex" /> corrente non rappresenta un mutex di sistema denominato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un mutex denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è stata completata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome del mutex di sistema da aprire.</param>
        <param name="result">Quando questo metodo viene restituito, contiene un oggetto di <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex denominato se la chiamata ha esito positivo o <see langword="null" /> se la chiamata ha esito negativo. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre il mutex denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è stata completata.</summary>
        <returns>
          <see langword="true" /> se il mutex denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il mutex denominato non esiste, questo metodo non crearlo. Per creare il mutex di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Mutex.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se un mutex denominato esiste, utilizzare questo overload del metodo anziché il <xref:System.Threading.Mutex.OpenExisting%28System.String%29> overload del metodo che genera un'eccezione se il mutex non esiste.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.Mutex> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso mutex di sistema denominato.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> overload del metodo e specificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> diritti, combinati utilizzando l'operazione OR bit per bit. Specifica il <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa del mutex e specificando il <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag consente a un thread di chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo.  
  
 Questo metodo non viene richiesta la proprietà del mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome del mutex di sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <param name="result">Quando questo metodo viene restituito, contiene un oggetto di <see cref="T:System.Threading.Mutex" /> che rappresenta il mutex denominato se la chiamata ha esito positivo o <see langword="null" /> se la chiamata ha esito negativo. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre il mutex denominato specificato, se esistente, con l'accesso di sicurezza desiderato, e restituisce un valore che indica se l'operazione è stata completata.</summary>
        <returns>
          <see langword="true" /> se il mutex denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il mutex denominato non esiste, questo metodo non crearlo. Per creare il mutex di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.Mutex.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se un mutex denominato esiste, utilizzare questo overload del metodo anziché il <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> overload del metodo che genera un'eccezione se il mutex non esiste.  
  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa del mutex e <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.Mutex> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso mutex di sistema denominato.  
  
 Questo metodo non viene richiesta la proprietà del mutex.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Il mutex denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per usarlo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>