<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LockRecursionPolicy.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52aaae222fcf2f023007bf6b87e2bf7c7bb83adaa.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2aaae222fcf2f023007bf6b87e2bf7c7bb83adaa</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.LockRecursionPolicy">
          <source>Specifies whether a lock can be entered multiple times by the same thread.</source>
          <target state="translated">Specifica se lo stesso thread può accedere a un blocco più volte.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The default recursion policy depends on the type of lock.</source>
          <target state="translated">I criteri di ricorsione predefinito dipende dal tipo di blocco.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type.</source>
          <target state="translated">Per i criteri predefiniti e il comportamento preciso di ricorsione del blocco per qualsiasi tipo di blocco, vedere la documentazione per il tipo.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For example, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.</source>
          <target state="translated">Ad esempio, la <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> classe consente a un thread di accedere al blocco in modalità di scrittura, se già attivato il blocco in modalità di lettura, indipendentemente dall'impostazione di criteri di blocco, per ridurre il rischio di deadlock.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>Currently only one lock uses this enumeration:</source>
          <target state="translated">Attualmente disponibile solo per questa enumerazione viene utilizzata da un blocco:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property.</source>
          <target state="translated">Per altre informazioni, vedere la proprietà <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">L'esempio seguente mostra due scenari di eccezione, che varia a seconda di <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> impostazione e l'altro no.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively.</source>
          <target state="translated">Nel primo scenario, il thread accede al blocco in modalità di lettura e quindi tenta di accedere in modo ricorsivo alla modalità di lettura.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to NoRecursion, an exception is thrown.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> viene creato utilizzando il costruttore predefinito, che imposta i criteri di ricorsione di NoRecursion, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If SupportsRecursion is used to create the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">Se SupportsRecursion viene utilizzato per creare il <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, viene generata alcuna eccezione.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode.</source>
          <target state="translated">Nel secondo scenario, il thread accede al blocco in modalità di lettura e quindi tenta di attivare il blocco in modalità di scrittura.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> viene generata un'eccezione indipendentemente dai criteri di ricorsione del blocco.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>If a thread tries to enter a lock recursively, an exception is thrown.</source>
          <target state="translated">Se un thread tenta di accedere a un blocco in modo ricorsivo, viene generata un'eccezione.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>Some classes may allow certain recursions when this setting is in effect.</source>
          <target state="translated">È possibile che alcune classi consentano particolari ricorsioni quando questa impostazione è attivata.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>A thread can enter a lock recursively.</source>
          <target state="translated">Un thread può accedere a un blocco in modo ricorsivo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>Some classes may restrict this capability.</source>
          <target state="translated">Alcune classi possono limitare questa funzionalità.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>