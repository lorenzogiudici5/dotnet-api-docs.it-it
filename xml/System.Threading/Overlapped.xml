<Type Name="Overlapped" FullName="System.Threading.Overlapped">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d093e306bafb51c5f1ca1d17286310e5a1a8cfc" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406554" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Overlapped" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Overlapped extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Overlapped" />
  <TypeSignature Language="VB.NET" Value="Public Class Overlapped" />
  <TypeSignature Language="C++ CLI" Value="public ref class Overlapped" />
  <TypeSignature Language="F#" Value="type Overlapped = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading.Overlapped</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce una rappresentazione gestita di una struttura <c>OVERLAPPED</c> Win32, inclusi i metodi per trasferire le informazioni da un'istanza di <see cref="T:System.Threading.Overlapped" /> a una struttura <see cref="T:System.Threading.NativeOverlapped" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Overlapped.Pack%2A> e <xref:System.Threading.Overlapped.UnsafePack%2A> metodi trasferiscono le informazioni da un <xref:System.Threading.Overlapped> l'oggetto in un <xref:System.Threading.NativeOverlapped> struttura che può essere passato alle funzioni API Win32 per asincrono di file i/o. Il <xref:System.Threading.Overlapped.Unpack%2A> metodo trasferisce le informazioni da un <xref:System.Threading.NativeOverlapped> struttura a un'istanza del <xref:System.Threading.Overlapped> classe.  
  
 Modifiche alle proprietà di un <xref:System.Threading.Overlapped> oggetto interessano a essa associati <xref:System.Threading.NativeOverlapped> struttura e viceversa.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Overlapped" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Overlapped ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Overlapped();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza vuota della classe <see cref="T:System.Threading.Overlapped" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Overlapped (int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 offsetLo, int32 offsetHi, int32 hEvent, class System.IAsyncResult ar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (offsetLo As Integer, offsetHi As Integer, hEvent As Integer, ar As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ^ ar);" />
      <MemberSignature Language="F#" Value="new System.Threading.Overlapped : int * int * int * IAsyncResult -&gt; System.Threading.Overlapped" Usage="new System.Threading.Overlapped (offsetLo, offsetHi, hEvent, ar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Not 64bit compatible.  Please use the constructor that takes IntPtr for the event handle")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="offsetLo" Type="System.Int32" />
        <Parameter Name="offsetHi" Type="System.Int32" />
        <Parameter Name="hEvent" Type="System.Int32" />
        <Parameter Name="ar" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="offsetLo">Word meno significativa della posizione del file dalla quale avviare il trasferimento.</param>
        <param name="offsetHi">Word più significativa della posizione del file dalla quale avviare il trasferimento.</param>
        <param name="hEvent">Handle all'evento che riceve un segnale al completamento dell'operazione di I/O.</param>
        <param name="ar">Oggetto che implementa l'interfaccia <see cref="T:System.IAsyncResult" /> e fornisce informazioni sullo stato relative all'operazione di I/O.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Overlapped" /> con la posizione del file specificata, l'handle dell'integer a 32 bit per un evento che riceve un segnale al completamento dell'operazione di I/O e un'interfaccia tramite cui restituire i risultati dell'operazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare la <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=nameWithType> proprietà da ottenere l'handle di qualsiasi evento di sincronizzazione gestito da cui deriva il <xref:System.Threading.WaitHandle> (classe).  
  
 L'implementazione di <xref:System.IAsyncResult> fornisce informazioni sullo stato dell'operazione dei / o. Passare al costruttore nel `ar` parametro e recuperarli in un secondo momento con la <xref:System.Threading.Overlapped.AsyncResult%2A> proprietà. Se un metodo di callback specificato per il <xref:System.Threading.Overlapped.Pack%2A> o <xref:System.Threading.Overlapped.UnsafePack%2A> metodo, il callback può recuperare il <xref:System.IAsyncResult> da decomprimere il <xref:System.Threading.NativeOverlapped> struttura riceve.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Overlapped (int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 offsetLo, int32 offsetHi, native int hEvent, class System.IAsyncResult ar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (offsetLo As Integer, offsetHi As Integer, hEvent As IntPtr, ar As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ^ ar);" />
      <MemberSignature Language="F#" Value="new System.Threading.Overlapped : int * int * nativeint * IAsyncResult -&gt; System.Threading.Overlapped" Usage="new System.Threading.Overlapped (offsetLo, offsetHi, hEvent, ar)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="offsetLo" Type="System.Int32" />
        <Parameter Name="offsetHi" Type="System.Int32" />
        <Parameter Name="hEvent" Type="System.IntPtr" />
        <Parameter Name="ar" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="offsetLo">Word meno significativa della posizione del file dalla quale avviare il trasferimento.</param>
        <param name="offsetHi">Word più significativa della posizione del file dalla quale avviare il trasferimento.</param>
        <param name="hEvent">Handle all'evento che riceve un segnale al completamento dell'operazione di I/O.</param>
        <param name="ar">Oggetto che implementa l'interfaccia <see cref="T:System.IAsyncResult" /> e fornisce informazioni sullo stato relative all'operazione di I/O.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Overlapped" /> con la posizione del file specificata, l'handle per un evento che riceve un segnale al completamento dell'operazione di I/O e un'interfaccia tramite cui restituire i risultati dell'operazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere l'handle di un oggetto di sincronizzazione gestito che deriva dal <xref:System.Threading.WaitHandle> classe, usare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=nameWithType> proprietà da ottenere un <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> dell'oggetto e quindi chiamare il <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> metodo.  
  
 L'implementazione di <xref:System.IAsyncResult> fornisce informazioni sullo stato dell'operazione dei / o. Passare al costruttore nel `ar` parametro e recuperarli in un secondo momento con la <xref:System.Threading.Overlapped.AsyncResult%2A> proprietà. Se un metodo di callback specificato per il <xref:System.Threading.Overlapped.Pack%2A> o <xref:System.Threading.Overlapped.UnsafePack%2A> metodo, il callback può recuperare il <xref:System.IAsyncResult> da decomprimere il <xref:System.Threading.NativeOverlapped> struttura riceve.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncResult">
      <MemberSignature Language="C#" Value="public IAsyncResult AsyncResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IAsyncResult AsyncResult" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.AsyncResult" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncResult As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IAsyncResult ^ AsyncResult { IAsyncResult ^ get(); void set(IAsyncResult ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncResult : IAsyncResult with get, set" Usage="System.Threading.Overlapped.AsyncResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'oggetto che fornisce informazioni sullo stato relative all'operazione di I/O.</summary>
        <value>Oggetto che implementa l'interfaccia <see cref="T:System.IAsyncResult" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EventHandle">
      <MemberSignature Language="C#" Value="public int EventHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EventHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.EventHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property EventHandle As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EventHandle { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.EventHandle : int with get, set" Usage="System.Threading.Overlapped.EventHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Not 64bit compatible.  Use EventHandleIntPtr instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'handle dell'integer a 32 bit per un evento di sincronizzazione che riceve un segnale al completamento dell'operazione di I/O.</summary>
        <value>Valore <see cref="T:System.Int32" /> che rappresenta l'handle dell'evento di sincronizzazione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà non può essere utilizzata su piattaforme a 64 bit. In alternativa, usare la proprietà <xref:System.Threading.Overlapped.EventHandleIntPtr%2A>.  
  
 Utilizzare la <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=nameWithType> proprietà da ottenere l'handle di qualsiasi evento di sincronizzazione gestito da cui deriva il <xref:System.Threading.WaitHandle> (classe).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EventHandleIntPtr">
      <MemberSignature Language="C#" Value="public IntPtr EventHandleIntPtr { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int EventHandleIntPtr" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.EventHandleIntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Property EventHandleIntPtr As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr EventHandleIntPtr { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.EventHandleIntPtr : nativeint with get, set" Usage="System.Threading.Overlapped.EventHandleIntPtr" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'handle per l'evento di sincronizzazione che riceve un segnale al completamento dell'operazione di I/O.</summary>
        <value>Oggetto <see cref="T:System.IntPtr" /> che rappresenta l'handle dell'evento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ottenere l'handle di un oggetto di sincronizzazione gestito che deriva dal <xref:System.Threading.WaitHandle> classe, usare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=nameWithType> proprietà da ottenere un <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> dell'oggetto e quindi chiamare il <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> metodo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Free">
      <MemberSignature Language="C#" Value="public static void Free (System.Threading.NativeOverlapped* nativeOverlappedPtr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Free(valuetype System.Threading.NativeOverlapped* nativeOverlappedPtr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Free(System::Threading::NativeOverlapped* nativeOverlappedPtr);" />
      <MemberSignature Language="F#" Value="static member Free : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; unit" Usage="System.Threading.Overlapped.Free nativeOverlappedPtr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeOverlappedPtr" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="nativeOverlappedPtr">Puntatore alla struttura <see cref="T:System.Threading.NativeOverlapped" /> da liberare.</param>
        <summary>Libera la memoria non gestita associata a una struttura sovrapposta nativa allocata dal metodo <see cref="Overload:System.Threading.Overlapped.Pack" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 È necessario chiamare il <xref:System.Threading.Overlapped.Free%2A> metodo esattamente una volta su ogni <xref:System.Threading.NativeOverlapped> puntatore si riceve dal <xref:System.Threading.Overlapped.Pack%2A> metodo. Se non si chiama il <xref:System.Threading.Overlapped.Free%2A> metodo, si verificherà una perdita di memoria. Se si chiama il <xref:System.Threading.Overlapped.Free%2A> metodo più volte, memoria verrà danneggiata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="nativeOverlappedPtr" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName="OffsetHigh">
      <MemberSignature Language="C#" Value="public int OffsetHigh { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OffsetHigh" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.OffsetHigh" />
      <MemberSignature Language="VB.NET" Value="Public Property OffsetHigh As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OffsetHigh { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.OffsetHigh : int with get, set" Usage="System.Threading.Overlapped.OffsetHigh" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la word più significativa della posizione del file dalla quale avviare il trasferimento. La posizione del file è un offset dei byte dall'inizio del file.</summary>
        <value>Valore <see cref="T:System.Int32" /> che rappresenta la word più significativa della posizione del file.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetLow">
      <MemberSignature Language="C#" Value="public int OffsetLow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OffsetLow" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Overlapped.OffsetLow" />
      <MemberSignature Language="VB.NET" Value="Public Property OffsetLow As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OffsetLow { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.OffsetLow : int with get, set" Usage="System.Threading.Overlapped.OffsetLow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta la word meno significativa della posizione del file dalla quale avviare il trasferimento. La posizione del file è un offset dei byte dall'inizio del file.</summary>
        <value>Valore <see cref="T:System.Int32" /> che rappresenta la word meno significativa della posizione del file.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Pack">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comprime l'istanza corrente in una struttura <see cref="T:System.Threading.NativeOverlapped" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pack">
      <MemberSignature Language="C#" Value="public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.NativeOverlapped* Pack(class System.Threading.IOCompletionCallback iocb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::NativeOverlapped* Pack(System::Threading::IOCompletionCallback ^ iocb);" />
      <MemberSignature Language="F#" Value="member this.Pack : System.Threading.IOCompletionCallback -&gt; nativeptr&lt;System.Threading.NativeOverlapped&gt;" Usage="overlapped.Pack iocb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use Pack(iocb, userData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.NativeOverlapped*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iocb" Type="System.Threading.IOCompletionCallback" />
      </Parameters>
      <Docs>
        <param name="iocb">Delegato <see cref="T:System.Threading.IOCompletionCallback" /> che rappresenta il metodo di callback chiamato al completamento dell'operazione di I/O asincrona.</param>
        <summary>Comprime l'istanza corrente in una struttura <see cref="T:System.Threading.NativeOverlapped" />, specificando il delegato da richiamare al completamento dell'operazione di I/O asincrona.</summary>
        <returns>Puntatore non gestito a una struttura <see cref="T:System.Threading.NativeOverlapped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il puntatore non gestito restituito da questo metodo può essere passato al sistema operativo in operazioni dei / o sovrapposte. Il <xref:System.Threading.NativeOverlapped> struttura è fissa nella memoria fisica finché <xref:System.Threading.Overlapped.Unpack%2A> viene chiamato.  
  
> [!IMPORTANT]
>  Il chiamante è responsabile del blocco del buffer. Se il dominio applicazione viene scaricato, tuttavia, l'handle del buffer bloccato viene eliminato e il buffer viene rilasciato, lasciando l'operazione dei / o scrivere all'indirizzo liberato. Per questo motivo, è preferibile utilizzare il <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> overload del metodo, in cui il runtime blocca il buffer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Threading.Overlapped" /> corrente è già stato compresso.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName="Pack">
      <MemberSignature Language="C#" Value="public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.NativeOverlapped* Pack(class System.Threading.IOCompletionCallback iocb, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::NativeOverlapped* Pack(System::Threading::IOCompletionCallback ^ iocb, System::Object ^ userData);" />
      <MemberSignature Language="F#" Value="member this.Pack : System.Threading.IOCompletionCallback * obj -&gt; nativeptr&lt;System.Threading.NativeOverlapped&gt;" Usage="overlapped.Pack (iocb, userData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.NativeOverlapped*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iocb" Type="System.Threading.IOCompletionCallback" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="iocb">Delegato <see cref="T:System.Threading.IOCompletionCallback" /> che rappresenta il metodo di callback chiamato al completamento dell'operazione di I/O asincrona.</param>
        <param name="userData">Oggetto o matrice di oggetti che rappresenta il buffer di input o output per l'operazione. Ogni oggetto rappresenta uno buffer, ad esempio una matrice di byte.</param>
        <summary>Comprime l'istanza corrente in una struttura <see cref="T:System.Threading.NativeOverlapped" />, specificando un delegato da richiamare al completamento dell'operazione di I/O asincrona e un oggetto gestito da utilizzare come buffer.</summary>
        <returns>Puntatore non gestito a una struttura <see cref="T:System.Threading.NativeOverlapped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il puntatore non gestito restituito da questo metodo può essere passato al sistema operativo in operazioni dei / o sovrapposte. Il <xref:System.Threading.NativeOverlapped> struttura è fissa nella memoria fisica finché <xref:System.Threading.Overlapped.Unpack%2A> viene chiamato.  
  
 Il buffer o buffer specificato in `userData` devono essere identici a quelli passati alla funzione non gestita del sistema operativo che esegue il / o asincrona.  
  
> [!NOTE]
>  Il runtime blocca il buffer o buffer specificato in `userData` per tutta la durata dell'operazione dei / o. Se il dominio applicazione viene scaricato, il runtime mantiene la memoria bloccata fino al completamento dell'operazione dei / o.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Threading.Overlapped" /> corrente è già stato compresso.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unpack">
      <MemberSignature Language="C#" Value="public static System.Threading.Overlapped Unpack (System.Threading.NativeOverlapped* nativeOverlappedPtr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Overlapped Unpack(valuetype System.Threading.NativeOverlapped* nativeOverlappedPtr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Overlapped ^ Unpack(System::Threading::NativeOverlapped* nativeOverlappedPtr);" />
      <MemberSignature Language="F#" Value="static member Unpack : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; System.Threading.Overlapped" Usage="System.Threading.Overlapped.Unpack nativeOverlappedPtr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Overlapped</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeOverlappedPtr" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="nativeOverlappedPtr">Puntatore non gestito a una struttura <see cref="T:System.Threading.NativeOverlapped" />.</param>
        <summary>Decomprime la struttura non gestita <see cref="T:System.Threading.NativeOverlapped" /> specificata in un oggetto <see cref="T:System.Threading.Overlapped" /> gestito.</summary>
        <returns>Oggetto <see cref="T:System.Threading.Overlapped" /> contenente le informazioni decompresse dalla struttura nativa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.NativeOverlapped> struttura non viene liberata dalla memoria fisica finché non si chiama il <xref:System.Threading.Overlapped.Free%2A> metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="nativeOverlappedPtr" /> è <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafePack">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comprime l'istanza corrente in una struttura <see cref="T:System.Threading.NativeOverlapped" />. Non propaga lo stack della chiamata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafePack">
      <MemberSignature Language="C#" Value="public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.NativeOverlapped* UnsafePack(class System.Threading.IOCompletionCallback iocb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::NativeOverlapped* UnsafePack(System::Threading::IOCompletionCallback ^ iocb);" />
      <MemberSignature Language="F#" Value="member this.UnsafePack : System.Threading.IOCompletionCallback -&gt; nativeptr&lt;System.Threading.NativeOverlapped&gt;" Usage="overlapped.UnsafePack iocb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use UnsafePack(iocb, userData) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.NativeOverlapped*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iocb" Type="System.Threading.IOCompletionCallback" />
      </Parameters>
      <Docs>
        <param name="iocb">Delegato <see cref="T:System.Threading.IOCompletionCallback" /> che rappresenta il metodo di callback chiamato al completamento dell'operazione di I/O asincrona.</param>
        <summary>Comprime l'istanza corrente in una struttura <see cref="T:System.Threading.NativeOverlapped" />, specificando il delegato da richiamare al completamento dell'operazione di I/O asincrona. Non propaga lo stack della chiamata.</summary>
        <returns>Puntatore non gestito a una struttura <see cref="T:System.Threading.NativeOverlapped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il puntatore non gestito restituito da questo metodo può essere passato al sistema operativo in operazioni dei / o sovrapposte. Il <xref:System.Threading.NativeOverlapped> struttura è fissa nella memoria fisica finché <xref:System.Threading.Overlapped.Unpack%2A> viene chiamato.  
  
 Il chiamante è responsabile del blocco del buffer. Se il dominio applicazione viene scaricato, tuttavia, l'handle del buffer bloccato viene eliminato e il buffer viene rilasciato, lasciando l'operazione dei / o scrivere all'indirizzo liberato. Per questo motivo, è preferibile utilizzare il <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> overload del metodo, in cui il runtime blocca il buffer.  
  
> [!CAUTION]
>  Utilizzando il <xref:System.Threading.Overlapped.UnsafePack%2A> metodo è stato possibile aprire inavvertitamente un problema di sicurezza. Sicurezza dall'accesso di codice si basa relativi controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack. Il <xref:System.Threading.Overlapped.UnsafePack%2A> metodo non propaga lo stack di chiamate. Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Threading.Overlapped" /> corrente è già stato compresso.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafePack">
      <MemberSignature Language="C#" Value="public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.NativeOverlapped* UnsafePack(class System.Threading.IOCompletionCallback iocb, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::NativeOverlapped* UnsafePack(System::Threading::IOCompletionCallback ^ iocb, System::Object ^ userData);" />
      <MemberSignature Language="F#" Value="member this.UnsafePack : System.Threading.IOCompletionCallback * obj -&gt; nativeptr&lt;System.Threading.NativeOverlapped&gt;" Usage="overlapped.UnsafePack (iocb, userData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Overlapped</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.NativeOverlapped*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iocb" Type="System.Threading.IOCompletionCallback" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="iocb">Delegato <see cref="T:System.Threading.IOCompletionCallback" /> che rappresenta il metodo di callback chiamato al completamento dell'operazione di I/O asincrona.</param>
        <param name="userData">Oggetto o matrice di oggetti che rappresenta il buffer di input o output per l'operazione. Ogni oggetto rappresenta uno buffer, ad esempio una matrice di byte.</param>
        <summary>Comprime l'istanza corrente in una struttura <see cref="T:System.Threading.NativeOverlapped" />, specificando il delegato da richiamare al completamento dell'operazione di I/O asincrona e un oggetto gestito da utilizzare come buffer. Non propaga lo stack della chiamata.</summary>
        <returns>Puntatore non gestito a una struttura <see cref="T:System.Threading.NativeOverlapped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il puntatore non gestito restituito da questo metodo può essere passato al sistema operativo in operazioni dei / o sovrapposte. Il <xref:System.Threading.NativeOverlapped> struttura è fissa nella memoria fisica finché <xref:System.Threading.Overlapped.Unpack%2A> viene chiamato.  
  
 Il buffer o buffer specificato in `userData` devono essere identici a quelli passati alla funzione non gestita del sistema operativo che esegue il / o asincrona.  
  
 Il runtime blocca il buffer o buffer specificato in`userData` per tutta la durata dell'operazione dei / o. Se il dominio applicazione viene scaricato, il runtime mantiene la memoria bloccata fino al completamento dell'operazione dei / o.  
  
> [!CAUTION]
>  Utilizzando il <xref:System.Threading.Overlapped.UnsafePack%2A> metodo è stato possibile aprire inavvertitamente un problema di sicurezza. Sicurezza dall'accesso di codice si basa relativi controlli delle autorizzazioni sulle autorizzazioni di tutti i chiamanti nello stack. Il <xref:System.Threading.Overlapped.UnsafePack%2A> metodo non propaga lo stack di chiamate. Codice dannoso potrebbe essere in grado di sfruttare questa vulnerabilità per evitare i controlli di autorizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.InvalidOperationException">L'oggetto <see cref="T:System.Threading.Overlapped" /> corrente è già compresso.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo da terminare mentre è in attesa per un thread in background terminare l'esecuzione. L'istanza corrente è un proxy trasparente per un  in un altro dominio applicazione.</permission>
      </Docs>
    </Member>
  </Members>
</Type>