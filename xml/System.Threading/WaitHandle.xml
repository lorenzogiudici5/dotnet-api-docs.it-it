<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5bc57b6d09c8f3f7aebbf5cc7bfbbcb207a197ba" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51937861" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Incapsula oggetti specifici del sistema operativo che attendono l'accesso esclusivo alle risorse condivise.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.WaitHandle> classe incapsula un handle di sincronizzazione nativo del sistema operativo e viene utilizzata per rappresentare tutti gli oggetti di sincronizzazione in fase di esecuzione che consentono più operazioni di attesa. Per un confronto tra gli handle di attesa con altri oggetti di sincronizzazione, vedere [panoramica delle primitive di sincronizzazione](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 Il <xref:System.Threading.WaitHandle> classe è astratta. Le classi derivate da <xref:System.Threading.WaitHandle> definire un meccanismo di segnalazione che indica l'attivazione o la disattivazione dell'accesso a una risorsa condivisa, ma usare ereditato <xref:System.Threading.WaitHandle> metodi per bloccare l'attesa per l'accesso alle risorse condivise. Le classi derivate da <xref:System.Threading.WaitHandle> includono:  
  
-   Classe <xref:System.Threading.Mutex>. Visualizzare [mutex](~/docs/standard/threading/mutexes.md).  
  
-   Il <xref:System.Threading.EventWaitHandle> classe e delle relative classi derivate <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>. Vedere [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   Classe <xref:System.Threading.Semaphore>. Visualizzare [Semaphore e SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Thread può essere bloccata su un singolo handle di attesa chiamando il metodo di istanza <xref:System.Threading.WaitHandle.WaitOne%2A>, che viene ereditata dalle classi derivate da <xref:System.Threading.WaitHandle>.  
  
 Le classi derivate di <xref:System.Threading.WaitHandle> differiscono relativa affinità dei thread. Handle di attesa evento (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, e <xref:System.Threading.ManualResetEvent>) e i semafori non presentano affinità di thread; qualsiasi thread può segnalare un semaforo o un handle di attesa evento. I mutex, d'altra parte, presentano affinità di thread; il thread che possiede un mutex necessario rilasciarlo e viene generata un'eccezione se un thread chiama il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo su un mutex di cui non è proprietario.  
  
 Poiché il <xref:System.Threading.WaitHandle> deriva dalla classe <xref:System.MarshalByRefObject>, queste classi possono essere utilizzate per sincronizzare le attività dei thread tra i limiti del dominio applicazione.  
  
 Oltre alle relative classi derivate di <xref:System.Threading.WaitHandle> classe ha un numero di metodi statici che blocca un thread finché uno o più oggetti di sincronizzazione ricevano un segnale. Sono inclusi:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, che consente a un thread segnalare un handle di attesa e immediatamente in attesa su un altro.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, che consente a un thread in attesa finché tutti gli handle di attesa in una matrice ricevano un segnale.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, che consente a un thread in attesa fino a quando non uno di un set specificato di handle di attesa è stato segnalato.  
  
 Gli overload di questi metodi forniscono gli intervalli di timeout per l'abbandono dell'attesa e la possibilità di uscire da un contesto di sincronizzazione prima dell'attesa, usare il contesto di sincronizzazione di altri thread.  
  
> [!IMPORTANT]
>  Questo tipo implementa la <xref:System.IDisposable> interfaccia. Dopo aver utilizzando il tipo o un tipo derivato da esso, è necessario eliminarlo direttamente o indirettamente. Per eliminare il tipo direttamente, chiamare relativi <xref:System.Threading.WaitHandle.Close%2A> metodo in un `try` / `catch` blocco. Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic. Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.  
  
 <xref:System.Threading.WaitHandle> implementa il <xref:System.IDisposable.Dispose%2A> pattern. Visualizzare [modello Dispose](~/docs/standard/design-guidelines/dispose-pattern.md). Quando si deriva da <xref:System.Threading.WaitHandle>, usare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà per archiviare l'handle nativo del sistema operativo. Non è necessario eseguire l'override protetto <xref:System.Threading.WaitHandle.Dispose%2A> metodo se non si usano altre risorse non gestite.  
  
   
  
## Examples  
 Nell'esempio di codice riportato di seguito viene illustrato come due thread possono eseguire attività in background mentre principale thread attende l'attività da completare tramite il metodo statico <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.WaitAll%2A> metodi del <xref:System.Threading.WaitHandle> classe.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Threading</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Oggetti e funzionalità del threading</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutex</related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semafori</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse contenute nell'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è l'implementazione pubblica del <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodo per il <xref:System.Threading.WaitHandle> classe e le relative classi derivate. Fornisce un'implementazione standard che chiama il `Dispose(Boolean)` rapporto di overload con un `true` argomento e quindi chiama il <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (metodo). Chiamare questo metodo per rilasciare tutte le risorse utilizzate da un'istanza di `WaitHandle` o una classe derivata.  
  
 Una volta che viene chiamato questo metodo, i riferimenti all'istanza corrente causano un comportamento indefinito.  
  
> [!NOTE]
>  Chiamare sempre <xref:System.Threading.WaitHandle.Close%2A> oppure <xref:System.Threading.WaitHandle.Dispose> prima di rilasciare l'ultimo riferimento al <xref:System.Threading.WaitHandle>. In caso contrario, le risorse utilizzate non verranno liberate.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È consigliabile eseguire l'override di <see langword="Dispose(Boolean)" /> metodo per rilasciare le risorse allocate classi derivate.</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementazione di un metodo Dispose</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo equivale al <xref:System.Threading.WaitHandle.Close%2A> (metodo).  
  
> [!NOTE]
>  Chiamare sempre <xref:System.Threading.WaitHandle.Close%2A> oppure <xref:System.Threading.WaitHandle.Dispose> prima di rilasciare l'ultimo riferimento al <xref:System.Threading.WaitHandle>. In caso contrario, le risorse utilizzate non verranno liberate.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Pulizia delle risorse non gestite</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</param>
        <summary>Quando ne viene eseguito l'override in una classe derivata, libera le risorse non gestite usate da <see cref="T:System.Threading.WaitHandle" /> ed eventualmente di liberare le risorse gestite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo viene chiamato il <xref:System.Threading.WaitHandle.Close%2A> e il <xref:System.Threading.WaitHandle.Dispose> metodi con il `explicitDisposing` parametro impostato su `true`.  Quando la `explicitDisposing` parametro è `true`, questo metodo rilascia tutte le risorse utilizzate da qualsiasi oggetto gestito da questo <xref:System.Threading.WaitHandle> riferimenti a oggetti.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È consigliabile eseguire l'override di <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> metodo per rilasciare le risorse allocate classi derivate.  
  
Il <see cref="M:System.Threading.WaitHandle.Close" /> o <see cref="M:System.Threading.WaitHandle.Dispose" /> metodo può essere chiamato più volte da altri oggetti. Quando si esegue l'override di questo metodo, prestare attenzione a non fare riferimento agli oggetti che sono stati eliminati in una precedente chiamata a <see langword="Dispose" /> o <see langword="Close" />.</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementazione di un metodo Dispose</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'handle nativo del sistema operativo.</summary>
        <value>
          <see langword="IntPtr" /> che rappresenta l'handle nativo del sistema operativo. Il valore predefinito è quello del campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assegnazione di un nuovo valore per il <xref:System.Threading.WaitHandle.Handle%2A> proprietà non chiude l'handle precedente. Ciò può comportare la perdita di una handle.  
  
 Non utilizzare questa proprietà in .NET Framework versione 2.0 o successiva. usare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà invece. Impostando questa proprietà su un handle valido anche set il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà, ma impostandola su <xref:System.Threading.WaitHandle.InvalidHandle> può comportare la perdita di una handle.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Richiede l'attendibilità totale per il chiamante immediato impostare il valore della proprietà. Questo membro non può essere impostato dal codice parzialmente attendibile o trasparente.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">I tipi derivati devono avere <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> per impostare il valore della proprietà.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Rappresenta un handle nativo del sistema operativo non valido. Questo campo è di sola lettura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzato internamente per inizializzare il <xref:System.Threading.WaitHandle.Handle%2A> proprietà.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>È possibile usare questo valore per determinare se il <see cref="P:System.Threading.WaitHandle.Handle" /> proprietà contiene un handle nativo del sistema operativo valido.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'handle nativo del sistema operativo.</summary>
        <value>Oggetto <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> che rappresenta l'handle nativo del sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si assegna un nuovo valore per il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà, l'handle precedente verrà chiusa quando precedente <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> oggetto viene raccolto. Non chiudere manualmente l'handle, in quanto il risultato è un' <xref:System.ObjectDisposedException> quando il <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> tenta di chiudere l'handle.  
  
 <xref:System.Threading.WaitHandle> implementa il <xref:System.IDisposable.Dispose%2A> pattern. Visualizzare [modello Dispose](~/docs/standard/design-guidelines/dispose-pattern.md). Quando si deriva da <xref:System.Threading.WaitHandle>, usare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà per archiviare l'handle del sistema operativo nativo. Non è necessario eseguire l'override protetto <xref:System.Threading.WaitHandle.Dispose%2A> metodo se non si usano altre risorse non gestite.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">I tipi derivati devono avere <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> per chiamare questo membro.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa in un altro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">Oggetto <see cref="T:System.Threading.WaitHandle" /> da segnalare.</param>
        <param name="toWaitOn">Oggetto <see cref="T:System.Threading.WaitHandle" /> in cui restare in attesa.</param>
        <summary>Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa in un altro.</summary>
        <returns>
          <see langword="true" /> in caso di esito positivo sia della segnalazione che dell'attesa. Se l'attesa non viene completata, il metodo non restituisce alcun risultato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa operazione non è garantita a essere atomici. Dopo il thread corrente segnala `toSignal` ma prima è in attesa di `toWaitOn`, un thread in esecuzione in un altro processore potrebbero segnalare `toWaitOn` o in attesa su di esso.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere che il thread termina un'attività.  
  
 L'esempio avviati cinque thread, consente di bloccare un' <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag e quindi rilascia un thread ogni volta l'utente preme il tasto INVIO. Nell'esempio viene quindi Accoda altri cinque thread e vengono rilasciati tutti usando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> è <see langword="null" />.  
  
oppure 
 <paramref name="toWaitOn" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il metodo è stato chiamato su un thread che dispone di <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> è un semaforo e dispone già di un conteggio completo.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">Oggetto <see cref="T:System.Threading.WaitHandle" /> da segnalare.</param>
        <param name="toWaitOn">Oggetto <see cref="T:System.Threading.WaitHandle" /> in cui restare in attesa.</param>
        <param name="millisecondsTimeout">Intero che rappresenta l'intervallo di attesa. Se il valore è <see cref="F:System.Threading.Timeout.Infinite" />, ovvero -1, l'attesa è infinita.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</param>
        <summary>Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa in un altro, specificando un intervallo di timeout come intero con segno a 32 bit e indicando se uscire dal dominio di sincronizzazione per il contesto prima dell'attesa.</summary>
        <returns>
          <see langword="true" /> in caso di esito positivo sia della segnalazione che dell'attesa oppure <see langword="false" /> se la segnalazione è stata completata ma si è verificato il timeout dell'attesa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa operazione non è garantita a essere atomici. Dopo il thread corrente segnala `toSignal` ma prima è in attesa di `toWaitOn`, un thread in esecuzione in un altro processore potrebbero segnalare `toWaitOn` o in attesa su di esso.  
  
 Se `millisecondsTimeout` è uguale a zero, il metodo non blocca. Controlla lo stato del `toWaitOn` e risponda immediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo). Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> è <see langword="null" />.  
  
oppure 
 <paramref name="toWaitOn" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il metodo viene chiamato su un thread che dispone di <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">Non è possibile segnalare la classe <see cref="T:System.Threading.WaitHandle" /> perché supererebbe il conteggio massimo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">Oggetto <see cref="T:System.Threading.WaitHandle" /> da segnalare.</param>
        <param name="toWaitOn">Oggetto <see cref="T:System.Threading.WaitHandle" /> in cui restare in attesa.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta l'intervallo di attesa. Se il valore è -1, l'attesa è infinita.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</param>
        <summary>Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa di un altro, specificando l'intervallo di timeout come <see cref="T:System.TimeSpan" /> e indicando se uscire dal dominio di sincronizzazione per il contesto prima dell'attesa.</summary>
        <returns>
          <see langword="true" /> in caso di esito positivo sia della segnalazione che dell'attesa oppure <see langword="false" /> se la segnalazione è stata completata ma si è verificato il timeout dell'attesa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa operazione non è garantita a essere atomici. Dopo il thread corrente segnala `toSignal` ma prima è in attesa di `toWaitOn`, un thread in esecuzione in un altro processore potrebbero segnalare `toWaitOn` o in attesa su di esso.  
  
 Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Se `timeout` è uguale a zero, il metodo non blocca. Controlla lo stato del `toWaitOn` e risponda immediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo). Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> è <see langword="null" />.  
  
oppure 
 <paramref name="toWaitOn" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il metodo è stato chiamato su un thread che dispone di <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" /> è un semaforo e dispone già di un conteggio completo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> restituisce un numero di millisecondi negativo diverso da -1.  
  
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attende che tutti gli elementi nella matrice specificata ricevano un segnale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà. Questa matrice non può contenere più riferimenti allo stesso oggetto.</param>
        <summary>Attende che tutti gli elementi nella matrice specificata ricevano un segnale.</summary>
        <returns>
          <see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, il metodo non restituisce alcun risultato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0. Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAll%2A> restituzione del metodo `true` quando viene abbandonato un mutex. Un mutex abbandonato indica spesso un grave errore di codifica. Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows). L'eccezione contiene informazioni utili per il debug.  
  
 Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando tutti gli handle vengono segnalati. In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione. Se la matrice contiene duplicati, la chiamata ha esito negativo con un <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.  
  
 Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload del metodo e specificare -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) per `millisecondsTimeout` e `true` per `exitContext`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come usare il pool di thread per creare e scrivere in un gruppo di file in modo asincrono. Ogni operazione di scrittura viene accodata come un elemento di lavoro e segnala al termine. Il thread principale attende che tutti gli elementi segnalare e quindi viene chiuso.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />. oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.  
  
oppure 
 <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 2.0 o successiva.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 In <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.ArgumentException" />.  
  
</para>
          </block>  
  
 La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.  
  
oppure 
L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà. Questa matrice non può contenere più riferimenti allo stesso oggetto (duplicati).</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.Int32" /> per specificare l'intervallo di tempo.</summary>
        <returns>
          <see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando l'attesa termina, vale a dire tutti gli handle vengono segnalati o quando si verifica il timeout. In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione. Se sono presenti duplicati nella matrice, la chiamata ha esito negativo con un <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.  
  
 Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.  
  
oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.  
  
oppure 
 <paramref name="waitHandles" /> è una matrice senza elementi.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 In <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.ArgumentException" />.  
  
</para>
          </block>  
  
 La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.  
  
oppure 
L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà. Questa matrice non può contenere più riferimenti allo stesso oggetto.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo.</summary>
        <returns>
          <see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando termina l'attesa, ovvero tutti gli handle vengono segnalati o si verifica un timeout. In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione. Se la matrice contiene duplicati, la chiamata avrà esito negativo.  
  
> [!NOTE]
>  Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.  
  
 Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.  
  
oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.  
  
oppure 
 <paramref name="waitHandles" /> è una matrice senza elementi.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 In <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.ArgumentException" />.  
  
</para>
          </block>  
  
 La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.  
  
oppure 
L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà. Questa matrice non può contenere più riferimenti allo stesso oggetto (duplicati).</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</param>
        <summary>Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.Int32" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</summary>
        <returns>
          <see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0. Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAll%2A> restituzione del metodo `true` quando viene abbandonato un mutex. Un mutex abbandonato indica spesso un grave errore di codifica. Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows). L'eccezione contiene informazioni utili per il debug.  
  
 Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando l'attesa termina, vale a dire tutti gli handle vengono segnalati o quando si verifica il timeout. In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione. Se sono presenti duplicati nella matrice, la chiamata ha esito negativo con un <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se un metodo attualmente in esecuzione in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo). Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto presenta la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attributo. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come usare il pool di thread per creare e scrivere in un gruppo di file in modo asincrono. Ogni operazione di scrittura viene accodata come un elemento di lavoro e segnala al termine. Il thread principale attende che tutti gli elementi segnalare e quindi viene chiuso.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.  
  
oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.  
  
oppure 
 <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 2.0 o successiva.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.  
  
oppure 
L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà. Questa matrice non può contenere più riferimenti allo stesso oggetto.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</param>
        <summary>Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</summary>
        <returns>
          <see langword="true" /> quando ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0. Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAll%2A> restituzione del metodo `true` quando viene abbandonato un mutex. Un mutex abbandonato indica spesso un grave errore di codifica. Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows). L'eccezione contiene informazioni utili per il debug.  
  
 Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando termina l'attesa, ovvero tutti gli handle vengono segnalati o si verifica un timeout. In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione. Se la matrice contiene duplicati, la chiamata avrà esito negativo.  
  
> [!NOTE]
>  Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.  
  
 Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se un metodo attualmente in esecuzione in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo). Restituisce il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come usare il pool di thread per creare e scrivere in un gruppo di file in modo asincrono. Ogni operazione di scrittura viene accodata come un elemento di lavoro e segnala al termine. Il thread principale attende che tutti gli elementi segnalare e quindi viene chiuso.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.  
  
oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.  
  
oppure 
 <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 2.0 o successiva.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.  
  
oppure 
L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attende che uno degli elementi nella matrice specificata riceva un segnale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</param>
        <summary>Attende che uno degli elementi nella matrice specificata riceva un segnale.</summary>
        <returns>Indice della matrice dell'oggetto che ha soddisfatto l'attesa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0. Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAny%2A> restituzione del metodo `true` se il tempo di attesa viene completata perché un mutex viene abbandonato. Un mutex abbandonato indica spesso un grave errore di codifica. Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows). L'eccezione contiene informazioni utili per il debug.  
  
 Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato. Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.  
  
> [!NOTE]
>  Nelle versioni di .NET Framework precedenti alla versione 2.0, se un thread termina o si interrompe senza rilasciare in modo esplicito un <xref:System.Threading.Mutex>e che `Mutex` è in corrispondenza dell'indice 0 (zero) in un `WaitAny` array in un altro thread, l'indice restituito da `WaitAny` è 128 anziché 0.  
  
 Questo metodo restituisce quando viene segnalato un handle qualsiasi. Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati. In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.  
  
 Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload del metodo e specificare -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) per `millisecondsTimeout` e `true` per `exitContext`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come chiamare il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo).  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.  
  
oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è la 2.0 o successiva.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo.</summary>
        <returns>Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato. Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.  
  
 Questo metodo restituisce la fine dell'attesa, uno degli handle vengono segnalato o quando si verifica un timeout. Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati. In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.  
  
 Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.  
  
oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> è una matrice senza elementi.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo.</summary>
        <returns>Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato. Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.  
  
 Questo metodo restituisce la fine dell'attesa, uno degli handle vengono segnalato o quando si verifica un timeout. Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati. In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.  
  
 Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.  
  
oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> è una matrice senza elementi.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</param>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</param>
        <summary>Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</summary>
        <returns>Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0. Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAny%2A> restituzione del metodo `true` se il tempo di attesa viene completata perché un mutex viene abbandonato. Un mutex abbandonato indica spesso un grave errore di codifica. Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows). L'eccezione contiene informazioni utili per il debug.  
  
 Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato. Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.  
  
> [!NOTE]
>  Nelle versioni di .NET Framework precedenti alla versione 2.0, se un thread termina o si interrompe senza rilasciare in modo esplicito un <xref:System.Threading.Mutex>e che `Mutex` è in corrispondenza dell'indice 0 (zero) in un `WaitAny` array in un altro thread, l'indice restituito da `WaitAny` è 128 anziché 0.  
  
 Questo metodo restituisce la fine dell'attesa, uno degli handle vengono segnalato o quando si verifica un timeout. Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati. In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo). Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come usare il pool di thread contemporaneamente cercare un file su più dischi. Per motivi di spazio, viene cercata solo nella directory radice di ogni disco.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.  
  
oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è la 2.0 o successiva.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</param>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</param>
        <summary>Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</summary>
        <returns>Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0. Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAny%2A> restituzione del metodo `true` se il tempo di attesa viene completata perché un mutex viene abbandonato. Un mutex abbandonato indica spesso un grave errore di codifica. Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows). L'eccezione contiene informazioni utili per il debug.  
  
 Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato. Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.  
  
> [!NOTE]
>  Nelle versioni di .NET Framework precedenti alla versione 2.0, se un thread termina o si interrompe senza rilasciare in modo esplicito un <xref:System.Threading.Mutex>e che `Mutex` è in corrispondenza dell'indice 0 (zero) in un `WaitAny` array in un altro thread, l'indice restituito da `WaitAny` è 128 anziché 0.  
  
 Questo metodo restituisce la fine dell'attesa, uno degli handle vengono segnalato o quando si verifica un timeout. Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati. In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.  
  
 Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo). Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come usare il pool di thread contemporaneamente cercare un file su più dischi. Per motivi di spazio, viene cercata solo nella directory radice di ogni disco.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.  
  
oppure 
Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è la 2.0 o successiva.</exception>
        <exception cref="T:System.InvalidOperationException">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale.</summary>
        <returns>Viene restituito <see langword="true" /> se l'istanza corrente riceve un segnale. Se l'istanza corrente non viene mai segnalata, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> non restituisce mai alcun valore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0. Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituzione del metodo `true` quando viene abbandonato un mutex. Un mutex abbandonato indica spesso un grave errore di codifica. Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows). L'eccezione contiene informazioni utili per il debug.  
  
 Il chiamante di questo metodo si blocca in modo indefinito finché l'istanza corrente riceve un segnale. Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona. Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.  
  
 Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload del metodo e specificare -1 o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> per il primo parametro e `false` per il secondo parametro.  
  
 Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo venga terminato durante l'attesa di un thread in background terminare l'esecuzione.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo.</summary>
        <returns>
          <see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout. Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona. Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.  
  
 Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.  
  
 Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo venga terminato durante l'attesa di un thread in background terminare l'esecuzione.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <summary>Blocca il thread corrente finché l'istanza corrente non riceve un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo.</summary>
        <returns>
          <see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout. Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona. Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.  
  
 Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.  
  
 Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</param>
        <summary>Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</summary>
        <returns>
          <see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0. Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituzione del metodo `true` quando viene abbandonato un mutex. Un mutex abbandonato indica spesso un grave errore di codifica. Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows). L'eccezione contiene informazioni utili per il debug.  
  
 Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout. Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona. Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.  
  
 Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo). Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.  
  
   
  
## Examples  
 L'esempio seguente illustra come il <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload del metodo si comporta quando viene chiamato all'interno di un dominio di sincronizzazione. In primo luogo, un thread attende con `exitContext` impostato su `false` e blocca fino a quando non scade il timeout di attesa. Un secondo thread viene eseguito dopo il primo thread termina e resta in attesa con `exitContext` impostato su `true`. La chiamata per segnalare l'handle di attesa per il secondo thread non è bloccata e il thread viene completata prima del timeout di attesa.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</param>
        <param name="exitContext">
          <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</param>
        <summary>Blocca il thread corrente finché l'istanza corrente non riceve un segnale, usando un oggetto <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</summary>
        <returns>
          <see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` è uguale a zero, il metodo non blocca. Verifica lo stato dell'handle di attesa e restituisce immediatamente.  
  
 <xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0. Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituzione del metodo `true` quando viene abbandonato un mutex. Un mutex abbandonato indica spesso un grave errore di codifica. Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows). L'eccezione contiene informazioni utili per il debug.  
  
 Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout. Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona. Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.  
  
 Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.  
  
 Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Note sull'uscita dal contesto  
 Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo chiamato dall'interno di un contesto gestito. Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>. Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.  
  
 Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo). Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene completato.  
  
 Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe. Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare. Quando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo venga terminato durante l'attesa di un thread in background terminare l'esecuzione.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza corrente è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito. 
oppure 
 <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex. Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indica che si è verificato il timeout di un'operazione <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> prima della segnalazione di uno degli handle di attesa. Questo campo è costante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo campo è uno dei possibili valori restituiti di `WaitAny`.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come usare il pool di thread contemporaneamente cercare un file su più dischi. Per motivi di spazio, viene cercata solo nella directory radice di ogni disco.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>