<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3118dc18b7fa730ca98fb9d4d7f20a2a31bb502" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48765173" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f4c3b-101">Incapsula oggetti specifici del sistema operativo che attendono l'accesso esclusivo alle risorse condivise.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f4c3b-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-102">Il <xref:System.Threading.WaitHandle> classe incapsula un handle di sincronizzazione nativo del sistema operativo e viene utilizzata per rappresentare tutti gli oggetti di sincronizzazione in fase di esecuzione che consentono più operazioni di attesa.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="f4c3b-103">Per un confronto tra gli handle di attesa con altri oggetti di sincronizzazione, vedere [panoramica delle primitive di sincronizzazione](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="f4c3b-104">Il <xref:System.Threading.WaitHandle> classe è astratta.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="f4c3b-105">Le classi derivate da <xref:System.Threading.WaitHandle> definire un meccanismo di segnalazione che indica l'attivazione o la disattivazione dell'accesso a una risorsa condivisa, ma usare ereditato <xref:System.Threading.WaitHandle> metodi per bloccare l'attesa per l'accesso alle risorse condivise.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="f4c3b-106">Le classi derivate da <xref:System.Threading.WaitHandle> includono:</span><span class="sxs-lookup"><span data-stu-id="f4c3b-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="f4c3b-107">Classe <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="f4c3b-108">Visualizzare [mutex](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="f4c3b-109">Il <xref:System.Threading.EventWaitHandle> classe e delle relative classi derivate <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="f4c3b-110">Vedere [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="f4c3b-111">Classe <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="f4c3b-112">Visualizzare [Semaphore e SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="f4c3b-113">Thread può essere bloccata su un singolo handle di attesa chiamando il metodo di istanza <xref:System.Threading.WaitHandle.WaitOne%2A>, che viene ereditata dalle classi derivate da <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="f4c3b-114">Le classi derivate di <xref:System.Threading.WaitHandle> differiscono relativa affinità dei thread.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="f4c3b-115">Handle di attesa evento (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, e <xref:System.Threading.ManualResetEvent>) e i semafori non presentano affinità di thread; qualsiasi thread può segnalare un semaforo o un handle di attesa evento.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="f4c3b-116">I mutex, d'altra parte, presentano affinità di thread; il thread che possiede un mutex necessario rilasciarlo e viene generata un'eccezione se un thread chiama il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo su un mutex di cui non è proprietario.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="f4c3b-117">Poiché il <xref:System.Threading.WaitHandle> deriva dalla classe <xref:System.MarshalByRefObject>, queste classi possono essere utilizzate per sincronizzare le attività dei thread tra i limiti del dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="f4c3b-118">Oltre alle relative classi derivate di <xref:System.Threading.WaitHandle> classe ha un numero di metodi statici che blocca un thread finché uno o più oggetti di sincronizzazione ricevano un segnale.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="f4c3b-119">Sono inclusi:</span><span class="sxs-lookup"><span data-stu-id="f4c3b-119">These include:</span></span>  
  
-   <span data-ttu-id="f4c3b-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, che consente a un thread segnalare un handle di attesa e immediatamente in attesa su un altro.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="f4c3b-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, che consente a un thread in attesa finché tutti gli handle di attesa in una matrice ricevano un segnale.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="f4c3b-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, che consente a un thread in attesa fino a quando non uno di un set specificato di handle di attesa è stato segnalato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="f4c3b-123">Gli overload di questi metodi forniscono gli intervalli di timeout per l'abbandono dell'attesa e la possibilità di uscire da un contesto di sincronizzazione prima dell'attesa, usare il contesto di sincronizzazione di altri thread.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="f4c3b-124">Questo tipo implementa la <xref:System.IDisposable> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="f4c3b-125">Dopo aver utilizzando il tipo o un tipo derivato da esso, è necessario eliminarlo direttamente o indirettamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="f4c3b-126">Per eliminare il tipo direttamente, chiamare relativi <xref:System.Threading.WaitHandle.Close%2A> metodo in un `try` / `catch` blocco.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="f4c3b-127">Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="f4c3b-128">Per altre informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="f4c3b-129"><xref:System.Threading.WaitHandle> implementa il <xref:System.IDisposable.Dispose%2A> pattern.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="f4c3b-130">Visualizzare [modello Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="f4c3b-131">Quando si deriva da <xref:System.Threading.WaitHandle>, usare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà per archiviare l'handle nativo del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="f4c3b-132">Non è necessario eseguire l'override protetto <xref:System.Threading.WaitHandle.Dispose%2A> metodo se non si usano altre risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-133">Nell'esempio di codice riportato di seguito viene illustrato come due thread possono eseguire attività in background mentre principale thread attende l'attività da completare tramite il metodo statico <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.WaitAll%2A> metodi del <xref:System.Threading.WaitHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="f4c3b-134">Questo tipo è thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f4c3b-134">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="f4c3b-135">Threading</span>
      <span class="sxs-lookup">
        <span data-stu-id="f4c3b-135">Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">
      <span data-ttu-id="f4c3b-136">Oggetti e funzionalità del threading</span>
      <span class="sxs-lookup">
        <span data-stu-id="f4c3b-136">Threading Objects and Features</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">
      <span data-ttu-id="f4c3b-137">Mutex</span>
      <span class="sxs-lookup">
        <span data-stu-id="f4c3b-137">Mutexes</span>
      </span>
    </related>
    <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">
      <span data-ttu-id="f4c3b-138">EventWaitHandle, AutoResetEvent e ManualResetEvent</span>
      <span class="sxs-lookup">
        <span data-stu-id="f4c3b-138">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">
      <span data-ttu-id="f4c3b-139">Semafori</span>
      <span class="sxs-lookup">
        <span data-stu-id="f4c3b-139">Semaphores</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-140">Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-140">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-141">Rilascia tutte le risorse contenute nell'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-141">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-142">Questo metodo è l'implementazione pubblica del <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodo per il <xref:System.Threading.WaitHandle> classe e le relative classi derivate.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-142">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="f4c3b-143">Fornisce un'implementazione standard che chiama il `Dispose(Boolean)` rapporto di overload con un `true` argomento e quindi chiama il <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-143">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f4c3b-144">Chiamare questo metodo per rilasciare tutte le risorse utilizzate da un'istanza di `WaitHandle` o una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-144">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="f4c3b-145">Una volta che viene chiamato questo metodo, i riferimenti all'istanza corrente causano un comportamento indefinito.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-145">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-146">Chiamare sempre <xref:System.Threading.WaitHandle.Close%2A> oppure <xref:System.Threading.WaitHandle.Dispose> prima di rilasciare l'ultimo riferimento al <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-146">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f4c3b-147">In caso contrario, le risorse utilizzate non verranno liberate.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-147">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f4c3b-148">È consigliabile eseguire l'override di <see langword="Dispose(Boolean)" /> metodo per rilasciare le risorse allocate classi derivate.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4c3b-148">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="f4c3b-149">Implementazione di un metodo Dispose</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-149">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-150">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-151">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.WaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-151">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-152">Questo metodo equivale al <xref:System.Threading.WaitHandle.Close%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-152">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-153">Chiamare sempre <xref:System.Threading.WaitHandle.Close%2A> oppure <xref:System.Threading.WaitHandle.Dispose> prima di rilasciare l'ultimo riferimento al <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-153">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="f4c3b-154">In caso contrario, le risorse utilizzate non verranno liberate.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-154">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">
          <span data-ttu-id="f4c3b-155">Pulizia delle risorse non gestite</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-155">Cleaning Up Unmanaged Resources</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="f4c3b-156">
            <see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-156">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-157">Quando ne viene eseguito l'override in una classe derivata, libera le risorse non gestite usate da <see cref="T:System.Threading.WaitHandle" /> ed eventualmente di liberare le risorse gestite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-157">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-158">Questo metodo viene chiamato il <xref:System.Threading.WaitHandle.Close%2A> e il <xref:System.Threading.WaitHandle.Dispose> metodi con il `explicitDisposing` parametro impostato su `true`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-158">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="f4c3b-159">Quando la `explicitDisposing` parametro è `true`, questo metodo rilascia tutte le risorse utilizzate da qualsiasi oggetto gestito da questo <xref:System.Threading.WaitHandle> riferimenti a oggetti.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-159">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f4c3b-160">È consigliabile eseguire l'override di <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> metodo per rilasciare le risorse allocate classi derivate.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4c3b-160">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span>
            </span>
            <span data-ttu-id="f4c3b-161">Il <see cref="M:System.Threading.WaitHandle.Close" /> o <see cref="M:System.Threading.WaitHandle.Dispose" /> metodo può essere chiamato più volte da altri oggetti.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4c3b-161">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="f4c3b-162">Quando si esegue l'override di questo metodo, prestare attenzione a non fare riferimento agli oggetti che sono stati eliminati in una precedente chiamata a <see langword="Dispose" /> o <see langword="Close" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4c3b-162">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">
          <span data-ttu-id="f4c3b-163">Implementazione di un metodo Dispose</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-163">Implementing a Dispose Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-164">Ottiene o imposta l'handle nativo del sistema operativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-164">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4c3b-165">
            <see langword="IntPtr" /> che rappresenta l'handle nativo del sistema operativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-165">An <see langword="IntPtr" /> representing the native operating system handle.</span>
          </span>
          <span data-ttu-id="f4c3b-166">Il valore predefinito è quello del campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-166">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-167">Assegnazione di un nuovo valore per il <xref:System.Threading.WaitHandle.Handle%2A> proprietà non chiude l'handle precedente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-167">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="f4c3b-168">Ciò può comportare la perdita di una handle.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-168">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="f4c3b-169">Non utilizzare questa proprietà in .NET Framework versione 2.0 o successiva. usare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà invece.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-169">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="f4c3b-170">Impostando questa proprietà su un handle valido anche set il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà, ma impostandola su <xref:System.Threading.WaitHandle.InvalidHandle> può comportare la perdita di una handle.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-170">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f4c3b-171">Richiede l'attendibilità totale per il chiamante immediato impostare il valore della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-171">Requires full trust for the immediate caller to set the property value.</span>
          </span>
          <span data-ttu-id="f4c3b-172">Questo membro non può essere impostato dal codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-172">This member cannot be set by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="f4c3b-173">I tipi derivati devono avere <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> per impostare il valore della proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-173">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-174">Rappresenta un handle nativo del sistema operativo non valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-174">Represents an invalid native operating system handle.</span>
          </span>
          <span data-ttu-id="f4c3b-175">Questo campo è di sola lettura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-175">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-176">Utilizzato internamente per inizializzare il <xref:System.Threading.WaitHandle.Handle%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-176">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f4c3b-177">È possibile usare questo valore per determinare se il <see cref="P:System.Threading.WaitHandle.Handle" /> proprietà contiene un handle nativo del sistema operativo valido.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f4c3b-177">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-178">Ottiene o imposta l'handle nativo del sistema operativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-178">Gets or sets the native operating system handle.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="f4c3b-179">Oggetto <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> che rappresenta l'handle nativo del sistema operativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-179">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-180">Quando si assegna un nuovo valore per il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà, l'handle precedente verrà chiusa quando precedente <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> oggetto viene raccolto.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-180">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="f4c3b-181">Non chiudere manualmente l'handle, in quanto il risultato è un' <xref:System.ObjectDisposedException> quando il <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> tenta di chiudere l'handle.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-181">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="f4c3b-182"><xref:System.Threading.WaitHandle> implementa il <xref:System.IDisposable.Dispose%2A> pattern.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-182"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="f4c3b-183">Visualizzare [modello Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-183">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="f4c3b-184">Quando si deriva da <xref:System.Threading.WaitHandle>, usare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà per archiviare l'handle del sistema operativo nativo.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-184">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="f4c3b-185">Non è necessario eseguire l'override protetto <xref:System.Threading.WaitHandle.Dispose%2A> metodo se non si usano altre risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-185">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="f4c3b-186">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-186">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="f4c3b-187">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-187">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
          <span data-ttu-id="f4c3b-188">I tipi derivati devono avere <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> per chiamare questo membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-188">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-189">Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa in un altro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-189">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="f4c3b-190">Oggetto <see cref="T:System.Threading.WaitHandle" /> da segnalare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-190">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="f4c3b-191">Oggetto <see cref="T:System.Threading.WaitHandle" /> in cui restare in attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-191">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-192">Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa in un altro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-192">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-193">
            <see langword="true" /> in caso di esito positivo sia della segnalazione che dell'attesa. Se l'attesa non viene completata, il metodo non restituisce alcun risultato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-193">
              <see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-194">Questa operazione non è garantita a essere atomici.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-194">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f4c3b-195">Dopo il thread corrente segnala `toSignal` ma prima è in attesa di `toWaitOn`, un thread in esecuzione in un altro processore potrebbero segnalare `toWaitOn` o in attesa su di esso.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-195">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-196">Il codice seguente viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere che il thread termina un'attività.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-196">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="f4c3b-197">L'esempio avviati cinque thread, consente di bloccare un' <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag e quindi rilascia un thread ogni volta l'utente preme il tasto INVIO.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-197">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="f4c3b-198">Nell'esempio viene quindi Accoda altri cinque thread e vengono rilasciati tutti usando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-198">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-199">
            <paramref name="toSignal" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-199">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-200">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-200">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-201">
            <paramref name="toWaitOn" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-201">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-202">Il metodo è stato chiamato su un thread che dispone di <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-202">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="f4c3b-203">Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-203">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-204">
            <paramref name="toSignal" /> è un semaforo e dispone già di un conteggio completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-204">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-205">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-205">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-206">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-206">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="f4c3b-207">Oggetto <see cref="T:System.Threading.WaitHandle" /> da segnalare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-207">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="f4c3b-208">Oggetto <see cref="T:System.Threading.WaitHandle" /> in cui restare in attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-208">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f4c3b-209">Intero che rappresenta l'intervallo di attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-209">An integer that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="f4c3b-210">Se il valore è <see cref="F:System.Threading.Timeout.Infinite" />, ovvero -1, l'attesa è infinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-210">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f4c3b-211">
            <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-211">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-212">Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa in un altro, specificando un intervallo di timeout come intero con segno a 32 bit e indicando se uscire dal dominio di sincronizzazione per il contesto prima dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-212">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-213">
            <see langword="true" /> in caso di esito positivo sia della segnalazione che dell'attesa oppure <see langword="false" /> se la segnalazione è stata completata ma si è verificato il timeout dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-213">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-214">Questa operazione non è garantita a essere atomici.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-214">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f4c3b-215">Dopo il thread corrente segnala `toSignal` ma prima è in attesa di `toWaitOn`, un thread in esecuzione in un altro processore potrebbero segnalare `toWaitOn` o in attesa su di esso.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-215">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="f4c3b-216">Se `millisecondsTimeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-216">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-217">Controlla lo stato del `toWaitOn` e risponda immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-217">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f4c3b-218">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="f4c3b-218">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f4c3b-219">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-219">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f4c3b-220">Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-220">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f4c3b-221">Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-221">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f4c3b-222">Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-222">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="f4c3b-223">Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-223">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f4c3b-224">Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-224">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f4c3b-225">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-225">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f4c3b-226">Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-226">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f4c3b-227">Quando il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-227">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-228">
            <paramref name="toSignal" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-228">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-229">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-229">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-230">
            <paramref name="toWaitOn" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-230">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-231">Il metodo viene chiamato su un thread che dispone di <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-231">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="f4c3b-232">Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-232">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-233">Non è possibile segnalare la classe <see cref="T:System.Threading.WaitHandle" /> perché supererebbe il conteggio massimo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-233">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-234">
            <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-234">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-235">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-235">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-236">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-236">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">
          <span data-ttu-id="f4c3b-237">Oggetto <see cref="T:System.Threading.WaitHandle" /> da segnalare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-237">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span>
          </span>
        </param>
        <param name="toWaitOn">
          <span data-ttu-id="f4c3b-238">Oggetto <see cref="T:System.Threading.WaitHandle" /> in cui restare in attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-238">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f4c3b-239">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta l'intervallo di attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-239">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span>
          </span>
          <span data-ttu-id="f4c3b-240">Se il valore è -1, l'attesa è infinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-240">If the value is -1, the wait is infinite.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f4c3b-241">
            <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-241">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-242">Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa di un altro, specificando l'intervallo di timeout come <see cref="T:System.TimeSpan" /> e indicando se uscire dal dominio di sincronizzazione per il contesto prima dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-242">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-243">
            <see langword="true" /> in caso di esito positivo sia della segnalazione che dell'attesa oppure <see langword="false" /> se la segnalazione è stata completata ma si è verificato il timeout dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-243">
              <see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-244">Questa operazione non è garantita a essere atomici.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-244">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="f4c3b-245">Dopo il thread corrente segnala `toSignal` ma prima è in attesa di `toWaitOn`, un thread in esecuzione in un altro processore potrebbero segnalare `toWaitOn` o in attesa su di esso.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-245">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="f4c3b-246">Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-246">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f4c3b-247">Se `timeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-247">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-248">Controlla lo stato del `toWaitOn` e risponda immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-248">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f4c3b-249">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="f4c3b-249">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f4c3b-250">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-250">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f4c3b-251">Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-251">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f4c3b-252">Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-252">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f4c3b-253">Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-253">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="f4c3b-254">Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-254">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="f4c3b-255">Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-255">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f4c3b-256">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-256">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f4c3b-257">Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-257">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f4c3b-258">Quando il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-258">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-259">
            <paramref name="toSignal" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-259">
              <paramref name="toSignal" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-260">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-260">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-261">
            <paramref name="toWaitOn" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-261">
              <paramref name="toWaitOn" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-262">Il metodo è stato chiamato su un thread che dispone di <see cref="T:System.STAThreadAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-262">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span>
          </span>
        </exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="f4c3b-263">Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-263">This method is not supported on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-264">
            <paramref name="toSignal" /> è un semaforo e dispone già di un conteggio completo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-264">
              <paramref name="toSignal" /> is a semaphore, and it already has a full count.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-265">
            <paramref name="timeout" /> restituisce un numero di millisecondi negativo diverso da -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-265">
              <paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span>
          </span>
          <span data-ttu-id="f4c3b-266">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-266">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-267">
            <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-267">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-268">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-268">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-269">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-269">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-270">Attende che tutti gli elementi nella matrice specificata ricevano un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-270">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-271">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-271">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f4c3b-272">Questa matrice non può contenere più riferimenti allo stesso oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-272">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-273">Attende che tutti gli elementi nella matrice specificata ricevano un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-273">Waits for all the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-274">
            <see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, il metodo non restituisce alcun risultato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-274">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-275"><xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-275"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f4c3b-276">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAll%2A> restituzione del metodo `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-276">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f4c3b-277">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-277">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f4c3b-278">Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-278">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f4c3b-279">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-279">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f4c3b-280">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando tutti gli handle vengono segnalati.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-280">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="f4c3b-281">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-281">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f4c3b-282">Se la matrice contiene duplicati, la chiamata ha esito negativo con un <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-282">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-283">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-283">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="f4c3b-284">Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload del metodo e specificare -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) per `millisecondsTimeout` e `true` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-284">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-285">Esempio di codice seguente viene illustrato come usare il pool di thread per creare e scrivere in un gruppo di file in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-285">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f4c3b-286">Ogni operazione di scrittura viene accodata come un elemento di lavoro e segnala al termine.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-286">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f4c3b-287">Il thread principale attende che tutti gli elementi segnalare e quindi viene chiuso.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-287">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-288">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-288">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-289">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-289">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-290">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-290">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-291">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-291">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-292">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 2.0 o successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-292">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="f4c3b-293">In <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="f4c3b-293">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="f4c3b-294">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-294">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-295">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-295">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f4c3b-296">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-296">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-297">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-297">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f4c3b-298">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-298">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-299">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-299">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-300">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-300">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-301">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-301">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-302">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-302">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f4c3b-303">Questa matrice non può contenere più riferimenti allo stesso oggetto (duplicati).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-303">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f4c3b-304">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-304">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-305">Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.Int32" /> per specificare l'intervallo di tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-305">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-306">
            <see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-306">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-307">Se `millisecondsTimeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-307">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-308">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-308">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-309">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando l'attesa termina, vale a dire tutti gli handle vengono segnalati o quando si verifica il timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-309">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="f4c3b-310">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-310">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f4c3b-311">Se sono presenti duplicati nella matrice, la chiamata ha esito negativo con un <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-311">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-312">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-312">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="f4c3b-313">Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-313">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-314">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-314">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-315">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-315">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-316">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-316">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-317">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-317">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-318">
            <paramref name="waitHandles" /> è una matrice senza elementi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-318">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="f4c3b-319">In <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="f4c3b-319">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="f4c3b-320">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-320">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-321">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-321">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f4c3b-322">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-322">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-323">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-323">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-324">
            <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-324">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-325">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-325">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-326">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-326">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-327">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-327">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-328">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-328">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f4c3b-329">Questa matrice non può contenere più riferimenti allo stesso oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-329">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f4c3b-330">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-330">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-331">Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-331">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-332">
            <see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-332">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-333">Se `timeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-333">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-334">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-334">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-335">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando termina l'attesa, ovvero tutti gli handle vengono segnalati o si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-335">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="f4c3b-336">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-336">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f4c3b-337">Se la matrice contiene duplicati, la chiamata avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-337">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-338">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-338">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="f4c3b-339">Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-339">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f4c3b-340">Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-340">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-341">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-341">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-342">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-342">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-343">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-343">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-344">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-344">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-345">
            <paramref name="waitHandles" /> è una matrice senza elementi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-345">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="f4c3b-346">In <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET per app di Windows Store</see> o nella <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">libreria di classi portabile</see> rilevare invece l'eccezione della classe di base, <see cref="T:System.ArgumentException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="f4c3b-346">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="f4c3b-347">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-347">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-348">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-348">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f4c3b-349">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-349">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-350">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-350">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-351">
            <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-351">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="f4c3b-352">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-352">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-353">
            <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-353">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-354">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-354">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-355">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-355">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-356">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-356">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-357">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-357">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f4c3b-358">Questa matrice non può contenere più riferimenti allo stesso oggetto (duplicati).</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-358">This array cannot contain multiple references to the same object (duplicates).</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f4c3b-359">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-359">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f4c3b-360">
            <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-360">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-361">Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.Int32" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-361">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-362">
            <see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-362">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-363">Se `millisecondsTimeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-363">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-364">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-364">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-365"><xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-365"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f4c3b-366">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAll%2A> restituzione del metodo `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-366">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f4c3b-367">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-367">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f4c3b-368">Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-368">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f4c3b-369">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-369">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f4c3b-370">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando l'attesa termina, vale a dire tutti gli handle vengono segnalati o quando si verifica il timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-370">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="f4c3b-371">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-371">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f4c3b-372">Se sono presenti duplicati nella matrice, la chiamata ha esito negativo con un <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-372">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-373">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-373">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f4c3b-374">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="f4c3b-374">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f4c3b-375">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-375">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f4c3b-376">Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-376">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f4c3b-377">Anche se un metodo attualmente in esecuzione in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-377">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f4c3b-378">Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-378">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="f4c3b-379">Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-379">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="f4c3b-380">Ciò può essere utile quando la classe associata al contesto presenta la <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-380">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="f4c3b-381">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-381">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f4c3b-382">Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-382">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f4c3b-383">Quando il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-383">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-384">Esempio di codice seguente viene illustrato come usare il pool di thread per creare e scrivere in un gruppo di file in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-384">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f4c3b-385">Ogni operazione di scrittura viene accodata come un elemento di lavoro e segnala al termine.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-385">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f4c3b-386">Il thread principale attende che tutti gli elementi segnalare e quindi viene chiuso.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-386">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-387">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-387">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-388">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-388">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-389">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-389">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-390">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-390">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-391">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 2.0 o successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-391">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="f4c3b-392">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-392">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-393">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-393">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f4c3b-394">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-394">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-395">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-395">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f4c3b-396">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-396">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-397">
            <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-397">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-398">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-398">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-399">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-399">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-400">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-400">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-401">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-401">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
          <span data-ttu-id="f4c3b-402">Questa matrice non può contenere più riferimenti allo stesso oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-402">This array cannot contain multiple references to the same object.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f4c3b-403">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-403">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f4c3b-404">
            <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-404">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-405">Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-405">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-406">
            <see langword="true" /> quando ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-406">
              <see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-407">Se `timeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-407">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-408">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-408">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-409"><xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-409"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f4c3b-410">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAll%2A> restituzione del metodo `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-410">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f4c3b-411">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-411">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f4c3b-412">Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-412">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f4c3b-413">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-413">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f4c3b-414">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando termina l'attesa, ovvero tutti gli handle vengono segnalati o si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-414">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="f4c3b-415">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-415">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="f4c3b-416">Se la matrice contiene duplicati, la chiamata avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-416">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-417">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato nei thread che hanno <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-417">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="f4c3b-418">Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-418">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f4c3b-419">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="f4c3b-419">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f4c3b-420">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-420">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f4c3b-421">Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-421">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f4c3b-422">Anche se un metodo attualmente in esecuzione in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-422">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f4c3b-423">Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-423">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="f4c3b-424">Restituisce il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-424">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="f4c3b-425">Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-425">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f4c3b-426">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-426">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f4c3b-427">Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-427">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f4c3b-428">Quando il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-428">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-429">Esempio di codice seguente viene illustrato come usare il pool di thread per creare e scrivere in un gruppo di file in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-429">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="f4c3b-430">Ogni operazione di scrittura viene accodata come un elemento di lavoro e segnala al termine.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-430">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="f4c3b-431">Il thread principale attende che tutti gli elementi segnalare e quindi viene chiuso.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-431">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-432">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-432">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-433">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-433">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-434">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-434">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-435">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-435">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-436">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 2.0 o successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-436">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <span data-ttu-id="f4c3b-437">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-437">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-438">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-438">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
          <span data-ttu-id="f4c3b-439">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-439">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-440">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-440">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f4c3b-441">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-441">
              <paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-442">
            <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-442">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="f4c3b-443">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-443">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-444">
            <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-444">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-445">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-445">The wait terminated because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-446">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-446">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-447">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-447">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-448">Attende che uno degli elementi nella matrice specificata riceva un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-448">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-449">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-449">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-450">Attende che uno degli elementi nella matrice specificata riceva un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-450">Waits for any of the elements in the specified array to receive a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-451">Indice della matrice dell'oggetto che ha soddisfatto l'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-451">The array index of the object that satisfied the wait.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-452"><xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-452"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f4c3b-453">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAny%2A> restituzione del metodo `true` se il tempo di attesa viene completata perché un mutex viene abbandonato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-453">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f4c3b-454">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-454">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f4c3b-455">Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-455">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f4c3b-456">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-456">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f4c3b-457">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-457">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f4c3b-458">Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-458">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-459">Nelle versioni di .NET Framework precedenti alla versione 2.0, se un thread termina o si interrompe senza rilasciare in modo esplicito un <xref:System.Threading.Mutex>e che `Mutex` è in corrispondenza dell'indice 0 (zero) in un `WaitAny` array in un altro thread, l'indice restituito da `WaitAny` è 128 anziché 0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-459">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f4c3b-460">Questo metodo restituisce quando viene segnalato un handle qualsiasi.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-460">This method returns when any handle is signaled.</span></span> <span data-ttu-id="f4c3b-461">Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-461">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f4c3b-462">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-462">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="f4c3b-463">Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload del metodo e specificare -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) per `millisecondsTimeout` e `true` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-463">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-464">Esempio di codice seguente viene illustrato come chiamare il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-464">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-465">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-465">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-466">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-466">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-467">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-467">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-468">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-468">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f4c3b-469">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-469">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-470">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-470">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-471">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-471">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f4c3b-472">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è la 2.0 o successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-472">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-473">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-473">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-474">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-474">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f4c3b-475">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-475">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-476">Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-476">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-477">Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="millisecondsTimeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-477">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-478">Se `millisecondsTimeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-478">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-479">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-479">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-480">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-480">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f4c3b-481">Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-481">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="f4c3b-482">Questo metodo restituisce la fine dell'attesa, uno degli handle vengono segnalato o quando si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-482">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="f4c3b-483">Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-483">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f4c3b-484">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-484">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="f4c3b-485">Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-485">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-486">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-486">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-487">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-487">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-488">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-488">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-489">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-489">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-490">
            <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-490">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-491">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-491">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-492">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-492">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f4c3b-493">
            <paramref name="waitHandles" /> è una matrice senza elementi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-493">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-494">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-494">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-495">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-495">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f4c3b-496">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-496">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-497">Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-497">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-498">Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="timeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-498">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-499">Se `timeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-499">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-500">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-500">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-501">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-501">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f4c3b-502">Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-502">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="f4c3b-503">Questo metodo restituisce la fine dell'attesa, uno degli handle vengono segnalato o quando si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-503">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="f4c3b-504">Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-504">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f4c3b-505">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-505">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="f4c3b-506">Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-506">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f4c3b-507">Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-507">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-508">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-508">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-509">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-509">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-510">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-510">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-511">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-511">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-512">
            <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-512">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="f4c3b-513">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-513">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-514">
            <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-514">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-515">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-515">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-516">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-516">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f4c3b-517">
            <paramref name="waitHandles" /> è una matrice senza elementi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-517">
              <paramref name="waitHandles" /> is an array with no elements.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-518">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-518">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-519">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-519">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f4c3b-520">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-520">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f4c3b-521">
            <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-521">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-522">Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-522">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-523">Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="millisecondsTimeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-523">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-524">Se `millisecondsTimeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-524">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-525">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-525">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-526"><xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-526"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f4c3b-527">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAny%2A> restituzione del metodo `true` se il tempo di attesa viene completata perché un mutex viene abbandonato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-527">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f4c3b-528">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-528">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f4c3b-529">Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-529">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f4c3b-530">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-530">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f4c3b-531">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-531">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f4c3b-532">Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-532">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-533">Nelle versioni di .NET Framework precedenti alla versione 2.0, se un thread termina o si interrompe senza rilasciare in modo esplicito un <xref:System.Threading.Mutex>e che `Mutex` è in corrispondenza dell'indice 0 (zero) in un `WaitAny` array in un altro thread, l'indice restituito da `WaitAny` è 128 anziché 0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-533">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f4c3b-534">Questo metodo restituisce la fine dell'attesa, uno degli handle vengono segnalato o quando si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-534">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="f4c3b-535">Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-535">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f4c3b-536">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-536">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f4c3b-537">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="f4c3b-537">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f4c3b-538">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-538">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f4c3b-539">Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-539">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f4c3b-540">Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-540">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f4c3b-541">Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-541">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="f4c3b-542">Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-542">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="f4c3b-543">Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-543">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f4c3b-544">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-544">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f4c3b-545">Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-545">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f4c3b-546">Quando il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-546">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-547">Esempio di codice seguente viene illustrato come usare il pool di thread contemporaneamente cercare un file su più dischi.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-547">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f4c3b-548">Per motivi di spazio, viene cercata solo nella directory radice di ogni disco.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-548">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-549">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-549">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-550">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-550">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-551">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-551">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-552">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-552">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f4c3b-553">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-553">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-554">
            <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-554">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-555">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-555">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-556">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-556">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f4c3b-557">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è la 2.0 o successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-557">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-558">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-558">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">
          <span data-ttu-id="f4c3b-559">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-559">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="f4c3b-560">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-560">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f4c3b-561">
            <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-561">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-562">Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-562">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-563">Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="timeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-563">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-564">Se `timeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-564">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-565">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-565">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-566"><xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-566"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f4c3b-567">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAny%2A> restituzione del metodo `true` se il tempo di attesa viene completata perché un mutex viene abbandonato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-567">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="f4c3b-568">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-568">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f4c3b-569">Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-569">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f4c3b-570">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-570">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f4c3b-571">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-571">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="f4c3b-572">Se `waitHandles` contiene un mutex con un numero di indice inferiore rispetto al mutex abbandonato, rilasciato il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo termina normalmente e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-572">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f4c3b-573">Nelle versioni di .NET Framework precedenti alla versione 2.0, se un thread termina o si interrompe senza rilasciare in modo esplicito un <xref:System.Threading.Mutex>e che `Mutex` è in corrispondenza dell'indice 0 (zero) in un `WaitAny` array in un altro thread, l'indice restituito da `WaitAny` è 128 anziché 0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-573">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="f4c3b-574">Questo metodo restituisce la fine dell'attesa, uno degli handle vengono segnalato o quando si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-574">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="f4c3b-575">Se più di un oggetto diventa segnalato durante la chiamata, il valore restituito è l'indice della matrice dell'oggetto segnalato con il minimo valore di indice di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-575">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="f4c3b-576">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-576">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="f4c3b-577">Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-577">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f4c3b-578">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="f4c3b-578">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f4c3b-579">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-579">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f4c3b-580">Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-580">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f4c3b-581">Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-581">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f4c3b-582">Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-582">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="f4c3b-583">Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-583">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="f4c3b-584">Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-584">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f4c3b-585">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-585">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f4c3b-586">Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-586">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f4c3b-587">Quando il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-587">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-588">Esempio di codice seguente viene illustrato come usare il pool di thread contemporaneamente cercare un file su più dischi.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-588">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f4c3b-589">Per motivi di spazio, viene cercata solo nella directory radice di ogni disco.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-589">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f4c3b-590">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-590">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f4c3b-591">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-591">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-592">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-592">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f4c3b-593">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-593">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="f4c3b-594">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-594">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-595">
            <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-595">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="f4c3b-596">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-596">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-597">
            <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-597">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-598">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-598">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-599">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-599">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f4c3b-600">
            <paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è la 2.0 o successiva.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-600">
              <paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-601">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-601">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-602">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-602">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-603">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-603">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-604">Viene restituito <see langword="true" /> se l'istanza corrente riceve un segnale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-604">
              <see langword="true" /> if the current instance receives a signal.</span>
          </span>
          <span data-ttu-id="f4c3b-605">Se l'istanza corrente non viene mai segnalata, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> non restituisce mai alcun valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-605">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-606"><xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-606"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f4c3b-607">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituzione del metodo `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-607">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f4c3b-608">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-608">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f4c3b-609">Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-609">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f4c3b-610">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-610">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f4c3b-611">Il chiamante di questo metodo si blocca in modo indefinito finché l'istanza corrente riceve un segnale.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-611">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="f4c3b-612">Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-612">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f4c3b-613">Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-613">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f4c3b-614">Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload del metodo e specificare -1 o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> per il primo parametro e `false` per il secondo parametro.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-614">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="f4c3b-615">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-615">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-616">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo venga terminato durante l'attesa di un thread in background terminare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-616">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f4c3b-617">L'istanza corrente è già stata eliminata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-617">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-618">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-618">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-619">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-619">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-620">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-620">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f4c3b-621">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-621">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-622">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-622">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-623">
            <see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-623">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-624">Se `millisecondsTimeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-624">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-625">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-625">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-626">Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-626">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f4c3b-627">Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-627">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f4c3b-628">Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-628">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f4c3b-629">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-629">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f4c3b-630">Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-630">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-631">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo venga terminato durante l'attesa di un thread in background terminare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-631">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f4c3b-632">L'istanza corrente è già stata eliminata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-632">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-633">
            <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-633">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-634">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-634">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-635">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-635">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-636">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-636">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="f4c3b-637">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-637">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-638">Blocca il thread corrente finché l'istanza corrente non riceve un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-638">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-639">
            <see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-639">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-640">Se `timeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-640">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-641">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-641">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-642">Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-642">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f4c3b-643">Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-643">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f4c3b-644">Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-644">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f4c3b-645">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-645">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f4c3b-646">Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-646">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f4c3b-647">Chiamare questo overload del metodo è uguale alla chiamata al metodo il <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-647">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f4c3b-648">L'istanza corrente è già stata eliminata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-648">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-649">
            <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-649">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="f4c3b-650">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-650">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-651">
            <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-651">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-652">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-652">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-653">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-653">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-654">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-654">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="f4c3b-655">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-655">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f4c3b-656">
            <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-656">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-657">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-657">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-658">
            <see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-658">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-659">Se `millisecondsTimeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-659">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-660">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-660">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-661"><xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-661"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f4c3b-662">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituzione del metodo `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-662">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f4c3b-663">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-663">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f4c3b-664">Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-664">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f4c3b-665">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-665">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f4c3b-666">Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-666">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f4c3b-667">Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-667">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f4c3b-668">Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-668">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f4c3b-669">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-669">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f4c3b-670">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="f4c3b-670">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f4c3b-671">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-671">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f4c3b-672">Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-672">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f4c3b-673">Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-673">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f4c3b-674">Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-674">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f4c3b-675">Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-675">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="f4c3b-676">Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-676">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f4c3b-677">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-677">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f4c3b-678">Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-678">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f4c3b-679">Quando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-679">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-680">L'esempio seguente illustra come il <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload del metodo si comporta quando viene chiamato all'interno di un dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-680">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="f4c3b-681">In primo luogo, un thread attende con `exitContext` impostato su `false` e blocca fino a quando non scade il timeout di attesa.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-681">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="f4c3b-682">Un secondo thread viene eseguito dopo il primo thread termina e resta in attesa con `exitContext` impostato su `true`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-682">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="f4c3b-683">La chiamata per segnalare l'handle di attesa per il secondo thread non è bloccata e il thread viene completata prima del timeout di attesa.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-683">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f4c3b-684">L'istanza corrente è già stata eliminata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-684">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-685">
            <paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-685">
              <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-686">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-686">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-687">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-687">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-688">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-688">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="f4c3b-689">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-689">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="f4c3b-690">
            <see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-690">
              <see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f4c3b-691">Blocca il thread corrente finché l'istanza corrente non riceve un segnale, usando un oggetto <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-691">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f4c3b-692">
            <see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-692">
              <see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-693">Se `timeout` è uguale a zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-693">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="f4c3b-694">Verifica lo stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-694">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="f4c3b-695"><xref:System.Threading.AbandonedMutexException> è stata introdotta in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-695"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="f4c3b-696">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituzione del metodo `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-696">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="f4c3b-697">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-697">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="f4c3b-698">Nel caso di un mutex di sistema, può indicare che un'applicazione è stata terminata in modo anomalo (ad esempio, usando Gestione attività Windows).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-698">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="f4c3b-699">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-699">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="f4c3b-700">Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-700">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="f4c3b-701">Usare questo metodo per bloccare fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato quando viene completata un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-701">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="f4c3b-702">Per altre informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-702">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="f4c3b-703">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-703">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="f4c3b-704">Il valore massimo `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-704">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="f4c3b-705">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="f4c3b-705">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="f4c3b-706">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-706">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="f4c3b-707">Questa situazione può verificarsi se il thread si trova all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-707">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="f4c3b-708">Anche se un metodo attualmente in esecuzione in una classe che non deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile essere in un contesto non predefinite se un <xref:System.ContextBoundObject> nello stack nel dominio dell'applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-708">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="f4c3b-709">Quando il codice è in esecuzione in un contesto non predefinito, che specifica `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire, per eseguire la transizione al contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="f4c3b-709">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f4c3b-710">Il thread viene restituito il contesto originale non predefinita dopo la chiamata al <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-710">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="f4c3b-711">Ciò può essere utile quando la classe associata al contesto presenta <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-711">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="f4c3b-712">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-712">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="f4c3b-713">Se nello stack di chiamate di un membro codice chiama il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo) e specifica `true` per `exitContext`, il thread esce dal dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-713">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="f4c3b-714">Quando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere di nuovo il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-714">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-715">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per mantenere un processo venga terminato durante l'attesa di un thread in background terminare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-715">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="f4c3b-716">L'istanza corrente è già stata eliminata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-716">The current instance has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="f4c3b-717">
            <paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-717">
              <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span>
          </span>
          <span data-ttu-id="f4c3b-718">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-718">-or-</span>
          </span>
          <span data-ttu-id="f4c3b-719">
            <paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-719">
              <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.AbandonedMutexException">
          <span data-ttu-id="f4c3b-720">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-720">The wait completed because a thread exited without releasing a mutex.</span>
          </span>
          <span data-ttu-id="f4c3b-721">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-721">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f4c3b-722">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-722">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>
          <span data-ttu-id="f4c3b-723">Indica che si è verificato il timeout di un'operazione <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> prima della segnalazione di uno degli handle di attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-723">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span>
          </span>
          <span data-ttu-id="f4c3b-724">Questo campo è costante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f4c3b-724">This field is constant.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f4c3b-725">Questo campo è uno dei possibili valori restituiti di `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-725">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f4c3b-726">Esempio di codice seguente viene illustrato come usare il pool di thread contemporaneamente cercare un file su più dischi.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-726">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="f4c3b-727">Per motivi di spazio, viene cercata solo nella directory radice di ogni disco.</span><span class="sxs-lookup"><span data-stu-id="f4c3b-727">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>