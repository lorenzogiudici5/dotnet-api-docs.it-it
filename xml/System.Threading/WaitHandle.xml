<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="0a660-101">Incapsula oggetti specifici del sistema operativo che attendono l'accesso esclusivo alle risorse condivise.</span><span class="sxs-lookup"><span data-stu-id="0a660-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-102">La <xref:System.Threading.WaitHandle> classe incapsula handle di sincronizzazione di Win32 e viene utilizzata per rappresentare tutti gli oggetti di sincronizzazione in fase di esecuzione che consentono più operazioni di attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="0a660-103">Per un confronto tra gli handle di attesa con altri oggetti di sincronizzazione, vedere [panoramica delle primitive di sincronizzazione](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="0a660-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="0a660-104">La <xref:System.Threading.WaitHandle> classe è astratta.</span><span class="sxs-lookup"><span data-stu-id="0a660-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="0a660-105">Le classi derivate da <xref:System.Threading.WaitHandle> definisce un meccanismo di segnalazione per indicare l'attivazione o la disattivazione di accesso a una risorsa condivisa, ma utilizzano ereditato <xref:System.Threading.WaitHandle> metodi di blocco durante l'attesa per l'accesso a risorse condivise.</span><span class="sxs-lookup"><span data-stu-id="0a660-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="0a660-106">Le classi derivate da <xref:System.Threading.WaitHandle> includono:</span><span class="sxs-lookup"><span data-stu-id="0a660-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="0a660-107">Classe <xref:System.Threading.Mutex>.</span><span class="sxs-lookup"><span data-stu-id="0a660-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="0a660-108">Vedere [mutex](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="0a660-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="0a660-109">Il <xref:System.Threading.EventWaitHandle> classe e le relative classi derivate, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="0a660-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="0a660-110">Vedere [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="0a660-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="0a660-111">Classe <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="0a660-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="0a660-112">Vedere [Semaphore e SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="0a660-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="0a660-113">I thread possono bloccarsi su un singolo handle di attesa chiamando il metodo di istanza <xref:System.Threading.WaitHandle.WaitOne%2A>, che viene ereditata dalle classi derivate da <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="0a660-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="0a660-114">Le classi derivate di <xref:System.Threading.WaitHandle> differiscono in termini di affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="0a660-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="0a660-115">Handle di attesa evento (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, e <xref:System.Threading.ManualResetEvent>) e i semafori non presentano affinità di thread; qualsiasi thread può segnalare un semaforo o un handle di attesa evento.</span><span class="sxs-lookup"><span data-stu-id="0a660-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="0a660-116">I mutex, d'altra parte, affinità di thread; il thread che possiede un mutex necessario rilasciarlo e viene generata un'eccezione se un thread chiama il <xref:System.Threading.Mutex.ReleaseMutex%2A> metodo su un mutex di cui non è proprietario.</span><span class="sxs-lookup"><span data-stu-id="0a660-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="0a660-117">Poiché il <xref:System.Threading.WaitHandle> deriva dalla classe <xref:System.MarshalByRefObject>, queste classi possono essere utilizzate per sincronizzare le attività dei thread tra i limiti del dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="0a660-118">Oltre alle classi derivate, la <xref:System.Threading.WaitHandle> classe ha un numero di metodi statici che un thread bloccato fino a quando una o più oggetti di sincronizzazione ricevano un segnale...</span><span class="sxs-lookup"><span data-stu-id="0a660-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="0a660-119">Sono inclusi:</span><span class="sxs-lookup"><span data-stu-id="0a660-119">These include:</span></span>  
  
-   <span data-ttu-id="0a660-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, che consente a un thread segnalare un handle di attesa e immediatamente in attesa su un altro.</span><span class="sxs-lookup"><span data-stu-id="0a660-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="0a660-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, che consente a un thread in attesa fino a quando tutti gli handle di attesa in una matrice ricevano un segnale.</span><span class="sxs-lookup"><span data-stu-id="0a660-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="0a660-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, che consente a un thread in attesa fino a quando non è stato segnalato uno di un set specificato di handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="0a660-123">Gli overload di questi metodi forniscono gli intervalli di timeout per l'abbandono dell'attesa e la possibilità di uscire da un contesto di sincronizzazione prima dell'attesa, utilizzare il contesto di sincronizzazione di altri thread.</span><span class="sxs-lookup"><span data-stu-id="0a660-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0a660-124">Questo tipo implementa il <xref:System.IDisposable> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="0a660-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="0a660-125">Termine utilizzando il tipo o un tipo derivato da esso, è necessario eliminarlo direttamente o indirettamente di esso.</span><span class="sxs-lookup"><span data-stu-id="0a660-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="0a660-126">Per eliminare direttamente il tipo, chiamare il relativo <xref:System.Threading.WaitHandle.Close%2A> metodo in un `try` / `catch` blocco.</span><span class="sxs-lookup"><span data-stu-id="0a660-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="0a660-127">Per eliminarlo indirettamente, utilizzare un costrutto di linguaggio come ad esempio `using` in C# o `Using` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="0a660-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="0a660-128">Per ulteriori informazioni, vedere la sezione "Utilizzo di oggetti che implementano IDisposable" nel <xref:System.IDisposable> argomento relativo all'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="0a660-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="0a660-129"><xref:System.Threading.WaitHandle> implementa il <xref:System.IDisposable.Dispose%2A> modello.</span><span class="sxs-lookup"><span data-stu-id="0a660-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="0a660-130">Vedere [modello Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="0a660-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="0a660-131">Quando si deriva dalla <xref:System.Threading.WaitHandle>, utilizzare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà per archiviare l'handle del sistema operativo nativo.</span><span class="sxs-lookup"><span data-stu-id="0a660-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="0a660-132">Non è necessario eseguire l'override protetto <xref:System.Threading.WaitHandle.Dispose%2A> metodo a meno di utilizzare altre risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="0a660-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-133">Nell'esempio di codice riportato di seguito viene illustrato come due thread possano eseguire attività in background mentre principale thread attende il completamento delle attività mediante il <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.WaitAll%2A> metodi il <xref:System.Threading.WaitHandle> classe.</span><span class="sxs-lookup"><span data-stu-id="0a660-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="0a660-134">Questo tipo è thread-safe.</span><span class="sxs-lookup"><span data-stu-id="0a660-134">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a660-135">Inizializza una nuova istanza della classe <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a660-136">Rilascia tutte le risorse contenute nell'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente.</span><span class="sxs-lookup"><span data-stu-id="0a660-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-137">Questo metodo è l'implementazione pubblica del <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> metodo per la <xref:System.Threading.WaitHandle> classe e le relative classi derivate.</span><span class="sxs-lookup"><span data-stu-id="0a660-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="0a660-138">Fornisce un'implementazione standard che chiama il `Dispose(Boolean)` eseguire l'overload con un `true` argomento e quindi chiama il <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0a660-139">Chiamare questo metodo per rilasciare tutte le risorse utilizzate da un'istanza di `WaitHandle` o una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="0a660-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="0a660-140">Una volta che viene chiamato questo metodo, i riferimenti all'istanza corrente causano un comportamento indefinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-141">Chiamare sempre il metodo <xref:System.Threading.WaitHandle.Close%2A> o <xref:System.Threading.WaitHandle.Dispose> prima di rilasciare l'ultimo riferimento al <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="0a660-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="0a660-142">In caso contrario, le risorse utilizzate non verranno liberate.</span><span class="sxs-lookup"><span data-stu-id="0a660-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="0a660-143">È necessario eseguire l'override di <see langword="Dispose(Boolean)" /> metodo per rilasciare le risorse allocate classi derivate.</span><span class="sxs-lookup"><span data-stu-id="0a660-143">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a660-144">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a660-145">Rilascia tutte le risorse usate dall'istanza corrente della classe <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-146">Questo metodo equivale al <xref:System.Threading.WaitHandle.Close%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-147">Chiamare sempre il metodo <xref:System.Threading.WaitHandle.Close%2A> o <xref:System.Threading.WaitHandle.Dispose> prima di rilasciare l'ultimo riferimento al <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="0a660-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="0a660-148">In caso contrario, le risorse utilizzate non verranno liberate.</span><span class="sxs-lookup"><span data-stu-id="0a660-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="0a660-149"><see langword="true" /> per rilasciare sia le risorse gestite sia quelle non gestite; <see langword="false" /> per rilasciare solo le risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="0a660-149"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="0a660-150">Quando ne viene eseguito l'override in una classe derivata, libera le risorse non gestite usate da <see cref="T:System.Threading.WaitHandle" /> ed eventualmente di liberare le risorse gestite.</span><span class="sxs-lookup"><span data-stu-id="0a660-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-151">Questo metodo viene chiamato dal <xref:System.Threading.WaitHandle.Close%2A> e <xref:System.Threading.WaitHandle.Dispose> metodi con il `explicitDisposing` parametro impostato su `true`.</span><span class="sxs-lookup"><span data-stu-id="0a660-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="0a660-152">Quando il `explicitDisposing` parametro `true`, questo metodo rilascia tutte le risorse utilizzate dagli oggetti gestiti da questo <xref:System.Threading.WaitHandle> i riferimenti all'oggetto.</span><span class="sxs-lookup"><span data-stu-id="0a660-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="0a660-153">È necessario eseguire l'override di <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> metodo per rilasciare le risorse allocate classi derivate.</span><span class="sxs-lookup"><span data-stu-id="0a660-153">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
 <span data-ttu-id="0a660-154">Il <see cref="M:System.Threading.WaitHandle.Close" /> o <see cref="M:System.Threading.WaitHandle.Dispose" /> metodo può essere chiamato più volte da altri oggetti.</span><span class="sxs-lookup"><span data-stu-id="0a660-154">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="0a660-155">Quando si esegue l'override di questo metodo, prestare attenzione a non fare riferimento a oggetti che sono stati eliminati in una precedente chiamata a <see langword="Dispose" /> o <see langword="Close" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-155">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0a660-156">Ottiene o imposta l'handle nativo del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="0a660-156">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="0a660-157"><see langword="IntPtr" /> che rappresenta l'handle nativo del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="0a660-157">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="0a660-158">Il valore predefinito è quello del campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-158">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-159">Assegnazione di un nuovo valore per il <xref:System.Threading.WaitHandle.Handle%2A> proprietà non comporta la chiusura dell'handle precedente.</span><span class="sxs-lookup"><span data-stu-id="0a660-159">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="0a660-160">Ciò può comportare la perdita di un handle.</span><span class="sxs-lookup"><span data-stu-id="0a660-160">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="0a660-161">Non utilizzare questa proprietà in .NET Framework versione 2.0 o successiva. Utilizzare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà invece.</span><span class="sxs-lookup"><span data-stu-id="0a660-161">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="0a660-162">Imposta questa proprietà su un handle valido anche il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà, ma se è impostato su <xref:System.Threading.WaitHandle.InvalidHandle> può comportare la perdita di un handle.</span><span class="sxs-lookup"><span data-stu-id="0a660-162">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="0a660-163">Richiede l'attendibilità totale per il chiamante immediato impostare il valore della proprietà.</span><span class="sxs-lookup"><span data-stu-id="0a660-163">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="0a660-164">Questo membro non può essere impostato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="0a660-164">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="0a660-165">Tipi derivati devono disporre <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> per impostare il valore della proprietà.</span><span class="sxs-lookup"><span data-stu-id="0a660-165">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0a660-166">Rappresenta un handle nativo del sistema operativo non valido.</span><span class="sxs-lookup"><span data-stu-id="0a660-166">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="0a660-167">Questo campo è di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="0a660-167">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-168">Utilizzata internamente per inizializzare il <xref:System.Threading.WaitHandle.Handle%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="0a660-168">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="0a660-169">È possibile utilizzare questo valore per determinare se il <see cref="P:System.Threading.WaitHandle.Handle" /> proprietà contiene un handle nativo del sistema operativo valido.</span><span class="sxs-lookup"><span data-stu-id="0a660-169">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0a660-170">Ottiene o imposta l'handle nativo del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="0a660-170">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="0a660-171">Oggetto <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> che rappresenta l'handle nativo del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="0a660-171">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-172">Quando si assegna un nuovo valore per il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà, l'handle precedente verrà chiuso quando precedente <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> gli oggetti vengono raccolti.</span><span class="sxs-lookup"><span data-stu-id="0a660-172">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="0a660-173">Non chiudere manualmente l'handle, perché ciò comporta un <xref:System.ObjectDisposedException> quando il <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> tenta di chiudere l'handle.</span><span class="sxs-lookup"><span data-stu-id="0a660-173">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="0a660-174"><xref:System.Threading.WaitHandle> implementa il <xref:System.IDisposable.Dispose%2A> modello.</span><span class="sxs-lookup"><span data-stu-id="0a660-174"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="0a660-175">Vedere [modello Dispose](~/docs/standard/design-guidelines/dispose-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="0a660-175">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="0a660-176">Quando si deriva dalla <xref:System.Threading.WaitHandle>, utilizzare il <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> proprietà per archiviare l'handle del sistema operativo nativo.</span><span class="sxs-lookup"><span data-stu-id="0a660-176">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="0a660-177">Non è necessario eseguire l'override protetto <xref:System.Threading.WaitHandle.Dispose%2A> metodo a meno di utilizzare altre risorse non gestite.</span><span class="sxs-lookup"><span data-stu-id="0a660-177">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="0a660-178">richiede l'attendibilità totale per il chiamante immediato.</span><span class="sxs-lookup"><span data-stu-id="0a660-178">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="0a660-179">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span><span class="sxs-lookup"><span data-stu-id="0a660-179">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="0a660-180">Tipi derivati devono disporre <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> per chiamare questo membro.</span><span class="sxs-lookup"><span data-stu-id="0a660-180">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a660-181">Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa in un altro.</span><span class="sxs-lookup"><span data-stu-id="0a660-181">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="0a660-182">Oggetto <see cref="T:System.Threading.WaitHandle" /> da segnalare.</span><span class="sxs-lookup"><span data-stu-id="0a660-182">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="0a660-183">Oggetto <see cref="T:System.Threading.WaitHandle" /> in cui restare in attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-183">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="0a660-184">Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa in un altro.</span><span class="sxs-lookup"><span data-stu-id="0a660-184">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-185"><see langword="true" /> in caso di esito positivo sia della segnalazione che dell'attesa. Se l'attesa non viene completata, il metodo non restituisce alcun risultato.</span><span class="sxs-lookup"><span data-stu-id="0a660-185"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-186">Questa operazione non deve necessariamente essere atomici.</span><span class="sxs-lookup"><span data-stu-id="0a660-186">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="0a660-187">Dopo il thread corrente segnala `toSignal` ma prima è in attesa di `toWaitOn`, un thread in esecuzione in un altro processore potrebbe segnalare `toWaitOn` o in attesa su di esso.</span><span class="sxs-lookup"><span data-stu-id="0a660-187">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-188">Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere finché il thread termina un'attività.</span><span class="sxs-lookup"><span data-stu-id="0a660-188">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="0a660-189">Nell'esempio vengono avviati cinque thread, consente di bloccarsi su un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag e quindi rilascia un thread ogni volta l'utente preme il tasto INVIO.</span><span class="sxs-lookup"><span data-stu-id="0a660-189">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="0a660-190">Nell'esempio viene quindi Accoda un altro thread cinque e vengono rilasciati tutti utilizzando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="0a660-190">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a660-191"><paramref name="toSignal" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-191"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-192">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-192">-or-</span></span>  
  
 <span data-ttu-id="0a660-193"><paramref name="toWaitOn" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-193"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-194">Il metodo è stato chiamato su un thread che dispone di <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-194">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="0a660-195">Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-195">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a660-196"><paramref name="toSignal" /> è un semaforo e dispone già di un conteggio completo.</span><span class="sxs-lookup"><span data-stu-id="0a660-196"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-197">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-197">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-198">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-198">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="0a660-199">Oggetto <see cref="T:System.Threading.WaitHandle" /> da segnalare.</span><span class="sxs-lookup"><span data-stu-id="0a660-199">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="0a660-200">Oggetto <see cref="T:System.Threading.WaitHandle" /> in cui restare in attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-200">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0a660-201">Intero che rappresenta l'intervallo di attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-201">An integer that represents the interval to wait.</span></span> <span data-ttu-id="0a660-202">Se il valore è <see cref="F:System.Threading.Timeout.Infinite" />, ovvero -1, l'attesa è infinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-202">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="0a660-203"><see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-203"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0a660-204">Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa in un altro, specificando un intervallo di timeout come intero con segno a 32 bit e indicando se uscire dal dominio di sincronizzazione per il contesto prima dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-204">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-205"><see langword="true" /> in caso di esito positivo sia della segnalazione che dell'attesa oppure <see langword="false" /> se la segnalazione è stata completata ma si è verificato il timeout dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-205"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-206">Questa operazione non deve necessariamente essere atomici.</span><span class="sxs-lookup"><span data-stu-id="0a660-206">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="0a660-207">Dopo il thread corrente segnala `toSignal` ma prima è in attesa di `toWaitOn`, un thread in esecuzione in un altro processore potrebbe segnalare `toWaitOn` o in attesa su di esso.</span><span class="sxs-lookup"><span data-stu-id="0a660-207">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="0a660-208">Se `millisecondsTimeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-208">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-209">Controlla lo stato del `toWaitOn` e viene restituito immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-209">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0a660-210">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="0a660-210">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0a660-211">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="0a660-211">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0a660-212">Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="0a660-212">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0a660-213">Anche se attualmente un metodo in una classe che deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="0a660-213">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0a660-214">Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-214">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="0a660-215">Il thread viene restituito il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="0a660-215">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="0a660-216">Può essere utile quando è la classe associata al contesto <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-216">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0a660-217">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="0a660-217">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0a660-218">Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="0a660-218">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0a660-219">Quando il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-219">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a660-220"><paramref name="toSignal" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-220"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-221">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-221">-or-</span></span>  
  
 <span data-ttu-id="0a660-222"><paramref name="toWaitOn" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-222"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-223">Il metodo viene chiamato su un thread che dispone di <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-223">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="0a660-224">Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-224">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-225">Non è possibile segnalare la classe <see cref="T:System.Threading.WaitHandle" /> perché supererebbe il conteggio massimo.</span><span class="sxs-lookup"><span data-stu-id="0a660-225">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-226"><paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-226"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-227">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-227">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-228">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-228">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="0a660-229">Oggetto <see cref="T:System.Threading.WaitHandle" /> da segnalare.</span><span class="sxs-lookup"><span data-stu-id="0a660-229">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="0a660-230">Oggetto <see cref="T:System.Threading.WaitHandle" /> in cui restare in attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-230">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="0a660-231">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta l'intervallo di attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-231">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="0a660-232">Se il valore è -1, l'attesa è infinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-232">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="0a660-233"><see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-233"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0a660-234">Segnala un oggetto <see cref="T:System.Threading.WaitHandle" /> e resta in attesa di un altro, specificando l'intervallo di timeout come <see cref="T:System.TimeSpan" /> e indicando se uscire dal dominio di sincronizzazione per il contesto prima dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-234">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-235"><see langword="true" /> in caso di esito positivo sia della segnalazione che dell'attesa oppure <see langword="false" /> se la segnalazione è stata completata ma si è verificato il timeout dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-235"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-236">Questa operazione non deve necessariamente essere atomici.</span><span class="sxs-lookup"><span data-stu-id="0a660-236">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="0a660-237">Dopo il thread corrente segnala `toSignal` ma prima è in attesa di `toWaitOn`, un thread in esecuzione in un altro processore potrebbe segnalare `toWaitOn` o in attesa su di esso.</span><span class="sxs-lookup"><span data-stu-id="0a660-237">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="0a660-238">Il valore massimo per `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a660-238">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0a660-239">Se `timeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-239">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-240">Controlla lo stato del `toWaitOn` e viene restituito immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-240">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0a660-241">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="0a660-241">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0a660-242">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="0a660-242">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0a660-243">Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="0a660-243">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0a660-244">Anche se attualmente un metodo in una classe che deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="0a660-244">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0a660-245">Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-245">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="0a660-246">Il thread viene restituito il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="0a660-246">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="0a660-247">Può essere utile quando è la classe associata al contesto <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-247">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0a660-248">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="0a660-248">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0a660-249">Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.WaitHandle.SignalAndWait%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="0a660-249">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0a660-250">Quando il <xref:System.Threading.WaitHandle.SignalAndWait%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-250">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="0a660-251"><paramref name="toSignal" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-251"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-252">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-252">-or-</span></span>  
  
 <span data-ttu-id="0a660-253"><paramref name="toWaitOn" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-253"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-254">Il metodo è stato chiamato su un thread che dispone di <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-254">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="0a660-255">Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-255">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0a660-256"><paramref name="toSignal" /> è un semaforo e dispone già di un conteggio completo.</span><span class="sxs-lookup"><span data-stu-id="0a660-256"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-257"><paramref name="timeout" /> restituisce un numero di millisecondi negativo diverso da -1.</span><span class="sxs-lookup"><span data-stu-id="0a660-257"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
 <span data-ttu-id="0a660-258">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-258">-or-</span></span>  
  
 <span data-ttu-id="0a660-259"><paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-259"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-260">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-260">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-261">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-261">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a660-262">Attende che tutti gli elementi nella matrice specificata ricevano un segnale.</span><span class="sxs-lookup"><span data-stu-id="0a660-262">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-263">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-263">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0a660-264">Questa matrice non può contenere più riferimenti allo stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="0a660-264">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="0a660-265">Attende che tutti gli elementi nella matrice specificata ricevano un segnale.</span><span class="sxs-lookup"><span data-stu-id="0a660-265">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-266"><see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, il metodo non restituisce alcun risultato.</span><span class="sxs-lookup"><span data-stu-id="0a660-266"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-267"><xref:System.Threading.AbandonedMutexException> è stato introdotto in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="0a660-267"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0a660-268">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAll%2A> restituisce `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-268">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0a660-269">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="0a660-269">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0a660-270">Nel caso di un mutex di sistema, questo potrebbe indicare che un'applicazione è stata interrotta bruscamente (ad esempio, per utilizzare Windows Task Manager).</span><span class="sxs-lookup"><span data-stu-id="0a660-270">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0a660-271">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="0a660-271">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0a660-272">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando vengono segnalati tutti gli handle.</span><span class="sxs-lookup"><span data-stu-id="0a660-272">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="0a660-273">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-273">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0a660-274">Se la matrice contiene duplicati, la chiamata ha esito negativo con un <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="0a660-274">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-275">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato per i thread <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-275">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="0a660-276">Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload del metodo e specificando -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) per `millisecondsTimeout` e `true` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="0a660-276">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-277">Esempio di codice seguente viene illustrato come utilizzare il pool di thread per creare e scrivere in un gruppo di file in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="0a660-277">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="0a660-278">Ogni operazione di scrittura è in coda come un elemento di lavoro e segnala al suo completamento.</span><span class="sxs-lookup"><span data-stu-id="0a660-278">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="0a660-279">Il thread principale attende che tutti gli elementi da segnalare e viene chiusa.</span><span class="sxs-lookup"><span data-stu-id="0a660-279">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-280">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-280">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="0a660-281">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-281">-or-</span></span>  
  
 <span data-ttu-id="0a660-282">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-282">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-283">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-283">-or-</span></span>  
  
 <span data-ttu-id="0a660-284"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 2.0 o successiva.</span><span class="sxs-lookup"><span data-stu-id="0a660-284"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="0a660-285">In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-285">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="0a660-286">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="0a660-286">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-287">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-287">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="0a660-288">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-288">-or-</span></span>  
  
 <span data-ttu-id="0a660-289">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span><span class="sxs-lookup"><span data-stu-id="0a660-289">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="0a660-290"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span><span class="sxs-lookup"><span data-stu-id="0a660-290"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-291">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-291">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-292">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-292">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-293">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-293">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-294">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-294">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0a660-295">Questa matrice non può contenere più riferimenti allo stesso oggetto (duplicati).</span><span class="sxs-lookup"><span data-stu-id="0a660-295">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0a660-296">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-296">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0a660-297">Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.Int32" /> per specificare l'intervallo di tempo.</span><span class="sxs-lookup"><span data-stu-id="0a660-297">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-298"><see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-298"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-299">Se `millisecondsTimeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-299">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-300">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-300">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-301">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo restituisce la fine dell'attesa, vale a dire che tutti gli handle sono segnalati o quando si verifica il timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-301">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="0a660-302">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-302">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0a660-303">Se sono presenti duplicati nella matrice, la chiamata ha esito negativo con un <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="0a660-303">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-304">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato per i thread <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-304">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="0a660-305">Chiamare questo overload del metodo corrisponde al chiamante di <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="0a660-305">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-306">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-306">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-307">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-307">-or-</span></span>  
  
 <span data-ttu-id="0a660-308">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-308">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-309">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-309">-or-</span></span>  
  
 <span data-ttu-id="0a660-310"><paramref name="waitHandles" /> è una matrice senza elementi.</span><span class="sxs-lookup"><span data-stu-id="0a660-310"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="0a660-311">In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-311">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="0a660-312">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="0a660-312">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-313">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-313">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="0a660-314">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-314">-or-</span></span>  
  
 <span data-ttu-id="0a660-315">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span><span class="sxs-lookup"><span data-stu-id="0a660-315">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-316"><paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-316"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-317">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-317">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-318">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-318">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-319">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-319">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-320">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-320">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0a660-321">Questa matrice non può contenere più riferimenti allo stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="0a660-321">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="0a660-322">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-322">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0a660-323">Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo.</span><span class="sxs-lookup"><span data-stu-id="0a660-323">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-324"><see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-324"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-325">Se `timeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-325">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-326">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-326">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-327">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando l'attesa termina, il che significa che vengono segnalati tutti gli handle o si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-327">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="0a660-328">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-328">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0a660-329">Se la matrice contiene duplicati, la chiamata avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="0a660-329">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-330">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato per i thread <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-330">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="0a660-331">Il valore massimo per `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a660-331">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0a660-332">Chiamare questo overload del metodo corrisponde al chiamante di <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="0a660-332">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-333">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-333">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-334">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-334">-or-</span></span>  
  
 <span data-ttu-id="0a660-335">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-335">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-336">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-336">-or-</span></span>  
  
 <span data-ttu-id="0a660-337"><paramref name="waitHandles" /> è una matrice senza elementi.</span><span class="sxs-lookup"><span data-stu-id="0a660-337"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="0a660-338">In [.NET per app di Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) o nella [libreria di classi portabile](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) rilevare invece l'eccezione della classe di base, <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-338">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="0a660-339">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="0a660-339">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-340">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-340">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="0a660-341">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-341">-or-</span></span>  
  
 <span data-ttu-id="0a660-342">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span><span class="sxs-lookup"><span data-stu-id="0a660-342">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-343"><paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-343"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="0a660-344">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-344">-or-</span></span>  
  
 <span data-ttu-id="0a660-345"><paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-345"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-346">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-346">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-347">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-347">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-348">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-348">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-349">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-349">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0a660-350">Questa matrice non può contenere più riferimenti allo stesso oggetto (duplicati).</span><span class="sxs-lookup"><span data-stu-id="0a660-350">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0a660-351">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-351">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="0a660-352"><see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-352"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0a660-353">Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.Int32" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-353">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-354"><see langword="true" /> se ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-354"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-355">Se `millisecondsTimeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-355">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-356">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-356">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-357"><xref:System.Threading.AbandonedMutexException> è stato introdotto in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="0a660-357"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0a660-358">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAll%2A> restituisce `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-358">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0a660-359">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="0a660-359">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0a660-360">Nel caso di un mutex di sistema, questo potrebbe indicare che un'applicazione è stata interrotta bruscamente (ad esempio, per utilizzare Windows Task Manager).</span><span class="sxs-lookup"><span data-stu-id="0a660-360">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0a660-361">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="0a660-361">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0a660-362">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo restituisce la fine dell'attesa, vale a dire che tutti gli handle sono segnalati o quando si verifica il timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-362">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="0a660-363">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-363">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0a660-364">Se sono presenti duplicati nella matrice, la chiamata ha esito negativo con un <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="0a660-364">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-365">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato per i thread <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-365">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0a660-366">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="0a660-366">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0a660-367">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="0a660-367">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0a660-368">Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="0a660-368">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0a660-369">Anche se attualmente un metodo in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="0a660-369">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0a660-370">Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-370">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="0a660-371">Il thread viene restituito il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="0a660-371">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="0a660-372">Può essere utile quando la classe associata al contesto non dispone di <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attributo.</span><span class="sxs-lookup"><span data-stu-id="0a660-372">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="0a660-373">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="0a660-373">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0a660-374">Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="0a660-374">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0a660-375">Quando il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-375">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-376">Esempio di codice seguente viene illustrato come utilizzare il pool di thread per creare e scrivere in un gruppo di file in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="0a660-376">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="0a660-377">Ogni operazione di scrittura è in coda come un elemento di lavoro e segnala al suo completamento.</span><span class="sxs-lookup"><span data-stu-id="0a660-377">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="0a660-378">Il thread principale attende che tutti gli elementi da segnalare e viene chiusa.</span><span class="sxs-lookup"><span data-stu-id="0a660-378">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-379">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-379">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-380">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-380">-or-</span></span>  
  
 <span data-ttu-id="0a660-381">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-381">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-382">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-382">-or-</span></span>  
  
 <span data-ttu-id="0a660-383"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 2.0 o successiva.</span><span class="sxs-lookup"><span data-stu-id="0a660-383"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="0a660-384">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="0a660-384">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-385">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-385">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="0a660-386">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-386">-or-</span></span>  
  
 <span data-ttu-id="0a660-387">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span><span class="sxs-lookup"><span data-stu-id="0a660-387">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="0a660-388"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span><span class="sxs-lookup"><span data-stu-id="0a660-388"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-389"><paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-389"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-390">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-390">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-391">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-391">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-392">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-392">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-393">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-393">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="0a660-394">Questa matrice non può contenere più riferimenti allo stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="0a660-394">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="0a660-395">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-395">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="0a660-396"><see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-396"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0a660-397">Attende che tutti gli elementi nella matrice specificata ricevano un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-397">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-398"><see langword="true" /> quando ogni elemento in <paramref name="waitHandles" /> ha ricevuto un segnale; in caso contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-398"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-399">Se `timeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-399">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-400">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-400">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-401"><xref:System.Threading.AbandonedMutexException> è stato introdotto in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="0a660-401"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0a660-402">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAll%2A> restituisce `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-402">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0a660-403">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="0a660-403">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0a660-404">Nel caso di un mutex di sistema, questo potrebbe indicare che un'applicazione è stata interrotta bruscamente (ad esempio, per utilizzare Windows Task Manager).</span><span class="sxs-lookup"><span data-stu-id="0a660-404">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0a660-405">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="0a660-405">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0a660-406">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito quando l'attesa termina, il che significa che vengono segnalati tutti gli handle o si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-406">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="0a660-407">In alcune implementazioni, se vengono passati più di 64 handle, un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-407">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="0a660-408">Se la matrice contiene duplicati, la chiamata avrà esito negativo.</span><span class="sxs-lookup"><span data-stu-id="0a660-408">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-409">Il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo non è supportato per i thread <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-409">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="0a660-410">Il valore massimo per `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a660-410">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0a660-411">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="0a660-411">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0a660-412">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="0a660-412">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0a660-413">Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="0a660-413">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0a660-414">Anche se attualmente un metodo in una classe che non è derivata da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="0a660-414">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0a660-415">Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-415">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="0a660-416">Restituisce il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="0a660-416">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="0a660-417">Può essere utile quando è la classe associata al contesto <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-417">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0a660-418">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="0a660-418">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0a660-419">Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.WaitHandle.WaitAll%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="0a660-419">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0a660-420">Quando il <xref:System.Threading.WaitHandle.WaitAll%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-420">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-421">Esempio di codice seguente viene illustrato come utilizzare il pool di thread per creare e scrivere in un gruppo di file in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="0a660-421">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="0a660-422">Ogni operazione di scrittura è in coda come un elemento di lavoro e segnala al suo completamento.</span><span class="sxs-lookup"><span data-stu-id="0a660-422">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="0a660-423">Il thread principale attende che tutti gli elementi da segnalare e viene chiusa.</span><span class="sxs-lookup"><span data-stu-id="0a660-423">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-424">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-424">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-425">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-425">-or-</span></span>  
  
 <span data-ttu-id="0a660-426">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-426">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-427">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-427">-or-</span></span>  
  
 <span data-ttu-id="0a660-428"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 2.0 o successiva.</span><span class="sxs-lookup"><span data-stu-id="0a660-428"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="0a660-429">La matrice <paramref name="waitHandles" /> contiene elementi duplicati.</span><span class="sxs-lookup"><span data-stu-id="0a660-429">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-430">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-430">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="0a660-431">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-431">-or-</span></span>  
  
 <span data-ttu-id="0a660-432">L'attributo <see cref="T:System.STAThreadAttribute" /> viene applicato alla routine del thread corrente e <paramref name="waitHandles" /> contiene più di un elemento.</span><span class="sxs-lookup"><span data-stu-id="0a660-432">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="0a660-433"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span><span class="sxs-lookup"><span data-stu-id="0a660-433"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-434"><paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-434"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="0a660-435">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-435">-or-</span></span>  
  
 <span data-ttu-id="0a660-436"><paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-436"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-437">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-437">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-438">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-438">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-439">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-439">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a660-440">Attende che uno degli elementi nella matrice specificata riceva un segnale.</span><span class="sxs-lookup"><span data-stu-id="0a660-440">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-441">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-441">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="0a660-442">Attende che uno degli elementi nella matrice specificata riceva un segnale.</span><span class="sxs-lookup"><span data-stu-id="0a660-442">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="0a660-443">Indice della matrice dell'oggetto che ha soddisfatto l'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-443">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-444"><xref:System.Threading.AbandonedMutexException> è stato introdotto in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="0a660-444"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0a660-445">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAny%2A> restituisce `true` se il tempo di attesa viene completata perché viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-445">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="0a660-446">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="0a660-446">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0a660-447">Nel caso di un mutex di sistema, questo potrebbe indicare che un'applicazione è stata interrotta bruscamente (ad esempio, per utilizzare Windows Task Manager).</span><span class="sxs-lookup"><span data-stu-id="0a660-447">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0a660-448">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="0a660-448">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0a660-449">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="0a660-449">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0a660-450">Se `waitHandles` contiene un mutex rilasciato con un numero di indice inferiore rispetto al mutex abbandonato, il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completata e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-450">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-451">Nelle versioni di .NET Framework precedenti alla versione 2.0, se un thread viene chiuso o annullato senza rilasciare esplicitamente un <xref:System.Threading.Mutex>e che `Mutex` in corrispondenza dell'indice 0 (zero) è un `WaitAny` matrice in un altro thread, l'indice restituito da `WaitAny` è 128 anziché 0.</span><span class="sxs-lookup"><span data-stu-id="0a660-451">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="0a660-452">Questo metodo restituisce quando viene segnalato un handle qualsiasi.</span><span class="sxs-lookup"><span data-stu-id="0a660-452">This method returns when any handle is signaled.</span></span> <span data-ttu-id="0a660-453">Se più di un oggetto viene segnalato durante la chiamata, il valore restituito è l'indice di matrice dell'oggetto segnalato con il valore di indice minimo di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="0a660-453">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0a660-454">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-454">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="0a660-455">Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload del metodo e specificando -1 (o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) per `millisecondsTimeout` e `true` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="0a660-455">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-456">Esempio di codice seguente viene illustrata la chiamata di <xref:System.Threading.WaitHandle.WaitAny%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-456">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-457">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-457">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-458">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-458">-or-</span></span>  
  
 <span data-ttu-id="0a660-459">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-459">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-460">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-460">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="0a660-461"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span><span class="sxs-lookup"><span data-stu-id="0a660-461"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-462">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-462">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-463">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-463">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a660-464"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è la 2.0 o successiva.</span><span class="sxs-lookup"><span data-stu-id="0a660-464"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-465">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-465">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-466">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-466">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0a660-467">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-467">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0a660-468">Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo.</span><span class="sxs-lookup"><span data-stu-id="0a660-468">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="0a660-469">Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="millisecondsTimeout" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-469">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-470">Se `millisecondsTimeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-470">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-471">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-471">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-472">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="0a660-472">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0a660-473">Se `waitHandles` contiene un mutex rilasciato con un numero di indice inferiore rispetto al mutex abbandonato, il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completata e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-473">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="0a660-474">Questo metodo restituisce la fine dell'attesa, quando uno degli handle vengono segnalato o quando si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-474">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="0a660-475">Se più di un oggetto viene segnalato durante la chiamata, il valore restituito è l'indice di matrice dell'oggetto segnalato con il valore di indice minimo di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="0a660-475">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0a660-476">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-476">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="0a660-477">Chiamare questo overload del metodo corrisponde al chiamante di <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="0a660-477">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-478">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-478">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-479">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-479">-or-</span></span>  
  
 <span data-ttu-id="0a660-480">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-480">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-481">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-481">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-482"><paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-482"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-483">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-483">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-484">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-484">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a660-485"><paramref name="waitHandles" /> è una matrice senza elementi.</span><span class="sxs-lookup"><span data-stu-id="0a660-485"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-486">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-486">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-487">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-487">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="0a660-488">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-488">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0a660-489">Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo.</span><span class="sxs-lookup"><span data-stu-id="0a660-489">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="0a660-490">Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-490">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-491">Se `timeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-491">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-492">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-492">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-493">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="0a660-493">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0a660-494">Se `waitHandles` contiene un mutex rilasciato con un numero di indice inferiore rispetto al mutex abbandonato, il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completata e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-494">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="0a660-495">Questo metodo restituisce la fine dell'attesa, quando uno degli handle vengono segnalato o quando si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-495">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="0a660-496">Se più di un oggetto viene segnalato durante la chiamata, il valore restituito è l'indice di matrice dell'oggetto segnalato con il valore di indice minimo di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="0a660-496">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0a660-497">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-497">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="0a660-498">Il valore massimo per `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a660-498">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0a660-499">Chiamare questo overload del metodo corrisponde al chiamante di <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="0a660-499">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-500">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-500">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-501">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-501">-or-</span></span>  
  
 <span data-ttu-id="0a660-502">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-502">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-503">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-503">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-504"><paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-504"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="0a660-505">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-505">-or-</span></span>  
  
 <span data-ttu-id="0a660-506"><paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-506"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-507">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-507">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-508">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-508">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a660-509"><paramref name="waitHandles" /> è una matrice senza elementi.</span><span class="sxs-lookup"><span data-stu-id="0a660-509"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-510">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-510">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-511">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-511">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0a660-512">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-512">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="0a660-513"><see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-513"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0a660-514">Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-514">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="0a660-515">Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="millisecondsTimeout" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-515">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-516">Se `millisecondsTimeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-516">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-517">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-517">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-518"><xref:System.Threading.AbandonedMutexException> è stato introdotto in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="0a660-518"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0a660-519">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAny%2A> restituisce `true` se il tempo di attesa viene completata perché viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-519">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="0a660-520">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="0a660-520">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0a660-521">Nel caso di un mutex di sistema, questo potrebbe indicare che un'applicazione è stata interrotta bruscamente (ad esempio, per utilizzare Windows Task Manager).</span><span class="sxs-lookup"><span data-stu-id="0a660-521">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0a660-522">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="0a660-522">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0a660-523">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="0a660-523">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0a660-524">Se `waitHandles` contiene un mutex rilasciato con un numero di indice inferiore rispetto al mutex abbandonato, il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completata e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-524">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-525">Nelle versioni di .NET Framework precedenti alla versione 2.0, se un thread viene chiuso o annullato senza rilasciare esplicitamente un <xref:System.Threading.Mutex>e che `Mutex` in corrispondenza dell'indice 0 (zero) è un `WaitAny` matrice in un altro thread, l'indice restituito da `WaitAny` è 128 anziché 0.</span><span class="sxs-lookup"><span data-stu-id="0a660-525">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="0a660-526">Questo metodo restituisce la fine dell'attesa, quando uno degli handle vengono segnalato o quando si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-526">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="0a660-527">Se più di un oggetto viene segnalato durante la chiamata, il valore restituito è l'indice di matrice dell'oggetto segnalato con il valore di indice minimo di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="0a660-527">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0a660-528">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-528">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0a660-529">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="0a660-529">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0a660-530">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="0a660-530">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0a660-531">Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="0a660-531">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0a660-532">Anche se attualmente un metodo in una classe che deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="0a660-532">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0a660-533">Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-533">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="0a660-534">Il thread viene restituito il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="0a660-534">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="0a660-535">Può essere utile quando è la classe associata al contesto <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-535">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0a660-536">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="0a660-536">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0a660-537">Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="0a660-537">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0a660-538">Quando il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-538">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-539">Esempio di codice seguente viene illustrato come utilizzare il pool di thread per la ricerca un file su più dischi contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-539">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="0a660-540">Per motivi di spazio, viene cercata solo nella directory radice di ogni disco.</span><span class="sxs-lookup"><span data-stu-id="0a660-540">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-541">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-541">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-542">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-542">-or-</span></span>  
  
 <span data-ttu-id="0a660-543">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-543">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-544">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-544">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="0a660-545"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span><span class="sxs-lookup"><span data-stu-id="0a660-545"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-546"><paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-546"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-547">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-547">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-548">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-548">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a660-549"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è la 2.0 o successiva.</span><span class="sxs-lookup"><span data-stu-id="0a660-549"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-550">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-550">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="0a660-551">Matrice <see langword="WaitHandle" /> contenente gli oggetti per i quali l'istanza corrente attenderà.</span><span class="sxs-lookup"><span data-stu-id="0a660-551">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="0a660-552">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-552">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="0a660-553"><see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-553"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0a660-554">Attende che uno degli elementi nella matrice specificata riceva un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-554">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="0a660-555">Indice della matrice dell'oggetto che ha soddisfatto l'attesa oppure <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> se nessun oggetto ha soddisfatto l'attesa ed è trascorso un intervallo di tempo equivalente a <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-555">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-556">Se `timeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-556">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-557">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-557">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-558"><xref:System.Threading.AbandonedMutexException> è stato introdotto in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="0a660-558"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0a660-559">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitAny%2A> restituisce `true` se il tempo di attesa viene completata perché viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-559">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="0a660-560">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="0a660-560">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0a660-561">Nel caso di un mutex di sistema, questo potrebbe indicare che un'applicazione è stata interrotta bruscamente (ad esempio, per utilizzare Windows Task Manager).</span><span class="sxs-lookup"><span data-stu-id="0a660-561">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0a660-562">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="0a660-562">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0a660-563">Il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo genera un <xref:System.Threading.AbandonedMutexException> solo quando il tempo di attesa viene completata a causa di un mutex abbandonato.</span><span class="sxs-lookup"><span data-stu-id="0a660-563">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="0a660-564">Se `waitHandles` contiene un mutex rilasciato con un numero di indice inferiore rispetto al mutex abbandonato, il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completata e non viene generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-564">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0a660-565">Nelle versioni di .NET Framework precedenti alla versione 2.0, se un thread viene chiuso o annullato senza rilasciare esplicitamente un <xref:System.Threading.Mutex>e che `Mutex` in corrispondenza dell'indice 0 (zero) è un `WaitAny` matrice in un altro thread, l'indice restituito da `WaitAny` è 128 anziché 0.</span><span class="sxs-lookup"><span data-stu-id="0a660-565">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="0a660-566">Questo metodo restituisce la fine dell'attesa, quando uno degli handle vengono segnalato o quando si verifica un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-566">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="0a660-567">Se più di un oggetto viene segnalato durante la chiamata, il valore restituito è l'indice di matrice dell'oggetto segnalato con il valore di indice minimo di tutti gli oggetti segnalati.</span><span class="sxs-lookup"><span data-stu-id="0a660-567">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="0a660-568">In alcune implementazioni, se vengono passati gli handle di 64, più di un <xref:System.NotSupportedException> viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="0a660-568">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="0a660-569">Il valore massimo per `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a660-569">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0a660-570">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="0a660-570">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0a660-571">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="0a660-571">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0a660-572">Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="0a660-572">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0a660-573">Anche se attualmente un metodo in una classe che deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="0a660-573">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0a660-574">Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-574">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="0a660-575">Il thread viene restituito il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="0a660-575">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="0a660-576">Può essere utile quando è la classe associata al contesto <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-576">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0a660-577">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="0a660-577">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0a660-578">Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.WaitHandle.WaitAny%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="0a660-578">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0a660-579">Quando il <xref:System.Threading.WaitHandle.WaitAny%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-579">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-580">Esempio di codice seguente viene illustrato come utilizzare il pool di thread per la ricerca un file su più dischi contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-580">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="0a660-581">Per motivi di spazio, viene cercata solo nella directory radice di ogni disco.</span><span class="sxs-lookup"><span data-stu-id="0a660-581">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0a660-582">Il valore del parametro <paramref name="waitHandles" /> è <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-582">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="0a660-583">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-583">-or-</span></span>  
  
 <span data-ttu-id="0a660-584">Uno o più oggetti nella matrice <paramref name="waitHandles" /> sono <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-584">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="0a660-585">Il numero di oggetti in <paramref name="waitHandles" /> è maggiore di quello consentito dal sistema.</span><span class="sxs-lookup"><span data-stu-id="0a660-585">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="0a660-586"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è 1.0 o 1.1.</span><span class="sxs-lookup"><span data-stu-id="0a660-586"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-587"><paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-587"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="0a660-588">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-588">-or-</span></span>  
  
 <span data-ttu-id="0a660-589"><paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-589"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-590">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-590">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-591">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-591">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0a660-592"><paramref name="waitHandles" /> è una matrice senza elementi e la versione di .NET Framework è la 2.0 o successiva.</span><span class="sxs-lookup"><span data-stu-id="0a660-592"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-593">La matrice <paramref name="waitHandles" /> contiene un proxy trasparente per un oggetto <see cref="T:System.Threading.WaitHandle" /> in un altro dominio di applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-593">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0a660-594">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale.</span><span class="sxs-lookup"><span data-stu-id="0a660-594">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0a660-595">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale.</span><span class="sxs-lookup"><span data-stu-id="0a660-595">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-596">Viene restituito <see langword="true" /> se l'istanza corrente riceve un segnale.</span><span class="sxs-lookup"><span data-stu-id="0a660-596"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="0a660-597">Se l'istanza corrente non viene mai segnalata, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> non restituisce mai alcun valore.</span><span class="sxs-lookup"><span data-stu-id="0a660-597">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-598"><xref:System.Threading.AbandonedMutexException> è stato introdotto in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="0a660-598"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0a660-599">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituisce `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-599">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0a660-600">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="0a660-600">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0a660-601">Nel caso di un mutex di sistema, questo potrebbe indicare che un'applicazione è stata interrotta bruscamente (ad esempio, per utilizzare Windows Task Manager).</span><span class="sxs-lookup"><span data-stu-id="0a660-601">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0a660-602">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="0a660-602">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0a660-603">Il chiamante di questo metodo si blocca in modo indefinito finché l'istanza corrente riceve un segnale.</span><span class="sxs-lookup"><span data-stu-id="0a660-603">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="0a660-604">Utilizzare questo metodo di bloccarsi fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato al completamento di un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="0a660-604">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0a660-605">Per ulteriori informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="0a660-605">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0a660-606">Chiamare questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload del metodo e specificando -1 o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> per il primo parametro e `false` per il secondo parametro.</span><span class="sxs-lookup"><span data-stu-id="0a660-606">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="0a660-607">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="0a660-607">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-608">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per impedire che un processo venga interrotto durante l'attesa di un thread in background terminare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="0a660-608">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0a660-609">L'istanza corrente è già stata eliminata.</span><span class="sxs-lookup"><span data-stu-id="0a660-609">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-610">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-610">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-611">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-611">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-612">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-612">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="0a660-613">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-613">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0a660-614">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo.</span><span class="sxs-lookup"><span data-stu-id="0a660-614">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-615"><see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-615"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-616">Se `millisecondsTimeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-616">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-617">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-617">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-618">Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-618">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="0a660-619">Utilizzare questo metodo di bloccarsi fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato al completamento di un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="0a660-619">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0a660-620">Per ulteriori informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="0a660-620">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0a660-621">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="0a660-621">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="0a660-622">Chiamare questo overload del metodo corrisponde al chiamante di <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="0a660-622">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-623">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per impedire che un processo venga interrotto durante l'attesa di un thread in background terminare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="0a660-623">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0a660-624">L'istanza corrente è già stata eliminata.</span><span class="sxs-lookup"><span data-stu-id="0a660-624">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-625"><paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-625"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-626">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-627">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-628">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="0a660-629">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-629">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0a660-630">Blocca il thread corrente finché l'istanza corrente non riceve un segnale, usando un valore <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo.</span><span class="sxs-lookup"><span data-stu-id="0a660-630">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-631"><see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-632">Se `timeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-632">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-633">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-634">Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="0a660-635">Utilizzare questo metodo di bloccarsi fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato al completamento di un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="0a660-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0a660-636">Per ulteriori informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="0a660-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0a660-637">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="0a660-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="0a660-638">Il valore massimo per `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a660-638">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="0a660-639">Chiamare questo overload del metodo corrisponde al chiamante di <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload e specificare `false` per `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="0a660-639">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0a660-640">L'istanza corrente è già stata eliminata.</span><span class="sxs-lookup"><span data-stu-id="0a660-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-641"><paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-641"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="0a660-642">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-642">-or-</span></span>  
  
 <span data-ttu-id="0a660-643"><paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-643"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-644">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-644">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-645">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-645">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-646">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-646">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="0a660-647">Numero di millisecondi di attesa oppure <see cref="F:System.Threading.Timeout.Infinite" /> (-1) per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-647">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="0a660-648"><see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-648"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0a660-649">Blocca il thread corrente finché l'oggetto <see cref="T:System.Threading.WaitHandle" /> corrente non riceve un segnale, usando un intero con segno a 32 bit per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-649">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-650"><see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-650"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-651">Se `millisecondsTimeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-651">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-652">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-652">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-653"><xref:System.Threading.AbandonedMutexException> è stato introdotto in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="0a660-653"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0a660-654">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituisce `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-654">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0a660-655">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="0a660-655">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0a660-656">Nel caso di un mutex di sistema, questo potrebbe indicare che un'applicazione è stata interrotta bruscamente (ad esempio, per utilizzare Windows Task Manager).</span><span class="sxs-lookup"><span data-stu-id="0a660-656">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0a660-657">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="0a660-657">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0a660-658">Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-658">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="0a660-659">Utilizzare questo metodo di bloccarsi fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato al completamento di un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="0a660-659">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0a660-660">Per ulteriori informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="0a660-660">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0a660-661">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="0a660-661">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0a660-662">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="0a660-662">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0a660-663">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="0a660-663">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0a660-664">Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="0a660-664">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0a660-665">Anche se attualmente un metodo in una classe che deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="0a660-665">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0a660-666">Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-666">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="0a660-667">Il thread viene restituito il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="0a660-667">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="0a660-668">Può essere utile quando è la classe associata al contesto <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-668">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0a660-669">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="0a660-669">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0a660-670">Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="0a660-670">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0a660-671">Quando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-671">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-672">L'esempio seguente mostra come <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload del metodo funziona quando viene chiamato all'interno di un dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-672">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="0a660-673">Innanzitutto, un thread in attesa con `exitContext` impostato su `false` e blocca fino alla scadenza del timeout di attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-673">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="0a660-674">Un secondo thread viene eseguito dopo il primo thread termina e resta in attesa con `exitContext` impostato su `true`.</span><span class="sxs-lookup"><span data-stu-id="0a660-674">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="0a660-675">La chiamata per segnalare l'handle di attesa per il secondo thread non è bloccata e il thread viene completato prima del timeout di attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-675">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0a660-676">L'istanza corrente è già stata eliminata.</span><span class="sxs-lookup"><span data-stu-id="0a660-676">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-677"><paramref name="millisecondsTimeout" /> è un numero negativo diverso da -1, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-677"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-678">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-678">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-679">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-679">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-680">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-680">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="0a660-681">Oggetto <see cref="T:System.TimeSpan" /> che rappresenta il numero di millisecondi di attesa oppure <see cref="T:System.TimeSpan" /> che rappresenta -1 millisecondi per un'attesa indefinita.</span><span class="sxs-lookup"><span data-stu-id="0a660-681">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="0a660-682"><see langword="true" /> per uscire dal dominio di sincronizzazione per il contesto prima dell'attesa, se all'interno di un contesto sincronizzato, e riacquisirlo successivamente; in caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-682"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0a660-683">Blocca il thread corrente finché l'istanza corrente non riceve un segnale, usando un oggetto <see cref="T:System.TimeSpan" /> per specificare l'intervallo di tempo e indicando se uscire dal dominio di sincronizzazione prima dell'attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-683">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="0a660-684"><see langword="true" /> se l'istanza corrente riceve un segnale; in caso contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-684"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-685">Se `timeout` è zero, il metodo non blocca.</span><span class="sxs-lookup"><span data-stu-id="0a660-685">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="0a660-686">Il test dello stato dell'handle di attesa e restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-686">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="0a660-687"><xref:System.Threading.AbandonedMutexException> è stato introdotto in .NET Framework versione 2.0.</span><span class="sxs-lookup"><span data-stu-id="0a660-687"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="0a660-688">Nelle versioni precedenti, il <xref:System.Threading.WaitHandle.WaitOne%2A> restituisce `true` quando viene abbandonato un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-688">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="0a660-689">Un mutex abbandonato indica spesso un grave errore di codifica.</span><span class="sxs-lookup"><span data-stu-id="0a660-689">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="0a660-690">Nel caso di un mutex di sistema, questo potrebbe indicare che un'applicazione è stata interrotta bruscamente (ad esempio, per utilizzare Windows Task Manager).</span><span class="sxs-lookup"><span data-stu-id="0a660-690">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="0a660-691">L'eccezione contiene informazioni utili per il debug.</span><span class="sxs-lookup"><span data-stu-id="0a660-691">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="0a660-692">Si verifica il chiamante di questo metodo si blocca fino a quando l'istanza corrente riceve un segnale o un timeout.</span><span class="sxs-lookup"><span data-stu-id="0a660-692">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="0a660-693">Utilizzare questo metodo di bloccarsi fino a un <xref:System.Threading.WaitHandle> riceve un segnale da un altro thread, ad esempio viene generato al completamento di un'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="0a660-693">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="0a660-694">Per ulteriori informazioni, vedere il <xref:System.IAsyncResult> interfaccia.</span><span class="sxs-lookup"><span data-stu-id="0a660-694">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="0a660-695">Eseguire l'override di questo metodo per personalizzare il comportamento delle classi derivate.</span><span class="sxs-lookup"><span data-stu-id="0a660-695">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="0a660-696">Il valore massimo per `timeout` è <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0a660-696">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="0a660-697">Note sull'uscita dal contesto</span><span class="sxs-lookup"><span data-stu-id="0a660-697">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="0a660-698">Il `exitContext` parametro ha effetto solo se il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo chiamato dall'interno di un contesto gestito.</span><span class="sxs-lookup"><span data-stu-id="0a660-698">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="0a660-699">Questa situazione può verificarsi se il thread è all'interno di una chiamata a un'istanza di una classe derivata da <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="0a660-699">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="0a660-700">Anche se attualmente un metodo in una classe che deriva da <xref:System.ContextBoundObject>, ad esempio <xref:System.String>, è possibile trovarsi in un contesto non predefinito se un <xref:System.ContextBoundObject> nello stack nel dominio applicazione corrente.</span><span class="sxs-lookup"><span data-stu-id="0a660-700">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="0a660-701">Quando il codice è in esecuzione in un contesto non predefinito, specificare `true` per `exitContext` fa sì che il thread esce dal contesto gestito (vale a dire transizione per il contesto predefinito) prima di eseguire il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="0a660-701">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="0a660-702">Il thread viene restituito il contesto non predefinito originale dopo la chiamata al <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene completato.</span><span class="sxs-lookup"><span data-stu-id="0a660-702">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="0a660-703">Può essere utile quando è la classe associata al contesto <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="0a660-703">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="0a660-704">In tal caso, tutte le chiamate ai membri della classe sono automaticamente sincronizzate e il dominio di sincronizzazione è l'intero corpo del codice per la classe.</span><span class="sxs-lookup"><span data-stu-id="0a660-704">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="0a660-705">Se viene chiamato codice nello stack di chiamate di un membro di <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo) e specifica `true` per `exitContext`, la chiusura del thread nel dominio di sincronizzazione, consentendo a un thread bloccato in una chiamata a qualsiasi membro dell'oggetto per continuare.</span><span class="sxs-lookup"><span data-stu-id="0a660-705">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="0a660-706">Quando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo viene restituito, il thread che ha effettuato la chiamata deve attendere per immettere nuovamente il dominio di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-706">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-707">Esempio di codice seguente viene illustrato come utilizzare un handle di attesa per impedire che un processo venga interrotto durante l'attesa di un thread in background terminare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="0a660-707">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0a660-708">L'istanza corrente è già stata eliminata.</span><span class="sxs-lookup"><span data-stu-id="0a660-708">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="0a660-709"><paramref name="timeout" /> è un numero negativo diverso da -1 millisecondi, che rappresenta un timeout infinito.</span><span class="sxs-lookup"><span data-stu-id="0a660-709"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="0a660-710">oppure</span><span class="sxs-lookup"><span data-stu-id="0a660-710">-or-</span></span>  
  
 <span data-ttu-id="0a660-711"><paramref name="timeout" /> è maggiore di <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="0a660-711"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="0a660-712">L'attesa è terminata perché un thread è stato chiuso senza rilasciare un mutex.</span><span class="sxs-lookup"><span data-stu-id="0a660-712">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="0a660-713">Questa eccezione non viene generata in Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="0a660-713">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0a660-714">L'istanza corrente corrisponde a un proxy trasparente per una classe <see cref="T:System.Threading.WaitHandle" /> in un altro dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="0a660-714">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="0a660-715">Indica che si è verificato il timeout di un'operazione <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> prima della segnalazione di uno degli handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="0a660-715">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="0a660-716">Questo campo è costante.</span><span class="sxs-lookup"><span data-stu-id="0a660-716">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0a660-717">Questo campo è uno dei possibili valori restituiti di `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="0a660-717">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0a660-718">Esempio di codice seguente viene illustrato come utilizzare il pool di thread per la ricerca un file su più dischi contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="0a660-718">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="0a660-719">Per motivi di spazio, viene cercata solo nella directory radice di ogni disco.</span><span class="sxs-lookup"><span data-stu-id="0a660-719">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>