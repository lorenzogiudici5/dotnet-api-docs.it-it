<Type Name="ManualResetEvent" FullName="System.Threading.ManualResetEvent">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3c19185907e45c5b7b80aae8627946c15d4efd4f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36605906" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ManualResetEvent : System.Threading.EventWaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ManualResetEvent extends System.Threading.EventWaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ManualResetEvent" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ManualResetEvent&#xA;Inherits EventWaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class ManualResetEvent sealed : System::Threading::EventWaitHandle" />
  <TypeSignature Language="F#" Value="type ManualResetEvent = class&#xA;    inherit EventWaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.EventWaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Notifica a uno o più thread in attesa che si è verificato un evento. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework versione 2.0 <xref:System.Threading.ManualResetEvent> deriva dalla nuova <xref:System.Threading.EventWaitHandle> classe. Un <xref:System.Threading.ManualResetEvent> è funzionalmente equivalente a un <xref:System.Threading.EventWaitHandle> creati con <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>.  
  
> [!NOTE]
>  A differenza di <xref:System.Threading.ManualResetEvent> (classe), il <xref:System.Threading.EventWaitHandle> classe fornisce accesso agli eventi di sincronizzazione di sistema denominati.  
  
 <xref:System.Threading.ManualResetEvent> consente ai thread di comunicare tra loro mediante la segnalazione. In genere, questa comunicazione riguarda un'attività che un thread necessario completare prima di procedere con altri thread.  
  
 Quando un thread inizia un'attività che deve essere completata prima delle altre thread procedere, viene chiamato <xref:System.Threading.EventWaitHandle.Reset%2A> inserire `ManualResetEvent` nello stato non segnalato. Questo thread può essere considerato come controllare il `ManualResetEvent`. Thread che chiamano <xref:System.Threading.WaitHandle.WaitOne%2A> nella `ManualResetEvent` verrà bloccata, l'attesa del segnale. Quando il thread di controllo viene completata l'attività, chiama <xref:System.Threading.EventWaitHandle.Set%2A> per segnalare che il thread in attesa può procedere. Vengono rilasciati tutti i thread in attesa.  
  
 Una volta che è stato segnalato, `ManualResetEvent` rimane segnalato fino a quando non viene reimpostato manualmente. Vale a dire, le chiamate a `WaitOne` restituire immediatamente.  
  
 È possibile controllare lo stato iniziale di un `ManualResetEvent` passando un valore booleano per il costruttore `true` se non viene segnalato lo stato iniziale e `false` in caso contrario.  
  
 `ManualResetEvent` può anche essere utilizzato con il `static` <xref:System.Threading.WaitHandle.WaitAll%2A> e <xref:System.Threading.WaitHandle.WaitAny%2A> metodi.  
  
 Per ulteriori informazioni sui meccanismi di sincronizzazione di thread, vedere [ManualResetEvent e ManualResetEventSlim](~/docs/standard/threading/manualresetevent-and-manualreseteventslim.md) nella documentazione concettuale.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come <xref:System.Threading.ManualResetEvent> funziona. L'esempio inizia con un <xref:System.Threading.ManualResetEvent> nello stato segnalato (vale a dire, `false` viene passato al costruttore). L'esempio crea tre dei thread, ognuno dei quali si blocca nel <xref:System.Threading.ManualResetEvent> chiamando il relativo <xref:System.Threading.WaitHandle.WaitOne%2A> metodo. Quando l'utente preme il **invio** chiave, nell'esempio viene chiamato il <xref:System.Threading.EventWaitHandle.Set%2A> (metodo), che quale rilascia tutti i thread. Ciò si differenzia il comportamento del <xref:System.Threading.AutoResetEvent> (classe), che rilascia i thread uno alla volta, reimpostare automaticamente dopo ogni rilascio.  
  
 Premendo il **invio** chiave viene nuovamente illustrato che il <xref:System.Threading.ManualResetEvent> rimane in stato segnalato fino al relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato: nell'esempio viene avviato due ulteriori thread. Questi thread non blocchino quando chiamano il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo), ma vengono invece eseguiti fino al completamento.  
  
 Premere il **invio** chiave nuovamente fa sì che l'esempio chiama il <xref:System.Threading.EventWaitHandle.Reset%2A> (metodo) e avviare uno o più thread, che si blocca quando viene chiamata <xref:System.Threading.WaitHandle.WaitOne%2A>. Premere il **invio** chiave uno ora finale chiamate <xref:System.Threading.EventWaitHandle.Set%2A> per rilasciare l'ultimo thread e il programma termina.  
  
 [!code-cpp[System.Threading.ManualResetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ManualResetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/CS/source.cs#1)]
 [!code-vb[System.Threading.ManualResetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questa classe è thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ManualResetEvent (bool initialState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ManualResetEvent(bool initialState);" />
      <MemberSignature Language="F#" Value="new System.Threading.ManualResetEvent : bool -&gt; System.Threading.ManualResetEvent" Usage="new System.Threading.ManualResetEvent initialState" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initialState">Viene restituito <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostare lo stato iniziale su non segnalato.</param>
        <summary>Consente l'inizializzazione di una nuova istanza della classe <see cref="T:System.Threading.ManualResetEvent" /> con un valore Booleano che indica se lo stato iniziale deve essere impostato su segnalato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se lo stato iniziale di un <xref:System.Threading.ManualResetEvent> viene segnalato (vale a dire, se viene creato passando `true` per `initialState`), i thread in attesa sul <xref:System.Threading.ManualResetEvent> non blocchino. Se lo stato iniziale è impostato su non segnalato, bloccano il thread fino al <xref:System.Threading.EventWaitHandle.Set%2A> metodo viene chiamato.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
  </Members>
</Type>