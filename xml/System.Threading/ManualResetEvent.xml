<Type Name="ManualResetEvent" FullName="System.Threading.ManualResetEvent">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6bd57be7d0b7a3e06e014afa452e4dadda84883c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30527805" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ManualResetEvent : System.Threading.EventWaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ManualResetEvent extends System.Threading.EventWaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ManualResetEvent" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ManualResetEvent&#xA;Inherits EventWaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class ManualResetEvent sealed : System::Threading::EventWaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.EventWaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Notifica a uno o più thread in attesa che si è verificato un evento. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework versione 2.0, <xref:System.Threading.ManualResetEvent> deriva dalla nuova <xref:System.Threading.EventWaitHandle> classe. Oggetto <xref:System.Threading.ManualResetEvent> è funzionalmente equivalente a un <xref:System.Threading.EventWaitHandle> creato con <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>.  
  
> [!NOTE]
>  A differenza di <xref:System.Threading.ManualResetEvent> (classe), la <xref:System.Threading.EventWaitHandle> classe fornisce accesso agli eventi di sincronizzazione di sistema denominati.  
  
 <xref:System.Threading.ManualResetEvent> consente ai thread di comunicare tra loro mediante la segnalazione. In genere, la presente comunicazione riguarda un'attività che un thread necessario completare prima di procedere altri thread.  
  
 Quando un thread avvia un'attività che deve essere completata prima di altri thread di procedere, viene chiamato <xref:System.Threading.EventWaitHandle.Reset%2A> inserire `ManualResetEvent` nello stato non segnalato. Il thread può essere considerato come il controllo di `ManualResetEvent`. Thread che chiamano <xref:System.Threading.WaitHandle.WaitOne%2A> sul `ManualResetEvent` verrà bloccata, l'attesa del segnale. Quando il thread di controllo viene completata l'attività, chiama <xref:System.Threading.EventWaitHandle.Set%2A> per segnalare che il thread in attesa può procedere. Vengono rilasciati tutti i thread in attesa.  
  
 Una volta che è stato segnalato, `ManualResetEvent` rimane segnalato fino a quando non viene reimpostato manualmente. Ovvero, le chiamate a `WaitOne` restituito immediatamente.  
  
 È possibile controllare lo stato iniziale di un `ManualResetEvent` passando un valore booleano al costruttore, `true` se viene segnalato lo stato iniziale e `false` in caso contrario.  
  
 `ManualResetEvent` può anche essere utilizzato con il `static` <xref:System.Threading.WaitHandle.WaitAll%2A> e <xref:System.Threading.WaitHandle.WaitAny%2A> metodi.  
  
 Per ulteriori informazioni sui meccanismi di sincronizzazione di thread, vedere [ManualResetEvent e ManualResetEventSlim](~/docs/standard/threading/manualresetevent-and-manualreseteventslim.md) nella documentazione concettuale.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come <xref:System.Threading.ManualResetEvent> funziona. L'esempio inizia con un <xref:System.Threading.ManualResetEvent> nello stato segnalato (vale a dire `false` viene passato al costruttore). L'esempio crea tre thread, ognuno dei quali si blocca nel <xref:System.Threading.ManualResetEvent> chiamando il relativo <xref:System.Threading.WaitHandle.WaitOne%2A> metodo. Quando l'utente preme il **invio** chiave, nell'esempio viene chiamato il <xref:System.Threading.EventWaitHandle.Set%2A> (metodo), che quale rilascia tutti i thread. Ciò si differenzia dal comportamento del <xref:System.Threading.AutoResetEvent> (classe), che rilascia i thread uno alla volta, reimpostare automaticamente dopo ogni rilascio.  
  
 Premendo il **invio** chiave viene nuovamente illustrato che il <xref:System.Threading.ManualResetEvent> rimane nello stato segnalato fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato: viene avviato il thread di altre due. Questi thread non blocchino quando chiamano il <xref:System.Threading.WaitHandle.WaitOne%2A> (metodo), ma vengono invece eseguiti fino al completamento.  
  
 Premendo il **invio** chiave nuovamente fa sì che l'esempio chiama il <xref:System.Threading.EventWaitHandle.Reset%2A> (metodo) e avviare uno o più thread, che si blocca quando viene chiamata <xref:System.Threading.WaitHandle.WaitOne%2A>. Premendo il **invio** chiave uno ora finale chiamate <xref:System.Threading.EventWaitHandle.Set%2A> per rilasciare l'ultimo thread e il programma termina.  
  
 [!code-cpp[System.Threading.ManualResetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ManualResetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/CS/source.cs#1)]
 [!code-vb[System.Threading.ManualResetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ManualResetEvent/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questa classe è thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ManualResetEvent (bool initialState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ManualResetEvent(bool initialState);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initialState">
          Viene restituito <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostare lo stato iniziale su non segnalato.</param>
        <summary>Consente l'inizializzazione di una nuova istanza della classe <see cref="T:System.Threading.ManualResetEvent" /> con un valore Booleano che indica se lo stato iniziale deve essere impostato su segnalato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se lo stato iniziale di un <xref:System.Threading.ManualResetEvent> viene segnalato (ovvero, se viene creato passando `true` per `initialState`), thread in attesa del <xref:System.Threading.ManualResetEvent> non blocchino. Se lo stato iniziale è impostato su non segnalato, bloccano il thread fino al <xref:System.Threading.EventWaitHandle.Set%2A> metodo viene chiamato.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.WaitHandle" />
      </Docs>
    </Member>
  </Members>
</Type>