<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f908dbd04f1ed17bee04e225536a93e5e092d9d1" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061697" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Crea e controlla un thread, ne imposta le priorità e ne ottiene lo stato.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando viene avviato un processo, common language runtime crea automaticamente un thread singolo in primo piano per l'esecuzione di codice dell'applicazione. Insieme a questo thread principale in primo piano, un processo può creare uno o più thread per l'esecuzione di una parte del codice programma associato al processo. Questi thread possono eseguire in primo piano o in background. Inoltre, è possibile utilizzare la <xref:System.Threading.ThreadPool> classe per eseguire codice su thread di lavoro che sono gestiti da common language runtime.  
  
 Contenuto della sezione  
  
 [Avviare un thread](#Starting)   
 [Il recupero di oggetti Thread](#Retrieving)   
 [Thread in primo piano e sfondo](#Foreground)   
 [Impostazioni cultura e thread](#Culture)   
 [Recupero di informazioni e controllo di thread](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>Avviare un thread  
 Avviare un thread fornendo un delegato che rappresenta il metodo che di thread consiste nell'eseguire nel costruttore di classe. Chiamare quindi il <xref:System.Threading.Thread.Start%2A> metodo per avviare l'esecuzione.  
  
 Il <xref:System.Threading.Thread> i costruttori possono accettare uno dei tipi di due delegati, a seconda se è possibile passare un argomento al metodo da eseguire:  
  
-   Se il metodo non dispone di argomenti, si passa un <xref:System.Threading.ThreadStart> delegare al costruttore. Dispone della firma:  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     Nell'esempio seguente crea e avvia un thread che esegue il `ExecuteInForeground` metodo. Il metodo visualizza le informazioni su alcune proprietà del thread, quindi esegue un ciclo in cui viene sospesa per mezzo secondo e visualizza il numero di secondi trascorsi. Quando il thread è stato eseguito per almeno cinque secondi, il thread e termina il ciclo termina l'esecuzione.  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   Se il metodo dispone di un argomento, si passa un <xref:System.Threading.ParameterizedThreadStart> delegare al costruttore. Dispone della firma:  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     Il metodo eseguito dal delegato può quindi eseguire il cast (in c#) o convertire (in Visual Basic) il parametro nel tipo appropriato.  
  
     L'esempio seguente è identico a quello precedente, ad eccezione del fatto che venga chiamato il <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> costruttore. Questa versione di `ExecuteInForeground` metodo presenta un singolo parametro che rappresenta il numero approssimativo di millisecondi per eseguire il ciclo.  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 Non è necessario mantenere un riferimento a un <xref:System.Threading.Thread> dopo aver avviato il thread dell'oggetto. Il thread continua l'esecuzione fino a quando non è stata completata la procedura del thread.  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>Il recupero di oggetti Thread  
 È possibile utilizzare il metodo statico (`Shared` in Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> proprietà per recuperare un riferimento dal codice che il thread è in esecuzione il thread attualmente in esecuzione. L'esempio seguente usa il <xref:System.Threading.Thread.CurrentThread%2A> proprietà per visualizzare informazioni sul pool di thread, un altro thread in primo piano, un thread in background e il thread principale dell'applicazione.  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>Thread in primo piano e sfondo  
 Le istanze del <xref:System.Threading.Thread> classe rappresentano i thread in foreground o thread in background. Thread in background sono identiche a thread in foreground con un'unica eccezione: un thread in background non mantenere un processo in esecuzione se tutti i thread in primo piano è sono interrotto. Dopo essere stati arrestati tutti i thread in primo piano, il runtime arresta tutti i thread in background e viene chiuso.  
  
 Per impostazione predefinita, i thread seguenti eseguire in primo piano:  
  
-   Il thread principale dell'applicazione.  
  
-   Tutti i thread creati chiamando un <xref:System.Threading.Thread> costruttore della classe.  
  
 Per impostazione predefinita, i thread seguenti eseguire in background:  
  
-   Thread del pool di thread, che sono un pool di thread di lavoro gestiti dal runtime.  È possibile configurare il lavoro di pianificazione e di pool di thread nel thread del pool utilizzando il <xref:System.Threading.ThreadPool> classe.  
  
    > [!NOTE]
    >  Operazioni asincrone basate su attività eseguire automaticamente sul thread del pool. Usano operazioni asincrone basate su attività di <xref:System.Threading.Tasks.Task> e <xref:System.Threading.Tasks.Task%601> classi per implementare il [modello asincrono basato su attività](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).  
  
-   Tutti i thread che accedono all'ambiente di esecuzione gestita dal codice non gestito.  
  
 È possibile modificare un thread di eseguire in background mediante l'impostazione di <xref:System.Threading.Thread.IsBackground%2A> proprietà in qualsiasi momento.  Thread in background sono utili per qualsiasi operazione che deve continuare fino a quando un'applicazione è in esecuzione ma non deve impedire l'applicazione venga terminata, ad esempio il monitoraggio delle modifiche al file system o le connessioni socket in ingresso.  
  
 Nell'esempio seguente viene illustrata la differenza tra i thread in primo piano e sfondo. È ad esempio nel primo esempio di [avviare un thread](#Starting) sezione, ad eccezione del fatto che imposta il thread per l'esecuzione in background prima di avviarla. Come illustrato nell'output, il ciclo viene interrotto prima che viene eseguito per cinque secondi.  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>Impostazioni cultura e thread  
 Ogni thread dispone di una lingua, rappresentata dal <xref:System.Threading.Thread.CurrentCulture%2A> rappresentati da proprietà e impostazioni cultura dell'interfaccia utente, il <xref:System.Threading.Thread.CurrentUICulture%2A> proprietà.  Le impostazioni cultura correnti supporta operazioni dipendenti dalle impostazioni cultura quali l'analisi e formattazione, confronto tra stringhe e l'ordinamento e controlla anche il sistema di scrittura e il calendario utilizzato da un thread. Le impostazioni cultura dell'interfaccia utente correnti disponibili per il recupero delle impostazioni cultura delle risorse nei file di risorse.  
  
 Quando viene creata un'istanza di un nuovo thread, le impostazioni cultura e le impostazioni cultura dell'interfaccia utente sono definiti dalle impostazioni cultura correnti del sistema e delle impostazioni cultura dell'interfaccia utente e non per le impostazioni cultura e le impostazioni cultura dell'interfaccia utente del thread da cui viene creato il nuovo thread. Ciò significa, ad esempio, che se la lingua di sistema corrente è l'inglese (Stati Uniti) e le impostazioni cultura correnti del thread principale dell'applicazione sono francese (Francia), le impostazioni cultura di un nuovo thread creato mediante la chiamata di <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> costruttore dal thread principale è l'inglese (Stati Uniti) e non francese (Francia). Per ulteriori informazioni, vedere la sezione "Impostazioni cultura e thread" del <xref:System.Globalization.CultureInfo> argomento relativo alla classe.  
  
> [!IMPORTANT]
>  Ciò non è possibile di thread che eseguono operazioni asincrone per le applicazioni che hanno come destinazione il [!INCLUDE[net_v46](~/includes/net-v46-md.md)] e versioni successive, In questo caso, le impostazioni cultura e le impostazioni cultura dell'interfaccia utente è parte di asincrono contesto operazioni; il thread in cui un'operazione asincrona viene eseguito dal predefinito eredita le impostazioni cultura e le impostazioni cultura dell'interfaccia utente del thread da cui è stata avviata l'operazione asincrona. Per altre informazioni, vedere la sezione dedicata alle impostazioni cultura e alle operazioni asincrone basate su attività nell'argomento relativo alla classe <xref:System.Globalization.CultureInfo>.  
  
 È possibile effettuare una delle operazioni seguenti per garantire che tutti i thread in esecuzione in un'applicazione condividono le stesse impostazioni cultura delle impostazioni cultura dell'interfaccia utente:  
  
-   È possibile passare un <xref:System.Globalization.CultureInfo> oggetto che rappresenta quelle impostazioni cultura per il <xref:System.Threading.ParameterizedThreadStart> delegato o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> metodo.  
  
-   Per le applicazioni in esecuzione sul [!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versioni successive, è possibile definire le impostazioni cultura e le impostazioni cultura dell'interfaccia utente che deve essere assegnata a tutti i thread creati in un dominio applicazione impostando il valore del <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> proprietà. Si tratta di un'impostazione a livello di dominio applicazione.  
  
 Per ulteriori informazioni ed esempi, vedere la sezione "Impostazioni cultura e al thread" del <xref:System.Globalization.CultureInfo> argomento relativo alla classe.  
  
<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>Recupero di informazioni e controllo di thread  
 È possibile recuperare un numero di valori di proprietà che forniscono informazioni su un thread. In alcuni casi, è anche possibile impostare questi valori di proprietà per controllare l'operazione del thread. Le proprietà di questi thread includono:  
  
-   Un nome <xref:System.Threading.Thread.Name%2A> è un'operazione di scrittura-una volta proprietà che è possibile utilizzare per identificare un thread.  Il valore predefinito è `null`.  
  
-   Un codice hash, che è possibile recuperare tramite una chiamata di <xref:System.Threading.Thread.GetHashCode%2A> metodo. Il codice hash può essere utilizzato per identificare in modo univoco un thread. per la durata del thread, il codice hash non entrerà in conflitto con il valore di altri thread, indipendentemente dal dominio dell'applicazione da cui ottenere il valore.  
  
-   Un ID thread. Il valore di sola lettura <xref:System.Threading.Thread.ManagedThreadId%2A> proprietà viene assegnata dal runtime e identifica in modo univoco un thread all'interno di processo.  
  
    > [!NOTE]
    >  L'oggetto [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) di un sistema operativo non ha una relazione fissa con un thread gestito, perché un host non gestito può controllare la relazione tra thread gestiti e non gestiti. In particolare, un host sofisticato può usare il [API di Hosting CLR](https://msdn.microsoft.com/library/ms404385.aspx) per pianificare molti thread gestiti sullo stesso thread del sistema operativo o spostare un thread gestito tra thread diversi del sistema operativo.  
  
-   Lo stato del thread corrente. Per la durata della sua esistenza, un thread si trova sempre in uno o più degli stati definiti per il <xref:System.Threading.ThreadState> proprietà.  
  
-   Un livello di priorità di pianificazione, definito dal <xref:System.Threading.ThreadPriority> proprietà. Sebbene sia possibile impostare questo valore di priorità di un thread di richiesta, non è necessariamente essere rispettato dal sistema operativo.  
  
-   La proprietà di sola lettura <xref:System.Threading.Thread.IsThreadPoolThread%2A> proprietà, che indica se un thread è un pool di thread.  
  
-   La proprietà <xref:System.Threading.Thread.IsBackground%2A>. Per ulteriori informazioni, vedere il [thread in primo piano e sfondo](#Foreground) sezione.  
  
## Examples  
 L'esempio seguente illustra le funzionalità di threading semplice.  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 Questo codice restituisce un output simile al seguente:  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Delegato che rappresenta i metodi da richiamare quando inizia l'esecuzione di questo thread.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />, specificando un delegato che consente di passare un oggetto al thread quando quest'ultimo viene avviato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread non viene avviata l'esecuzione quando viene creato. Per pianificare l'esecuzione del thread, chiamare il <xref:System.Threading.Thread.Start%2A> metodo. Per passare un oggetto dati per il thread, utilizzare il <xref:System.Threading.Thread.Start%28System.Object%29> overload del metodo.  
  
> [!NOTE]
>  Gli utenti di Visual Basic è possono omettere il <xref:System.Threading.ThreadStart> costruttore durante la creazione di un thread. Utilizzare il `AddressOf` operatore quando si passa al metodo, ad esempio `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic chiama automaticamente il <xref:System.Threading.ThreadStart> costruttore.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrata la sintassi per creare e utilizzare un <xref:System.Threading.ParameterizedThreadStart> delegato con un metodo statico e un metodo di istanza.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">Delegato <see cref="T:System.Threading.ThreadStart" /> che rappresenta i metodi da richiamare quando inizia l'esecuzione di questo thread.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread non viene avviata l'esecuzione quando viene creato. Per pianificare l'esecuzione del thread, chiamare il <xref:System.Threading.Thread.Start%2A> metodo.  
  
> [!NOTE]
>  Gli utenti di Visual Basic è possono omettere il <xref:System.Threading.ThreadStart> costruttore durante la creazione di un thread. Utilizzare il `AddressOf` operatore quando si passa ad esempio il metodo `Dim t As New Thread(AddressOf ThreadProc)`. Visual Basic chiama automaticamente il <xref:System.Threading.ThreadStart> costruttore.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come creare un thread che esegue un metodo statico.  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 Esempio di codice seguente viene illustrato come creare un thread che esegue un metodo di istanza.  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="start" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Delegato <see cref="T:System.Threading.ParameterizedThreadStart" /> che rappresenta i metodi da richiamare quando inizia l'esecuzione di questo thread.</param>
        <param name="maxStackSize">Dimensione massima dello stack, in byte, usata dal thread oppure 0 per usare la dimensione massima predefinita specificata nell'intestazione del file eseguibile.  
  
 Importante   Per il codice parzialmente attendibile, <c>maxStackSize</c> viene ignorato se è maggiore delle dimensioni predefinite dello stack. Non viene generata alcuna eccezione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />, specificando un delegato che consente di passare un oggetto al thread quando quest'ultimo viene avviato e specificando la dimensione massima dello stack per il thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Evitare di utilizzare questo overload del costruttore. La dimensione dello stack predefinito utilizzata dal <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> overload del costruttore è la dimensione dello stack consigliata per i thread. Se un thread presenta problemi di memoria, la causa più probabile è un errore di programmazione, ad esempio una ricorsione infinita.  
  
> [!IMPORTANT]
>  A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], solo completamente attendibili codice può impostare `maxStackSize` su un valore che è maggiore della dimensione dello stack predefinita (1 megabyte). Se viene specificato un valore maggiore per `maxStackSize` durante l'esecuzione di codice con attendibilità parziale, `maxStackSize` viene ignorato e viene utilizzata la dimensione predefinita. Non viene generata alcuna eccezione. Codice a qualsiasi livello di attendibilità può impostare `maxStackSize` su un valore che è inferiore alle dimensioni dello stack predefinito.  
  
> [!NOTE]
>  Se si sviluppa una libreria completamente attendibile che verrà utilizzata da codice parzialmente attendibile, ed è necessario avviare un thread che richiede uno stack di grandi dimensioni, è necessario dichiarare l'attendibilità totale prima di creare il thread o la dimensione predefinita verrà utilizzata. Non eseguire questa operazione a meno che non è controllare completamente il codice che viene eseguita sul thread.  
  
 Se `maxStackSize` è minore rispetto alla dimensione minima dello stack, viene utilizzata la dimensione minima dello stack. Se `maxStackSize` non è un multiplo delle dimensioni della pagina, viene arrotondato al multiplo successivo più grande delle dimensioni della pagina. Ad esempio, se si utilizza .NET Framework versione 2.0 in Windows Vista, 256KB (262.144 byte) è la dimensione minima dello stack e le dimensioni della pagina sono 64KB (65.536 byte).  
  
> [!NOTE]
>  Nelle versioni di Microsoft Windows precedenti a Windows XP e Windows Server 2003, `maxStackSize` viene ignorato e viene utilizzata la dimensione dello stack specificata nell'intestazione del file eseguibile.  
  
 Se si specifica una dimensione dello stack molto piccola, potrebbe essere necessario disabilitare il sondaggio overflow dello stack. Quando lo stack è fortemente vincolato, l'individuazione tramite probe stesso causare un overflow dello stack. Per disabilitare il sondaggio overflow dello stack, aggiungere quanto segue al file di configurazione dell'applicazione.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Delegato <see cref="T:System.Threading.ThreadStart" /> che rappresenta i metodi da richiamare quando inizia l'esecuzione di questo thread.</param>
        <param name="maxStackSize">Dimensione massima dello stack, in byte, usata dal thread oppure 0 per usare la dimensione massima predefinita specificata nell'intestazione del file eseguibile.  
  
 Importante   Per il codice parzialmente attendibile, <c>maxStackSize</c> viene ignorato se è maggiore delle dimensioni predefinite dello stack. Non viene generata alcuna eccezione.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />, specificando la dimensione massima dello stack per il thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Evitare di utilizzare questo overload del costruttore. La dimensione dello stack predefinito utilizzata dal <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> overload del costruttore è la dimensione dello stack consigliata per i thread. Se un thread presenta problemi di memoria, la causa più probabile è un errore di programmazione, ad esempio una ricorsione infinita.  
  
> [!IMPORTANT]
>  A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], solo completamente attendibili codice può impostare `maxStackSize` su un valore che è maggiore della dimensione dello stack predefinita (1 megabyte). Se viene specificato un valore maggiore per `maxStackSize` durante l'esecuzione di codice con attendibilità parziale, `maxStackSize` viene ignorato e viene utilizzata la dimensione predefinita. Non viene generata alcuna eccezione. Codice a qualsiasi livello di attendibilità può impostare `maxStackSize` su un valore che è inferiore alle dimensioni dello stack predefinito.  
  
> [!NOTE]
>  Se si sviluppa una libreria completamente attendibile che verrà utilizzata da codice parzialmente attendibile, ed è necessario avviare un thread che richiede uno stack di grandi dimensioni, è necessario dichiarare l'attendibilità totale prima di creare il thread o la dimensione predefinita verrà utilizzata. Non eseguire questa operazione a meno che non è controllare completamente il codice che viene eseguita sul thread.  
  
 Se `maxStackSize` è minore rispetto alla dimensione minima dello stack, viene utilizzata la dimensione minima dello stack. Se `maxStackSize` non è un multiplo delle dimensioni della pagina, viene arrotondato al multiplo successivo più grande delle dimensioni della pagina. Ad esempio, se si utilizza .NET Framework versione 2.0 in Windows Vista, 256KB (262.144 byte) è la dimensione minima dello stack e le dimensioni della pagina sono 64KB (65.536 byte).  
  
> [!NOTE]
>  Nelle versioni di Microsoft Windows precedenti a Windows XP e Windows Server 2003, `maxStackSize` viene ignorato e viene utilizzata la dimensione dello stack specificata nell'intestazione del file eseguibile.  
  
 Se si specifica una dimensione dello stack molto piccola, potrebbe essere necessario disabilitare il sondaggio overflow dello stack. Quando lo stack è fortemente vincolato, l'individuazione tramite probe stesso causare un overflow dello stack. Per disabilitare il sondaggio overflow dello stack, aggiungere quanto segue al file di configurazione dell'applicazione.  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="start" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxStackSize" /> è minore di zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Genera un'eccezione <see cref="T:System.Threading.ThreadAbortException" /> nel thread in cui viene richiamato, per iniziare il processo di terminazione del thread. La chiamata a questo metodo in genere termina il thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera un'eccezione <see cref="T:System.Threading.ThreadAbortException" /> nel thread in cui viene richiamato, per iniziare il processo di terminazione del thread. La chiamata a questo metodo in genere termina il thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene richiamato su un thread, il sistema genererà un <xref:System.Threading.ThreadAbortException> nel thread per interromperlo. `ThreadAbortException` è un'eccezione speciale che può essere intercettata dal codice dell'applicazione, ma viene generata nuovamente alla fine del `catch` blocco a meno che non <xref:System.Threading.Thread.ResetAbort%2A> viene chiamato. `ResetAbort` Annulla la richiesta di interruzione e impedisce la `ThreadAbortException` di terminazione del thread. Non eseguite `finally` i blocchi vengono eseguiti prima dell'interruzione del thread.  
  
> [!NOTE]
>  Quando un thread chiama `Abort` su se stesso, l'effetto è simile per generare un'eccezione; il <xref:System.Threading.ThreadAbortException> si verifica immediatamente e il risultato è prevedibile. Tuttavia, se un thread chiama `Abort` in un altro thread, viene interrotto qualsiasi codice è in esecuzione. È anche possibile che un costruttore statico potrebbe essere interrotto. In rari casi, ciò potrebbe impedire le istanze di tale classe viene creato nel dominio dell'applicazione. Nelle versioni di .NET Framework 1.0 e 1.1, è probabile che si interrompa il thread mentre un `finally` blocco viene eseguito, nel qual caso il `finally` blocco viene interrotta.  
  
 Il thread non è garantito da interrompere immediatamente o affatto. Questa situazione può verificarsi se un thread esegue una quantità di calcolo in illimitata di `finally` blocchi che vengono chiamati come parte della procedura di interruzione, l'interruzione è posticipata in tal modo all'infinito. Per attendere finché non viene interrotto un thread, è possibile chiamare il <xref:System.Threading.Thread.Join%2A> metodo sul thread dopo la chiamata di <xref:System.Threading.Thread.Abort%2A> (metodo), ma non c'è garanzia che termina l'attesa.  
  
> [!NOTE]
>  Il thread che chiama <xref:System.Threading.Thread.Abort%2A> potrebbe bloccarsi se il thread che è stata interrotta in un'area protetta di codice, ad esempio un `catch` blocco `finally` blocco o area a esecuzione vincolata. Se il thread che chiama <xref:System.Threading.Thread.Abort%2A> mantiene un blocco che richiede il thread interrotto, può verificarsi un deadlock.  
  
 Se `Abort` viene chiamato su un thread che non è stato avviato, il thread sarà interrotto quando <xref:System.Threading.Thread.Start%2A> viene chiamato. Se `Abort` viene chiamato su un thread è bloccato o è inattivo, il thread è interrotto e quindi interrotto.  
  
 Se `Abort` viene chiamato su un thread che era stato sospeso, una <xref:System.Threading.ThreadStateException> viene generata nel thread che ha chiamato <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState.AbortRequested> viene aggiunto per il <xref:System.Threading.Thread.ThreadState%2A> proprietà del thread interrotto. Oggetto <xref:System.Threading.ThreadAbortException> non viene generata nel thread sospeso finché <xref:System.Threading.Thread.Resume%2A> viene chiamato.  
  
 Se `Abort` viene chiamato su un thread gestito durante l'esecuzione di codice non gestito, un `ThreadAbortException` non viene generata fino a quando il thread viene restituito al codice gestito.  
  
 Se due chiamate a `Abort` provengono allo stesso tempo, è possibile che una chiamata impostare le informazioni sullo stato e l'altra per eseguire il `Abort`. Tuttavia, un'applicazione non è in grado di rilevare questa situazione.  
  
 Dopo aver `Abort` viene richiamato su un thread, lo stato del thread include <xref:System.Threading.ThreadState.AbortRequested>. Dopo che il thread è terminato in seguito a una chiamata a `Abort`, lo stato del thread viene modificato in <xref:System.Threading.ThreadState.Stopped>. Con autorizzazioni sufficienti, un thread che è la destinazione di un `Abort` possibile annullare l'interruzione utilizzando il `ResetAbort` metodo. Per un esempio in cui viene illustrata la chiamata di `ResetAbort` metodo, vedere la `ThreadAbortException` classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: questo membro non è supportato.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Il thread che si sta interrompendo è attualmente sospeso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operazioni avanzate sui thread. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">Oggetto che contiene informazioni specifiche dell'applicazione, ad esempio lo stato, che possono essere usate dal thread interrotto.</param>
        <summary>Genera un'eccezione <see cref="T:System.Threading.ThreadAbortException" /> nel thread in cui viene richiamato per iniziare il processo di terminazione del thread fornendo anche informazioni sull'eccezione relative alla terminazione del thread. La chiamata a questo metodo in genere termina il thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando questo metodo viene richiamato su un thread, il sistema genererà un <xref:System.Threading.ThreadAbortException> nel thread per interromperlo. `ThreadAbortException` è un'eccezione speciale che può essere intercettata dal codice dell'applicazione, ma viene generata nuovamente alla fine del `catch` blocco a meno che non <xref:System.Threading.Thread.ResetAbort%2A> viene chiamato. `ResetAbort` Annulla la richiesta di interruzione e impedisce la `ThreadAbortException` di terminazione del thread. Non eseguite `finally` i blocchi vengono eseguiti prima dell'interruzione del thread.  
  
> [!NOTE]
>  Quando un thread chiama `Abort` su se stesso, l'effetto è simile per generare un'eccezione; il <xref:System.Threading.ThreadAbortException> si verifica immediatamente e il risultato è prevedibile. Tuttavia, se un thread chiama `Abort` in un altro thread, viene interrotto qualsiasi codice è in esecuzione. È probabile che un costruttore statico venga interrotto. In rari casi, ciò potrebbe impedire le istanze di tale classe viene creato nel dominio dell'applicazione. Nelle versioni di .NET Framework 1.0 e 1.1, è probabile che si interrompa il thread mentre un `finally` blocco viene eseguito, nel qual caso il `finally` blocco viene interrotta.  
  
 Il thread non è garantito da interrompere immediatamente o affatto. Questa situazione può verificarsi se un thread esegue una quantità di calcolo in illimitata di `finally` blocchi che vengono chiamati come parte della procedura di interruzione, l'interruzione è posticipata in tal modo all'infinito. Per attendere finché non viene interrotto un thread, è possibile chiamare il <xref:System.Threading.Thread.Join%2A> metodo sul thread dopo la chiamata di <xref:System.Threading.Thread.Abort%2A> (metodo), ma non c'è garanzia che termina l'attesa.  
  
> [!NOTE]
>  Il thread che chiama <xref:System.Threading.Thread.Abort%2A> potrebbe bloccarsi se il thread che è stata interrotta in un'area protetta di codice, ad esempio un `catch` blocco `finally` blocco o area a esecuzione vincolata. Se il thread che chiama <xref:System.Threading.Thread.Abort%2A> mantiene un blocco che richiede il thread interrotto, può verificarsi un deadlock.  
  
 Se `Abort` viene chiamato su un thread che non è stato avviato, il thread sarà interrotto quando <xref:System.Threading.Thread.Start%2A> viene chiamato. Se `Abort` viene chiamato su un thread è bloccato o è inattivo, il thread è interrotto e quindi interrotto.  
  
 Se `Abort` viene chiamato su un thread che era stato sospeso, una <xref:System.Threading.ThreadStateException> viene generata nel thread che ha chiamato <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState.AbortRequested> viene aggiunto per il <xref:System.Threading.Thread.ThreadState%2A> proprietà del thread interrotto. Oggetto <xref:System.Threading.ThreadAbortException> non viene generata nel thread sospeso finché <xref:System.Threading.Thread.Resume%2A> viene chiamato.  
  
 Se `Abort` viene chiamato su un thread gestito durante l'esecuzione di codice non gestito, un `ThreadAbortException` non viene generata fino a quando il thread viene restituito al codice gestito.  
  
 Se due chiamate a `Abort` provengono allo stesso tempo, è possibile che una chiamata impostare le informazioni sullo stato e l'altra per eseguire il `Abort`. Tuttavia, un'applicazione non è in grado di rilevare questa situazione.  
  
 Dopo aver `Abort` viene richiamato su un thread, lo stato del thread include <xref:System.Threading.ThreadState.AbortRequested>. Dopo che il thread è terminato in seguito a una chiamata a `Abort`, lo stato del thread viene modificato in <xref:System.Threading.ThreadState.Stopped>. Con autorizzazioni sufficienti, un thread che è la destinazione di un `Abort` possibile annullare l'interruzione utilizzando il `ResetAbort` metodo. Per un esempio in cui viene illustrata la chiamata di `ResetAbort` metodo, vedere la `ThreadAbortException` classe.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come passare informazioni a un thread che è stata interrotta.  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: questo membro non è supportato.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Il thread che si sta interrompendo è attualmente sospeso.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operazioni avanzate sui thread. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Alloca uno slot di dati senza nome su tutti i thread. Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Slot di dati denominato allocato su tutti i thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework fornisce due meccanismi per l'utilizzo di archiviazione locale di thread (TLS): i campi statici relativi ai thread (, ovvero i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati. I campi statici relativi ai thread forniscono prestazioni migliori rispetto agli slot di dati e abilitare il controllo in fase di compilazione. Per ulteriori informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Lo slot è allocato su tutti i thread.  
  
 I thread usano un meccanismo di memoria di archiviazione locale per archiviare dati specifici del thread. Common language runtime alloca una matrice di archiviazione di dati più slot a ogni processo al momento della creazione. Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per riutilizzarlo dopo la scadenza del thread. Gli slot di dati sono univoci per ogni thread. Nessun altro thread (nemmeno un thread figlio) può ottenere i dati.  
  
   
  
## Examples  
 In questa sezione contiene due esempi di codice. Nel primo esempio viene illustrato come utilizzare un campo che è contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche di un thread. Nel secondo esempio viene illustrato come utilizzare uno slot di dati per eseguire la stessa operazione.  
  
 **Primo esempio**  
  
 Nell'esempio seguente viene illustrato come utilizzare un campo che è contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche di un thread. Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Secondo esempio**  
  
 Esempio di codice seguente viene illustrato come utilizzare uno slot di dati per archiviare le informazioni specifiche di un thread.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dello slot di dati da allocare.</param>
        <summary>Alloca uno slot di dati denominato su tutti i thread. Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Slot di dati denominato allocato su tutti i thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework fornisce due meccanismi per l'utilizzo di archiviazione locale di thread (TLS): i campi statici relativi ai thread (, ovvero i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati. I campi statici relativi ai thread forniscono prestazioni migliori rispetto agli slot di dati e abilitare il controllo in fase di compilazione. Per ulteriori informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 I thread usano un meccanismo di memoria di archiviazione locale per archiviare dati specifici del thread. Common language runtime alloca una matrice di archiviazione di dati più slot a ogni processo al momento della creazione. Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per riutilizzarlo dopo la scadenza del thread. Gli slot di dati sono univoci per ogni thread. Nessun altro thread (nemmeno un thread figlio) può ottenere i dati.  
  
 Non è necessario utilizzare il <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metodo per allocare uno slot di dati denominato, perché il <xref:System.Threading.Thread.GetNamedDataSlot%2A> metodo alloca lo slot se non è già stato allocato.  
  
> [!NOTE]
>  Se il <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> viene usato il metodo, deve essere chiamato nel thread principale all'avvio del programma, perché viene generata un'eccezione se uno slot con il nome specificato è già stato allocato. Non è possibile verificare se uno slot è già stato allocato.  
  
 Gli slot allocati con questo metodo devono essere liberati con <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.  
  
   
  
## Examples  
 In questa sezione contiene due esempi di codice. Nel primo esempio viene illustrato come utilizzare un campo che è contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche di un thread. Nel secondo esempio viene illustrato come utilizzare uno slot di dati per eseguire la stessa operazione.  
  
 **Primo esempio**  
  
 Nell'esempio seguente viene illustrato come utilizzare un campo che è contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche di un thread. Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Secondo esempio**  
  
 Nell'esempio seguente viene illustrato come usare uno slot di dati denominato per archiviare le informazioni specifiche di un thread.  
  
> [!NOTE]
>  Il codice di esempio non utilizza il <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> (metodo), in quanto il <xref:System.Threading.Thread.GetNamedDataSlot%2A> metodo alloca lo slot se non è già stato allocato. Se il <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> viene usato il metodo, deve essere chiamato nel thread principale all'avvio del programma.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Esiste già uno slot di dati denominato con il nome specificato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta lo stato dell'apartment del thread.</summary>
        <value>Uno dei valori di <see cref="T:System.Threading.ApartmentState" />. Il valore iniziale è <see langword="Unknown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Il <xref:System.Threading.Thread.ApartmentState%2A> proprietà è obsoleta.**  Sono disponibili le alternative non obsoleta di <xref:System.Threading.Thread.GetApartmentState%2A> metodo per recuperare lo stato dell'apartment e <xref:System.Threading.Thread.SetApartmentState%2A> per impostare lo stato dell'apartment.  
  
 In .NET Framework versioni 1.0 e 1.1, il `ApartmentState` proprietà contrassegna un thread per indicare che sarà eseguito in un apartment a thread singolo o multithread. Questa proprietà può essere impostata quando il thread si trova il `Unstarted` o `Running` stato; tuttavia, può essere solo una volta per un thread. Se la proprietà non è stata impostata, restituisce `Unknown`.  
  
 Tentativo di utilizzare il <xref:System.Threading.Thread.ApartmentState%2A> proprietà per impostare lo stato dell'apartment di un thread il cui stato di apartment è già stata impostata viene ignorata. Tuttavia, il <xref:System.Threading.Thread.SetApartmentState%2A> metodo genera un <xref:System.InvalidOperationException> in questo caso.  
  
> [!IMPORTANT]
>  In .NET Framework versione 2.0, i nuovi thread vengono inizializzati come <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se lo stato di apartment non è stato impostato prima dell'avvio. Il thread principale dell'applicazione viene inizializzato a <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> per impostazione predefinita. È non possibile impostare non è più il thread principale dell'applicazione <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> impostando il <xref:System.Threading.ApartmentState?displayProperty=nameWithType> proprietà sulla prima riga di codice. Utilizzare il <xref:System.STAThreadAttribute> invece.  
  
 In .NET Framework versione 2.0, è possibile specificare il modello di threading COM per un'applicazione C++ utilizzando la [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](http://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) l'opzione del linker.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare lo stato dell'apartment di un thread.  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Viene effettuato un tentativo di impostare questa proprietà su uno stato che non è uno stato dell'apartment valido (uno stato diverso da apartment a thread singolo (<see langword="STA" />) o apartment con multithreading (<see langword="MTA" />)).</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a un host che l'esecuzione sta per entrare in un'area di codice in cui gli effetti di un'interruzione del thread o di un'eccezione non gestita possono rappresentare un rischio per altre attività nel dominio applicazione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Host di common language runtime (CLR), ad esempio Microsoft SQL Server 2005, è possibile stabilire criteri diversi per gli errori nelle aree non critiche del codice. Un'area critica è uno in cui gli effetti di un'interruzione del thread o un'eccezione non gestita potrebbero non essere limitati all'attività corrente. Al contrario, un'interruzione o un errore in un'area critica di codice influisce solo sull'attività in cui si verifica l'errore.  
  
 Si consideri, ad esempio, un'attività che tenta di allocare memoria quando un blocco. Se l'allocazione di memoria non riesce, interrompere l'attività corrente non è sufficiente per garantire la stabilità del <xref:System.AppDomain>, poiché può esserci altre attività nel dominio di cui è in attesa del blocco stesso. Se l'attività corrente viene terminato, il deadlock altre attività.  
  
 Quando si verifica un errore in un'area critica, l'host può decidere di scaricare l'intero <xref:System.AppDomain> anziché correre il rischio di continuare l'esecuzione in uno stato potenzialmente instabile. Per notificare all'host che il codice sta entrando in un'area critica, chiamare <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Chiamare <xref:System.Threading.Thread.EndCriticalRegion%2A> quando esecuzione restituisce un'area critica del codice.  
  
 Questo metodo nel codice in esecuzione in SQL Server 2005 richiede il codice da eseguire a livello di protezione più elevato di host.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A> per suddividere un blocco di codice in aree non critiche.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a un host che il codice gestito sta per eseguire istruzioni che dipendono dall'identità del thread fisico corrente del sistema operativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni host di common language runtime, ad esempio Microsoft SQL Server 2005, forniscono una propria gestione dei thread. Un host che fornisce la gestione di thread può spostare un'attività in esecuzione da un thread fisico del sistema operativo a altra in qualsiasi momento. La maggior parte delle attività non sono interessate da questo passaggio. Tuttavia, alcune attività presentano affinità di thread, vale a dire dipendono dall'identità di un thread fisico del sistema operativo. Queste attività è necessario notificare all'host quando eseguono codice che non deve essere spostato.  
  
 Ad esempio, se l'applicazione chiama un'API di sistema di acquisire un sistema operativo di blocco che presenta affinità di thread, ad esempio Win32 CRITICAL_SECTION, è necessario chiamare <xref:System.Threading.Thread.BeginThreadAffinity%2A> prima di acquisire il blocco, e <xref:System.Threading.Thread.EndThreadAffinity%2A> dopo il rilascio del blocco.  
  
 Questo metodo nel codice in esecuzione in SQL Server 2005 richiede il codice da eseguire a livello di protezione più elevato di host.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Threading.Thread.BeginThreadAffinity%2A> e <xref:System.Threading.Thread.EndThreadAffinity%2A> per notificare a un host che un blocco di codice dipende dall'identità di un thread fisico del sistema operativo.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il contesto corrente in cui è in esecuzione il thread.</summary>
        <value>Oggetto <see cref="T:System.Runtime.Remoting.Contexts.Context" /> che rappresenta il contesto del thread corrente.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le impostazioni cultura per il thread corrente.</summary>
        <value>Oggetto che rappresenta le impostazioni cultura per il thread corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Globalization.CultureInfo> oggetto restituito da questa proprietà, insieme ai relativi oggetti associati, determinare il formato predefinito per le date, ore, numeri, i valori di valuta, l'ordinamento del testo, convenzioni di maiuscole e minuscole e confronti tra stringhe. Vedere la <xref:System.Globalization.CultureInfo> classe per conoscere i nomi delle impostazioni cultura e gli identificatori, le differenze tra le impostazioni cultura invarianti, neutre e specifiche, e le informazioni sulla lingua modo influisce sui domini applicazione e thread. Vedere il <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> proprietà per conoscere la modalità di determinazione delle impostazioni cultura predefinite di un thread e come gli utenti impostare informazioni sulle impostazioni cultura per i computer.  
  
 A partire dal [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], è possibile impostare il <xref:System.Threading.Thread.CurrentCulture%2A> proprietà a una lingua. In questo modo il comportamento del <xref:System.Globalization.CultureInfo> classe è stata modificata: quando rappresenta impostazioni cultura neutre, i valori delle proprietà (in particolare, il <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, e <xref:System.Globalization.CultureInfo.TextInfo%2A> proprietà) ora riflettere le impostazioni cultura specifiche che sono associata a impostazioni cultura di sistema. Nelle versioni precedenti di .NET Framework, il <xref:System.Threading.Thread.CurrentCulture%2A> proprietà ha generato un <xref:System.NotSupportedException> eccezione quando è stata assegnata una lingua.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrata l'istruzione di threading che consente all'interfaccia utente di un Windows Form per visualizzare le impostazioni cultura che è impostato nel Pannello di controllo. È necessario codice aggiuntivo.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La proprietà è impostata su <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per impostare la proprietà. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta l'entità corrente del thread (per la sicurezza basata sui ruoli).</summary>
        <value>Valore <see cref="T:System.Security.Principal.IPrincipal" /> che rappresenta il contesto di sicurezza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come impostare e recuperare l'entità di un thread.  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha l'autorizzazione necessaria per impostare l'entità.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Per modificare l'oggetto principal. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il thread attualmente in esecuzione.</summary>
        <value>Oggetto <see cref="T:System.Threading.Thread" /> che rappresenta il thread attualmente in esecuzione.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea un'attività che a sua volta crea 20 attività figlio. L'applicazione, come anche ogni attività, chiama il `ShowThreadInformation` metodo che utilizza il <xref:System.Threading.Thread.CurrentThread%2A> proprietà per visualizzare le informazioni sul thread in cui è in esecuzione.  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 Ogni attività figlio genera numeri casuali di 1 milione compreso tra 1 e 1 milione e restituisce la Media. Le chiamate di attività padre la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo per garantire che le attività figlio vengano completate prima di visualizzare la media restituita da ciascuna attività e calcolare la media dei mezzi.  
  
 Si noti che mentre l'applicazione viene eseguita in un thread in primo piano, ogni attività venga eseguita in un pool di thread.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta le impostazioni cultura correnti usate da Gestione risorse per cercare le risorse specifiche delle impostazioni cultura in fase di esecuzione.</summary>
        <value>Oggetto che rappresenta le impostazioni cultura correnti.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le impostazioni cultura dell'interfaccia utente specificano le risorse di un'applicazione deve supportare l'input dell'utente e output e per impostazione predefinita è quella della lingua del sistema operativo. Vedere la <xref:System.Globalization.CultureInfo> classe per conoscere i nomi delle impostazioni cultura e gli identificatori, le differenze tra le impostazioni cultura invarianti, neutre e specifiche, e le informazioni sulla lingua modo influisce sui domini applicazione e thread. Vedere il <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> proprietà apprendere la modalità di determinazione delle impostazioni cultura dell'interfaccia utente predefinita di un thread.  
  
 Il <xref:System.Globalization.CultureInfo> restituita da questa proprietà può essere una lingua. Impostazioni cultura neutre non devono essere utilizzate con i metodi di formattazione, ad esempio <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, e <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>. Utilizzare il <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> metodo per ottenere una lingua specifica oppure utilizzare il <xref:System.Threading.Thread.CurrentCulture%2A> proprietà.  
  
> [!NOTE]
>  Il <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> genererà <xref:System.ArgumentException> per le impostazioni cultura neutre "zh-Hant" ("zh-CHT") e "zh-Hans" ("zh-CHS").  
  
   
  
## Examples  
 Nell'esempio seguente determina se la lingua delle impostazioni cultura dell'interfaccia utente del thread corrente è il francese. In caso contrario, imposta le impostazioni cultura dell'interfaccia utente del thread corrente per inglese (Stati Uniti).  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 Esempio di codice seguente viene illustrata l'istruzione di threading che consente all'interfaccia utente di un Windows Form per visualizzare le impostazioni cultura che è impostato nel Pannello di controllo. È necessario codice aggiuntivo.  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La proprietà è impostata su <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La proprietà è impostata su un nome delle impostazioni cultura che non può essere usato per individuare un file di risorse. I nomi dei file di risorsa devono includere solo lettere, numeri, trattini o caratteri di sottolineatura.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disattiva la pulizia automatica dei Runtime Callable Wrapper (RCW) per il thread corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per impostazione predefinita, common language runtime (CLR) pulisce runtime callable wrapper automaticamente. I messaggi pump CLR durante la pulitura, che potrebbe causare problemi di reentrancy per alcune applicazioni che soddisfano i criteri non comuni seguenti:  
  
-   L'applicazione effettua un proprio messaggi.  
  
-   L'applicazione deve controllare con precisione durante la distribuzione dei messaggi si verifica.  
  
 Tali applicazioni possono utilizzare il <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> metodo per impedire che in questo recupero automatico dei runtime callable wrapper CLR.  
  
 Quando questo metodo è stato chiamato su un thread, la pulizia automatica non può essere nuovamente abilitata per tale thread. Quando l'applicazione è pronta per pulire runtime callable wrapper, utilizzare il <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> metodo per indicare al runtime di pulire tutti i runtime callable wrapper nel contesto corrente. La distribuzione dei messaggi, si verifica durante l'esecuzione del metodo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a un host che l'esecuzione sta per entrare in un'area di codice in cui gli effetti di un'interruzione del thread o di un'eccezione non gestita sono limitati all'attività corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Host di common language runtime (CLR), ad esempio Microsoft SQL Server 2005, è possibile stabilire criteri diversi per gli errori nelle aree non critiche del codice. Un'area critica è uno in cui gli effetti di un'interruzione del thread o un'eccezione non gestita potrebbero non essere limitati all'attività corrente. Al contrario, un'interruzione o un errore in un'area critica di codice influisce solo sull'attività in cui si verifica l'errore.  
  
 Si consideri, ad esempio, un'attività che tenta di allocare memoria quando un blocco. Se l'allocazione di memoria non riesce, interrompere l'attività corrente non è sufficiente per garantire la stabilità del <xref:System.AppDomain>, poiché può esserci altre attività nel dominio di cui è in attesa del blocco stesso. Se l'attività corrente viene terminato, il deadlock altre attività.  
  
 Quando si verifica un errore in un'area critica, l'host può decidere di scaricare l'intero <xref:System.AppDomain> anziché correre il rischio di continuare l'esecuzione in uno stato potenzialmente instabile. Per notificare all'host che il codice sta entrando in un'area critica, chiamare <xref:System.Threading.Thread.BeginCriticalRegion%2A>. Chiamare <xref:System.Threading.Thread.EndCriticalRegion%2A> quando esecuzione restituisce un'area critica del codice.  
  
 Questo metodo nel codice in esecuzione in SQL Server 2005 richiede il codice da eseguire a livello di protezione più elevato di host.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A> per suddividere un blocco di codice in aree non critiche.  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica a un host che il codice gestito ha terminato l'esecuzione di istruzioni che dipendono dall'identità del thread fisico corrente del sistema operativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alcuni host di common language runtime, ad esempio Microsoft SQL Server 2005, forniscono una propria gestione dei thread. Un host che fornisce la gestione di thread può spostare un'attività in esecuzione da un thread fisico del sistema operativo a altra in qualsiasi momento. La maggior parte delle attività non sono interessate da questo passaggio. Tuttavia, alcune attività presentano affinità di thread, vale a dire dipendono dall'identità di un thread fisico del sistema operativo. Queste attività è necessario notificare all'host quando eseguono codice che non deve essere spostato.  
  
 Ad esempio, se l'applicazione chiama un'API di sistema di acquisire un sistema operativo di blocco che presenta affinità di thread, ad esempio Win32 CRITICAL_SECTION, è necessario chiamare <xref:System.Threading.Thread.BeginThreadAffinity%2A> prima di acquisire il blocco, e <xref:System.Threading.Thread.EndThreadAffinity%2A> dopo il rilascio del blocco.  
  
 Questo metodo nel codice in esecuzione in SQL Server 2005 richiede il codice da eseguire a livello di protezione più elevato di host.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Threading.Thread.BeginThreadAffinity%2A> e <xref:System.Threading.Thread.EndThreadAffinity%2A> per notificare a un host che un blocco di codice dipende dall'identità di un thread fisico del sistema operativo.  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione richiesta.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Threading.ExecutionContext" /> contenente informazioni sui diversi contesti del thread corrente.</summary>
        <value>Oggetto <see cref="T:System.Threading.ExecutionContext" /> che consolida le informazioni di contesto per il thread corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Threading.ExecutionContext> classe fornisce un singolo contenitore per tutte le informazioni relative a un thread logico di esecuzione. Ciò include il contesto di sicurezza, il contesto di chiamata, contesto di sincronizzazione, il contesto di localizzazione e contesto di transazione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantisce che le risorse vengano liberate e che vengano eseguite le altre operazioni di pulizia quando l'oggetto <see cref="T:System.Threading.Thread" /> viene recuperato da Garbage Collector.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il garbage collector chiama <xref:System.Threading.Thread.Finalize%2A> quando l'oggetto corrente è pronto per essere completato.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dello slot di dati da liberare.</param>
        <summary>Elimina l'associazione tra un nome e uno slot per tutti i thread del processo. Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework fornisce due meccanismi per l'utilizzo di archiviazione locale di thread (TLS): i campi statici relativi ai thread (, ovvero i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati. I campi statici relativi ai thread forniscono prestazioni migliori rispetto agli slot di dati e abilitare il controllo in fase di compilazione. Per ulteriori informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 Dopo che un thread qualsiasi chiama `FreeNamedDataSlot`, altri thread che chiama <xref:System.Threading.Thread.GetNamedDataSlot%2A> con lo stesso nome dovrà allocare un nuovo slot associato al nome. Le chiamate successive a `GetNamedDataSlot` da qualsiasi thread restituirà il nuovo slot. Tuttavia, qualsiasi thread che dispone ancora di un <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> restituito da una precedente chiamata a `GetNamedDataSlot` possono continuare a utilizzare il vecchio slot.  
  
 Uno slot che è stato associato a un nome viene rilasciato solo quando ogni `LocalDataStoreSlot` ottenuto prima della chiamata a `FreeNamedDataSlot` è stato rilasciato e sottoposto a garbage collection.  
  
 I thread usano un meccanismo di memoria di archiviazione locale per archiviare dati specifici del thread. Common language runtime alloca una matrice di archiviazione di dati più slot a ogni processo al momento della creazione. Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per riutilizzarlo dopo la scadenza del thread. Gli slot di dati sono univoci per ogni thread. Nessun altro thread (nemmeno un thread figlio) può ottenere i dati.  
  
   
  
## Examples  
 In questa sezione contiene due esempi di codice. Nel primo esempio viene illustrato come utilizzare un campo che è contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche di un thread. Nel secondo esempio viene illustrato come utilizzare uno slot di dati per eseguire la stessa operazione.  
  
 **Primo esempio**  
  
 Nell'esempio seguente viene illustrato come utilizzare un campo che è contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche di un thread. Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Secondo esempio**  
  
 Nell'esempio seguente viene illustrato come usare uno slot di dati denominato per archiviare le informazioni specifiche di un thread.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un valore <see cref="T:System.Threading.ApartmentState" /> che indica lo stato dell'apartment.</summary>
        <returns>Uno dei valori di <see cref="T:System.Threading.ApartmentState" /> che indica lo stato dell'apartment del thread gestito. Il valore predefinito è <see cref="F:System.Threading.ApartmentState.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo, insieme al <xref:System.Threading.Thread.SetApartmentState%2A> (metodo) e <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo sostituisce il <xref:System.Threading.Thread.ApartmentState%2A> proprietà.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, e <xref:System.Threading.Thread.TrySetApartmentState%2A> metodi. L'esempio di codice crea un thread. Prima dell'avvio del thread, <xref:System.Threading.Thread.GetApartmentState%2A> Visualizza iniziale <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stato e <xref:System.Threading.Thread.SetApartmentState%2A> modifica lo stato in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo quindi restituisce `false` durante il tentativo di modifica dello stato in <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> perché lo stato dell'apartment è già impostato. Se fosse stata tentata la stessa operazione con <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> sarebbe stata generata l'eccezione.  
  
 Una volta avviato il thread, il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo viene utilizzato nuovamente. In questo caso genera <xref:System.Threading.ThreadStateException> perché il thread è già stato avviato.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un oggetto <see cref="T:System.Threading.CompressedStack" /> che può essere usato per acquisire lo stack per il thread corrente.</summary>
        <returns>Nessuno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è più supportato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In tutti i casi.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">Oggetto <see cref="T:System.LocalDataStoreSlot" /> dal quale ottenere il valore.</param>
        <summary>Recupera il valore dallo slot specificato sul thread corrente, all'interno del dominio corrente del thread corrente. Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Valore recuperato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework fornisce due meccanismi per l'utilizzo di archiviazione locale di thread (TLS): i campi statici relativi ai thread (, ovvero i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati. I campi statici relativi ai thread forniscono prestazioni migliori rispetto agli slot di dati e abilitare il controllo in fase di compilazione. Per ulteriori informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 I thread usano un meccanismo di memoria di archiviazione locale per archiviare dati specifici del thread. Common language runtime alloca una matrice di archiviazione di dati più slot a ogni processo al momento della creazione. Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per riutilizzarlo dopo la scadenza del thread. Gli slot di dati sono univoci per ogni thread. Nessun altro thread (nemmeno un thread figlio) può ottenere i dati.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> è un `Shared` metodo che viene applicato sempre al thread attualmente in esecuzione, anche se si chiama utilizzando una variabile che fa riferimento a un altro thread. Per evitare confusione, utilizzare il nome della classe quando si chiama `Shared` metodi: `Dim test As Object = Thread.GetData(testSlot)`.  
  
   
  
## Examples  
 In questa sezione contiene due esempi di codice. Nel primo esempio viene illustrato come utilizzare un campo che è contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche di un thread. Nel secondo esempio viene illustrato come utilizzare uno slot di dati per eseguire la stessa operazione.  
  
 **Primo esempio**  
  
 Nell'esempio seguente viene illustrato come utilizzare un campo che è contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche di un thread. Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Secondo esempio**  
  
 Nell'esempio seguente viene illustrato come utilizzare uno slot di dati per archiviare le informazioni specifiche di un thread.  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il dominio corrente in cui viene eseguito il thread corrente.</summary>
        <returns>Oggetto <see cref="T:System.AppDomain" /> che rappresenta il dominio applicazione corrente del thread in esecuzione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come recuperare il nome e ID di `AppDomain` in cui è in esecuzione il thread.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un identificatore di dominio applicazione univoco.</summary>
        <returns>Intero con segno a 32 bit che identifica in modo univoco il dominio applicazione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Esempio di codice seguente viene illustrato come recuperare il nome e ID di `AppDomain` in cui è in esecuzione il thread.  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un codice hash per il thread corrente.</summary>
        <returns>Intero del valore del codice hash.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il codice hash non deve necessariamente essere univoco. Utilizzare il <xref:System.Threading.Thread.ManagedThreadId%2A> proprietà se è necessario un identificatore univoco per un thread gestito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dello slot di dati locale.</param>
        <summary>Cerca uno slot di dati denominato. Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <returns>Oggetto <see cref="T:System.LocalDataStoreSlot" /> allocato per il thread.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework fornisce due meccanismi per l'utilizzo di archiviazione locale di thread (TLS): i campi statici relativi ai thread (, ovvero i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati. I campi statici relativi ai thread forniscono prestazioni migliori rispetto agli slot di dati e abilitare il controllo in fase di compilazione. Per ulteriori informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 I thread usano un meccanismo di memoria di archiviazione locale per archiviare dati specifici del thread. Common language runtime alloca una matrice di archiviazione di dati più slot a ogni processo al momento della creazione. Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per riutilizzarlo dopo la scadenza del thread. Gli slot di dati sono univoci per ogni thread. Nessun altro thread (nemmeno un thread figlio) può ottenere i dati.  
  
 Se lo slot denominato non esiste, viene allocato un nuovo slot. Gli slot di dati denominato sono pubblici e possono essere modificati da chiunque.  
  
   
  
## Examples  
 In questa sezione contiene due esempi di codice. Nel primo esempio viene illustrato come utilizzare un campo che è contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche di un thread. Nel secondo esempio viene illustrato come utilizzare uno slot di dati per eseguire la stessa operazione.  
  
 **Primo esempio**  
  
 Nell'esempio seguente viene illustrato come utilizzare un campo che è contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche di un thread. Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Secondo esempio**  
  
 Nell'esempio seguente viene illustrato come usare uno slot di dati denominato per archiviare le informazioni specifiche di un thread.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompe un thread il cui stato è <see langword="WaitSleepJoin" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il thread non è attualmente bloccato in uno stato di join, la sospensione o l'attesa, verrà interrotto quando si è iniziato il blocco.  
  
 <xref:System.Threading.ThreadInterruptedException> viene generata nel thread interrotto, ma non prima del blocco del thread. Se il thread si blocca mai, non viene mai generata l'eccezione e pertanto il thread potrebbe completarsi senza subire alcuna interruzione.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di un thread in esecuzione quando viene interrotto e successivamente viene bloccato.  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione <see cref="T:System.Security.Permissions.SecurityPermission" /> necessaria.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operazioni avanzate sui thread. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica lo stato di esecuzione del thread corrente.</summary>
        <value>
          Viene restituito <see langword="true" /> se il thread è stato avviato, ma non è terminato normalmente o è stato interrotto. In caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica se il thread viene eseguito in background.</summary>
        <value>
          <see langword="true" /> se il thread viene o verrà eseguito in background; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread è un thread in background o un thread in primo piano. Thread in background sono identiche a thread in primo piano, ad eccezione del fatto che i thread in background non impediscono di terminare un processo. Una volta terminato tutti i thread in foreground appartenenti a un processo da common language runtime termina il processo. Qualsiasi thread in background rimanenti vengono arrestati e non viene completato.  
  
 Per impostazione predefinita, i thread seguenti eseguono in primo piano (ovvero, i relativi <xref:System.Threading.Thread.IsBackground%2A> restituisce proprietà `false`):  
  
-   Il thread principale (o thread principale dell'applicazione).  
  
-   Tutti i thread creati chiamando un <xref:System.Threading.Thread> costruttore della classe.  
  
 Per impostazione predefinita, i thread seguenti eseguono in background (ovvero, i relativi <xref:System.Threading.Thread.IsBackground%2A> restituisce proprietà `true`):  
  
-   Thread del pool di thread, che sono un pool di thread di lavoro gestiti dal runtime. È possibile configurare il lavoro di pianificazione e di pool di thread nel thread del pool utilizzando il <xref:System.Threading.ThreadPool> classe.  
  
    > [!NOTE]
    >  Operazioni asincrone basate su attività eseguire automaticamente sul thread del pool.  
  
-   Tutti i thread che accedono all'ambiente di esecuzione gestita dal codice non gestito.  
  
   
  
## Examples  
 Nell'esempio seguente viene confrontato il comportamento di thread in primo piano e sfondo. Crea un thread in primo piano e un thread in background. Il thread in primo piano mantiene il processo in esecuzione finché non viene completato il `for` ciclo e termina. Tuttavia, come illustrato nell'output di esempio, perché il thread in primo piano ha terminato l'esecuzione, il processo viene terminato prima che il thread in background ha completato l'esecuzione.  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Thread inattivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se un thread appartiene o meno al pool di thread gestiti.</summary>
        <value>
          <see langword="true" /> se il thread appartiene al pool di thread gestiti; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per ulteriori informazioni vedere [il Thread Pool gestito](~/docs/standard/threading/the-managed-thread-pool.md).  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come determinare se un thread dal pool di thread.  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Blocca il thread chiamante fino al termine del thread rappresentato da questa istanza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Blocca il thread chiamante finché non termina il thread rappresentato da questa istanza, pur continuando a eseguire la distribuzione di <see langword="SendMessage" /> e COM standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> è un metodo di sincronizzazione che blocca il thread chiamante (ovvero, il thread che chiama il metodo) finché il thread il cui <xref:System.Threading.Thread.Join%2A> metodo viene chiamato è stata completata. Utilizzare questo metodo per garantire che un thread è stato terminato. Se non viene terminato il thread, il chiamante verrà bloccata per un periodo illimitato. Nell'esempio seguente, il `Thread1` thread chiama il <xref:System.Threading.Thread.Join> metodo `Thread2`, causando `Thread1` per bloccare fino al `Thread2` è stata completata.  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 Se il thread ha già terminato quando <xref:System.Threading.Thread.Join%2A> viene chiamato il metodo restituisce immediatamente.  
  
> [!WARNING]
>  Non deve mai chiamare il <xref:System.Threading.Thread.Join%2A> metodo il <xref:System.Threading.Thread> oggetto che rappresenta il thread corrente del thread corrente. In questo modo l'app bloccato perché il thread corrente attende indefinitamente, su se stesso  
  
 Questo metodo modifica lo stato del thread chiamante per includere <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Non è possibile richiamare `Join` su un thread che si trova il <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> dello stato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Il chiamante ha provato a eseguire il join di un thread che si trova nello stato <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Il thread viene interrotto durante l'attesa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Tempo di attesa espresso in millisecondi prima che il thread venga terminato.</param>
        <summary>Blocca il thread chiamante finché non termina il thread rappresentato da questa istanza o finché non trascorre l'intervallo di tempo specificato, pur continuando a eseguire la distribuzione di SendMessage e COM standard.</summary>
        <returns>
          <see langword="true" /> se il thread è stato terminato; <see langword="false" /> se il thread non è stato terminato dopo l'intervallo di tempo specificato dal parametro <paramref name="millisecondsTimeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> è un metodo di sincronizzazione che blocca il thread chiamante (ovvero, il thread che chiama il metodo) finché il thread di entrambi i cui <xref:System.Threading.Thread.Join%2A> metodo viene chiamato è stata completata o è trascorso l'intervallo di timeout. Nell'esempio seguente, il `Thread1` thread chiama il <xref:System.Threading.Thread.Join> metodo `Thread2`, causando `Thread1` blocco finché `Thread2` è stata completata o 2 secondi.  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 Se <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> specificato per il `millisecondsTimeout` parametro, questo metodo funziona in modo identico al <xref:System.Threading.Thread.Join> overload del metodo, tranne il valore restituito.  
  
 Se il thread ha già terminato quando <xref:System.Threading.Thread.Join%2A> viene chiamato il metodo restituisce immediatamente.  
  
 Questo metodo modifica lo stato del thread chiamante per includere <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>. Non è possibile richiamare `Join` su un thread che si trova il <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> dello stato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> in millisecondi.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Il thread non è stato avviato.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Oggetto <see cref="T:System.TimeSpan" /> impostato sul tempo di attesa prima che il thread venga terminato.</param>
        <summary>Blocca il thread chiamante finché non termina il thread rappresentato da questa istanza o finché non trascorre l'intervallo di tempo specificato, pur continuando a eseguire la distribuzione di SendMessage e COM standard.</summary>
        <returns>
          <see langword="true" /> se il thread è stato terminato; <see langword="false" /> se il thread non è stato terminato dopo l'intervallo di tempo specificato dal parametro <paramref name="timeout" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> è un metodo di sincronizzazione che blocca il thread chiamante (ovvero, il thread che chiama il metodo) finché il thread di entrambi i cui <xref:System.Threading.Thread.Join%2A> metodo viene chiamato è stata completata o è trascorso l'intervallo di timeout. Nell'esempio seguente, il `Thread1` thread chiama il <xref:System.Threading.Thread.Join> metodo `Thread2`, causando `Thread1` blocco finché `Thread2` è stata completata o 2 secondi.  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 Se <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> specificato per `timeout`, questo metodo funziona in modo identico al <xref:System.Threading.Thread.Join> overload del metodo, tranne il valore restituito.  
  
 Se il thread ha già terminato quando <xref:System.Threading.Thread.Join%2A> viene chiamato il metodo restituisce immediatamente.  
  
 Questo metodo modifica lo stato del thread corrente per includere <xref:System.Threading.ThreadState.WaitSleepJoin>. Non è possibile richiamare `Join` su un thread che si trova il <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> dello stato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come utilizzare un `TimeSpan` valore con il `Join` metodo.  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> in millisecondi oppure è maggiore di <see cref="F:System.Int32.MaxValue" /> in millisecondi.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Il chiamante ha provato a eseguire il join di un thread che si trova nello stato <see cref="F:System.Threading.ThreadState.Unstarted" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un identificatore univoco per il thread gestito corrente.</summary>
        <value>Intero che rappresenta un identificatore univoco per il thread gestito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread <xref:System.Threading.Thread.ManagedThreadId%2A> valore della proprietà consente di identificare in modo univoco i thread nel processo.  
  
 Il valore di <xref:System.Threading.Thread.ManagedThreadId%2A> proprietà varia nel tempo, anche se il codice non gestito che ospita common language runtime implementa il thread come fiber.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sincronizza l'accesso alla memoria come segue: il processore che esegue il thread corrente non può riordinare le istruzioni in modo tale che gli accessi alla memoria prima della chiamata al metodo <see cref="M:System.Threading.Thread.MemoryBarrier" /> vengano eseguiti dopo quelli successivi alla chiamata al metodo <see cref="M:System.Threading.Thread.MemoryBarrier" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> è necessario solo nei sistemi multiprocessori con memoria debole ordinamento (ad esempio, un sistema che utilizza più processori Intel Itanium).  
  
 Per la maggior parte dei casi, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione o <xref:System.Threading.Monitor> classe fornisce un modo semplice per sincronizzare i dati.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il nome del thread.</summary>
        <value>Stringa che contiene il nome del thread oppure <see langword="null" /> se non è stato impostato alcun nome.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà è di scrittura-una volta. Poiché il valore predefinito di un thread <xref:System.Threading.Thread.Name%2A> proprietà `null`, è possibile determinare se un nome è già stato in modo esplicito assegnato al thread confrontandolo con `null`.  
  
 La stringa assegnata al <xref:System.Threading.Thread.Name%2A> proprietà può includere qualsiasi carattere Unicode.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come assegnare un nome di un thread.  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">È stata richiesta un'operazOttiene o imposta il descrittore di sicurezza per questa voce.ione set, ma la proprietà <see langword="Name" /> è già stata impostata.</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un valore che indica la priorità di pianificazione di un thread.</summary>
        <value>Uno dei valori di <see cref="T:System.Threading.ThreadPriority" />. Il valore predefinito è <see cref="F:System.Threading.ThreadPriority.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un thread può essere assegnato a una delle seguente priorità <xref:System.Threading.ThreadPriority> valori:  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 Sistemi operativi non devono rispettare la priorità di un thread.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato il risultato della modifica della priorità di un thread. Vengono creati tre thread, la priorità di un thread è impostata su <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, e la priorità di un secondo è impostata su <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>. Ogni thread incrementa una variabile in un `while` ciclo e viene eseguito per un determinato periodo di tempo.  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Il thread ha raggiunto uno stato finale, come <see cref="F:System.Threading.ThreadState.Aborted" />.</exception>
        <exception cref="T:System.ArgumentException">Il valore specificato per un'operazione di impostazione non è un valore <see cref="T:System.Threading.ThreadPriority" /> valido.</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annulla il metodo <see cref="M:System.Threading.Thread.Abort(System.Object)" /> richiesto per il thread corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo può essere chiamato solo da codice con le autorizzazioni appropriate.  
  
 Quando viene eseguita una chiamata a `Abort` per terminare un thread, il sistema genererà un <xref:System.Threading.ThreadAbortException>. `ThreadAbortException` è un'eccezione speciale che può essere intercettata dal codice dell'applicazione, ma viene generata nuovamente alla fine del blocco catch, a meno che non `ResetAbort` viene chiamato. `ResetAbort` Annulla la richiesta di interruzione e impedisce la `ThreadAbortException` di terminazione del thread.  
  
 Vedere <xref:System.Threading.ThreadAbortException> per un esempio in cui viene illustrata la chiamata di `ResetAbort` metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: questo membro non è supportato.</exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <see langword="Abort" /> non è stato richiamato sul thread corrente.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non ha l'autorizzazione di sicurezza richiesta per il thread corrente.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operazioni avanzate sui thread. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Riprende un thread che era stato sospeso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Non utilizzare il <xref:System.Threading.Thread.Suspend%2A> e <xref:System.Threading.Thread.Resume%2A> metodi per sincronizzare le attività dei thread. Non è possibile sapere quale codice un thread è in esecuzione quando viene sospeso. Se si sospende un thread mentre contiene dei blocchi durante una valutazione delle autorizzazioni di sicurezza, altri thread di <xref:System.AppDomain> potrebbe essere bloccato. Se si sospende un thread durante l'esecuzione di un costruttore di classe, altri thread di <xref:System.AppDomain> che tentano di utilizzare quella classe sono bloccati. In modo molto semplice, possono verificarsi deadlock.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: questo membro non è supportato.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Il thread non è stato avviato, è inattivo o non è in stato sospeso.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione <see cref="T:System.Security.Permissions.SecurityPermission" /> necessaria.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operazioni avanzate sui thread. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Nuovo stato dell'apartment.</param>
        <summary>Imposta lo stato dell'apartment di un thread prima che venga avviato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nuovi thread vengono inizializzati come <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se lo stato di apartment non è stato impostato prima dell'avvio. Prima dell'avvio di un thread, è necessario impostare lo stato dell'apartment.  
  
> [!NOTE]
>  Il thread principale dell'applicazione viene inizializzato a <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> per impostazione predefinita. L'unico modo per impostare lo stato dell'apartment del thread principale dell'applicazione per <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> viene applicato il <xref:System.STAThreadAttribute> al metodo del punto di ingresso dell'attributo.  
  
 Il <xref:System.Threading.Thread.SetApartmentState%2A> metodo, insieme al <xref:System.Threading.Thread.GetApartmentState%2A> (metodo) e <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo sostituisce il <xref:System.Threading.Thread.ApartmentState%2A> proprietà.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, e <xref:System.Threading.Thread.TrySetApartmentState%2A> metodi. L'esempio di codice crea un thread. Prima dell'avvio del thread, <xref:System.Threading.Thread.GetApartmentState%2A> Visualizza iniziale <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stato e <xref:System.Threading.Thread.SetApartmentState%2A> modifica lo stato in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo quindi restituisce `false` durante il tentativo di modifica dello stato in <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> perché lo stato dell'apartment è già impostato. Se fosse stata tentata la stessa operazione con <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> sarebbe stata generata l'eccezione.  
  
 Una volta avviato il thread, il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo viene utilizzato nuovamente. In questo caso genera <xref:System.Threading.ThreadStateException> perché il thread è già stato avviato.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: questo membro non è supportato nelle piattaforme macOS e Linux.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> non è uno stato dell'apartment valido.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Il thread è già stato avviato.</exception>
        <exception cref="T:System.InvalidOperationException">Lo stato di apartment è già stato inizializzato.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">Oggetto <see cref="T:System.Threading.CompressedStack" /> da applicare al thread corrente.</param>
        <summary>Applica un oggetto <see cref="T:System.Threading.CompressedStack" /> acquisito al thread corrente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo non è più supportato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In tutti i casi.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">Oggetto <see cref="T:System.LocalDataStoreSlot" /> nel quale impostare il valore.</param>
        <param name="data">Valore da impostare.</param>
        <summary>Imposta i dati nello slot specificato sul thread in esecuzione per il dominio corrente di tale thread. Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework fornisce due meccanismi per l'utilizzo di archiviazione locale di thread (TLS): i campi statici relativi ai thread (, ovvero i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati. I campi statici relativi ai thread forniscono prestazioni migliori rispetto agli slot di dati e abilitare il controllo in fase di compilazione. Per ulteriori informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).  
  
 I thread usano un meccanismo di memoria di archiviazione locale per archiviare dati specifici del thread. Common language runtime alloca una matrice di archiviazione di dati più slot a ogni processo al momento della creazione. Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per il riutilizzo dopo il termine procedure thread e <xref:System.Threading.Thread> oggetto è stato recuperato da garbage collection. Gli slot di dati sono univoci per ogni thread. Nessun altro thread (nemmeno un thread figlio) può ottenere i dati.  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> è un `Shared` metodo che viene applicato sempre al thread attualmente in esecuzione, anche se si chiama utilizzando una variabile che fa riferimento a un altro thread. Per evitare confusione, utilizzare il nome della classe quando si chiama `Shared` metodi: `Thread.SetData(testSlot, "test data")`.  
  
   
  
## Examples  
 In questa sezione contiene due esempi di codice. Nel primo esempio viene illustrato come utilizzare un campo che è contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche di un thread. Nel secondo esempio viene illustrato come utilizzare uno slot di dati per eseguire la stessa operazione.  
  
 **Primo esempio**  
  
 Nell'esempio seguente viene illustrato come utilizzare un campo che è contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche di un thread. Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **Secondo esempio**  
  
 Nell'esempio seguente viene illustrato come usare uno slot di dati denominato per archiviare le informazioni specifiche di un thread.  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sospende il thread corrente per il periodo di tempo specificato.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Numero di millisecondi per cui sospendere il thread. Se il valore dell'argomento <c>millisecondsTimeout</c> è zero, il thread cede il periodo di tempo rimanente a un thread di uguale priorità pronto per l'esecuzione. Se non sono presenti altri thread di uguale priorità pronti per l'esecuzione, l'esecuzione del thread corrente non viene sospesa.</param>
        <summary>Sospende il thread corrente per il numero specificato di millisecondi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il thread non verrà pianificato per l'esecuzione dal sistema operativo per la quantità di tempo specificato. Questo metodo modifica lo stato del thread da includere <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 È possibile specificare <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> per il `millisecondsTimeout` parametro per sospendere il thread per un periodo illimitato. Tuttavia, si consiglia di utilizzare altri <xref:System.Threading?displayProperty=nameWithType> classi, ad esempio <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, o <xref:System.Threading.Semaphore> invece per sincronizzare i thread o gestire le risorse.  
  
 I cicli di sistema a una specifica velocità chiamato la risoluzione del clock. Il timeout effettivo potrebbe non essere esattamente il timeout specificato, verrà modificato il timeout specificato per l'occasione di cicli macchina. Per ulteriori informazioni sulla risoluzione di orologio e il tempo di attesa, vedere il [sospensione funzione](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) argomento. Questo metodo chiama il [sospensione funzione](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) dal sistema Windows API.  
  
 Questo metodo non esegue la distribuzione di SendMessage e COM standard.  
  
> [!NOTE]
>  Se si desidera rendere inattivo su un thread che ha <xref:System.STAThreadAttribute>, ma si desidera eseguire la distribuzione di SendMessage e COM standard, è possibile utilizzare uno degli overload di <xref:System.Threading.Thread.Join%2A> metodo che specifica un intervallo di timeout.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.Thread.Sleep%2A> metodo per bloccare il thread dell'applicazione principale.  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di timeout è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Periodo di tempo per cui sospendere il thread. Se il valore dell'argomento <c>millisecondsTimeout</c> è <see cref="F:System.TimeSpan.Zero" />, il thread cede il periodo di tempo rimanente a un thread di uguale priorità pronto per l'esecuzione. Se non sono presenti altri thread di uguale priorità pronti per l'esecuzione, l'esecuzione del thread corrente non viene sospesa.</param>
        <summary>Sospende il thread corrente per il periodo di tempo specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il thread non verrà pianificato per l'esecuzione dal sistema operativo per la quantità di tempo specificato. Questo metodo modifica lo stato del thread da includere <xref:System.Threading.ThreadState.WaitSleepJoin>.  
  
 È possibile specificare <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> per il `timeout` parametro per sospendere il thread per un periodo illimitato. Tuttavia, si consiglia di utilizzare altri <xref:System.Threading?displayProperty=nameWithType> classi, ad esempio <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, o <xref:System.Threading.Semaphore> invece per sincronizzare i thread o gestire le risorse.  
  
 Questo overload di <xref:System.Threading.Thread.Sleep%2A> utilizza il numero totale di millisecondi interi in `timeout`. Millisecondi frazionari vengono ignorati.  
  
 Questo metodo non esegue la distribuzione di SendMessage e COM standard.  
  
> [!NOTE]
>  Se si desidera rendere inattivo su un thread che ha <xref:System.STAThreadAttribute>, ma si desidera eseguire la distribuzione di SendMessage e COM standard, è possibile utilizzare uno degli overload di <xref:System.Threading.Thread.Join%2A> metodo che specifica un intervallo di timeout.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> overload del metodo per bloccare il thread dell'applicazione principale cinque volte, per due secondi ogni volta.  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore di <paramref name="timeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> in millisecondi oppure è maggiore di <see cref="F:System.Int32.MaxValue" /> in millisecondi.</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">Intero con segno a 32 bit che definisce la durata dell'attesa di un thread.</param>
        <summary>Determina che un thread rimanga in attesa il numero di volte definito dal parametro <paramref name="iterations" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Thread.SpinWait%2A> metodo è utile per l'implementazione di blocchi. Le classi in .NET Framework, ad esempio <xref:System.Threading.Monitor> e <xref:System.Threading.ReaderWriterLock>, utilizzare questo metodo internamente. <xref:System.Threading.Thread.SpinWait%2A> Inserisce essenzialmente il processore in un ciclo molto ridotto, con il conteggio dei cicli specificato per il `iterations` parametro. La durata dell'attesa pertanto dipende dalla velocità del processore.  
  
 Confrontare questa operazione con il <xref:System.Threading.Thread.Sleep%2A> metodo. Un thread che chiama <xref:System.Threading.Thread.Sleep%2A> restituisce il resto del periodo corrente del tempo del processore, anche se l'intervallo specificato è uguale a zero. Specificando un intervallo diverso da zero per <xref:System.Threading.Thread.Sleep%2A> rimuove il thread dalla considerazione dall'utilità di pianificazione di thread fino a quando non è trascorso l'intervallo di tempo.  
  
 <xref:System.Threading.Thread.SpinWait%2A> non è in genere utile per le applicazioni comuni. Nella maggior parte dei casi, è necessario usare le classi di sincronizzazione fornite da .NET Framework. ad esempio, chiamare <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> o un'istruzione che esegue il wrapping <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in c# o `SyncLock` in Visual Basic).  
  
> [!CAUTION]
>  Nel raro caso in cui è preferibile evitare un cambio di contesto, ad esempio quando si sa che una modifica dello stato è imminente, effettuare una chiamata al <xref:System.Threading.Thread.SpinWait%2A> metodo nel ciclo. Il codice <xref:System.Threading.Thread.SpinWait%2A> esegue è progettata per evitare i problemi che possono verificarsi nei computer con più processori. Ad esempio, nei computer con più processori Intel basati sulla tecnologia Hyper-Threading, <xref:System.Threading.Thread.SpinWait%2A> impedisce l'esaurimento delle risorse del processore in determinate situazioni.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina la pianificazione dell'esecuzione di un thread.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina il cambiamento da parte del sistema operativo dello stato dell'istanza corrente in <see cref="F:System.Threading.ThreadState.Running" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una volta che un thread si trova il <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stato, il sistema operativo pianificarne l'esecuzione. Il thread inizia l'esecuzione alla prima riga del metodo rappresentato dal <xref:System.Threading.ThreadStart> o <xref:System.Threading.ParameterizedThreadStart> delegato fornito al costruttore del thread. Si noti che la chiamata a <xref:System.Threading.Thread.Start%2A> non blocca il thread chiamante.  
  
> [!NOTE]
>  Se questo overload viene utilizzato con un thread creato utilizzando un <xref:System.Threading.ParameterizedThreadStart> delegare, `null` viene passato al metodo eseguito dal thread.  
  
 Quando il thread termina, non può essere riavviato con un'altra chiamata a `Start`.  
  
   
  
## Examples  
 Nell'esempio seguente crea e avvia un thread.  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Il thread è già stato avviato.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per avviare il thread.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">Oggetto contenente i dati che devono essere usati dal metodo eseguito dal thread.</param>
        <summary>Determina il cambiamento da parte del sistema operativo dello stato dell'istanza corrente in <see cref="F:System.Threading.ThreadState.Running" /> e, facoltativamente, fornisce un oggetto contenente i dati che devono essere usati dal metodo eseguito dal thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una volta che un thread si trova il <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> stato, il sistema operativo pianificarne l'esecuzione. Il thread inizia l'esecuzione alla prima riga del metodo rappresentato dal <xref:System.Threading.ThreadStart> o <xref:System.Threading.ParameterizedThreadStart> delegato fornito al costruttore del thread. Si noti che la chiamata a <xref:System.Threading.Thread.Start%2A> non blocca il thread chiamante.  
  
 Quando il thread termina, non può essere riavviato con un'altra chiamata a `Start`.  
  
 Questo overload e <xref:System.Threading.ParameterizedThreadStart> delegato semplificano passare dati a una procedura thread, ma la tecnica non è indipendente dai tipi perché qualsiasi oggetto può essere passato a questo overload. Un modo più efficiente per passare dati a una procedura thread è inserire sia la procedura del thread e i campi dati in un oggetto di lavoro. Per ulteriori informazioni, vedere [la creazione di thread e passaggio di dati in fase di avvio](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).  
  
   
  
## Examples  
 Nell'esempio seguente viene creato un <xref:System.Threading.ParameterizedThreadStart> delegato con un metodo statico e un metodo di istanza.  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">Il thread è già stato avviato.</exception>
        <exception cref="T:System.OutOfMemoryException">La memoria disponibile non è sufficiente per avviare il thread.</exception>
        <exception cref="T:System.InvalidOperationException">Questo thread è stato creato usando un delegato di <see cref="T:System.Threading.ThreadStart" /> invece di uno di <see cref="T:System.Threading.ParameterizedThreadStart" />.</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sospende il thread o, se il thread è già sospeso, non avrà alcun effetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se il thread è già sospeso, questo metodo non ha alcun effetto.  
  
> [!CAUTION]
>  Non utilizzare il <xref:System.Threading.Thread.Suspend%2A> e <xref:System.Threading.Thread.Resume%2A> metodi per sincronizzare le attività dei thread. Non è possibile sapere quale codice un thread è in esecuzione quando viene sospeso. Se si sospende un thread mentre contiene dei blocchi durante una valutazione delle autorizzazioni di sicurezza, altri thread di <xref:System.AppDomain> potrebbe essere bloccato. Se si sospende un thread durante l'esecuzione di un costruttore di classe, altri thread di <xref:System.AppDomain> che tentano di utilizzare quella classe sono bloccati. In modo molto semplice, possono verificarsi deadlock.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Solo .NET Core: questo membro non è supportato.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Il thread non è stato avviato o è inattivo.</exception>
        <exception cref="T:System.Security.SecurityException">Il chiamante non dispone dell'autorizzazione <see cref="T:System.Security.Permissions.SecurityPermission" /> necessaria.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per operazioni avanzate sui thread. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="rgszNames">Matrice di nomi passata di cui eseguire il mapping.</param>
        <param name="cNames">Conteggio dei nomi di cui eseguire il mapping.</param>
        <param name="lcid">Contesto delle impostazioni locali in cui interpretare i nomi.</param>
        <param name="rgDispId">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</param>
        <summary>Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetIDsOfNames`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informazioni sul tipo da restituire.</param>
        <param name="lcid">Identificatore delle impostazioni locali per le informazioni sul tipo.</param>
        <param name="ppTInfo">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</param>
        <summary>Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfo`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</param>
        <summary>Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::GetTypeInfoCount`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica il membro.</param>
        <param name="riid">Riservato per utilizzi futuri. Deve essere IID_NULL.</param>
        <param name="lcid">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</param>
        <param name="wFlags">Flag che descrivono il contesto della chiamata.</param>
        <param name="pDispParams">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</param>
        <param name="pVarResult">Puntatore alla posizione in cui deve essere archiviato il risultato.</param>
        <param name="pExcepInfo">Puntatore a una struttura contenente informazioni sull'eccezione.</param>
        <param name="puArgErr">Indice del primo argomento che contiene un errore.</param>
        <summary>Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito. Per ulteriori informazioni su `IDispatch::Invoke`, vedere MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore contenente gli stati del thread corrente.</summary>
        <value>Uno dei valori di <see cref="T:System.Threading.ThreadState" /> che indica lo stato del thread corrente. Il valore iniziale è <see langword="Unstarted" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.Thread.ThreadState%2A> proprietà fornisce informazioni più specifiche di <xref:System.Threading.Thread.IsAlive%2A> proprietà.  
  
> [!IMPORTANT]
>  Lo stato del thread è importante solo negli scenari di debug. Il codice non deve mai usare lo stato del thread per sincronizzare le attività dei thread.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'accesso di `ThreadState` di un thread.  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">Nuovo stato dell'apartment.</param>
        <summary>Imposta lo stato dell'apartment di un thread prima che venga avviato.</summary>
        <returns>
          <see langword="true" /> se è impostato lo stato dell'apartment; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nuovi thread vengono inizializzati come <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se lo stato di apartment non è stato impostato prima dell'avvio. Prima dell'avvio di un thread, è necessario impostare lo stato dell'apartment.  
  
> [!NOTE]
>  Il thread principale dell'applicazione viene inizializzato a <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> per impostazione predefinita. L'unico modo per impostare lo stato dell'apartment del thread principale dell'applicazione per <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> viene applicato il <xref:System.STAThreadAttribute> al metodo del punto di ingresso dell'attributo.  
  
 Il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo, insieme al <xref:System.Threading.Thread.GetApartmentState%2A> (metodo) e <xref:System.Threading.Thread.SetApartmentState%2A> metodo sostituisce il <xref:System.Threading.Thread.ApartmentState%2A> proprietà.  
  
   
  
## Examples  
 L'esempio di codice seguente illustra il <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, e <xref:System.Threading.Thread.TrySetApartmentState%2A> metodi. L'esempio di codice crea un thread. Prima dell'avvio del thread, <xref:System.Threading.Thread.GetApartmentState%2A> Visualizza iniziale <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> stato e <xref:System.Threading.Thread.SetApartmentState%2A> modifica lo stato in <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>. Il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo quindi restituisce `false` durante il tentativo di modifica dello stato in <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> perché lo stato dell'apartment è già impostato. Se fosse stata tentata la stessa operazione con <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> sarebbe stata generata l'eccezione.  
  
 Una volta avviato il thread, il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo viene utilizzato nuovamente. In questo caso genera <xref:System.Threading.ThreadStateException> perché il thread è già stato avviato.  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="state" /> non è uno stato dell'apartment valido.</exception>
        <exception cref="T:System.Threading.ThreadStateException">Il thread è già stato avviato.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">Campo da leggere.</param>
        <summary>Legge il valore di un campo. Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</summary>
        <returns>Ultimo valore scritto nel campo da un processore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr&amp;" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">Campo in cui deve essere scritto il valore.</param>
        <param name="value">Valore da scrivere.</param>
        <summary>Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> per casi speciali di sincronizzazione. In circostanze normali, in c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.  
  
 In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> garantisce che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori. Potrebbe essere necessario scaricare le cache di processore.  
  
 Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> garantiscono che un valore letto o scritto nella memoria e non memorizzato nella cache (ad esempio, in un registro del processore). Di conseguenza, è possibile utilizzare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread o dall'hardware.  
  
 Chiamare questo metodo interessa solo un singolo accesso alla memoria. Per consentire la sincronizzazione efficace per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
> [!NOTE]
>  In c#, utilizzando il `volatile` garantisce che tutti gli accessi al campo utilizzano il modificatore su un campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina che il thread chiamante ceda l'esecuzione a un altro thread pronto per l'esecuzione sul processore corrente. Il sistema operativo seleziona il thread a cui cedere l'esecuzione.</summary>
        <returns>
          <see langword="true" /> se il sistema operativo ha passato l'esecuzione a un altro thread. In caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se questo metodo ha esito positivo, viene restituito il resto dell'intervallo di tempo corrente del thread. Il sistema operativo pianifica il thread chiamante per un altro intervallo di tempo, in base alla relativa priorità e lo stato di altri thread che sono disponibili per l'esecuzione.  
  
 Cede il controllo è limitato per il processore che esegue il thread chiamante. Il sistema operativo non cambia esecuzione a un altro processore, anche se tale processore è inattivo o è in esecuzione un thread di priorità più bassa. Se non sono presenti altri thread che sono pronti per l'esecuzione sul processore corrente, se il sistema operativo non ceda l'esecuzione e se questo metodo restituisce `false`.  
  
 Questo metodo equivale all'utilizzo di platform invoke per chiamare Win32 nativo `SwitchToThread` (funzione). È necessario chiamare il <xref:System.Threading.Thread.Yield%2A> metodo anziché utilizzare platform invoke, perché ignora qualsiasi comportamento personalizzato di threading dell'host ha richiesto di platform invoke.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>