<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="195329e46927ec7485d68643b0c65bff7b6dec83" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51928528" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="2da3d-101">Crea e controlla un thread, ne imposta le priorità e ne ottiene lo stato.</span>
      <span class="sxs-lookup">
        <span data-stu-id="2da3d-101">Creates and controls a thread, sets its priority, and gets its status.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-102">Quando viene avviato un processo, common language runtime crea automaticamente un thread singolo in primo piano per eseguire il codice dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="2da3d-103">Insieme a questo thread principale in primo piano, un processo può creare uno o più thread per eseguire una parte del codice del programma associato al processo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="2da3d-104">È possibile eseguire i thread in primo piano o in background.</span><span class="sxs-lookup"><span data-stu-id="2da3d-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="2da3d-105">Inoltre, è possibile usare il <xref:System.Threading.ThreadPool> classe per eseguire il codice nei thread di lavoro che sono gestiti da common language runtime.</span><span class="sxs-lookup"><span data-stu-id="2da3d-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="2da3d-106">Contenuto della sezione</span><span class="sxs-lookup"><span data-stu-id="2da3d-106">In this section</span></span>  
  
 <span data-ttu-id="2da3d-107">[Avvio di un thread](#Starting) </span><span class="sxs-lookup"><span data-stu-id="2da3d-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="2da3d-108">[Recupero di oggetti Thread](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="2da3d-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="2da3d-109">[Thread in primo piano e sfondo](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="2da3d-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="2da3d-110">[Impostazioni cultura e thread](#Culture) </span><span class="sxs-lookup"><span data-stu-id="2da3d-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="2da3d-111">Recupero di informazioni e controllo di thread</span><span class="sxs-lookup"><span data-stu-id="2da3d-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="2da3d-112">Avvio di un thread</span><span class="sxs-lookup"><span data-stu-id="2da3d-112">Starting a thread</span></span>  
 <span data-ttu-id="2da3d-113">Si avvia un thread fornendo un delegato che rappresenta il metodo che di thread consiste nell'eseguire nel relativo costruttore di classe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="2da3d-114">È quindi possibile chiamare il <xref:System.Threading.Thread.Start%2A> metodo per avviare l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="2da3d-115">Il <xref:System.Threading.Thread> costruttori possono assumere uno dei tipi di delegati di due, a seconda del fatto che è possibile passare un argomento al metodo da eseguire:</span><span class="sxs-lookup"><span data-stu-id="2da3d-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="2da3d-116">Se il metodo non dispone di argomenti, si passa un <xref:System.Threading.ThreadStart> delegato al costruttore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="2da3d-117">Ha la firma:</span><span class="sxs-lookup"><span data-stu-id="2da3d-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="2da3d-118">Nell'esempio seguente crea e avvia un thread che esegue il `ExecuteInForeground` (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="2da3d-119">Il metodo visualizza informazioni su alcune proprietà dei thread, quindi esegue un ciclo in cui viene sospeso per mezzo secondo e visualizza il numero di secondi trascorsi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="2da3d-120">Quando il thread è stato eseguito per almeno cinque secondi, il ciclo termina e il thread termina l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="2da3d-121">Se il metodo ha un argomento, si passa un <xref:System.Threading.ParameterizedThreadStart> delegato al costruttore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="2da3d-122">Ha la firma:</span><span class="sxs-lookup"><span data-stu-id="2da3d-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="2da3d-123">Il metodo eseguito dal delegato può quindi eseguire il cast (in c#) o convertire (in Visual Basic) il parametro nel tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="2da3d-124">Nell'esempio seguente è identico a quello precedente, ad eccezione del fatto che chiami il <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> costruttore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="2da3d-125">Questa versione del `ExecuteInForeground` metodo ha un singolo parametro che rappresenta il numero approssimativo di millisecondi il ciclo consiste nell'eseguire.</span><span class="sxs-lookup"><span data-stu-id="2da3d-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="2da3d-126">Non è necessario conservare un riferimento a un <xref:System.Threading.Thread> dopo aver avviato il thread dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="2da3d-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="2da3d-127">Il thread continua l'esecuzione fino al termine della routine del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="2da3d-128">Recupero di oggetti Thread</span><span class="sxs-lookup"><span data-stu-id="2da3d-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="2da3d-129">È possibile usare il metodo statico (`Shared` in Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> proprietà per recuperare un riferimento al thread attualmente in esecuzione dal codice che il thread è in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="2da3d-130">L'esempio seguente usa il <xref:System.Threading.Thread.CurrentThread%2A> proprietà per visualizzare informazioni sul thread dell'applicazione principale, un altro thread in primo piano, un thread in background e un pool di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="2da3d-131">Thread in primo piano e sfondo</span><span class="sxs-lookup"><span data-stu-id="2da3d-131">Foreground and background threads</span></span>  
 <span data-ttu-id="2da3d-132">Le istanze del <xref:System.Threading.Thread> classe rappresentano i thread in primo piano o thread in background.</span><span class="sxs-lookup"><span data-stu-id="2da3d-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="2da3d-133">I thread in background sono identici ai thread in primo piano con una sola eccezione: un thread in background non mantiene un processo in esecuzione se tutti i thread in primo piano sono terminati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="2da3d-134">Una volta arrestati tutti i thread in primo piano, il runtime arresta tutti i thread in background e viene terminato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="2da3d-135">Per impostazione predefinita, i thread seguenti eseguire in primo piano:</span><span class="sxs-lookup"><span data-stu-id="2da3d-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="2da3d-136">Il thread principale dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="2da3d-137">Tutti i thread creati chiamando un <xref:System.Threading.Thread> costruttore della classe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="2da3d-138">Eseguire i thread seguenti in background per impostazione predefinita:</span><span class="sxs-lookup"><span data-stu-id="2da3d-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="2da3d-139">Thread del pool di thread, costituiti da un pool di thread di lavoro gestiti dal runtime.</span><span class="sxs-lookup"><span data-stu-id="2da3d-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="2da3d-140">È possibile configurare il lavoro del pool e la pianificazione del thread nel pool di thread usando il <xref:System.Threading.ThreadPool> classe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2da3d-141">Eseguire automaticamente operazioni asincrone basate su attività nel pool di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="2da3d-142">Operazioni asincrone basate su attività usano il <xref:System.Threading.Tasks.Task> e <xref:System.Threading.Tasks.Task%601> classi per implementare le [modello asincrono basato su attività](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span><span class="sxs-lookup"><span data-stu-id="2da3d-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="2da3d-143">Tutti i thread che accedono all'ambiente di esecuzione gestita dal codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="2da3d-144">È possibile modificare un thread per l'esecuzione in background mediante l'impostazione di <xref:System.Threading.Thread.IsBackground%2A> proprietà in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="2da3d-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="2da3d-145">I thread in background sono utili per qualsiasi operazione che deve continuare fino a quando un'applicazione è in esecuzione ma non dovrebbe impedire l'applicazione da terminare il programma, ad esempio il monitoraggio delle modifiche al file system o le connessioni socket in ingresso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="2da3d-146">Nell'esempio seguente viene illustrata la differenza tra i thread in primo piano e sfondo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="2da3d-147">È, ad esempio nel primo esempio il [avvio di un thread](#Starting) sezione, ad eccezione del fatto che imposta il thread per l'esecuzione in background prima di avviarla.</span><span class="sxs-lookup"><span data-stu-id="2da3d-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="2da3d-148">Come illustrato nell'output, il ciclo viene interrotto prima dell'esecuzione per cinque secondi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="2da3d-149">Impostazioni cultura e thread</span><span class="sxs-lookup"><span data-stu-id="2da3d-149">Culture and threads</span></span>  
 <span data-ttu-id="2da3d-150">Ogni thread dispone di impostazioni cultura, rappresentate dal <xref:System.Threading.Thread.CurrentCulture%2A> proprietà e impostazioni cultura dell'interfaccia utente, rappresentato dal <xref:System.Threading.Thread.CurrentUICulture%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="2da3d-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="2da3d-151">Le impostazioni cultura correnti supporta operazioni dipendenti dalle impostazioni cultura quali l'analisi e formattazione, confronto tra stringhe e l'ordinamento e controlla anche il sistema di scrittura e il calendario usato da un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="2da3d-152">Le impostazioni cultura correnti dell'interfaccia utente fornisce per il recupero di distinzione delle impostazioni cultura delle risorse nei file di risorse.</span><span class="sxs-lookup"><span data-stu-id="2da3d-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="2da3d-153">Il <xref:System.Threading.Thread.CurrentCulture> e <xref:System.Threading.Thread.CurrentUICulture> proprietà non funzionano in modo affidabile quando usato con qualsiasi thread diverso da quello corrente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="2da3d-154">In .NET Framework, la lettura di queste proprietà è affidabile, anche se non è impostare queste proprietà per un thread diverso da quello corrente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="2da3d-155">In .NET Core, un <xref:System.InvalidOperationException> viene generata se un thread tenta di leggere o scrivere queste proprietà in un thread diverso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="2da3d-156">È consigliabile usare la <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> proprietà da recuperare e impostare le impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="2da3d-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="2da3d-157">Quando viene creata un'istanza di un nuovo thread, le impostazioni cultura e le impostazioni cultura dell'interfaccia utente vengono definiti dalle impostazioni cultura correnti del sistema e delle impostazioni cultura dell'interfaccia utente e non per le impostazioni cultura e le impostazioni cultura dell'interfaccia utente del thread da cui viene creato il nuovo thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="2da3d-158">Ciò significa, ad esempio, che se le impostazioni cultura correnti del sistema sono l'inglese (Stati Uniti) e le impostazioni cultura correnti del thread principale dell'applicazione sono il francese (Francia), le impostazioni cultura di un nuovo thread creato mediante la chiamata di <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> costruttore dal thread principale è inglese (Stati Uniti) e non francese (Francia).</span><span class="sxs-lookup"><span data-stu-id="2da3d-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="2da3d-159">Per altre informazioni, vedere la sezione "Impostazioni cultura e thread" del <xref:System.Globalization.CultureInfo> argomento relativo alla classe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-160">Ciò non è possibile di thread che eseguono operazioni asincrone per le app che hanno come destinazione il [!INCLUDE[net_v46](~/includes/net-v46-md.md)] e versioni successive, In questo caso, le impostazioni cultura e le impostazioni cultura dell'interfaccia utente è parte di un'asincrona contesto operazioni, il thread in cui un'operazione asincrona esegue l'istruzione con predefinito eredita le impostazioni cultura e le impostazioni cultura dell'interfaccia utente del thread da cui è stata avviata l'operazione asincrona.</span><span class="sxs-lookup"><span data-stu-id="2da3d-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="2da3d-161">Per altre informazioni, vedere la sezione dedicata alle impostazioni cultura e alle operazioni asincrone basate su attività nell'argomento relativo alla classe <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="2da3d-162">È possibile effettuare una delle operazioni seguenti per assicurarsi che tutti i thread in esecuzione in un'applicazione condividono le stesse impostazioni cultura e le impostazioni cultura dell'interfaccia utente:</span><span class="sxs-lookup"><span data-stu-id="2da3d-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="2da3d-163">È possibile passare un <xref:System.Globalization.CultureInfo> oggetto che rappresenta quelle impostazioni cultura per il <xref:System.Threading.ParameterizedThreadStart> delegare o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="2da3d-164">Per le App in esecuzione sul [!INCLUDE[net_v45](~/includes/net-v45-md.md)] e versioni successive, è possibile definire le impostazioni cultura e le impostazioni cultura dell'interfaccia utente che deve essere assegnato a tutti i thread creati in un dominio dell'applicazione impostando il valore della <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> proprietà.</span><span class="sxs-lookup"><span data-stu-id="2da3d-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="2da3d-165">Si tratta di un'impostazione di dominio per ogni applicazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="2da3d-166">Per altre informazioni ed esempi, vedere la sezione "Impostazioni cultura e thread" del <xref:System.Globalization.CultureInfo> argomento relativo alla classe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="2da3d-167">Recupero di informazioni e controllo di thread</span><span class="sxs-lookup"><span data-stu-id="2da3d-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="2da3d-168">È possibile recuperare un numero di valori di proprietà che forniscono informazioni su un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="2da3d-169">In alcuni casi, è anche possibile impostare questi valori di proprietà per controllare l'operazione del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="2da3d-170">Queste proprietà thread includono:</span><span class="sxs-lookup"><span data-stu-id="2da3d-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="2da3d-171">Un nome</span><span class="sxs-lookup"><span data-stu-id="2da3d-171">A name.</span></span> <span data-ttu-id="2da3d-172"><xref:System.Threading.Thread.Name%2A> è un'operazione di scrittura-proprietà di una volta che è possibile usare per identificare un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="2da3d-173">Il valore predefinito è `null`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="2da3d-174">Un codice hash, che è possibile recuperare tramite una chiamata di <xref:System.Threading.Thread.GetHashCode%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="2da3d-175">Il codice hash può essere utilizzato per identificare in modo univoco un thread. per la durata del thread, il codice hash non entrerà in conflitto con il valore da un altro thread, indipendentemente dal dominio dell'applicazione da cui ottenere il valore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="2da3d-176">Un ID del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-176">A thread ID.</span></span> <span data-ttu-id="2da3d-177">Il valore di sola lettura <xref:System.Threading.Thread.ManagedThreadId%2A> proprietà viene assegnata dal runtime e identifica in modo univoco un thread all'interno di un processo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2da3d-178">L'oggetto [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) di un sistema operativo non ha una relazione fissa con un thread gestito, perché un host non gestito può controllare la relazione tra thread gestiti e non gestiti.</span><span class="sxs-lookup"><span data-stu-id="2da3d-178">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="2da3d-179">In particolare, un host sofisticato può usare la [API Hosting CLR](https://msdn.microsoft.com/library/ms404385.aspx) per pianificare molti thread gestiti sullo stesso thread del sistema operativo o spostare un thread gestito tra thread del sistema operativo diverso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-179">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="2da3d-180">Stato corrente del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-180">The thread's current state.</span></span> <span data-ttu-id="2da3d-181">Per la durata della sua esistenza, un thread è sempre in uno o più degli stati definiti per il <xref:System.Threading.ThreadState> proprietà.</span><span class="sxs-lookup"><span data-stu-id="2da3d-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="2da3d-182">Un livello di priorità di pianificazione, definito dal <xref:System.Threading.ThreadPriority> proprietà.</span><span class="sxs-lookup"><span data-stu-id="2da3d-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="2da3d-183">Sebbene sia possibile impostare questo valore per richiedere la priorità del thread, non è garantito a essere rispettato dal sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="2da3d-184">Di sola lettura <xref:System.Threading.Thread.IsThreadPoolThread%2A> proprietà, che indica se un thread è un pool di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="2da3d-185">La proprietà <xref:System.Threading.Thread.IsBackground%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="2da3d-186">Per altre informazioni, vedere la [thread in primo piano e sfondo](#Foreground) sezione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="2da3d-187">L'esempio seguente illustra le funzionalità di threading semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="2da3d-188">Questo codice restituisce un output simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="2da3d-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="2da3d-189">Questo tipo è thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="2da3d-189">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
      <span data-ttu-id="2da3d-190">Thread e threading</span>
      <span class="sxs-lookup">
        <span data-stu-id="2da3d-190">Threads and Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">
      <span data-ttu-id="2da3d-191">Utilizzo di thread e threading</span>
      <span class="sxs-lookup">
        <span data-stu-id="2da3d-191">Using Threads and Threading</span>
      </span>
    </related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96">
      <span data-ttu-id="2da3d-192">Origine di riferimento per la classe Thread</span>
      <span class="sxs-lookup">
        <span data-stu-id="2da3d-192">Reference Source for the Thread Class</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-193">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="2da3d-194">Delegato che rappresenta i metodi da richiamare quando inizia l'esecuzione di questo thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-194">A delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-195">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />, specificando un delegato che consente di passare un oggetto al thread quando quest'ultimo viene avviato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-196">Un thread non viene avviata l'esecuzione al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="2da3d-197">Per pianificare l'esecuzione del thread, chiamare il <xref:System.Threading.Thread.Start%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="2da3d-198">Per passare un oggetto dati per il thread, usare il <xref:System.Threading.Thread.Start%28System.Object%29> overload del metodo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-199">Gli utenti di Visual Basic è possono omettere il <xref:System.Threading.ThreadStart> costruttore durante la creazione di un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="2da3d-200">Usare la `AddressOf` operatore quando si passa il metodo, ad esempio `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="2da3d-201">Visual Basic chiama automaticamente il <xref:System.Threading.ThreadStart> costruttore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-202">L'esempio seguente illustra la sintassi per creare e utilizzare un <xref:System.Threading.ParameterizedThreadStart> delegato con un metodo statico e un metodo di istanza.</span><span class="sxs-lookup"><span data-stu-id="2da3d-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da3d-203">
            <paramref name="start" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-203">
              <paramref name="start" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">
          <span data-ttu-id="2da3d-204">Creazione di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-204">Creating Threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="2da3d-205">Delegato <see cref="T:System.Threading.ThreadStart" /> che rappresenta i metodi da richiamare quando inizia l'esecuzione di questo thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-206">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-207">Un thread non viene avviata l'esecuzione al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="2da3d-208">Per pianificare l'esecuzione del thread, chiamare il <xref:System.Threading.Thread.Start%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-209">Gli utenti di Visual Basic è possono omettere il <xref:System.Threading.ThreadStart> costruttore durante la creazione di un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="2da3d-210">Usare la `AddressOf` operatore quando si passa ad esempio il metodo `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="2da3d-211">Visual Basic chiama automaticamente il <xref:System.Threading.ThreadStart> costruttore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-212">Esempio di codice seguente viene illustrato come creare un thread che esegue un metodo statico.</span><span class="sxs-lookup"><span data-stu-id="2da3d-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="2da3d-213">Esempio di codice seguente viene illustrato come creare un thread che esegue un metodo di istanza.</span><span class="sxs-lookup"><span data-stu-id="2da3d-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da3d-214">Il valore del parametro <paramref name="start" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-214">The <paramref name="start" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">
          <span data-ttu-id="2da3d-215">Creazione di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-215">Creating Threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="2da3d-216">Delegato <see cref="T:System.Threading.ParameterizedThreadStart" /> che rappresenta i metodi da richiamare quando inizia l'esecuzione di questo thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <param name="maxStackSize">
          <span data-ttu-id="2da3d-217">Dimensione massima dello stack, in byte, usata dal thread oppure 0 per usare la dimensione massima predefinita specificata nell'intestazione del file eseguibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span>
          </span>
          <span data-ttu-id="2da3d-218">Importante   Per il codice parzialmente attendibile, <c>maxStackSize</c> viene ignorato se è maggiore delle dimensioni predefinite dello stack.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-218">Important   For partially trusted code, <c>maxStackSize</c> is ignored if it is greater than the default stack size.</span>
          </span>
          <span data-ttu-id="2da3d-219">Non viene generata alcuna eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-219">No exception is thrown.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-220">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />, specificando un delegato che consente di passare un oggetto al thread quando quest'ultimo viene avviato e specificando la dimensione massima dello stack per il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-221">Evitare di utilizzare questo overload del costruttore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="2da3d-222">La dimensione predefinita usata dal <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> overload del costruttore è la dimensione dello stack consigliati per i thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="2da3d-223">Se un thread ha problemi di memoria, la causa più probabile è un errore di programmazione, ad esempio una ricorsione infinita.</span><span class="sxs-lookup"><span data-stu-id="2da3d-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-224">Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]only completamente attendibile il codice può impostare `maxStackSize` su un valore che è maggiore della dimensione dello stack predefinito (1 megabyte).</span><span class="sxs-lookup"><span data-stu-id="2da3d-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="2da3d-225">Se viene specificato un valore più grande per `maxStackSize` durante l'esecuzione di codice con attendibilità parziale, `maxStackSize` viene ignorato e viene usata la dimensione predefinita.</span><span class="sxs-lookup"><span data-stu-id="2da3d-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="2da3d-226">Non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-226">No exception is thrown.</span></span> <span data-ttu-id="2da3d-227">Il codice a qualsiasi livello di attendibilità può impostare `maxStackSize` su un valore minore di dimensioni predefinite dello stack.</span><span class="sxs-lookup"><span data-stu-id="2da3d-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-228">Se si sviluppa una libreria completamente attendibile che verrà usata da codice parzialmente attendibile, ed è necessario avviare un thread che richiede uno stack di grandi dimensioni, deve asserire l'attendibilità prima di creare il thread o la dimensione predefinita verrà usata.</span><span class="sxs-lookup"><span data-stu-id="2da3d-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="2da3d-229">Non eseguire questa operazione a meno che non è controllare completamente il codice eseguito sul thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="2da3d-230">Se `maxStackSize` è minore rispetto alla dimensione minima dello stack, viene usata la dimensione minima dello stack.</span><span class="sxs-lookup"><span data-stu-id="2da3d-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="2da3d-231">Se `maxStackSize` non è un multiplo della dimensione della pagina, viene arrotondato al multiplo successivo più grande delle dimensioni della pagina.</span><span class="sxs-lookup"><span data-stu-id="2da3d-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="2da3d-232">Ad esempio, se si usa la versione 2.0 di .NET Framework in Windows Vista, 256KB (262.144 byte) è la dimensione minima dello stack e le dimensioni della pagina sono 64KB (65.536 byte).</span><span class="sxs-lookup"><span data-stu-id="2da3d-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-233">Nelle versioni di Microsoft Windows precedenti a Windows XP e Windows Server 2003, `maxStackSize` viene ignorato e viene usata la dimensione specificata nell'intestazione del file eseguibile.</span><span class="sxs-lookup"><span data-stu-id="2da3d-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="2da3d-234">Se si specifica una dimensione dello stack molto piccolo, si potrebbe essere necessario disabilitare l'individuazione tramite probe dall'overflow dello stack.</span><span class="sxs-lookup"><span data-stu-id="2da3d-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="2da3d-235">Quando lo stack è vincolato gravi, l'individuazione tramite probe stesso causare un overflow dello stack.</span><span class="sxs-lookup"><span data-stu-id="2da3d-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="2da3d-236">Per disabilitare l'individuazione tramite probe dello stack overflow, aggiungere quanto segue al file di configurazione dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da3d-237">
            <paramref name="start" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-237">
              <paramref name="start" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2da3d-238">
            <paramref name="maxStackSize" /> è minore di zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-238">
              <paramref name="maxStackSize" /> is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="2da3d-239">Delegato <see cref="T:System.Threading.ThreadStart" /> che rappresenta i metodi da richiamare quando inizia l'esecuzione di questo thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span>
          </span>
        </param>
        <param name="maxStackSize">
          <span data-ttu-id="2da3d-240">Dimensione massima dello stack, in byte, usata dal thread oppure 0 per usare la dimensione massima predefinita specificata nell'intestazione del file eseguibile.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span>
          </span>
          <span data-ttu-id="2da3d-241">Importante   Per il codice parzialmente attendibile, <c>maxStackSize</c> viene ignorato se è maggiore delle dimensioni predefinite dello stack.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-241">Important   For partially trusted code, <c>maxStackSize</c> is ignored if it is greater than the default stack size.</span>
          </span>
          <span data-ttu-id="2da3d-242">Non viene generata alcuna eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-242">No exception is thrown.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-243">Inizializza una nuova istanza della classe <see cref="T:System.Threading.Thread" />, specificando la dimensione massima dello stack per il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-244">Evitare di utilizzare questo overload del costruttore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="2da3d-245">La dimensione predefinita usata dal <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> overload del costruttore è la dimensione dello stack consigliati per i thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="2da3d-246">Se un thread ha problemi di memoria, la causa più probabile è un errore di programmazione, ad esempio una ricorsione infinita.</span><span class="sxs-lookup"><span data-stu-id="2da3d-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-247">Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]only completamente attendibile il codice può impostare `maxStackSize` su un valore che è maggiore della dimensione dello stack predefinito (1 megabyte).</span><span class="sxs-lookup"><span data-stu-id="2da3d-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="2da3d-248">Se viene specificato un valore più grande per `maxStackSize` durante l'esecuzione di codice con attendibilità parziale, `maxStackSize` viene ignorato e viene usata la dimensione predefinita.</span><span class="sxs-lookup"><span data-stu-id="2da3d-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="2da3d-249">Non viene generata alcuna eccezione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-249">No exception is thrown.</span></span> <span data-ttu-id="2da3d-250">Il codice a qualsiasi livello di attendibilità può impostare `maxStackSize` su un valore minore di dimensioni predefinite dello stack.</span><span class="sxs-lookup"><span data-stu-id="2da3d-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-251">Se si sviluppa una libreria completamente attendibile che verrà usata da codice parzialmente attendibile, ed è necessario avviare un thread che richiede uno stack di grandi dimensioni, deve asserire l'attendibilità prima di creare il thread o la dimensione predefinita verrà usata.</span><span class="sxs-lookup"><span data-stu-id="2da3d-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="2da3d-252">Non eseguire questa operazione a meno che non è controllare completamente il codice eseguito sul thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="2da3d-253">Se `maxStackSize` è minore rispetto alla dimensione minima dello stack, viene usata la dimensione minima dello stack.</span><span class="sxs-lookup"><span data-stu-id="2da3d-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="2da3d-254">Se `maxStackSize` non è un multiplo della dimensione della pagina, viene arrotondato al multiplo successivo più grande delle dimensioni della pagina.</span><span class="sxs-lookup"><span data-stu-id="2da3d-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="2da3d-255">Ad esempio, se si usa la versione 2.0 di .NET Framework in Windows Vista, 256KB (262.144 byte) è la dimensione minima dello stack e le dimensioni della pagina sono 64KB (65.536 byte).</span><span class="sxs-lookup"><span data-stu-id="2da3d-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-256">Nelle versioni di Microsoft Windows precedenti a Windows XP e Windows Server 2003, `maxStackSize` viene ignorato e viene usata la dimensione specificata nell'intestazione del file eseguibile.</span><span class="sxs-lookup"><span data-stu-id="2da3d-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="2da3d-257">Se si specifica una dimensione dello stack molto piccolo, si potrebbe essere necessario disabilitare l'individuazione tramite probe dall'overflow dello stack.</span><span class="sxs-lookup"><span data-stu-id="2da3d-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="2da3d-258">Quando lo stack è vincolato gravi, l'individuazione tramite probe stesso causare un overflow dello stack.</span><span class="sxs-lookup"><span data-stu-id="2da3d-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="2da3d-259">Per disabilitare l'individuazione tramite probe dello stack overflow, aggiungere quanto segue al file di configurazione dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da3d-260">
            <paramref name="start" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-260">
              <paramref name="start" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2da3d-261">
            <paramref name="maxStackSize" /> è minore di zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-261">
              <paramref name="maxStackSize" /> is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-262">Genera un'eccezione <see cref="T:System.Threading.ThreadAbortException" /> nel thread in cui viene richiamato, per iniziare il processo di terminazione del thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span>
          </span>
          <span data-ttu-id="2da3d-263">La chiamata a questo metodo in genere termina il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-263">Calling this method usually terminates the thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-264">Genera un'eccezione <see cref="T:System.Threading.ThreadAbortException" /> nel thread in cui viene richiamato, per iniziare il processo di terminazione del thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-264">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span>
          </span>
          <span data-ttu-id="2da3d-265">La chiamata a questo metodo in genere termina il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-265">Calling this method usually terminates the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-266">Quando questo metodo viene richiamato su un thread, il sistema genera un <xref:System.Threading.ThreadAbortException> nel thread per interromperla.</span><span class="sxs-lookup"><span data-stu-id="2da3d-266">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="2da3d-267">`ThreadAbortException` è un'eccezione speciale che può essere intercettata dal codice dell'applicazione, ma viene generata nuovamente alla fine del `catch` bloccare a meno che non <xref:System.Threading.Thread.ResetAbort%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-267">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="2da3d-268">`ResetAbort` Annulla la richiesta di interruzione e impedisce il `ThreadAbortException` di terminazione del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-268">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="2da3d-269">Considerate `finally` blocchi vengono eseguiti prima dell'interruzione del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-269">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-270">Quando un thread chiama `Abort` su se stesso, l'effetto è simile a generare un'eccezione; il <xref:System.Threading.ThreadAbortException> avviene immediatamente, e il risultato è prevedibile.</span><span class="sxs-lookup"><span data-stu-id="2da3d-270">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="2da3d-271">Tuttavia, se un thread chiama `Abort` in un altro thread, viene interrotto qualsiasi riga di codice è in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-271">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="2da3d-272">È anche possibile che un costruttore statico potrebbe essere interrotto.</span><span class="sxs-lookup"><span data-stu-id="2da3d-272">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="2da3d-273">In rari casi, ciò potrebbe impedire le istanze di tale classe creati nel dominio dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-273">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="2da3d-274">Nelle versioni 1.0 e 1.1 di .NET Framework, è probabile il thread si interrompa mentre un `finally` blocco viene eseguito, nel qual caso il `finally` blocco viene interrotta.</span><span class="sxs-lookup"><span data-stu-id="2da3d-274">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="2da3d-275">Il thread non è garantito da interrompere immediatamente oppure affatto.</span><span class="sxs-lookup"><span data-stu-id="2da3d-275">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="2da3d-276">Questa situazione può verificarsi se un thread viene eseguita una quantità illimitata di calcolo nel `finally` blocchi che vengono chiamati come parte della procedura di interruzione, in tal modo all'infinito ritardando l'interruzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-276">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="2da3d-277">Per attendere finché un thread è stata interrotta, è possibile chiamare il <xref:System.Threading.Thread.Join%2A> metodo sul thread dopo la chiamata di <xref:System.Threading.Thread.Abort%2A> (metodo), ma non è garantito che termina l'attesa.</span><span class="sxs-lookup"><span data-stu-id="2da3d-277">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-278">Il thread che chiama <xref:System.Threading.Thread.Abort%2A> potrebbero bloccare se il thread che è stata interrotta in un'area protetta di codice, ad esempio un `catch` blocco `finally` blocco o area a esecuzione vincolata.</span><span class="sxs-lookup"><span data-stu-id="2da3d-278">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="2da3d-279">Se il thread che chiama <xref:System.Threading.Thread.Abort%2A> mantiene un blocco che richiede il thread interrotto, può verificarsi un deadlock.</span><span class="sxs-lookup"><span data-stu-id="2da3d-279">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="2da3d-280">Se `Abort` viene chiamato su un thread che non è stato avviato, il thread verrà interrotta quando <xref:System.Threading.Thread.Start%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-280">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="2da3d-281">Se `Abort` viene chiamato su un thread è bloccato o è in stato di sospensione, il thread viene interrotto e quindi interrotto.</span><span class="sxs-lookup"><span data-stu-id="2da3d-281">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="2da3d-282">Se `Abort` viene chiamato su un thread che è stata sospesa, una <xref:System.Threading.ThreadStateException> generata nel thread che ha chiamato <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState.AbortRequested> viene aggiunto al <xref:System.Threading.Thread.ThreadState%2A> proprietà del thread interrotto.</span><span class="sxs-lookup"><span data-stu-id="2da3d-282">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="2da3d-283">Oggetto <xref:System.Threading.ThreadAbortException> non viene generata nel thread sospeso finché non <xref:System.Threading.Thread.Resume%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-283">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="2da3d-284">Se `Abort` viene chiamato su un thread gestito durante l'esecuzione di codice non gestito, un `ThreadAbortException` non viene generata fino a quando il thread viene restituito al codice gestito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-284">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="2da3d-285">Se due chiamate a `Abort` provengono allo stesso tempo, è possibile che una chiamata impostare le informazioni sullo stato e l'altra per eseguire il `Abort`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-285">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="2da3d-286">Tuttavia, un'applicazione non è in grado di rilevare questa situazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-286">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="2da3d-287">Dopo aver `Abort` viene richiamato su un thread, include lo stato del thread <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-287">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="2da3d-288">Dopo che il thread è stato terminato a seguito di una chiamata al `Abort`, viene modificato lo stato del thread in <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-288">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="2da3d-289">Con autorizzazioni sufficienti, un thread che è la destinazione di un' `Abort` può annullare l'interruzione utilizzando il `ResetAbort` (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-289">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="2da3d-290">Per un esempio in cui viene illustrato come chiamare le `ResetAbort` metodo, vedere il `ThreadAbortException` classe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-290">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="2da3d-291">Solo .NET Core: questo membro non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-291">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-292">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-292">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-293">Il thread che si sta interrompendo è attualmente sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-293">The thread that is being aborted is currently suspended.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da3d-294">per operazioni avanzate sui thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-294">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="2da3d-295">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-295">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="2da3d-296">Thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-296">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">
          <span data-ttu-id="2da3d-297">Utilizzo di thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-297">Using threads and threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">
          <span data-ttu-id="2da3d-298">Eliminazione definitiva di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-298">Destroying threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">
          <span data-ttu-id="2da3d-299">Oggetto che contiene informazioni specifiche dell'applicazione, ad esempio lo stato, che possono essere usate dal thread interrotto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-299">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-300">Genera un'eccezione <see cref="T:System.Threading.ThreadAbortException" /> nel thread in cui viene richiamato per iniziare il processo di terminazione del thread fornendo anche informazioni sull'eccezione relative alla terminazione del thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-300">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span>
          </span>
          <span data-ttu-id="2da3d-301">La chiamata a questo metodo in genere termina il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-301">Calling this method usually terminates the thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-302">Quando questo metodo viene richiamato su un thread, il sistema genera un <xref:System.Threading.ThreadAbortException> nel thread per interromperla.</span><span class="sxs-lookup"><span data-stu-id="2da3d-302">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="2da3d-303">`ThreadAbortException` è un'eccezione speciale che può essere intercettata dal codice dell'applicazione, ma viene generata nuovamente alla fine del `catch` bloccare a meno che non <xref:System.Threading.Thread.ResetAbort%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-303">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="2da3d-304">`ResetAbort` Annulla la richiesta di interruzione e impedisce il `ThreadAbortException` di terminazione del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-304">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="2da3d-305">Considerate `finally` blocchi vengono eseguiti prima dell'interruzione del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-305">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-306">Quando un thread chiama `Abort` su se stesso, l'effetto è simile a generare un'eccezione; il <xref:System.Threading.ThreadAbortException> avviene immediatamente, e il risultato è prevedibile.</span><span class="sxs-lookup"><span data-stu-id="2da3d-306">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="2da3d-307">Tuttavia, se un thread chiama `Abort` in un altro thread, viene interrotto qualsiasi riga di codice è in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-307">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="2da3d-308">È probabile che venga interrotto un costruttore statico.</span><span class="sxs-lookup"><span data-stu-id="2da3d-308">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="2da3d-309">In rari casi, ciò potrebbe impedire le istanze di tale classe creati nel dominio dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-309">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="2da3d-310">Nelle versioni 1.0 e 1.1 di .NET Framework, è probabile il thread si interrompa mentre un `finally` blocco viene eseguito, nel qual caso il `finally` blocco viene interrotta.</span><span class="sxs-lookup"><span data-stu-id="2da3d-310">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="2da3d-311">Il thread non è garantito da interrompere immediatamente oppure affatto.</span><span class="sxs-lookup"><span data-stu-id="2da3d-311">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="2da3d-312">Questa situazione può verificarsi se un thread viene eseguita una quantità illimitata di calcolo nel `finally` blocchi che vengono chiamati come parte della procedura di interruzione, in tal modo all'infinito ritardando l'interruzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-312">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="2da3d-313">Per attendere finché un thread è stata interrotta, è possibile chiamare il <xref:System.Threading.Thread.Join%2A> metodo sul thread dopo la chiamata di <xref:System.Threading.Thread.Abort%2A> (metodo), ma non c'è garanzia che termina l'attesa.</span><span class="sxs-lookup"><span data-stu-id="2da3d-313">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-314">Il thread che chiama <xref:System.Threading.Thread.Abort%2A> potrebbero bloccare se il thread che è stata interrotta in un'area protetta di codice, ad esempio un `catch` blocco `finally` blocco o area a esecuzione vincolata.</span><span class="sxs-lookup"><span data-stu-id="2da3d-314">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="2da3d-315">Se il thread che chiama <xref:System.Threading.Thread.Abort%2A> mantiene un blocco che richiede il thread interrotto, può verificarsi un deadlock.</span><span class="sxs-lookup"><span data-stu-id="2da3d-315">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="2da3d-316">Se `Abort` viene chiamato su un thread che non è stato avviato, il thread verrà interrotta quando <xref:System.Threading.Thread.Start%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-316">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="2da3d-317">Se `Abort` viene chiamato su un thread è bloccato o è in stato di sospensione, il thread viene interrotto e quindi interrotto.</span><span class="sxs-lookup"><span data-stu-id="2da3d-317">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="2da3d-318">Se `Abort` viene chiamato su un thread che è stata sospesa, una <xref:System.Threading.ThreadStateException> generata nel thread che ha chiamato <xref:System.Threading.Thread.Abort%2A>, e <xref:System.Threading.ThreadState.AbortRequested> viene aggiunto al <xref:System.Threading.Thread.ThreadState%2A> proprietà del thread interrotto.</span><span class="sxs-lookup"><span data-stu-id="2da3d-318">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="2da3d-319">Oggetto <xref:System.Threading.ThreadAbortException> non viene generata nel thread sospeso finché non <xref:System.Threading.Thread.Resume%2A> viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-319">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="2da3d-320">Se `Abort` viene chiamato su un thread gestito durante l'esecuzione di codice non gestito, un `ThreadAbortException` non viene generata fino a quando il thread viene restituito al codice gestito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-320">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="2da3d-321">Se due chiamate a `Abort` provengono allo stesso tempo, è possibile che una chiamata impostare le informazioni sullo stato e l'altra per eseguire il `Abort`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-321">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="2da3d-322">Tuttavia, un'applicazione non è in grado di rilevare questa situazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-322">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="2da3d-323">Dopo aver `Abort` viene richiamato su un thread, include lo stato del thread <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-323">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="2da3d-324">Dopo che il thread è stato terminato a seguito di una chiamata al `Abort`, viene modificato lo stato del thread in <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-324">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="2da3d-325">Con autorizzazioni sufficienti, un thread che è la destinazione di un' `Abort` può annullare l'interruzione utilizzando il `ResetAbort` (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-325">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="2da3d-326">Per un esempio in cui viene illustrato come chiamare le `ResetAbort` metodo, vedere il `ThreadAbortException` classe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-326">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-327">Esempio di codice seguente viene illustrato come passare informazioni a un thread che è stata interrotta.</span><span class="sxs-lookup"><span data-stu-id="2da3d-327">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="2da3d-328">Solo .NET Core: questo membro non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-328">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-329">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-329">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-330">Il thread che si sta interrompendo è attualmente sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-330">The thread that is being aborted is currently suspended.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da3d-331">per operazioni avanzate sui thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-331">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="2da3d-332">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-332">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="2da3d-333">Thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-333">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">
          <span data-ttu-id="2da3d-334">Utilizzo di thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-334">Using threads and threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">
          <span data-ttu-id="2da3d-335">Eliminazione definitiva di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-335">Destroying threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-336">Alloca uno slot di dati senza nome su tutti i thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-336">Allocates an unnamed data slot on all the threads.</span>
          </span>
          <span data-ttu-id="2da3d-337">Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-337">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-338">Slot di dati denominato allocato su tutti i thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-338">The allocated named data slot on all threads.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-339">.NET Framework fornisce due meccanismi per l'uso di archiviazione thread-local (TLS): i campi statici relativi ai thread (vale a dire, i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-339">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="2da3d-340">Campi statici relativi ai thread garantiscono prestazioni nettamente migliori rispetto agli slot di dati e abilitare il controllo dei tipi in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-340">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="2da3d-341">Per altre informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="2da3d-341">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="2da3d-342">Lo slot viene allocato su tutti i thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-342">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="2da3d-343">Thread di usano un meccanismo di memoria di archiviazione locale per archiviare i dati specifici di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-343">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="2da3d-344">Common language runtime alloca una matrice di archiviazione dei dati di più slot a ogni processo al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-344">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="2da3d-345">Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per il riutilizzo dopo la scadenza del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-345">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="2da3d-346">Gli slot di dati sono univoci per ogni thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-346">Data slots are unique per thread.</span></span> <span data-ttu-id="2da3d-347">Nessun altro thread (non lo è nemmeno un thread figlio) può ottenere i dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-347">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-348">In questa sezione sono riportati due esempi di codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-348">This section contains two code examples.</span></span> <span data-ttu-id="2da3d-349">Il primo esempio illustra come usare un campo contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-349">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-350">Nel secondo esempio viene illustrato come usare uno slot di dati per eseguire la stessa operazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-350">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="2da3d-351">**Primo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-351">**First Example**</span></span>  
  
 <span data-ttu-id="2da3d-352">Nell'esempio seguente viene illustrato come utilizzare un campo contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-352">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-353">Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-353">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="2da3d-354">**Secondo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-354">**Second Example**</span></span>  
  
 <span data-ttu-id="2da3d-355">Esempio di codice seguente viene illustrato come usare uno slot di dati per archiviare le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-355">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="2da3d-356">Thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-356">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="2da3d-357">Archiviazione locale del thread: slot di dati e campi statici relativi ai thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-357">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da3d-358">Nome dello slot di dati da allocare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-358">The name of the data slot to be allocated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-359">Alloca uno slot di dati denominato su tutti i thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-359">Allocates a named data slot on all threads.</span>
          </span>
          <span data-ttu-id="2da3d-360">Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-360">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-361">Slot di dati denominato allocato su tutti i thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-361">The allocated named data slot on all threads.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-362">.NET Framework fornisce due meccanismi per l'uso di archiviazione thread-local (TLS): i campi statici relativi ai thread (vale a dire, i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-362">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="2da3d-363">Campi statici relativi ai thread garantiscono prestazioni nettamente migliori rispetto agli slot di dati e abilitare il controllo dei tipi in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-363">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="2da3d-364">Per altre informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="2da3d-364">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="2da3d-365">Thread di usano un meccanismo di memoria di archiviazione locale per archiviare i dati specifici di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-365">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="2da3d-366">Common language runtime alloca una matrice di archiviazione dei dati di più slot a ogni processo al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-366">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="2da3d-367">Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per il riutilizzo dopo la scadenza del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-367">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="2da3d-368">Gli slot di dati sono univoci per ogni thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-368">Data slots are unique per thread.</span></span> <span data-ttu-id="2da3d-369">Nessun altro thread (non lo è nemmeno un thread figlio) può ottenere i dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-369">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="2da3d-370">Non è necessario usare il <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metodo per allocare uno slot di dati denominati, perché il <xref:System.Threading.Thread.GetNamedDataSlot%2A> metodo alloca lo slot, se non è già stato allocato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-370">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-371">Se il <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> viene usato il metodo, deve essere chiamato nel thread principale all'avvio del programma, perché viene generata un'eccezione se uno slot con il nome specificato è già stato allocato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-371">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="2da3d-372">Non è possibile per verificare se uno slot è già stato allocato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-372">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="2da3d-373">Gli slot allocati con questo metodo devono essere liberati con <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-373">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-374">In questa sezione sono riportati due esempi di codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-374">This section contains two code examples.</span></span> <span data-ttu-id="2da3d-375">Il primo esempio illustra come usare un campo contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-375">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-376">Nel secondo esempio viene illustrato come usare uno slot di dati per eseguire la stessa operazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-376">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="2da3d-377">**Primo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-377">**First Example**</span></span>  
  
 <span data-ttu-id="2da3d-378">Nell'esempio seguente viene illustrato come utilizzare un campo contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-378">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-379">Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-379">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="2da3d-380">**Secondo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-380">**Second Example**</span></span>  
  
 <span data-ttu-id="2da3d-381">Nell'esempio seguente viene illustrato come utilizzare uno slot di dati denominati per archiviare le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-381">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-382">Il codice di esempio non utilizza il <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> metodo, perché il <xref:System.Threading.Thread.GetNamedDataSlot%2A> metodo alloca lo slot, se non è già stato allocato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-382">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="2da3d-383">Se il <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> viene usato il metodo, deve essere chiamato nel thread principale all'avvio del programma.</span><span class="sxs-lookup"><span data-stu-id="2da3d-383">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da3d-384">Esiste già uno slot di dati denominato con il nome specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-384">A named data slot with the specified name already exists.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="2da3d-385">Thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-385">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="2da3d-386">Archiviazione locale del thread: slot di dati e campi statici relativi ai thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-386">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-387">Ottiene o imposta lo stato dell'apartment del thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-387">Gets or sets the apartment state of this thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-388">Uno dei valori di <see cref="T:System.Threading.ApartmentState" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-388">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span>
          </span>
          <span data-ttu-id="2da3d-389">Il valore iniziale è <see langword="Unknown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-389">The initial value is <see langword="Unknown" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-390">**Il <xref:System.Threading.Thread.ApartmentState%2A> proprietà è obsoleta.**</span><span class="sxs-lookup"><span data-stu-id="2da3d-390">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="2da3d-391">Le alternative non obsoleto sono le <xref:System.Threading.Thread.GetApartmentState%2A> metodo per recuperare lo stato dell'apartment e <xref:System.Threading.Thread.SetApartmentState%2A> metodo per impostare lo stato dell'apartment.</span><span class="sxs-lookup"><span data-stu-id="2da3d-391">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="2da3d-392">In .NET Framework versioni 1.0 e 1.1, il `ApartmentState` proprietà contrassegna un thread per indicare che sarà eseguito in un apartment a thread singolo o multithread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-392">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="2da3d-393">Questa proprietà può essere impostata quando il thread si trova il `Unstarted` o `Running` thread stato; tuttavia, è possibile specificare una sola volta per un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-393">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="2da3d-394">Se la proprietà non è stata impostata, restituisce `Unknown`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-394">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="2da3d-395">Tenta di utilizzare il <xref:System.Threading.Thread.ApartmentState%2A> proprietà per impostare lo stato dell'apartment di un thread il cui stato di apartment è già stata impostata viene ignorata.</span><span class="sxs-lookup"><span data-stu-id="2da3d-395">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="2da3d-396">Tuttavia, il <xref:System.Threading.Thread.SetApartmentState%2A> metodo genera un <xref:System.InvalidOperationException> in questo caso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-396">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-397">In .NET Framework versione 2.0, i nuovi thread vengono inizializzate come <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se lo stato di apartment non è stato impostato prima dell'avvio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-397">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="2da3d-398">Il thread principale dell'applicazione viene inizializzato su <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="2da3d-398">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="2da3d-399">È non possibile impostare non è più il thread principale dell'applicazione <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> impostando la <xref:System.Threading.ApartmentState?displayProperty=nameWithType> proprietà sulla prima riga del codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-399">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="2da3d-400">Usare il <xref:System.STAThreadAttribute> invece.</span><span class="sxs-lookup"><span data-stu-id="2da3d-400">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="2da3d-401">In .NET Framework versione 2.0, è possibile specificare il modello di threading COM per un'applicazione C++ utilizzando la [/CLRTHREADATTRIBUTE (Imposta attributo Thread di CLR)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) l'opzione del linker.</span><span class="sxs-lookup"><span data-stu-id="2da3d-401">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-402">Esempio di codice seguente viene illustrato come impostare lo stato dell'apartment di un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-402">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da3d-403">Viene effettuato un tentativo di impostare questa proprietà su uno stato che non è uno stato dell'apartment valido (uno stato diverso da apartment a thread singolo (<see langword="STA" />) o apartment con multithreading (<see langword="MTA" />)).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-403">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-404">Notifica a un host che l'esecuzione sta per entrare in un'area di codice in cui gli effetti di un'interruzione del thread o di un'eccezione non gestita possono rappresentare un rischio per altre attività nel dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-404">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-405">Gli host di common language runtime (CLR), ad esempio Microsoft SQL Server 2005, è possono stabilire criteri diversi per gli errori nelle aree critiche e non critici del codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-405">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="2da3d-406">Un'area critica è uno in cui gli effetti di un'eccezione non gestita o un'interruzione del thread potrebbero non essere limitati all'attività corrente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-406">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="2da3d-407">Al contrario, un annullamento o errore in un'area critica del codice interessa solo l'attività in cui si verifica l'errore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-407">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="2da3d-408">Si consideri ad esempio un'attività che tenta di allocare memoria durante un blocco viene mantenuto attivo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-408">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="2da3d-409">Se l'allocazione di memoria ha esito negativo, interrompere l'attività corrente non è sufficiente per garantire la stabilità del <xref:System.AppDomain>, poiché può esserci altre attività nel dominio dell'attesa del blocco stesso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-409">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="2da3d-410">Se l'attività corrente è terminata, il deadlock altre attività.</span><span class="sxs-lookup"><span data-stu-id="2da3d-410">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="2da3d-411">Quando si verifica un errore in un'area critica, l'host può decidere di scaricare l'intero <xref:System.AppDomain> anziché accettare il rischio di continuare l'esecuzione in uno stato potenzialmente instabile.</span><span class="sxs-lookup"><span data-stu-id="2da3d-411">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="2da3d-412">Per informare l'host che il codice sta entrando in un'area critica, chiamare <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-412">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="2da3d-413">Chiamare <xref:System.Threading.Thread.EndCriticalRegion%2A> quando l'esecuzione restituisce un'area critica del codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-413">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="2da3d-414">Con questo metodo nel codice in esecuzione in SQL Server 2005 è necessario il codice da eseguire a livello di protezione più elevato di host.</span><span class="sxs-lookup"><span data-stu-id="2da3d-414">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-415">Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A> metodi per dividere un blocco di codice in aree non critici e importanti.</span><span class="sxs-lookup"><span data-stu-id="2da3d-415">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-416">Notifica a un host che il codice gestito sta per eseguire istruzioni che dipendono dall'identità del thread fisico corrente del sistema operativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-416">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-417">Alcuni host di common language runtime, ad esempio Microsoft SQL Server 2005, gestione dei propri thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-417">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="2da3d-418">Un host che fornisce la gestione di thread può spostare un'attività in esecuzione da un thread fisico del sistema operativo a un altro in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="2da3d-418">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="2da3d-419">La maggior parte delle attività non sono interessate da questo passaggio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-419">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="2da3d-420">Tuttavia, alcune attività presentano affinità di thread, vale a dire dipendono dall'identità di un thread fisico del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-420">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="2da3d-421">Queste attività devono notificare all'host quando si esegue il codice che non deve essere spostato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-421">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="2da3d-422">Ad esempio, se l'applicazione chiama un'API di sistema per acquisire un sistema operativo di blocco che presenta affinità di thread, ad esempio CRITICAL_SECTION Win32, è necessario chiamare <xref:System.Threading.Thread.BeginThreadAffinity%2A> prima di acquisire il blocco e <xref:System.Threading.Thread.EndThreadAffinity%2A> dopo il rilascio del blocco.</span><span class="sxs-lookup"><span data-stu-id="2da3d-422">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="2da3d-423">Con questo metodo nel codice in esecuzione in SQL Server 2005 è necessario il codice da eseguire a livello di protezione più elevato di host.</span><span class="sxs-lookup"><span data-stu-id="2da3d-423">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-424">Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Threading.Thread.BeginThreadAffinity%2A> e <xref:System.Threading.Thread.EndThreadAffinity%2A> per notificare a un host in cui un blocco di codice dipende dall'identità di un thread fisico del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-424">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-425">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-425">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da3d-426">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-426">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da3d-427">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-427">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-428">Ottiene il contesto corrente in cui è in esecuzione il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-428">Gets the current context in which the thread is executing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-429">Oggetto <see cref="T:System.Runtime.Remoting.Contexts.Context" /> che rappresenta il contesto del thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-429">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-430">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-430">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da3d-431">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-431">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da3d-432">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-432">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-433">Ottiene o imposta le impostazioni cultura per il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-433">Gets or sets the culture for the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-434">Oggetto che rappresenta le impostazioni cultura per il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-434">An object that represents the culture for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-435">Il <xref:System.Globalization.CultureInfo> oggetto restituito da questa proprietà, insieme ai relativi oggetti associati, determinare il formato predefinito per le date, ore, numeri, i valori di valuta, l'ordinamento del testo, le convenzioni di maiuscole e minuscole e confronti tra stringhe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-435">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="2da3d-436">Vedere il <xref:System.Globalization.CultureInfo> classe per conoscere i nomi delle impostazioni cultura e le differenze tra le impostazioni cultura invariabili, neutre e specifiche, identificatori e le informazioni sulle impostazioni cultura modo influisce su domini applicazione e thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-436">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="2da3d-437">Vedere il <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> proprietà per scoprire come viene determinata dalle impostazioni cultura predefinite del thread e come gli utenti impostare informazioni sulle impostazioni cultura per i computer.</span><span class="sxs-lookup"><span data-stu-id="2da3d-437">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="2da3d-438">Il <xref:System.Threading.Thread.CurrentCulture> proprietà non funziona in modo affidabile quando usato con qualsiasi thread diverso da quello corrente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-438">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="2da3d-439">In .NET Framework, la lettura della proprietà è affidabile, anche se non quella di un thread diverso da quello corrente è.</span><span class="sxs-lookup"><span data-stu-id="2da3d-439">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="2da3d-440">In .NET Core, un' <xref:System.InvalidOperationException> viene generata se un thread tenta di leggere o scrivere i <xref:System.Threading.Thread.CurrentCulture> proprietà su un thread diverso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-440">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="2da3d-441">È consigliabile usare il <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> proprietà da recuperare e impostare le impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="2da3d-441">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="2da3d-442">Inizia con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], è possibile impostare il <xref:System.Threading.Thread.CurrentCulture%2A> proprietà a una lingua.</span><span class="sxs-lookup"><span data-stu-id="2da3d-442">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="2da3d-443">Infatti, il comportamento del <xref:System.Globalization.CultureInfo> classe è stata modificata: quando rappresenta impostazioni cultura neutre, i valori delle proprietà (in particolare, il <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, e <xref:System.Globalization.CultureInfo.TextInfo%2A> proprietà) ora riflettere le impostazioni cultura specifiche sono associata a impostazioni cultura di sistema.</span><span class="sxs-lookup"><span data-stu-id="2da3d-443">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="2da3d-444">Nelle versioni precedenti di .NET Framework, il <xref:System.Threading.Thread.CurrentCulture%2A> proprietà ha generato un <xref:System.NotSupportedException> eccezione quando è stata assegnata una lingua neutra.</span><span class="sxs-lookup"><span data-stu-id="2da3d-444">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="2da3d-445">Nell'esempio seguente mostra l'istruzione di threading che consente all'interfaccia utente di un'applicazione Windows Forms per visualizzare le impostazioni cultura che viene impostato nel Pannello di controllo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-445">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="2da3d-446">È necessario codice aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-446">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da3d-447">La proprietà è impostata su <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-447">The property is set to <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da3d-448">Solo .NET Core: la lettura o la scrittura delle impostazioni cultura di un thread da un altro thread non sono supportate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-448">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da3d-449">Per impostare la proprietà.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-449">for setting the property.</span>
          </span>
          <span data-ttu-id="2da3d-450">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-450">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-451">Ottiene o imposta l'entità corrente del thread (per la sicurezza basata sui ruoli).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-451">Gets or sets the thread's current principal (for role-based security).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-452">Valore <see cref="T:System.Security.Principal.IPrincipal" /> che rappresenta il contesto di sicurezza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-452">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2da3d-453">Esempio di codice seguente viene illustrato come impostare e recuperare l'entità di un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-453">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-454">Il chiamante non ha l'autorizzazione necessaria per impostare l'entità.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-454">The caller does not have the permission required to set the principal.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da3d-455">Per modificare l'oggetto principal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-455">to manipulate the principal object.</span>
          </span>
          <span data-ttu-id="2da3d-456">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-456">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-457">Ottiene il thread attualmente in esecuzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-457">Gets the currently running thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-458">Oggetto <see cref="T:System.Threading.Thread" /> che rappresenta il thread attualmente in esecuzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-458">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2da3d-459">Nell'esempio seguente crea un'attività che a sua volta crea 20 delle attività figlio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-459">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="2da3d-460">L'applicazione stessa, come anche ogni attività, chiama il `ShowThreadInformation` metodo, che usa il <xref:System.Threading.Thread.CurrentThread%2A> proprietà per visualizzare informazioni sul thread in cui è in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-460">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="2da3d-461">Ogni attività figlio genera numeri casuali di 1 milione compreso tra 1 e 1 milione e restituisce il valore medio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-461">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="2da3d-462">Le chiamate di attività padre la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metodo per assicurarsi di avranno completato le attività figlio prima di visualizzare la media restituita da ogni attività e calcolando la media dei mezzi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-462">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="2da3d-463">Si noti che mentre l'applicazione in esecuzione su un thread in primo piano, ogni attività viene eseguita in un pool di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-463">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-464">Ottiene o imposta le impostazioni cultura correnti usate da Gestione risorse per cercare le risorse specifiche delle impostazioni cultura in fase di esecuzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-464">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-465">Oggetto che rappresenta le impostazioni cultura correnti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-465">An object that represents the current culture.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-466">Le impostazioni cultura dell'interfaccia utente specificano le risorse di un'applicazione deve supportare l'input dell'utente e l'output e per impostazione predefinita è quello utilizzato per la lingua del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-466">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="2da3d-467">Vedere il <xref:System.Globalization.CultureInfo> classe per conoscere i nomi delle impostazioni cultura e le differenze tra le impostazioni cultura invariabili, neutre e specifiche, identificatori e le informazioni sulle impostazioni cultura modo influisce su domini applicazione e thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-467">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="2da3d-468">Vedere il <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> proprietà per informazioni su come viene determinata dalle impostazioni cultura dell'interfaccia utente predefinita del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-468">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="2da3d-469">Il <xref:System.Threading.Thread.CurrentUICulture> proprietà non funziona in modo affidabile quando usato con qualsiasi thread diverso da quello corrente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-469">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="2da3d-470">In .NET Framework, la lettura della proprietà è affidabile, anche se non quella di un thread diverso da quello corrente è.</span><span class="sxs-lookup"><span data-stu-id="2da3d-470">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="2da3d-471">In .NET Core, un' <xref:System.InvalidOperationException> viene generata se un thread tenta di leggere o scrivere i <xref:System.Threading.Thread.CurrentUICulture> proprietà su un thread diverso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-471">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="2da3d-472">È consigliabile usare il <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> proprietà da recuperare e impostare le impostazioni cultura correnti.</span><span class="sxs-lookup"><span data-stu-id="2da3d-472">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="2da3d-473">Il <xref:System.Globalization.CultureInfo> restituita da questa proprietà può essere una lingua neutra.</span><span class="sxs-lookup"><span data-stu-id="2da3d-473">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="2da3d-474">Impostazioni cultura non associate non devono essere utilizzate con i metodi di formattazione, ad esempio <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, e <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-474">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da3d-475">Usare la <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> metodo per ottenere le impostazioni cultura specifica, oppure utilizzare il <xref:System.Threading.Thread.CurrentCulture%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="2da3d-475">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-476">Il <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> Genera metodo <xref:System.ArgumentException> per le impostazioni cultura non associate "zh-Hant" ("zh-CHT") e "zh-Hans" ("zh-CHS").</span><span class="sxs-lookup"><span data-stu-id="2da3d-476">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-477">Nell'esempio seguente determina se la lingua delle impostazioni cultura dell'interfaccia utente del thread corrente è il francese.</span><span class="sxs-lookup"><span data-stu-id="2da3d-477">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="2da3d-478">In caso contrario, imposta le impostazioni cultura dell'interfaccia utente del thread corrente per inglese (Stati Uniti).</span><span class="sxs-lookup"><span data-stu-id="2da3d-478">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="2da3d-479">Esempio di codice seguente illustra l'istruzione di threading che consente all'interfaccia utente di visualizzare le impostazioni cultura che viene impostato nel Pannello di controllo Windows Form.</span><span class="sxs-lookup"><span data-stu-id="2da3d-479">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="2da3d-480">È necessario codice aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-480">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da3d-481">La proprietà è impostata su <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-481">The property is set to <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da3d-482">La proprietà è impostata su un nome delle impostazioni cultura che non può essere usato per individuare un file di risorse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-482">The property is set to a culture name that cannot be used to locate a resource file.</span>
          </span>
          <span data-ttu-id="2da3d-483">I nomi dei file di risorsa devono includere solo lettere, numeri, trattini o caratteri di sottolineatura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-483">Resource filenames must include only letters, numbers, hyphens or underscores.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da3d-484">Solo .NET Core: la lettura o la scrittura delle impostazioni cultura di un thread da un altro thread non sono supportate.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-484">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-485">Disattiva la pulizia automatica dei Runtime Callable Wrapper (RCW) per il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-485">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-486">Per impostazione predefinita, common language runtime (CLR) pulisce i runtime callable wrapper automaticamente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-486">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="2da3d-487">I messaggi pump CLR durante la pulitura, che potrebbe causare problemi di reentrancy per alcune applicazioni che soddisfano i criteri di insolito seguenti:</span><span class="sxs-lookup"><span data-stu-id="2da3d-487">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="2da3d-488">L'applicazione esegue la propria distribuzione di messaggi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-488">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="2da3d-489">L'applicazione deve controllare con precisione quando la distribuzione dei messaggi si verifica.</span><span class="sxs-lookup"><span data-stu-id="2da3d-489">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="2da3d-490">Tali applicazioni possono utilizzare il <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> metodo per impedire che in questo recupero automatico dei runtime callable wrapper CLR.</span><span class="sxs-lookup"><span data-stu-id="2da3d-490">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="2da3d-491">Quando questo metodo è stato chiamato su un thread, la pulizia automatica non può essere riabilitata per il thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-491">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="2da3d-492">Quando l'applicazione è pronta per pulire i runtime callable wrapper, utilizzare il <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> metodo per indicare al runtime per pulire tutti i runtime callable wrapper nel contesto corrente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-492">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="2da3d-493">La distribuzione dei messaggi si verifica durante l'esecuzione del metodo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-493">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da3d-494">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-494">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da3d-495">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-495">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-496">Notifica a un host che l'esecuzione sta per entrare in un'area di codice in cui gli effetti di un'interruzione del thread o di un'eccezione non gestita sono limitati all'attività corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-496">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-497">Gli host di common language runtime (CLR), ad esempio Microsoft SQL Server 2005, è possono stabilire criteri diversi per gli errori nelle aree critiche e non critici del codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-497">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="2da3d-498">Un'area critica è uno in cui gli effetti di un'eccezione non gestita o un'interruzione del thread potrebbero non essere limitati all'attività corrente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-498">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="2da3d-499">Al contrario, un annullamento o errore in un'area critica del codice interessa solo l'attività in cui si verifica l'errore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-499">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="2da3d-500">Si consideri ad esempio un'attività che tenta di allocare memoria durante un blocco viene mantenuto attivo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-500">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="2da3d-501">Se l'allocazione di memoria ha esito negativo, interrompere l'attività corrente non è sufficiente per garantire la stabilità del <xref:System.AppDomain>, poiché può esserci altre attività nel dominio dell'attesa del blocco stesso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-501">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="2da3d-502">Se l'attività corrente è terminata, il deadlock altre attività.</span><span class="sxs-lookup"><span data-stu-id="2da3d-502">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="2da3d-503">Quando si verifica un errore in un'area critica, l'host può decidere di scaricare l'intero <xref:System.AppDomain> anziché accettare il rischio di continuare l'esecuzione in uno stato potenzialmente instabile.</span><span class="sxs-lookup"><span data-stu-id="2da3d-503">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="2da3d-504">Per informare l'host che il codice sta entrando in un'area critica, chiamare <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-504">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="2da3d-505">Chiamare <xref:System.Threading.Thread.EndCriticalRegion%2A> quando l'esecuzione restituisce un'area critica del codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-505">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="2da3d-506">Con questo metodo nel codice in esecuzione in SQL Server 2005 è necessario il codice da eseguire a livello di protezione più elevato di host.</span><span class="sxs-lookup"><span data-stu-id="2da3d-506">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-507">Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Threading.Thread.BeginCriticalRegion%2A> e <xref:System.Threading.Thread.EndCriticalRegion%2A> metodi per dividere un blocco di codice in aree non critici e importanti.</span><span class="sxs-lookup"><span data-stu-id="2da3d-507">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-508">Notifica a un host che il codice gestito ha terminato l'esecuzione di istruzioni che dipendono dall'identità del thread fisico corrente del sistema operativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-508">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-509">Alcuni host di common language runtime, ad esempio Microsoft SQL Server 2005, gestione dei propri thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-509">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="2da3d-510">Un host che fornisce la gestione di thread può spostare un'attività in esecuzione da un thread fisico del sistema operativo a un altro in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="2da3d-510">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="2da3d-511">La maggior parte delle attività non sono interessate da questo passaggio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-511">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="2da3d-512">Tuttavia, alcune attività presentano affinità di thread, vale a dire dipendono dall'identità di un thread fisico del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-512">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="2da3d-513">Queste attività devono notificare all'host quando si esegue il codice che non deve essere spostato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-513">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="2da3d-514">Ad esempio, se l'applicazione chiama un'API di sistema per acquisire un sistema operativo di blocco che presenta affinità di thread, ad esempio CRITICAL_SECTION Win32, è necessario chiamare <xref:System.Threading.Thread.BeginThreadAffinity%2A> prima di acquisire il blocco e <xref:System.Threading.Thread.EndThreadAffinity%2A> dopo il rilascio del blocco.</span><span class="sxs-lookup"><span data-stu-id="2da3d-514">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="2da3d-515">Con questo metodo nel codice in esecuzione in SQL Server 2005 è necessario il codice da eseguire a livello di protezione più elevato di host.</span><span class="sxs-lookup"><span data-stu-id="2da3d-515">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-516">Nell'esempio seguente viene illustrato l'utilizzo dei <xref:System.Threading.Thread.BeginThreadAffinity%2A> e <xref:System.Threading.Thread.EndThreadAffinity%2A> per notificare a un host in cui un blocco di codice dipende dall'identità di un thread fisico del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-516">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-517">Il chiamante non dispone dell'autorizzazione richiesta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-517">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da3d-518">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-518">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da3d-519">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-519">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-520">Ottiene un oggetto <see cref="T:System.Threading.ExecutionContext" /> contenente informazioni sui diversi contesti del thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-520">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-521">Oggetto <see cref="T:System.Threading.ExecutionContext" /> che consolida le informazioni di contesto per il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-521">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-522">Il <xref:System.Threading.ExecutionContext> classe fornisce un singolo contenitore per tutte le informazioni relative a un thread logico di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-522">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="2da3d-523">Ciò include il contesto di sicurezza, contesto di chiamata, contesto di sincronizzazione, il contesto di localizzazione e contesto di transazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-523">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-524">Garantisce che le risorse vengano liberate e che vengano eseguite le altre operazioni di pulizia quando l'oggetto <see cref="T:System.Threading.Thread" /> viene recuperato da Garbage Collector.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-524">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-525">Il garbage collector chiama <xref:System.Threading.Thread.Finalize%2A> quando l'oggetto corrente è pronto per essere completato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-525">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da3d-526">Nome dello slot di dati da liberare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-526">The name of the data slot to be freed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-527">Elimina l'associazione tra un nome e uno slot per tutti i thread del processo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-527">Eliminates the association between a name and a slot, for all threads in the process.</span>
          </span>
          <span data-ttu-id="2da3d-528">Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-528">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-529">.NET Framework fornisce due meccanismi per l'uso di archiviazione thread-local (TLS): i campi statici relativi ai thread (vale a dire, i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-529">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="2da3d-530">Campi statici relativi ai thread garantiscono prestazioni nettamente migliori rispetto agli slot di dati e abilitare il controllo dei tipi in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-530">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="2da3d-531">Per altre informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="2da3d-531">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="2da3d-532">Dopo che un thread qualsiasi chiama `FreeNamedDataSlot`, un altro thread che chiama <xref:System.Threading.Thread.GetNamedDataSlot%2A> con lo stesso nome dovrà allocare un nuovo slot associato al nome.</span><span class="sxs-lookup"><span data-stu-id="2da3d-532">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="2da3d-533">Le chiamate successive a `GetNamedDataSlot` da qualsiasi thread restituirà il nuovo slot.</span><span class="sxs-lookup"><span data-stu-id="2da3d-533">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="2da3d-534">Tuttavia, uno o più thread che ha ancora un <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> restituito da una precedente chiamata a `GetNamedDataSlot` possono continuare a usare il vecchio slot.</span><span class="sxs-lookup"><span data-stu-id="2da3d-534">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="2da3d-535">Uno slot che è stato associato a un nome viene rilasciato solo quando ogni `LocalDataStoreSlot` che è stato ottenuto prima della chiamata al `FreeNamedDataSlot` è stato rilasciato e sottoposto a garbage collection.</span><span class="sxs-lookup"><span data-stu-id="2da3d-535">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="2da3d-536">Thread di usano un meccanismo di memoria di archiviazione locale per archiviare i dati specifici di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-536">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="2da3d-537">Common language runtime alloca una matrice di archiviazione dei dati di più slot a ogni processo al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-537">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="2da3d-538">Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per il riutilizzo dopo la scadenza del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-538">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="2da3d-539">Gli slot di dati sono univoci per ogni thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-539">Data slots are unique per thread.</span></span> <span data-ttu-id="2da3d-540">Nessun altro thread (non lo è nemmeno un thread figlio) può ottenere i dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-540">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-541">In questa sezione sono riportati due esempi di codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-541">This section contains two code examples.</span></span> <span data-ttu-id="2da3d-542">Il primo esempio illustra come usare un campo contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-542">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-543">Nel secondo esempio viene illustrato come usare uno slot di dati per eseguire la stessa operazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-543">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="2da3d-544">**Primo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-544">**First Example**</span></span>  
  
 <span data-ttu-id="2da3d-545">Nell'esempio seguente viene illustrato come utilizzare un campo contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-545">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-546">Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-546">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="2da3d-547">**Secondo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-547">**Second Example**</span></span>  
  
 <span data-ttu-id="2da3d-548">Nell'esempio seguente viene illustrato come utilizzare uno slot di dati denominati per archiviare le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-548">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="2da3d-549">Thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-549">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="2da3d-550">Archiviazione locale del thread: slot di dati e campi statici relativi ai thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-550">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-551">Restituisce un valore <see cref="T:System.Threading.ApartmentState" /> che indica lo stato dell'apartment.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-551">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-552">Uno dei valori di <see cref="T:System.Threading.ApartmentState" /> che indica lo stato dell'apartment del thread gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-552">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span>
          </span>
          <span data-ttu-id="2da3d-553">Il valore predefinito è <see cref="F:System.Threading.ApartmentState.Unknown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-553">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-554">Questo metodo, insieme al <xref:System.Threading.Thread.SetApartmentState%2A> metodo e il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo, sostituisce il <xref:System.Threading.Thread.ApartmentState%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="2da3d-554">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-555">L'esempio di codice seguente illustra il <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, e <xref:System.Threading.Thread.TrySetApartmentState%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-555">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="2da3d-556">L'esempio di codice crea un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-556">The code example creates a thread.</span></span> <span data-ttu-id="2da3d-557">Prima dell'avvio, il thread <xref:System.Threading.Thread.GetApartmentState%2A> consente di visualizzare iniziale <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> lo stato e <xref:System.Threading.Thread.SetApartmentState%2A> imposta lo stato su <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-557">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da3d-558">Il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo quindi restituisce `false` quando si prova a modificare lo stato su <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> perché lo stato di apartment è già impostato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-558">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="2da3d-559">Se fosse stata tentata la stessa operazione con <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> sarebbe stata generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-559">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="2da3d-560">Dopo che quest'ultimo viene avviato, il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo viene usato di nuovo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-560">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="2da3d-561">Questa volta viene genera <xref:System.Threading.ThreadStateException> perché il thread è già stato avviato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-561">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-562">Restituisce un oggetto <see cref="T:System.Threading.CompressedStack" /> che può essere usato per acquisire lo stack per il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-562">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-563">Nessuno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-563">None.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-564">Questo metodo non è più supportato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-564">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da3d-565">In tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-565">In all cases.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da3d-566">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-566">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da3d-567">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-567">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">
          <span data-ttu-id="2da3d-568">Oggetto <see cref="T:System.LocalDataStoreSlot" /> dal quale ottenere il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-568">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-569">Recupera il valore dallo slot specificato sul thread corrente, all'interno del dominio corrente del thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-569">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span>
          </span>
          <span data-ttu-id="2da3d-570">Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-570">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-571">Valore recuperato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-571">The retrieved value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-572">.NET Framework fornisce due meccanismi per l'uso di archiviazione thread-local (TLS): i campi statici relativi ai thread (vale a dire, i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-572">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="2da3d-573">Campi statici relativi ai thread garantiscono prestazioni nettamente migliori rispetto agli slot di dati e abilitare il controllo dei tipi in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-573">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="2da3d-574">Per altre informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="2da3d-574">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="2da3d-575">Thread di usano un meccanismo di memoria di archiviazione locale per archiviare i dati specifici di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-575">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="2da3d-576">Common language runtime alloca una matrice di archiviazione dei dati di più slot a ogni processo al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-576">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="2da3d-577">Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per il riutilizzo dopo la scadenza del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-577">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="2da3d-578">Gli slot di dati sono univoci per ogni thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-578">Data slots are unique per thread.</span></span> <span data-ttu-id="2da3d-579">Nessun altro thread (non lo è nemmeno un thread figlio) può ottenere i dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-579">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-580"><xref:System.Threading.Thread.GetData%2A> è un `Shared` metodo che si applica sempre al thread attualmente in esecuzione, anche se viene chiamato utilizzando una variabile che fa riferimento a un altro thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-580"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="2da3d-581">Per evitare confusione, usare il nome della classe quando si chiama `Shared` metodi: `Dim test As Object = Thread.GetData(testSlot)`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-581">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-582">In questa sezione sono riportati due esempi di codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-582">This section contains two code examples.</span></span> <span data-ttu-id="2da3d-583">Il primo esempio illustra come usare un campo contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-583">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-584">Nel secondo esempio viene illustrato come usare uno slot di dati per eseguire la stessa operazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-584">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="2da3d-585">**Primo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-585">**First Example**</span></span>  
  
 <span data-ttu-id="2da3d-586">Nell'esempio seguente viene illustrato come utilizzare un campo contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-586">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-587">Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-587">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="2da3d-588">**Secondo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-588">**Second Example**</span></span>  
  
 <span data-ttu-id="2da3d-589">Nell'esempio seguente viene illustrato come usare uno slot di dati per archiviare le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-589">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="2da3d-590">Thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-590">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="2da3d-591">Archiviazione locale del thread: slot di dati e campi statici relativi ai thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-591">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-592">Restituisce il dominio corrente in cui viene eseguito il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-592">Returns the current domain in which the current thread is running.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-593">Oggetto <see cref="T:System.AppDomain" /> che rappresenta il dominio applicazione corrente del thread in esecuzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-593">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2da3d-594">Esempio di codice seguente viene illustrato come recuperare il nome e ID del `AppDomain` in cui è in esecuzione il thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-594">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-595">Restituisce un identificatore di dominio applicazione univoco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-595">Returns a unique application domain identifier.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-596">Intero con segno a 32 bit che identifica in modo univoco il dominio applicazione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-596">A 32-bit signed integer uniquely identifying the application domain.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2da3d-597">Esempio di codice seguente viene illustrato come recuperare il nome e ID del `AppDomain` in cui è in esecuzione il thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-597">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-598">Restituisce un codice hash per il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-598">Returns a hash code for the current thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-599">Intero del valore del codice hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-599">An integer hash code value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-600">Il codice hash non deve necessariamente essere univoci.</span><span class="sxs-lookup"><span data-stu-id="2da3d-600">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="2da3d-601">Usare il <xref:System.Threading.Thread.ManagedThreadId%2A> proprietà se è necessario un identificatore univoco per un thread gestito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-601">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da3d-602">Nome dello slot di dati locale.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-602">The name of the local data slot.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-603">Cerca uno slot di dati denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-603">Looks up a named data slot.</span>
          </span>
          <span data-ttu-id="2da3d-604">Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-604">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-605">Oggetto <see cref="T:System.LocalDataStoreSlot" /> allocato per il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-605">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-606">.NET Framework fornisce due meccanismi per l'uso di archiviazione thread-local (TLS): i campi statici relativi ai thread (vale a dire, i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-606">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="2da3d-607">Campi statici relativi ai thread garantiscono prestazioni nettamente migliori rispetto agli slot di dati e abilitare il controllo dei tipi in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-607">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="2da3d-608">Per altre informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="2da3d-608">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="2da3d-609">Thread di usano un meccanismo di memoria di archiviazione locale per archiviare i dati specifici di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-609">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="2da3d-610">Common language runtime alloca una matrice di archiviazione dei dati di più slot a ogni processo al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-610">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="2da3d-611">Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per il riutilizzo dopo la scadenza del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-611">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="2da3d-612">Gli slot di dati sono univoci per ogni thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-612">Data slots are unique per thread.</span></span> <span data-ttu-id="2da3d-613">Nessun altro thread (non lo è nemmeno un thread figlio) può ottenere i dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-613">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="2da3d-614">Se lo slot denominato non esiste, viene allocato un nuovo slot.</span><span class="sxs-lookup"><span data-stu-id="2da3d-614">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="2da3d-615">Gli slot di dati denominati sono pubblici e possono essere modificati da qualsiasi utente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-615">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-616">In questa sezione sono riportati due esempi di codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-616">This section contains two code examples.</span></span> <span data-ttu-id="2da3d-617">Il primo esempio illustra come usare un campo contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-617">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-618">Nel secondo esempio viene illustrato come usare uno slot di dati per eseguire la stessa operazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-618">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="2da3d-619">**Primo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-619">**First Example**</span></span>  
  
 <span data-ttu-id="2da3d-620">Nell'esempio seguente viene illustrato come utilizzare un campo contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-620">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-621">Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-621">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="2da3d-622">**Secondo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-622">**Second Example**</span></span>  
  
 <span data-ttu-id="2da3d-623">Nell'esempio seguente viene illustrato come utilizzare uno slot di dati denominati per archiviare le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-623">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="2da3d-624">Thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-624">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="2da3d-625">Archiviazione locale del thread: slot di dati e campi statici relativi ai thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-625">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-626">Interrompe un thread il cui stato è <see langword="WaitSleepJoin" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-626">Interrupts a thread that is in the <see langword="WaitSleepJoin" /> thread state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-627">Se il thread non è attualmente bloccato in attesa, sospensione o di stato di join, verrà interrotto quando si è iniziato il blocco.</span><span class="sxs-lookup"><span data-stu-id="2da3d-627">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="2da3d-628"><xref:System.Threading.ThreadInterruptedException> viene generata nel thread interrotto, ma non prima del blocco del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-628"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="2da3d-629">Se il thread si blocca mai, non viene mai generata l'eccezione e pertanto il thread potrebbe essere completato senza subire alcuna interruzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-629">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-630">Esempio di codice seguente viene illustrato il comportamento di un thread in esecuzione quando viene interrotto e successivamente viene bloccato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-630">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-631">Il chiamante non ha l'oggetto <see cref="T:System.Security.Permissions.SecurityPermission" /> appropriato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-631">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da3d-632">per operazioni avanzate sui thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-632">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="2da3d-633">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-633">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">
          <span data-ttu-id="2da3d-634">Sospensione e interruzione di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-634">Pausing and interrupting threads</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="2da3d-635">Stati dei thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-635">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-636">Ottiene un valore che indica lo stato di esecuzione del thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-636">Gets a value indicating the execution status of the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-637">Viene restituito <see langword="true" /> se il thread è stato avviato, ma non è terminato normalmente o è stato interrotto. In caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-637">
              <see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-638">Ottiene o imposta un valore che indica se il thread viene eseguito in background.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-638">Gets or sets a value indicating whether or not a thread is a background thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-639">
            <see langword="true" /> se il thread viene o verrà eseguito in background; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-639">
              <see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-640">Un thread è un thread in background o un thread in primo piano.</span><span class="sxs-lookup"><span data-stu-id="2da3d-640">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="2da3d-641">I thread in background sono identici ai thread in primo piano, ad eccezione del fatto che i thread in background non impediscono a un processo di terminazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-641">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="2da3d-642">Dopo avere terminato tutti i thread in primo piano che appartengono a un processo, common language runtime termina il processo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-642">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="2da3d-643">I thread in background rimanenti vengono arrestati e non viene completata.</span><span class="sxs-lookup"><span data-stu-id="2da3d-643">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="2da3d-644">Per impostazione predefinita, i thread seguenti eseguono in primo piano (vale a dire loro <xref:System.Threading.Thread.IsBackground%2A> restituisce proprietà `false`):</span><span class="sxs-lookup"><span data-stu-id="2da3d-644">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="2da3d-645">Il thread principale (o thread principale dell'applicazione).</span><span class="sxs-lookup"><span data-stu-id="2da3d-645">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="2da3d-646">Tutti i thread creati chiamando un <xref:System.Threading.Thread> costruttore della classe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-646">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="2da3d-647">Per impostazione predefinita, i thread seguenti eseguono in background (vale a dire loro <xref:System.Threading.Thread.IsBackground%2A> restituisce proprietà `true`):</span><span class="sxs-lookup"><span data-stu-id="2da3d-647">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="2da3d-648">Thread del pool di thread, costituiti da un pool di thread di lavoro gestiti dal runtime.</span><span class="sxs-lookup"><span data-stu-id="2da3d-648">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="2da3d-649">È possibile configurare il lavoro del pool e la pianificazione del thread nel pool di thread usando il <xref:System.Threading.ThreadPool> classe.</span><span class="sxs-lookup"><span data-stu-id="2da3d-649">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="2da3d-650">Eseguire automaticamente operazioni asincrone basate su attività nel pool di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-650">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="2da3d-651">Tutti i thread che accedono all'ambiente di esecuzione gestita dal codice non gestito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-651">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-652">Nell'esempio seguente viene confrontato il comportamento dei thread in primo piano e sfondo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-652">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="2da3d-653">Crea un thread in primo piano e un thread in background.</span><span class="sxs-lookup"><span data-stu-id="2da3d-653">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="2da3d-654">Il thread in primo piano mantiene il processo in esecuzione fino alla completa relativa `for` ciclo e viene terminato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-654">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="2da3d-655">Tuttavia, come illustrato nell'output dell'esempio, perché il thread in primo piano ha terminato l'esecuzione, il processo viene terminato prima che il thread in background è stata completata l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-655">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-656">Thread inattivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-656">The thread is dead.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md">
          <span data-ttu-id="2da3d-657">Thread in primo piano e in background</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-657">Foreground and Background Threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-658">Ottiene un valore che indica se un thread appartiene o meno al pool di thread gestiti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-658">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-659">
            <see langword="true" /> se il thread appartiene al pool di thread gestiti; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-659">
              <see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-660">Per altre informazioni, vedere [pool di thread gestiti](~/docs/standard/threading/the-managed-thread-pool.md).</span><span class="sxs-lookup"><span data-stu-id="2da3d-660">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-661">Esempio di codice seguente viene illustrato come determinare se un thread dal pool di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-661">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">
          <span data-ttu-id="2da3d-662">Pool di thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-662">The Managed Thread Pool</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-663">Blocca il thread chiamante fino al termine del thread rappresentato da questa istanza.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-663">Blocks the calling thread until the thread represented by this instance terminates.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-664">Blocca il thread chiamante finché non termina il thread rappresentato da questa istanza, pur continuando a eseguire la distribuzione di <see langword="SendMessage" /> e COM standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-664">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-665"><xref:System.Threading.Thread.Join%2A> è un metodo di sincronizzazione che blocca il thread chiamante (vale a dire, il thread che chiama il metodo) finché il thread la cui <xref:System.Threading.Thread.Join%2A> viene chiamato il metodo è stata completata.</span><span class="sxs-lookup"><span data-stu-id="2da3d-665"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="2da3d-666">Usare questo metodo per garantire che un thread è stato terminato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-666">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="2da3d-667">Il chiamante si bloccherà all'infinito se non viene terminato il thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-667">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="2da3d-668">Nell'esempio seguente, il `Thread1` thread chiama il <xref:System.Threading.Thread.Join> metodo `Thread2`, determinando in tal modo `Thread1` per bloccare fino al `Thread2` è stata completata.</span><span class="sxs-lookup"><span data-stu-id="2da3d-668">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="2da3d-669">Se il thread ha già terminato quando <xref:System.Threading.Thread.Join%2A> viene chiamato il metodo restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-669">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="2da3d-670">Non chiamare mai il <xref:System.Threading.Thread.Join%2A> metodo del <xref:System.Threading.Thread> oggetto che rappresenta il thread corrente dal thread corrente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-670">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="2da3d-671">In questo modo, l'app bloccato perché il thread corrente è in attesa su se stesso in modo indefinito,</span><span class="sxs-lookup"><span data-stu-id="2da3d-671">This causes your app to hang because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="2da3d-672">Questo metodo viene modificato lo stato del thread chiamante per includere <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-672">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da3d-673">Non è possibile richiamare `Join` su un thread che si trova il <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> dello stato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-673">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-674">Il chiamante ha provato a eseguire il join di un thread che si trova nello stato <see cref="F:System.Threading.ThreadState.Unstarted" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-674">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="2da3d-675">Il thread viene interrotto durante l'attesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-675">The thread is interrupted while waiting.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="2da3d-676">Stati dei thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-676">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="2da3d-677">Tempo di attesa espresso in millisecondi prima che il thread venga terminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-677">The number of milliseconds to wait for the thread to terminate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-678">Blocca il thread chiamante finché non termina il thread rappresentato da questa istanza o finché non trascorre l'intervallo di tempo specificato, pur continuando a eseguire la distribuzione di SendMessage e COM standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-678">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-679">
            <see langword="true" /> se il thread è stato terminato; <see langword="false" /> se il thread non è stato terminato dopo l'intervallo di tempo specificato dal parametro <paramref name="millisecondsTimeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-679">
              <see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-680"><xref:System.Threading.Thread.Join%28System.Int32%29> è un metodo di sincronizzazione che blocca il thread chiamante (vale a dire, il thread che chiama il metodo) finché entrambi i thread la cui <xref:System.Threading.Thread.Join%2A> viene chiamato il metodo è stata completata o è trascorso l'intervallo di timeout.</span><span class="sxs-lookup"><span data-stu-id="2da3d-680"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="2da3d-681">Nell'esempio seguente, il `Thread1` thread chiama il <xref:System.Threading.Thread.Join> metodo `Thread2`, determinando in tal modo `Thread1` blocco finché `Thread2` è stata completata o allo scadere della 2 secondi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-681">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="2da3d-682">Se <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> viene specificato per il `millisecondsTimeout` parametro, questo metodo funziona in modo identico al <xref:System.Threading.Thread.Join> overload del metodo, tranne il valore restituito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-682">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="2da3d-683">Se il thread ha già terminato quando <xref:System.Threading.Thread.Join%2A> viene chiamato il metodo restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-683">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="2da3d-684">Questo metodo viene modificato lo stato del thread chiamante per includere <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-684">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da3d-685">Non è possibile richiamare `Join` su un thread che si trova il <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> dello stato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-685">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2da3d-686">Il valore di <paramref name="millisecondsTimeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-686">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-687">Il thread non è stato avviato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-687">The thread has not been started.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="2da3d-688">Stati dei thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-688">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="2da3d-689">Oggetto <see cref="T:System.TimeSpan" /> impostato sul tempo di attesa prima che il thread venga terminato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-689">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-690">Blocca il thread chiamante finché non termina il thread rappresentato da questa istanza o finché non trascorre l'intervallo di tempo specificato, pur continuando a eseguire la distribuzione di SendMessage e COM standard.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-690">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-691">
            <see langword="true" /> se il thread è stato terminato; <see langword="false" /> se il thread non è stato terminato dopo l'intervallo di tempo specificato dal parametro <paramref name="timeout" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-691">
              <see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-692"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> è un metodo di sincronizzazione che blocca il thread chiamante (vale a dire, il thread che chiama il metodo) finché entrambi i thread la cui <xref:System.Threading.Thread.Join%2A> viene chiamato il metodo è stata completata o è trascorso l'intervallo di timeout.</span><span class="sxs-lookup"><span data-stu-id="2da3d-692"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="2da3d-693">Nell'esempio seguente, il `Thread1` thread chiama il <xref:System.Threading.Thread.Join> metodo `Thread2`, determinando in tal modo `Thread1` blocco finché `Thread2` è stata completata o allo scadere della 2 secondi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-693">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="2da3d-694">Se <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> viene specificato per `timeout`, questo metodo si comporta in modo identico al <xref:System.Threading.Thread.Join> overload del metodo, tranne il valore restituito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-694">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="2da3d-695">Se il thread ha già terminato quando <xref:System.Threading.Thread.Join%2A> viene chiamato il metodo restituisce immediatamente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-695">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="2da3d-696">Questo metodo viene modificato lo stato del thread corrente per includere <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-696">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="2da3d-697">Non è possibile richiamare `Join` su un thread che si trova il <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> dello stato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-697">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-698">Esempio di codice seguente viene illustrato come utilizzare un `TimeSpan` valore con il `Join` (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-698">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2da3d-699">Il valore di <paramref name="timeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> in millisecondi oppure è maggiore di <see cref="F:System.Int32.MaxValue" /> in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-699">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-700">Il chiamante ha provato a eseguire il join di un thread che si trova nello stato <see cref="F:System.Threading.ThreadState.Unstarted" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-700">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="2da3d-701">Stati dei thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-701">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-702">Ottiene un identificatore univoco per il thread gestito corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-702">Gets a unique identifier for the current managed thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-703">Intero che rappresenta un identificatore univoco per il thread gestito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-703">An integer that represents a unique identifier for this managed thread.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-704">Un thread <xref:System.Threading.Thread.ManagedThreadId%2A> valore della proprietà che consente di identificare in modo univoco tale thread all'interno di un processo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-704">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="2da3d-705">Il valore della <xref:System.Threading.Thread.ManagedThreadId%2A> proprietà varia nel corso del tempo, anche se il codice non gestito che ospita common language runtime implementa i thread come un fiber.</span><span class="sxs-lookup"><span data-stu-id="2da3d-705">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-706">Sincronizza l'accesso alla memoria come segue: il processore che esegue il thread corrente non può riordinare le istruzioni in modo tale che gli accessi alla memoria prima della chiamata al metodo <see cref="M:System.Threading.Thread.MemoryBarrier" /> vengano eseguiti dopo quelli successivi alla chiamata al metodo <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-706">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-707"><xref:System.Threading.Thread.MemoryBarrier%2A> è necessario solo nei sistemi multiprocessore con ordinamento (ad esempio, un sistema che utilizza più processori Intel Itanium) della memoria vulnerabile.</span><span class="sxs-lookup"><span data-stu-id="2da3d-707"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="2da3d-708">Maggior parte dei casi, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione o il <xref:System.Threading.Monitor> classe offre metodi più semplici per sincronizzare i dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-708">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-709">Ottiene o imposta il nome del thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-709">Gets or sets the name of the thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-710">Stringa che contiene il nome del thread oppure <see langword="null" /> se non è stato impostato alcun nome.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-710">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-711">Questa proprietà è di scrittura-una volta.</span><span class="sxs-lookup"><span data-stu-id="2da3d-711">This property is write-once.</span></span> <span data-ttu-id="2da3d-712">Poiché il valore predefinito di un thread <xref:System.Threading.Thread.Name%2A> proprietà viene `null`, è possibile determinare se un nome è già stato esplicitamente assegnato al thread e confrontarlo con `null`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-712">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="2da3d-713">La stringa assegnata al <xref:System.Threading.Thread.Name%2A> proprietà può includere qualsiasi carattere Unicode.</span><span class="sxs-lookup"><span data-stu-id="2da3d-713">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-714">Nell'esempio seguente viene illustrato come denominare un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-714">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da3d-715">È stata richiesta un'operazOttiene o imposta il descrittore di sicurezza per questa voce.ione set, ma la proprietà <see langword="Name" /> è già stata impostata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-715">A set operation was requested, but the <see langword="Name" /> property has already been set.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-716">Ottiene o imposta un valore che indica la priorità di pianificazione di un thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-716">Gets or sets a value indicating the scheduling priority of a thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-717">Uno dei valori di <see cref="T:System.Threading.ThreadPriority" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-717">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span>
          </span>
          <span data-ttu-id="2da3d-718">Il valore predefinito è <see cref="F:System.Threading.ThreadPriority.Normal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-718">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-719">Un thread può essere assegnato uno dei seguente priorità <xref:System.Threading.ThreadPriority> valori:</span><span class="sxs-lookup"><span data-stu-id="2da3d-719">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="2da3d-720">I sistemi operativi non sono necessari per rispettare la priorità di un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-720">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-721">L'esempio seguente illustra il risultato della modifica della priorità di un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-721">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="2da3d-722">Vengono creati tre thread, la priorità di un thread viene impostata su <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, e la priorità di secondo è impostata su <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-722">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da3d-723">Ogni thread incrementa una variabile in un `while` ciclo e viene eseguito per un determinato periodo di tempo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-723">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-724">Il thread ha raggiunto uno stato finale, ad esempio <see cref="F:System.Threading.ThreadState.Aborted" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-724">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da3d-725">Il valore specificato per un'operazione set non è un valore <see cref="T:System.Threading.ThreadPriority" /> valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-725">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md">
          <span data-ttu-id="2da3d-726">Pianificazione di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-726">Scheduling threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-727">Annulla il metodo <see cref="M:System.Threading.Thread.Abort(System.Object)" /> richiesto per il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-727">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-728">Questo metodo può essere chiamato solo dal codice con le autorizzazioni appropriate.</span><span class="sxs-lookup"><span data-stu-id="2da3d-728">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="2da3d-729">Quando viene effettuata una chiamata a `Abort` per terminare un thread, il sistema genera un <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-729">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="2da3d-730">`ThreadAbortException` è un'eccezione speciale che può essere intercettata dal codice dell'applicazione, ma viene generata nuovamente alla fine del blocco catch, a meno che non `ResetAbort` viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-730">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="2da3d-731">`ResetAbort` Annulla la richiesta di interruzione e impedisce il `ThreadAbortException` di terminazione del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-731">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="2da3d-732">Visualizzare <xref:System.Threading.ThreadAbortException> per un esempio in cui viene illustrato come chiamare il `ResetAbort` (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-732">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="2da3d-733">Solo .NET Core: questo membro non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-733">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-734">
            <see langword="Abort" /> non è stato richiamato sul thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-734">
              <see langword="Abort" /> was not invoked on the current thread.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-735">Il chiamante non ha l'autorizzazione di sicurezza richiesta per il thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-735">The caller does not have the required security permission for the current thread.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da3d-736">per operazioni avanzate sui thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-736">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="2da3d-737">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-737">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">
          <span data-ttu-id="2da3d-738">Eliminazione definitiva di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-738">Destroying threads</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="2da3d-739">Stati dei thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-739">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-740">Riprende un thread che era stato sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-740">Resumes a thread that has been suspended.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="2da3d-741">Non usare la <xref:System.Threading.Thread.Suspend%2A> e <xref:System.Threading.Thread.Resume%2A> metodi per sincronizzare le attività di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-741">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="2da3d-742">Non è possibile sapere se il tipo di codice un thread è in esecuzione quando viene sospeso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-742">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="2da3d-743">Se si sospende un thread mentre contiene dei blocchi durante una valutazione delle autorizzazioni di sicurezza, altri thread di <xref:System.AppDomain> potrebbe essere bloccato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-743">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="2da3d-744">Se si sospende un thread durante l'esecuzione di un costruttore di classe, altri thread di <xref:System.AppDomain> che tenta di usare quella classe sono bloccati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-744">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="2da3d-745">I deadlock possono verificarsi in modo molto semplice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-745">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="2da3d-746">Solo .NET Core: questo membro non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-746">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-747">Il thread non è stato avviato, è inattivo o non è in stato sospeso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-747">The thread has not been started, is dead, or is not in the suspended state.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-748">Il chiamante non ha l'oggetto <see cref="T:System.Security.Permissions.SecurityPermission" /> appropriato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-748">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da3d-749">per operazioni avanzate sui thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-749">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="2da3d-750">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-750">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">
          <span data-ttu-id="2da3d-751">Sospensione e interruzione di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-751">Pausing and interrupting threads</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="2da3d-752">Stati dei thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-752">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="2da3d-753">Nuovo stato dell'apartment.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-753">The new apartment state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-754">Imposta lo stato dell'apartment di un thread prima che venga avviato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-754">Sets the apartment state of a thread before it is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-755">Nuovi thread vengono inizializzate come <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se lo stato di apartment non è stato impostato prima dell'avvio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-755">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="2da3d-756">Stato di apartment deve essere impostato prima dell'avvio di un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-756">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-757">Il thread principale dell'applicazione viene inizializzato su <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="2da3d-757">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="2da3d-758">L'unico modo per impostare lo stato dell'apartment del thread principale dell'applicazione per <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste nell'applicare il <xref:System.STAThreadAttribute> al metodo del punto di ingresso dell'attributo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-758">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="2da3d-759">Il <xref:System.Threading.Thread.SetApartmentState%2A> metodo, insieme al <xref:System.Threading.Thread.GetApartmentState%2A> metodo e il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo sostituisce il <xref:System.Threading.Thread.ApartmentState%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="2da3d-759">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-760">L'esempio di codice seguente illustra il <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, e <xref:System.Threading.Thread.TrySetApartmentState%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-760">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="2da3d-761">L'esempio di codice crea un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-761">The code example creates a thread.</span></span> <span data-ttu-id="2da3d-762">Prima dell'avvio, il thread <xref:System.Threading.Thread.GetApartmentState%2A> consente di visualizzare iniziale <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> lo stato e <xref:System.Threading.Thread.SetApartmentState%2A> imposta lo stato su <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-762">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da3d-763">Il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo quindi restituisce `false` quando si prova a modificare lo stato su <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> perché lo stato di apartment è già impostato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-763">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="2da3d-764">Se fosse stata tentata la stessa operazione con <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> sarebbe stata generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-764">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="2da3d-765">Dopo che quest'ultimo viene avviato, il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo viene usato di nuovo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-765">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="2da3d-766">Questa volta viene genera <xref:System.Threading.ThreadStateException> perché il thread è già stato avviato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-766">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="2da3d-767">Solo .NET Core: questo membro non è supportato nelle piattaforme macOS e Linux.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-767">.NET Core only: This member is not supported on the macOS and Linux platforms.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da3d-768">
            <paramref name="state" /> non è uno stato di apartment valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-768">
              <paramref name="state" /> is not a valid apartment state.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-769">Il thread è già stato avviato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-769">The thread has already been started.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da3d-770">Lo stato di apartment è già stato inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-770">The apartment state has already been initialized.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">
          <span data-ttu-id="2da3d-771">Oggetto <see cref="T:System.Threading.CompressedStack" /> da applicare al thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-771">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-772">Applica un oggetto <see cref="T:System.Threading.CompressedStack" /> acquisito al thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-772">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-773">Questo metodo non è più supportato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-773">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da3d-774">In tutti i casi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-774">In all cases.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da3d-775">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-775">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da3d-776">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-776">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">
          <span data-ttu-id="2da3d-777">Oggetto <see cref="T:System.LocalDataStoreSlot" /> nel quale impostare il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-777">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span>
          </span>
        </param>
        <param name="data">
          <span data-ttu-id="2da3d-778">Valore da impostare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-778">The value to be set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-779">Imposta i dati nello slot specificato sul thread in esecuzione per il dominio corrente di tale thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-779">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span>
          </span>
          <span data-ttu-id="2da3d-780">Per ottenere prestazioni migliori, usare i campi contrassegnati con l'attributo <see cref="T:System.ThreadStaticAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-780">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-781">.NET Framework fornisce due meccanismi per l'uso di archiviazione thread-local (TLS): i campi statici relativi ai thread (vale a dire, i campi contrassegnati con il <xref:System.ThreadStaticAttribute> attributo) e gli slot di dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-781">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="2da3d-782">Campi statici relativi ai thread garantiscono prestazioni nettamente migliori rispetto agli slot di dati e abilitare il controllo dei tipi in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-782">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="2da3d-783">Per altre informazioni sull'uso di TLS, vedere [memoria locale di Thread: slot di dati e campi statici relativi ai Thread](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="2da3d-783">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="2da3d-784">Thread di usano un meccanismo di memoria di archiviazione locale per archiviare i dati specifici di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-784">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="2da3d-785">Common language runtime alloca una matrice di archiviazione dei dati di più slot a ogni processo al momento della creazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-785">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="2da3d-786">Il thread può allocare uno slot di dati nell'archivio dati, archiviare e recuperare un valore nello slot e liberare lo slot per il riutilizzo dopo il termine di routine del thread e <xref:System.Threading.Thread> oggetto è stato recuperato da garbage collection.</span><span class="sxs-lookup"><span data-stu-id="2da3d-786">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="2da3d-787">Gli slot di dati sono univoci per ogni thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-787">Data slots are unique per thread.</span></span> <span data-ttu-id="2da3d-788">Nessun altro thread (non lo è nemmeno un thread figlio) può ottenere i dati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-788">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-789"><xref:System.Threading.Thread.SetData%2A> è un `Shared` metodo che si applica sempre al thread attualmente in esecuzione, anche se viene chiamato utilizzando una variabile che fa riferimento a un altro thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-789"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="2da3d-790">Per evitare confusione, usare il nome della classe quando si chiama `Shared` metodi: `Thread.SetData(testSlot, "test data")`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-790">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-791">In questa sezione sono riportati due esempi di codice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-791">This section contains two code examples.</span></span> <span data-ttu-id="2da3d-792">Il primo esempio illustra come usare un campo contrassegnato con il <xref:System.ThreadStaticAttribute> attributo per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-792">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-793">Nel secondo esempio viene illustrato come usare uno slot di dati per eseguire la stessa operazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-793">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="2da3d-794">**Primo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-794">**First Example**</span></span>  
  
 <span data-ttu-id="2da3d-795">Nell'esempio seguente viene illustrato come utilizzare un campo contrassegnato con <xref:System.ThreadStaticAttribute> per contenere le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-795">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="2da3d-796">Questa tecnica offre prestazioni migliori rispetto alla tecnica è illustrata nel secondo esempio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-796">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="2da3d-797">**Secondo esempio**</span><span class="sxs-lookup"><span data-stu-id="2da3d-797">**Second Example**</span></span>  
  
 <span data-ttu-id="2da3d-798">Nell'esempio seguente viene illustrato come utilizzare uno slot di dati denominati per archiviare le informazioni specifiche per thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-798">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="2da3d-799">Thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-799">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">
          <span data-ttu-id="2da3d-800">Archiviazione locale del thread: slot di dati e campi statici relativi ai thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-800">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-801">Sospende il thread corrente per il periodo di tempo specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-801">Suspends the current thread for the specified amount of time.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="2da3d-802">Numero di millisecondi per cui sospendere il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-802">The number of milliseconds for which the thread is suspended.</span>
          </span>
          <span data-ttu-id="2da3d-803">Se il valore dell'argomento <c>millisecondsTimeout</c> è zero, il thread cede il periodo di tempo rimanente a un thread di uguale priorità pronto per l'esecuzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-803">If the value of the <c>millisecondsTimeout</c> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span>
          </span>
          <span data-ttu-id="2da3d-804">Se non sono presenti altri thread di uguale priorità pronti per l'esecuzione, l'esecuzione del thread corrente non viene sospesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-804">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-805">Sospende il thread corrente per il numero specificato di millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-805">Suspends the current thread for the specified number of milliseconds.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-806">Il thread sarà pianificato per l'esecuzione dal sistema operativo per la quantità di tempo specificato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-806">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="2da3d-807">Questo metodo viene modificato lo stato del thread da includere <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-807">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="2da3d-808">È possibile specificare <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> per il `millisecondsTimeout` parametro la sospensione del thread per un periodo illimitato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-808">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="2da3d-809">Tuttavia, è consigliabile usare altri <xref:System.Threading?displayProperty=nameWithType> classi, ad esempio <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, o <xref:System.Threading.Semaphore> invece a sincronizzare i thread o gestire le risorse.</span><span class="sxs-lookup"><span data-stu-id="2da3d-809">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="2da3d-810">I segni di graduazione dell'orologio del sistema a una specifica velocità viene chiamato il tipo di clock.</span><span class="sxs-lookup"><span data-stu-id="2da3d-810">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="2da3d-811">Il timeout effettivo potrebbe non essere esattamente il timeout specificato, in quanto il timeout specificato verrà regolato per coincidono con segni di graduazione dell'orologio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-811">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="2da3d-812">Per altre informazioni sulla risoluzione dell'orologio e il tempo di attesa, vedere la [sospensione funzione](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) argomento.</span><span class="sxs-lookup"><span data-stu-id="2da3d-812">For more information on clock resolution and the waiting time, see the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="2da3d-813">Questo metodo chiama il [sospensione funzione](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) dal sistema di Windows API.</span><span class="sxs-lookup"><span data-stu-id="2da3d-813">This method calls the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="2da3d-814">Questo metodo non esegue la distribuzione di SendMessage e COM standard.</span><span class="sxs-lookup"><span data-stu-id="2da3d-814">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-815">Se si desidera rendere inattivo in un thread che ha <xref:System.STAThreadAttribute>, ma si vuole eseguire la distribuzione di SendMessage e COM standard, è possibile usare uno degli overload del <xref:System.Threading.Thread.Join%2A> metodo che specifica un intervallo di timeout.</span><span class="sxs-lookup"><span data-stu-id="2da3d-815">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-816">L'esempio seguente usa il <xref:System.Threading.Thread.Sleep%2A> metodo per bloccare il thread dell'applicazione principale.</span><span class="sxs-lookup"><span data-stu-id="2da3d-816">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2da3d-817">Il valore di timeout è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-817">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="2da3d-818">Periodo di tempo per cui sospendere il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-818">The amount of time for which the thread is suspended.</span>
          </span>
          <span data-ttu-id="2da3d-819">Se il valore dell'argomento <c>millisecondsTimeout</c> è <see cref="F:System.TimeSpan.Zero" />, il thread cede il periodo di tempo rimanente a un thread di uguale priorità pronto per l'esecuzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-819">If the value of the <c>millisecondsTimeout</c> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span>
          </span>
          <span data-ttu-id="2da3d-820">Se non sono presenti altri thread di uguale priorità pronti per l'esecuzione, l'esecuzione del thread corrente non viene sospesa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-820">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-821">Sospende il thread corrente per il periodo di tempo specificato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-821">Suspends the current thread for the specified amount of time.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-822">Il thread sarà pianificato per l'esecuzione dal sistema operativo per la quantità di tempo specificato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-822">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="2da3d-823">Questo metodo viene modificato lo stato del thread da includere <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-823">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="2da3d-824">È possibile specificare <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> per il `timeout` parametro la sospensione del thread per un periodo illimitato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-824">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="2da3d-825">Tuttavia, è consigliabile usare altri <xref:System.Threading?displayProperty=nameWithType> classi, ad esempio <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, o <xref:System.Threading.Semaphore> invece a sincronizzare i thread o gestire le risorse.</span><span class="sxs-lookup"><span data-stu-id="2da3d-825">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="2da3d-826">Questo overload del metodo <xref:System.Threading.Thread.Sleep%2A> Usa il numero totale di millisecondi interi in `timeout`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-826">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="2da3d-827">Millisecondi frazionari vengono ignorati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-827">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="2da3d-828">Questo metodo non esegue la distribuzione di SendMessage e COM standard.</span><span class="sxs-lookup"><span data-stu-id="2da3d-828">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-829">Se si desidera rendere inattivo in un thread che ha <xref:System.STAThreadAttribute>, ma si vuole eseguire la distribuzione di SendMessage e COM standard, è possibile usare uno degli overload del <xref:System.Threading.Thread.Join%2A> metodo che specifica un intervallo di timeout.</span><span class="sxs-lookup"><span data-stu-id="2da3d-829">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-830">L'esempio seguente usa il <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> overload del metodo per bloccare il thread dell'applicazione principale cinque volte, per due secondi, ogni volta.</span><span class="sxs-lookup"><span data-stu-id="2da3d-830">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="2da3d-831">Il valore di <paramref name="timeout" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" /> in millisecondi oppure è maggiore di <see cref="F:System.Int32.MaxValue" /> in millisecondi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-831">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">
          <span data-ttu-id="2da3d-832">Intero con segno a 32 bit che definisce la durata dell'attesa di un thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-832">A 32-bit signed integer that defines how long a thread is to wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-833">Determina che un thread rimanga in attesa il numero di volte definito dal parametro <paramref name="iterations" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-833">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-834">Il <xref:System.Threading.Thread.SpinWait%2A> metodo è utile per l'implementazione di blocchi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-834">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="2da3d-835">Le classi in .NET Framework, ad esempio <xref:System.Threading.Monitor> e <xref:System.Threading.ReaderWriterLock>, usare questo metodo internamente.</span><span class="sxs-lookup"><span data-stu-id="2da3d-835">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="2da3d-836"><xref:System.Threading.Thread.SpinWait%2A> Inserisce essenzialmente il processore in un ciclo molto ridotto, con il conteggio dei cicli specificato da di `iterations` parametro.</span><span class="sxs-lookup"><span data-stu-id="2da3d-836"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="2da3d-837">La durata dell'attesa pertanto dipende dalla velocità del processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-837">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="2da3d-838">Confrontare questa operazione con il <xref:System.Threading.Thread.Sleep%2A> (metodo).</span><span class="sxs-lookup"><span data-stu-id="2da3d-838">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="2da3d-839">Un thread che chiama <xref:System.Threading.Thread.Sleep%2A> restituisce il resto del periodo corrente del tempo del processore, anche se l'intervallo specificato è uguale a zero.</span><span class="sxs-lookup"><span data-stu-id="2da3d-839">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="2da3d-840">Se si specifica un intervallo diverso da zero per <xref:System.Threading.Thread.Sleep%2A> rimuove il thread dalla considerazione dall'utilità di pianificazione thread fino a quando non è trascorso l'intervallo di tempo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-840">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="2da3d-841"><xref:System.Threading.Thread.SpinWait%2A> non è in genere utile per le applicazioni comuni.</span><span class="sxs-lookup"><span data-stu-id="2da3d-841"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="2da3d-842">Nella maggior parte dei casi, è consigliabile usare le classi di sincronizzazione fornite da .NET Framework. ad esempio, chiamare <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> o un'istruzione che esegue il wrapping <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in c# o `SyncLock` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da3d-842">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="2da3d-843">Nel raro caso in cui è preferibile evitare un cambio di contesto, ad esempio quando si sa che una modifica dello stato è imminente, effettuare una chiamata al <xref:System.Threading.Thread.SpinWait%2A> metodo nel ciclo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-843">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="2da3d-844">Il codice <xref:System.Threading.Thread.SpinWait%2A> esegue è progettato per prevenire i problemi che possono verificarsi nei computer con più processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-844">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="2da3d-845">Ad esempio, nei computer con più processori Intel basati su tecnologia Hyper-Threading, <xref:System.Threading.Thread.SpinWait%2A> impedisce l'esaurimento delle risorse del processore in determinate situazioni.</span><span class="sxs-lookup"><span data-stu-id="2da3d-845">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-846">Determina la pianificazione dell'esecuzione di un thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-846">Causes a thread to be scheduled for execution.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-847">Determina il cambiamento da parte del sistema operativo dello stato dell'istanza corrente in <see cref="F:System.Threading.ThreadState.Running" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-847">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-848">Una volta che un thread si trova il <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> lo stato, il sistema operativo possibile pianificarne l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-848">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="2da3d-849">Il thread inizia l'esecuzione alla prima riga del metodo rappresentato dal <xref:System.Threading.ThreadStart> o <xref:System.Threading.ParameterizedThreadStart> delegato fornito al costruttore del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-849">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="2da3d-850">Si noti che la chiamata a <xref:System.Threading.Thread.Start%2A> non blocca il thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="2da3d-850">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-851">Se questo overload viene usato con un thread creato con una <xref:System.Threading.ParameterizedThreadStart> delegare, `null` viene passato al metodo eseguito dal thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-851">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="2da3d-852">Quando termina, il thread non può essere riavviato con un'altra chiamata a `Start`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-852">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-853">Nell'esempio seguente crea e avvia un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-853">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-854">Il thread è già stato avviato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-854">The thread has already been started.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="2da3d-855">La memoria disponibile non è sufficiente per avviare il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-855">There is not enough memory available to start this thread.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">
          <span data-ttu-id="2da3d-856">Thread e threading</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-856">Threads and Threading</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">
          <span data-ttu-id="2da3d-857">Creazione di thread e passaggio di dati all'avvio</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-857">Creating Threads and Passing Data at Start Time</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">
          <span data-ttu-id="2da3d-858">Oggetto contenente i dati che devono essere usati dal metodo eseguito dal thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-858">An object that contains data to be used by the method the thread executes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-859">Determina il cambiamento da parte del sistema operativo dello stato dell'istanza corrente in <see cref="F:System.Threading.ThreadState.Running" /> e, facoltativamente, fornisce un oggetto contenente i dati che devono essere usati dal metodo eseguito dal thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-859">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-860">Una volta che un thread si trova il <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> lo stato, il sistema operativo possibile pianificarne l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-860">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="2da3d-861">Il thread inizia l'esecuzione alla prima riga del metodo rappresentato dal <xref:System.Threading.ThreadStart> o <xref:System.Threading.ParameterizedThreadStart> delegato fornito al costruttore del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-861">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="2da3d-862">Si noti che la chiamata a <xref:System.Threading.Thread.Start%2A> non blocca il thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="2da3d-862">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="2da3d-863">Quando termina, il thread non può essere riavviato con un'altra chiamata a `Start`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-863">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="2da3d-864">Questo overload e <xref:System.Threading.ParameterizedThreadStart> delegato rendono più semplice passare dati a una routine del thread, ma la tecnica non è indipendente dai tipi perché qualsiasi oggetto può essere passato a questo overload.</span><span class="sxs-lookup"><span data-stu-id="2da3d-864">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="2da3d-865">Un modo più efficiente per passare dati a una routine del thread è inserire sia la routine del thread e i campi dati in un oggetto di lavoro.</span><span class="sxs-lookup"><span data-stu-id="2da3d-865">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="2da3d-866">Per altre informazioni, vedere [creazione di thread e passaggio di dati in fase di avvio](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span><span class="sxs-lookup"><span data-stu-id="2da3d-866">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-867">L'esempio seguente crea un <xref:System.Threading.ParameterizedThreadStart> delegato con un metodo statico e un metodo di istanza.</span><span class="sxs-lookup"><span data-stu-id="2da3d-867">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-868">Il thread è già stato avviato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-868">The thread has already been started.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="2da3d-869">La memoria disponibile non è sufficiente per avviare il thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-869">There is not enough memory available to start this thread.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da3d-870">Questo thread è stato creato usando un delegato di <see cref="T:System.Threading.ThreadStart" /> invece di uno di <see cref="T:System.Threading.ParameterizedThreadStart" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-870">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">
          <span data-ttu-id="2da3d-871">Creazione di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-871">Creating Threads</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-872">Sospende il thread o, se il thread è già sospeso, non avrà alcun effetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-872">Either suspends the thread, or if the thread is already suspended, has no effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-873">Se il thread è già sospeso, questo metodo non ha effetto.</span><span class="sxs-lookup"><span data-stu-id="2da3d-873">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="2da3d-874">Non usare la <xref:System.Threading.Thread.Suspend%2A> e <xref:System.Threading.Thread.Resume%2A> metodi per sincronizzare le attività di thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-874">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="2da3d-875">Non è possibile sapere se il tipo di codice un thread è in esecuzione quando viene sospeso.</span><span class="sxs-lookup"><span data-stu-id="2da3d-875">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="2da3d-876">Se si sospende un thread mentre contiene dei blocchi durante una valutazione delle autorizzazioni di sicurezza, altri thread di <xref:System.AppDomain> potrebbe essere bloccato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-876">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="2da3d-877">Se si sospende un thread durante l'esecuzione di un costruttore di classe, altri thread di <xref:System.AppDomain> che tenta di usare quella classe sono bloccati.</span><span class="sxs-lookup"><span data-stu-id="2da3d-877">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="2da3d-878">I deadlock possono verificarsi in modo molto semplice.</span><span class="sxs-lookup"><span data-stu-id="2da3d-878">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <span data-ttu-id="2da3d-879">Solo .NET Core: questo membro non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-879">.NET Core only: This member is not supported.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-880">Il thread non è stato avviato o è inattivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-880">The thread has not been started or is dead.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="2da3d-881">Il chiamante non ha l'oggetto <see cref="T:System.Security.Permissions.SecurityPermission" /> appropriato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-881">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da3d-882">per operazioni avanzate sui thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-882">for advanced operations on threads.</span>
          </span>
          <span data-ttu-id="2da3d-883">Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-883">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span>
          </span>
        </permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">
          <span data-ttu-id="2da3d-884">Sospensione e interruzione di thread</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-884">Pausing and interrupting threads</span>
          </span>
        </related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="2da3d-885">Stati dei thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-885">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="2da3d-886">Riservato per utilizzi futuri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-886">Reserved for future use.</span>
          </span>
          <span data-ttu-id="2da3d-887">Deve essere IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-887">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="2da3d-888">Matrice di nomi passata di cui eseguire il mapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-888">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="2da3d-889">Conteggio dei nomi di cui eseguire il mapping.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-889">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="2da3d-890">Contesto delle impostazioni locali in cui interpretare i nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-890">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="2da3d-891">Matrice allocata dal chiamante che riceve gli ID corrispondenti ai nomi.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-891">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-892">Esegue il mapping di un set di nomi a un set corrispondente di ID dispatch.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-892">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-893">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-893">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="2da3d-894">Per altre informazioni sulle `IDispatch::GetIDsOfNames`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="2da3d-894">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="2da3d-895">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-895">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="2da3d-896">Informazioni sul tipo da restituire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-896">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="2da3d-897">Identificatore delle impostazioni locali per le informazioni sul tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-897">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="2da3d-898">Riceve un puntatore all'oggetto relativo alle informazioni sul tipo richiesto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-898">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-899">Recupera le informazioni sul tipo relative a un oggetto che può quindi essere usato per ottenere informazioni sul tipo relative a un'interfaccia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-899">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-900">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-900">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="2da3d-901">Per altre informazioni sulle `IDispatch::GetTypeInfo`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="2da3d-901">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="2da3d-902">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-902">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="2da3d-903">Punta a una posizione che riceve il numero di interfacce di informazioni sul tipo fornite dall'oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-903">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-904">Recupera il numero delle interfacce di informazioni sul tipo fornite da un oggetto (0 o 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-904">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-905">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-905">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="2da3d-906">Per altre informazioni sulle `IDispatch::GetTypeInfoCount`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="2da3d-906">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="2da3d-907">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-907">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="2da3d-908">Identifica il membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-908">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="2da3d-909">Riservato per utilizzi futuri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-909">Reserved for future use.</span>
          </span>
          <span data-ttu-id="2da3d-910">Deve essere IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-910">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="2da3d-911">Contesto di impostazioni locali all'interno del quale devono essere interpretati gli argomenti.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-911">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="2da3d-912">Flag che descrivono il contesto della chiamata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-912">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="2da3d-913">Puntatore a una struttura contenente una matrice di argomenti, una matrice di DISPID per argomenti denominati e i conteggi del numero di elementi nelle matrici.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-913">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="2da3d-914">Puntatore alla posizione in cui deve essere archiviato il risultato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-914">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="2da3d-915">Puntatore a una struttura contenente informazioni sull'eccezione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-915">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="2da3d-916">Indice del primo argomento che contiene un errore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-916">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-917">Fornisce l'accesso a proprietà e metodi esposti da un oggetto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-917">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-918">Questo metodo consente l'accesso alle classi gestite da codice non gestito e non deve essere chiamato da codice gestito.</span><span class="sxs-lookup"><span data-stu-id="2da3d-918">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="2da3d-919">Per altre informazioni sulle `IDispatch::Invoke`, consultare la MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="2da3d-919">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="2da3d-920">L'accesso ad associazione tardiva usando l'interfaccia COM <c>IDispatch</c> non è supportato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-920">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-921">Ottiene un valore contenente gli stati del thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-921">Gets a value containing the states of the current thread.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da3d-922">Uno dei valori di <see cref="T:System.Threading.ThreadState" /> che indica lo stato del thread corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-922">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span>
          </span>
          <span data-ttu-id="2da3d-923">Il valore iniziale è <see langword="Unstarted" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-923">The initial value is <see langword="Unstarted" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-924">Il <xref:System.Threading.Thread.ThreadState%2A> proprietà fornisce informazioni più specifiche di <xref:System.Threading.Thread.IsAlive%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="2da3d-924">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da3d-925">Lo stato del thread è importante solo negli scenari di debug.</span><span class="sxs-lookup"><span data-stu-id="2da3d-925">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="2da3d-926">Il codice non deve mai usare lo stato del thread per sincronizzare le attività dei thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-926">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-927">Esempio di codice seguente viene illustrato l'accesso di `ThreadState` di un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-927">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">
          <span data-ttu-id="2da3d-928">Stati dei thread gestiti</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-928">Managed Thread States</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="2da3d-929">Nuovo stato dell'apartment.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-929">The new apartment state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-930">Imposta lo stato dell'apartment di un thread prima che venga avviato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-930">Sets the apartment state of a thread before it is started.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-931">
            <see langword="true" /> se è impostato lo stato dell'apartment; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-931">
              <see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-932">Nuovi thread vengono inizializzate come <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> se lo stato di apartment non è stato impostato prima dell'avvio.</span><span class="sxs-lookup"><span data-stu-id="2da3d-932">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="2da3d-933">Stato di apartment deve essere impostato prima dell'avvio di un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-933">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-934">Il thread principale dell'applicazione viene inizializzato su <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> per impostazione predefinita.</span><span class="sxs-lookup"><span data-stu-id="2da3d-934">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="2da3d-935">L'unico modo per impostare lo stato dell'apartment del thread principale dell'applicazione per <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste nell'applicare il <xref:System.STAThreadAttribute> al metodo del punto di ingresso dell'attributo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-935">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="2da3d-936">Il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo, insieme al <xref:System.Threading.Thread.GetApartmentState%2A> metodo e il <xref:System.Threading.Thread.SetApartmentState%2A> metodo sostituisce il <xref:System.Threading.Thread.ApartmentState%2A> proprietà.</span><span class="sxs-lookup"><span data-stu-id="2da3d-936">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da3d-937">L'esempio di codice seguente illustra il <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, e <xref:System.Threading.Thread.TrySetApartmentState%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="2da3d-937">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="2da3d-938">L'esempio di codice crea un thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-938">The code example creates a thread.</span></span> <span data-ttu-id="2da3d-939">Prima dell'avvio, il thread <xref:System.Threading.Thread.GetApartmentState%2A> consente di visualizzare iniziale <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> lo stato e <xref:System.Threading.Thread.SetApartmentState%2A> imposta lo stato su <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-939">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da3d-940">Il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo quindi restituisce `false` quando si prova a modificare lo stato su <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> perché lo stato di apartment è già impostato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-940">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="2da3d-941">Se fosse stata tentata la stessa operazione con <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> sarebbe stata generata l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-941">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="2da3d-942">Dopo che quest'ultimo viene avviato, il <xref:System.Threading.Thread.TrySetApartmentState%2A> metodo viene usato di nuovo.</span><span class="sxs-lookup"><span data-stu-id="2da3d-942">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="2da3d-943">Questa volta viene genera <xref:System.Threading.ThreadStateException> perché il thread è già stato avviato.</span><span class="sxs-lookup"><span data-stu-id="2da3d-943">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da3d-944">
            <paramref name="state" /> non è uno stato di apartment valido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-944">
              <paramref name="state" /> is not a valid apartment state.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadStateException">
          <span data-ttu-id="2da3d-945">Il thread è già stato avviato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-945">The thread has already been started.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-946">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-946">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-947">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-947">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-948">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-948">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-949">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-949">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-950">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-950">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-951">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-951">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-952"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-952"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-953">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-953">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-954">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-954">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-955">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-955">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-956">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-956">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-957">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-957">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-958">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-958">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-959">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-959">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-960">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-960">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-961">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-961">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-962">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-962">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-963">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-963">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-964">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-964">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-965"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-965"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-966">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-966">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-967">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-967">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-968">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-968">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-969">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-969">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-970">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-970">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-971">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-971">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-972">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-972">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-973">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-973">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-974">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-974">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-975">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-975">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-976">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-976">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-977">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-977">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-978"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-978"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-979">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-979">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-980">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-980">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-981">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-981">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-982">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-982">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-983">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-983">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-984">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-984">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-985">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-985">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-986">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-986">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-987">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-987">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-988">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-988">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-989">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-989">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-990">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-990">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-991"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-991"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-992">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-992">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-993">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-993">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-994">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-994">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-995">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-995">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-996">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-996">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-997">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-997">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-998">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-998">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-999">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-999">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1000">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1000">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1001">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1001">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-1002">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1002">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1003">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1003">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1004"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1004"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1005">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1005">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1006">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1006">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-1007">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1007">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1008">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1008">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1009">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1009">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1010">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1010">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1011">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1011">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1012">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1012">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1013">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1013">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1014">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1014">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-1015">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1015">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1016">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1016">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1017"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1017"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1018">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1018">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1019">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1019">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-1020">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1020">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1021">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1021">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1022">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1022">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1023">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1023">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1024">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1024">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1025">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1025">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1026">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1026">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1027">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1027">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-1028">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1028">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1029">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1029">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1030"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1030"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1031">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1031">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1032">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1032">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-1033">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1033">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1034">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1034">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1035">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1035">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1036">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1036">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1037">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1037">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1038">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1038">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1039">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1039">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1040">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1040">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-1041">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1041">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1042">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1042">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1043"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1043"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1044">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1044">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1045">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1045">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-1046">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1046">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1047">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1047">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1048">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1048">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1049">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1049">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1050">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1050">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1051">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1051">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1052">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1052">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1053">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1053">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-1054">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1054">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1055">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1055">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1056"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1056"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1057">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1057">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1058">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1058">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-1059">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1059">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1060">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1060">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1061">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1061">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1062">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1062">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1063">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1063">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1064">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1064">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1065">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1065">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1066">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1066">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-1067">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1067">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1068">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1068">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1069"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1069"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1070">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1070">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1071">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1071">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-1072">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1072">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1073">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1073">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1074">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1074">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1075">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1075">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1076">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1076">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1077">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1077">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1078">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1078">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1079">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1079">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-1080">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1080">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1081">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1081">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1082"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1082"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1083">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1083">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1084">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1084">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-1085">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1085">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1086">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1086">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1087">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1087">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1088">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1088">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1089">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1089">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1090">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1090">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1091">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1091">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1092">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1092">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-1093">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1093">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1094">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1094">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1095"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1095"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1096">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1096">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1097">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1097">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-1098">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1098">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1099">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1099">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1100">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1100">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1101">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1101">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1102">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1102">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1103">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1103">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1104">Campo da leggere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1104">The field to be read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1105">Legge il valore di un campo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1105">Reads the value of a field.</span>
          </span>
          <span data-ttu-id="2da3d-1106">Tale valore è l'ultimo che è stato scritto da un processore qualsiasi in un computer, indipendentemente dal numero di processori o dallo stato della cache del processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1106">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1107">Ultimo valore scritto nel campo da un processore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1107">The latest value written to the field by any processor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1108"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1108"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1109">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1109">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1110">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileRead%2A> Ottiene l'ultimo valore scritto in una posizione di memoria da qualsiasi processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1110">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="2da3d-1111">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1111">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1112">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1112">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1113">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1113">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1114">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1114">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1115">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1115">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1116">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1116">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-1117">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1117">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1118">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1118">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1119">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1119">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1120">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1120">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1121"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1121"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1122">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1122">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1123">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1123">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1124">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1124">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1125">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1125">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1126">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1126">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1127">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1127">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1128">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1128">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1129">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1129">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1130">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1130">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1131">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1131">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1132">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1132">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1133"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1133"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1134">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1134">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1135">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1135">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1136">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1136">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1137">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1137">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1138">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1138">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1139">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1139">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1140">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1140">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1141">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1141">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1142">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1142">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1143">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1143">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1144">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1144">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1145"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1145"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1146">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1146">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1147">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1147">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1148">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1148">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1149">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1149">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1150">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1150">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1151">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1151">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1152">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1152">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1153">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1153">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1154">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1154">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1155">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1155">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1156">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1156">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1157"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1157"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1158">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1158">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1159">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1159">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1160">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1160">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1161">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1161">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1162">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1162">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1163">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1163">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1164">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1164">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1165">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1165">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1166">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1166">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1167">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1167">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1168">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1168">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1169"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1169"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1170">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1170">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1171">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1171">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1172">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1172">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1173">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1173">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1174">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1174">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1175">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1175">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1176">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1176">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1177">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1177">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1178">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1178">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1179">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1179">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1180">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1180">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1181"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1181"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1182">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1182">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1183">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1183">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1184">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1184">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1185">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1185">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1186">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1186">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1187">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1187">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1188">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1188">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1189">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1189">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1190">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1190">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1191">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1191">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1192">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1192">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1193"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1193"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1194">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1194">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1195">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1195">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1196">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1196">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1197">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1197">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1198">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1198">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1199">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1199">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1200">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1200">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1201">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1201">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1202">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1202">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1203">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1203">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1204">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1204">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1205"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1205"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1206">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1206">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1207">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1207">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1208">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1208">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1209">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1209">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1210">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1210">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1211">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1211">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1212">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1212">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1213">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1213">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1214">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1214">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1215">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1215">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1216">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1216">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1217"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1217"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1218">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1218">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1219">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1219">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1220">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1220">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1221">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1221">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1222">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1222">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1223">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1223">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1224">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1224">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1225">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1225">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1226">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1226">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1227">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1227">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1228">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1228">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1229"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1229"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1230">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1230">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1231">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1231">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1232">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1232">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1233">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1233">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1234">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1234">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1235">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1235">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1236">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1236">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1237">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1237">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1238">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1238">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1239">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1239">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1240">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1240">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1241"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1241"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1242">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1242">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1243">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1243">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1244">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1244">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1245">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1245">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1246">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1246">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1247">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1247">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1248">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1248">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1249">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1249">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1250">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1250">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1251">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1251">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1252">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1252">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1253"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1253"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1254">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1254">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1255">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1255">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1256">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1256">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1257">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1257">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1258">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1258">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1259">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1259">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1260">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1260">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1261">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1261">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">
          <span data-ttu-id="2da3d-1262">Campo in cui deve essere scritto il valore.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1262">The field to which the value is to be written.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="2da3d-1263">Valore da scrivere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1263">The value to be written.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da3d-1264">Scrive immediatamente un valore in un campo, in modo che tale valore possa essere visibile a tutti i processori nel computer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1264">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1265"><xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> sono per i casi speciali di sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1265"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="2da3d-1266">In circostanze normali, il codice c# `lock` istruzione, Visual Basic `SyncLock` istruzione e <xref:System.Threading.Monitor> classe rappresentano alternative più semplici.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1266">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="2da3d-1267">In un sistema multiprocessore, <xref:System.Threading.Thread.VolatileWrite%2A> assicura che un valore scritto in una posizione di memoria è immediatamente visibile a tutti i processori.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1267">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="2da3d-1268">Potrebbe essere necessario scaricare le cache di processore.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1268">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="2da3d-1269">Anche in un sistema monoprocessore <xref:System.Threading.Thread.VolatileRead%2A> e <xref:System.Threading.Thread.VolatileWrite%2A> assicurarsi che un valore viene letto o scritto in memoria e non memorizzato nella cache (ad esempio, in un registro del processore).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1269">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="2da3d-1270">Di conseguenza, è possibile usare tali per sincronizzare l'accesso a un campo che può essere aggiornato da un altro thread, o dall'hardware.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1270">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="2da3d-1271">Chiamare questo metodo interessa solo un singolo accesso alla memoria.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1271">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="2da3d-1272">Per garantire la sincronizzazione effettiva per un campo, è necessario utilizzare tutti gli accessi al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1272">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da3d-1273">In c# usando il `volatile` modificatore in un campo garantisce che tutti gli accessi al campo utilizzano <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1273">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da3d-1274">Determina che il thread chiamante ceda l'esecuzione a un altro thread pronto per l'esecuzione sul processore corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1274">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span>
          </span>
          <span data-ttu-id="2da3d-1275">Il sistema operativo seleziona il thread a cui cedere l'esecuzione.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1275">The operating system selects the thread to yield to.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da3d-1276">
            <see langword="true" /> se il sistema operativo ha passato l'esecuzione a un altro thread; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da3d-1276">
              <see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da3d-1277">Se questo metodo ha esito positivo, viene restituito il resto della porzione di tempo corrente del thread.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1277">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="2da3d-1278">Il sistema operativo pianifica il thread chiamante per un altro intervallo di tempo, in base alle relative priorità e lo stato di altri thread che sono disponibili per l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1278">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="2da3d-1279">Cede il controllo è limitato per il processore che è in esecuzione il thread chiamante.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1279">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="2da3d-1280">Il sistema operativo non passerà l'esecuzione a un altro processore, anche se tale processore è inattivo o è in esecuzione un thread di priorità più bassa.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1280">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="2da3d-1281">Se non sono presenti altri thread che sono pronte per l'esecuzione sul processore corrente, il sistema operativo non assicura l'esecuzione e questo metodo restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1281">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="2da3d-1282">Questo metodo equivale all'utilizzo platform invoke per chiamare Win32 nativo `SwitchToThread` (funzione).</span><span class="sxs-lookup"><span data-stu-id="2da3d-1282">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="2da3d-1283">È necessario chiamare il <xref:System.Threading.Thread.Yield%2A> metodo invece di usare platform invoke, in quanto ignora qualsiasi comportamento personalizzato di threading dell'host ha richiesto di platform invoke.</span><span class="sxs-lookup"><span data-stu-id="2da3d-1283">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>