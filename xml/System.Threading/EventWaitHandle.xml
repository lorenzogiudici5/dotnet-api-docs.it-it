<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a78f45e800db6ea099f816c0d991970357e9300e" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49152355" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un evento di sincronizzazione dei thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.EventWaitHandle> classe consente ai thread di comunicare tra loro mediante la segnalazione. In genere, uno o più thread bloccati in un <xref:System.Threading.EventWaitHandle> fino a quando un thread non bloccato non chiama il <xref:System.Threading.EventWaitHandle.Set%2A> metodo, il rilascio di una o più thread bloccati. Un thread può segnalare una <xref:System.Threading.EventWaitHandle> e quindi venire bloccato, chiamando la `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> (metodo).  
  
> [!NOTE]
>  Il <xref:System.Threading.EventWaitHandle> classe fornisce accesso agli eventi di sincronizzazione di sistema denominati.  
  
 Il comportamento di un <xref:System.Threading.EventWaitHandle> che è stato segnalato dipende dalla modalità di reimpostazione. Un' <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag viene reimpostato automaticamente quando viene segnalato, dopo il rilascio di un singolo thread in attesa. Un oggetto <xref:System.Threading.EventWaitHandle> creato con il flag <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> rimane segnalato fino a quando non viene chiamato il relativo metodo <xref:System.Threading.EventWaitHandle.Reset%2A>.  
  
 Gli eventi di reimpostazione automatica forniscono l'accesso esclusivo a una risorsa. Se un evento di reimpostazione automatica viene segnalato quando nessun thread è in attesa, rimane segnalato finché un thread non prova ad attenderlo. L'evento rilascia il thread e viene immediatamente reimpostato, bloccando i thread successivi.  
  
 Reimpostazione manuale degli eventi sono come le attività di controllo. Quando l'evento non viene segnalato, bloccherà i thread in attesa su di esso. Quando l'evento viene segnalato, vengono rilasciati tutti i thread in attesa e l'evento rimane segnalato (vale a dire, attese successivi non bloccano) fino a quando non relativo <xref:System.Threading.EventWaitHandle.Reset%2A> viene chiamato il metodo. Gli eventi di reimpostazione manuale sono utili quando un thread necessario completare un'attività prima che altri thread possa procedere.  
  
 <xref:System.Threading.EventWaitHandle> gli oggetti possono essere usati con il `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metodi.  
  
 Per altre informazioni sui meccanismi di sincronizzazione di thread, vedere [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere che il thread termina un'attività.  
  
 Nell'esempio avviati cinque thread e consente loro di bloccare un' <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag e quindi rilascia un thread ogni volta l'utente preme il tasto INVIO. Nell'esempio viene quindi Accoda altri cinque thread e vengono rilasciati tutti usando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
    <related type="Article" href="~/docs/standard/threading/index.md">Threading gestito</related>
    <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostarlo su non segnalato.</param>
        <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato e se la reimpostazione viene eseguita automaticamente o manualmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se lo stato iniziale dell'evento è impostato su non segnalato, bloccherà i thread in attesa dell'evento. Se viene segnalato lo stato iniziale e il <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata. Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread che attende l'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e bloccano i thread successivi.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere che il thread termina un'attività.  
  
 Nell'esempio avviati cinque thread e consente loro di bloccare un' <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag e quindi rilascia un thread ogni volta l'utente preme il tasto INVIO. Nell'esempio viene quindi Accoda altri cinque thread e vengono rilasciati tutti usando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
        <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
        <param name="name">Nome di un evento di sincronizzazione a livello di sistema.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato se creato a seguito di questa chiamata e se la reimpostazione viene eseguita automaticamente o manualmente e indicando il nome di un evento di sincronizzazione di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` viene `null` o una stringa vuota, una variabile locale <xref:System.Threading.EventWaitHandle> viene creato.  
  
 Se un evento di sistema con il nome specificato per il `name` parametro esiste già, il `initialState` parametro viene ignorato.  
  
> [!IMPORTANT]
>  Quando si utilizza questo costruttore per gli eventi di sistema denominato, specificare `false` per `initialState`. Questo costruttore fornisce un modo per determinare se è stato creato un evento di sistema denominato, pertanto è possibile fare supposizioni sullo stato dell'evento denominato. Per determinare se è stato creato un evento denominato, usare il <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> costruttore o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> costruttore.  
  
 Se lo stato iniziale dell'evento è impostato su non segnalato, bloccherà i thread in attesa dell'evento. Se viene segnalato lo stato iniziale e il <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata. Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread che attende l'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e bloccano i thread successivi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
        <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
        <param name="name">Nome di un evento di sincronizzazione a livello di sistema.</param>
        <param name="createdNew">Quando restituisce il controllo, questo metodo contiene <see langword="true" /> se è stato creato un evento locale (ovvero, se <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato l'evento di sistema denominato specificato. <see langword="false" /> se l'evento di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, che specifica se l'handle di attesa viene inizialmente segnalato se creato in seguito alla chiamata, se viene reimpostato automaticamente o manualmente, nonché il nome di un evento di sincronizzazione di sistema e una variabile Boolean il cui valore dopo la chiamata indica se è stato creato l'evento di sistema denominato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un evento di sistema con il nome specificato per il `name` parametro esiste già, il `initialState` parametro viene ignorato. Dopo aver chiamato questo costruttore, usare il valore della variabile specificata per il `ref` parametro (`ByRef` parametro in Visual Basic)`createdNew` per determinare se l'evento di sistema denominato già esistente o se è stato creato.  
  
 Se lo stato iniziale dell'evento è impostato su non segnalato, bloccherà i thread in attesa dell'evento. Se viene segnalato lo stato iniziale e il <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata. Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread che attende l'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e bloccano i thread successivi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
        <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
        <param name="name">Nome di un evento di sincronizzazione a livello di sistema.</param>
        <param name="createdNew">Quando restituisce il controllo, questo metodo contiene <see langword="true" /> se è stato creato un evento locale (ovvero, se <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato l'evento di sistema denominato specificato. <see langword="false" /> se l'evento di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <param name="eventSecurity">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare all'evento di sistema denominato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, che specifica se l'handle di attesa viene inizialmente segnalato se creato in seguito alla chiamata, se viene reimpostato automaticamente o manualmente, nonché il nome di un evento di sincronizzazione di sistema, una variabile Boolean il cui valore dopo la chiamata indica se è stato creato l'evento di sistema denominato e la sicurezza del controllo di accesso da applicare all'evento denominato, se è stato creato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per applicare la sicurezza del controllo di accesso a un evento di sistema denominato al momento della creazione, impedendo ad altro codice di assumere il controllo dell'evento.  
  
 Questo costruttore inizializza un <xref:System.Threading.EventWaitHandle> oggetto che rappresenta un evento di sistema. È possibile creare più <xref:System.Threading.EventWaitHandle> gli oggetti che rappresentano lo stesso evento di sistema.  
  
 Se l'evento di sistema non esiste, viene creato con la sicurezza del controllo di accesso specificato. Se l'evento esiste, la sicurezza del controllo di accesso specificato viene ignorata.  
  
> [!NOTE]
>  Il chiamante dispone di controllo completo sull'oggetto appena creato <xref:System.Threading.EventWaitHandle> oggetto anche se `eventSecurity` nega o non riesce a concedere alcuni diritti di accesso per l'utente corrente. Tuttavia, se l'utente corrente tenta di ottenere un'altra <xref:System.Threading.EventWaitHandle> per rappresentare lo stesso evento denominato, usando un costruttore dell'oggetto o il <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metodo, viene applicata la sicurezza del controllo di accesso di Windows.  
  
 Se un evento di sistema con il nome specificato per il `name` parametro esiste già, il `initialState` parametro viene ignorato. Dopo aver chiamato questo costruttore, usare il valore della variabile specificata per il `ref` parametro (`ByRef` parametro in Visual Basic) `createdNew` per determinare se l'evento di sistema denominato già esistente o se è stato creato.  
  
 Se lo stato iniziale dell'evento è impostato su non segnalato, bloccherà i thread in attesa dell'evento. Se viene segnalato lo stato iniziale e il <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata. Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread che attende l'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e bloccano i thread successivi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un evento di sistema denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale e la sicurezza del controllo di accesso che nega il diritto di usare l'evento all'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, l'evento viene aperto con i diritti necessari per l'attesa e segnalarlo. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito usando le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <exception cref="T:System.ArgumentException">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso per l'evento di sistema denominato rappresentato dall'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso per l'evento di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> metodo utilizza la seguente combinazione di flag (combinati mediante un'operazione OR bit per bit) per cercare le autorizzazioni: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> diritti di chiamare questo metodo e l'evento devono essere stato aperto con la <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un evento di sistema denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale e la sicurezza del controllo di accesso che nega il diritto di usare l'evento all'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo che le autorizzazioni sono state lette, utilizzando il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> (metodo), e l'evento modificato, viene aperto con i diritti necessari per l'attesa e segnalarlo. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito usando le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente rappresenta un evento di sistema denominato e l'utente non dispone di <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
oppure 
L'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente rappresenta un evento di sistema denominato e non è stato aperto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Non supportato per Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> è già stato chiamato in precedenza su questo <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un evento di sincronizzazione denominato specificato, se esistente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
        <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente.</summary>
        <returns>Oggetto che rappresenta l'evento di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metodo tenta di aprire l'evento di sistema denominato specificato. Se l'evento di sistema non esiste, questo metodo genera un'eccezione anziché creare l'evento di sistema. Per creare l'evento di sistema quando non esiste già, usare uno dei <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo e specificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit.  
  
 Che specifica la <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa dell'evento di sistema denominato e specificando le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un evento di sistema denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale e la sicurezza del controllo di accesso che nega il diritto di usare l'evento all'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, l'evento viene aperto con i diritti necessari per l'attesa e segnalarlo. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito usando le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento di sistema denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per utilizzarlo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente, con l'accesso di sicurezza desiderato.</summary>
        <returns>Oggetto che rappresenta l'evento di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa dell'evento e il <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag per consentire ai thread chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.  
  
 Il <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metodo tenta di aprire un evento di sistema denominato esistente. Se l'evento di sistema non esiste, questo metodo genera un'eccezione anziché creare l'evento di sistema. Per creare l'evento di sistema quando non esiste già, usare uno dei <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un evento di sistema denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale e la sicurezza del controllo di accesso che nega il diritto di usare l'evento all'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, l'evento viene aperto con i diritti necessari per l'attesa e segnalarlo. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito usando le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento di sistema denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta lo stato dell'evento come non segnalato, provocando il blocco dei thread.</summary>
        <returns>
          <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> è già stato chiamato in precedenza su questo <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta lo stato dell'evento su segnalato, per consentire a uno più thread in attesa di continuare.</summary>
        <returns>
          <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (tra cui <xref:System.Threading.AutoResetEvent>), il <xref:System.Threading.EventWaitHandle.Set%2A> metodo rilascia un singolo thread. Se non sono presenti thread in attesa, l'handle di attesa rimane segnalato finché un thread tenta di attesa su di esso o fino al relativo <xref:System.Threading.EventWaitHandle.Reset%2A> viene chiamato il metodo.  
  
> [!IMPORTANT]
>  Non c'è garanzia che ogni chiamata ai <xref:System.Threading.EventWaitHandle.Set%2A> metodo rilascerà un thread da un <xref:System.Threading.EventWaitHandle> cui modalità di ripristino è <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Se due chiamate sono troppo vicini, in modo che la seconda chiamata si verifica prima che un thread è stato rilasciato, viene rilasciato un solo thread. È come se non è stata eseguita la seconda chiamata. Inoltre, se <xref:System.Threading.EventWaitHandle.Set%2A> viene chiamato quando nessun thread in attesa e <xref:System.Threading.EventWaitHandle> già segnalato, la chiamata non ha alcun effetto.  
  
 Per un <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (tra cui <xref:System.Threading.ManualResetEvent>), chiamando la <xref:System.Threading.EventWaitHandle.Set%2A> metodo lascia l'handle di attesa in uno stato segnalato fino al relativo <xref:System.Threading.EventWaitHandle.Reset%2A> viene chiamato il metodo.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere che il thread termina un'attività.  
  
 Nell'esempio avviati cinque thread e consente loro di bloccare un' <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag e quindi rilascia un thread ogni volta l'utente preme il tasto INVIO. Nell'esempio viene quindi Accoda altri cinque thread e vengono rilasciati tutti usando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> è già stato chiamato in precedenza su questo <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare all'evento di sistema denominato.</param>
        <summary>Imposta la sicurezza del controllo di accesso per un evento di sistema denominato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'utente deve disporre <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> diritti di chiamare questo metodo e l'evento devono essere stato aperto con la <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento tra processi di un evento di sistema denominato con controllo degli accessi. Nell'esempio viene usato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale e la sicurezza del controllo di accesso che nega il diritto di usare l'evento all'utente corrente, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato in due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso alla chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. Viene rilevata l'eccezione e l'esempio Usa il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, usando il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> metodo, l'evento viene aperto con i diritti necessari per l'attesa e segnalarlo. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito usando le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone di <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
oppure 
L'evento non è stato aperto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">L'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente non rappresenta un evento di sistema denominato.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> è già stato chiamato in precedenza su questo <see cref="T:System.Threading.EventWaitHandle" />.</exception>
        <related type="Article" href="http://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle, AutoResetEvent e ManualResetEvent</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un evento di sincronizzazione denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è stata completata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
        <param name="result">Quando restituisce il controllo, questo metodo contiene un oggetto <see cref="T:System.Threading.EventWaitHandle" /> che rappresenta l'evento di sincronizzazione denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
        <returns>
          <see langword="true" /> se l'evento di sincronizzazione denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'evento di sincronizzazione denominato non esiste, questo metodo non crearla. Per creare l'evento di sistema quando non esiste già, usare uno dei <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se un evento di sincronizzazione denominato esiste, utilizzare questo overload del metodo anziché il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo che genera un'eccezione se l'evento di sincronizzazione non esiste.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> overload del metodo e specificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> diritti, combinati tramite l'operazione OR bit per bit. Che specifica la <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa dell'evento di sistema denominato e specificando le <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag consente a un thread chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.  
  
 Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <param name="result">Quando restituisce il controllo, questo metodo contiene un oggetto <see cref="T:System.Threading.EventWaitHandle" /> che rappresenta l'evento di sincronizzazione denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente, con l'accesso di sicurezza desiderato e restituisce un valore che indica se l'operazione è riuscita.</summary>
        <returns>
          <see langword="true" /> se l'evento di sincronizzazione denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'evento di sincronizzazione denominato non esiste, questo metodo non crearla. Per creare l'evento di sistema quando non esiste già, usare uno dei <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi se un evento di sincronizzazione denominato esiste, utilizzare questo overload del metodo anziché il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo che genera un'eccezione se l'evento di sincronizzazione non esiste.  
  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa dell'evento e il <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag per consentire ai thread chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.  
  
 Più chiamate al metodo che usano lo stesso valore per `name` non necessariamente restituiscono lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il parametro <paramref name="name" /> è una stringa vuota.  
  
oppure 
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>