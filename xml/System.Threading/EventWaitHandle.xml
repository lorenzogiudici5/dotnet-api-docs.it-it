<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="04ca1c444cfd772670659b4609b267628b38c728" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531145" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un evento di sincronizzazione dei thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Threading.EventWaitHandle> classe consente ai thread di comunicare tra loro mediante la segnalazione. In genere, uno o più thread bloccati in un <xref:System.Threading.EventWaitHandle> fino a quando un thread sbloccato chiama il <xref:System.Threading.EventWaitHandle.Set%2A> metodo, rilasciando uno o più thread bloccati. Un thread può segnalare un <xref:System.Threading.EventWaitHandle> e quindi bloccare su di esso, chiamando la `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> metodo.  
  
> [!NOTE]
>  La <xref:System.Threading.EventWaitHandle> classe fornisce accesso agli eventi di sincronizzazione di sistema denominati.  
  
 Il comportamento di un <xref:System.Threading.EventWaitHandle> che è stato segnalato dipende dalla modalità di reimpostazione. Un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag viene reimpostato automaticamente quando viene segnalato, dopo il rilascio di un singolo thread in attesa. Un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag rimane segnalato fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato.  
  
 Gli eventi di reimpostazione automatica forniscono l'accesso esclusivo a una risorsa. Se un evento di reimpostazione automatica viene segnalato quando nessun thread è in attesa, rimane segnalato finché un thread non prova ad attenderlo. L'evento rilascia il thread e viene immediatamente reimpostato, bloccando i thread successivi.  
  
 Gli eventi sono simili gate di reimpostazione manuale. L'evento non viene segnalato, bloccherà i thread in attesa su di esso. Quando l'evento viene segnalato, vengono rilasciati tutti i thread in attesa e l'evento rimane segnalato (vale a dire attese successive non bloccano) fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato. Eventi di reimpostazione manuale sono utili quando un thread deve completare un'attività prima di procedere altri thread.  
  
 <xref:System.Threading.EventWaitHandle> gli oggetti possono essere utilizzati con il `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metodi.  
  
 Per ulteriori informazioni sui meccanismi di sincronizzazione di thread, vedere [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere finché il thread termina un'attività.  
  
 L'esempio avvia cinque thread e permette il blocco su un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, quindi rilascia un thread ogni volta l'utente preme il tasto INVIO. Nell'esempio viene quindi Accoda un altro thread cinque e vengono rilasciati tutti utilizzando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostarlo su non segnalato.</param>
        <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato e se la reimpostazione viene eseguita automaticamente o manualmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se lo stato iniziale dell'evento è impostato su non segnalato, i thread in attesa dell'evento verranno bloccata. Se viene segnalato lo stato iniziale e <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata. Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread in attesa dell'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e i thread successivi verranno bloccata.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere finché il thread termina un'attività.  
  
 L'esempio avvia cinque thread e permette il blocco su un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, quindi rilascia un thread ogni volta l'utente preme il tasto INVIO. Nell'esempio viene quindi Accoda un altro thread cinque e vengono rilasciati tutti utilizzando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
        <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
        <param name="name">Nome di un evento di sincronizzazione a livello di sistema.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato se creato a seguito di questa chiamata e se la reimpostazione viene eseguita automaticamente o manualmente e indicando il nome di un evento di sincronizzazione di sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` è `null` o una stringa vuota, una variabile locale <xref:System.Threading.EventWaitHandle> viene creato.  
  
 Se un evento di sistema con il nome specificato per il `name` parametro esiste già, il `initialState` parametro viene ignorato.  
  
> [!IMPORTANT]
>  Quando si utilizza questo costruttore per gli eventi di sistema denominato, specificare `false` per `initialState`. Questo costruttore fornisce un modo per determinare se è stato creato un evento di sistema denominato, in modo non è possibile apportare tutte le premesse sullo stato dell'evento denominato. Per determinare se è stato creato un evento denominato, utilizzare il <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> costruttore o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> costruttore.  
  
 Se lo stato iniziale dell'evento è impostato su non segnalato, i thread in attesa dell'evento verranno bloccata. Se viene segnalato lo stato iniziale e <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata. Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread in attesa dell'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e i thread successivi verranno bloccata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <exception cref="T:System.ArgumentException">
          La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
        <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
        <param name="name">Nome di un evento di sincronizzazione a livello di sistema.</param>
        <param name="createdNew">Quando restituisce il controllo, questo metodo contiene <see langword="true" /> se è stato creato un evento locale (ovvero, se <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato l'evento di sistema denominato specificato. <see langword="false" /> se l'evento di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, che specifica se l'handle di attesa viene inizialmente segnalato se creato in seguito alla chiamata, se viene reimpostato automaticamente o manualmente, nonché il nome di un evento di sincronizzazione di sistema e una variabile Boolean il cui valore dopo la chiamata indica se è stato creato l'evento di sistema denominato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se un evento di sistema con il nome specificato per il `name` parametro esiste già, il `initialState` parametro viene ignorato. Dopo aver chiamato questo costruttore, utilizzare il valore della variabile specificata per il `ref` parametro (`ByRef` parametro in Visual Basic)`createdNew` per determinare se l'evento di sistema denominato già esistente o se è stato creato.  
  
 Se lo stato iniziale dell'evento è impostato su non segnalato, i thread in attesa dell'evento verranno bloccata. Se viene segnalato lo stato iniziale e <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata. Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread in attesa dell'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e i thread successivi verranno bloccata.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <exception cref="T:System.ArgumentException">
          La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</param>
        <param name="mode">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</param>
        <param name="name">Nome di un evento di sincronizzazione a livello di sistema.</param>
        <param name="createdNew">Quando restituisce il controllo, questo metodo contiene <see langword="true" /> se è stato creato un evento locale (ovvero, se <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato l'evento di sistema denominato specificato. <see langword="false" /> se l'evento di sistema denominato specificato è già esistente. Questo parametro viene passato non inizializzato.</param>
        <param name="eventSecurity">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare all'evento di sistema denominato.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, che specifica se l'handle di attesa viene inizialmente segnalato se creato in seguito alla chiamata, se viene reimpostato automaticamente o manualmente, nonché il nome di un evento di sincronizzazione di sistema, una variabile Boolean il cui valore dopo la chiamata indica se è stato creato l'evento di sistema denominato e la sicurezza del controllo di accesso da applicare all'evento denominato, se è stato creato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilizzare questo costruttore per applicare la sicurezza del controllo di accesso a un evento di sistema denominato quando viene creato, impedendo ad altro codice di assumere il controllo dell'evento.  
  
 Questo costruttore inizializza un <xref:System.Threading.EventWaitHandle> oggetto che rappresenta un evento di sistema. È possibile creare più <xref:System.Threading.EventWaitHandle> gli oggetti che rappresentano lo stesso evento di sistema.  
  
 Se l'evento di sistema non esiste, viene creato con la sicurezza del controllo di accesso specificato. Se l'evento non esiste, la sicurezza del controllo di accesso specificato viene ignorata.  
  
> [!NOTE]
>  Il chiamante ha il controllo completo su appena creato <xref:System.Threading.EventWaitHandle> oggetto anche se `eventSecurity` nega o non concede alcuni diritti di accesso per l'utente corrente. Tuttavia, se l'utente corrente tenta di ottenere un altro <xref:System.Threading.EventWaitHandle> per rappresentare lo stesso evento denominato, utilizzando un costruttore dell'oggetto o <xref:System.Threading.EventWaitHandle.OpenExisting%2A> (metodo), viene applicata la sicurezza del controllo di accesso di Windows.  
  
 Se un evento di sistema con il nome specificato per il `name` parametro esiste già, il `initialState` parametro viene ignorato. Dopo aver chiamato questo costruttore, utilizzare il valore della variabile specificata per il `ref` parametro (`ByRef` parametro in Visual Basic) `createdNew` per determinare se l'evento di sistema denominato già esistente o se è stato creato.  
  
 Se lo stato iniziale dell'evento è impostato su non segnalato, i thread in attesa dell'evento verranno bloccata. Se viene segnalato lo stato iniziale e <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata. Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread in attesa dell'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e i thread successivi verranno bloccata.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, l'evento viene aperto con i diritti necessari per l'attesa e la segnalazione. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</exception>
        <exception cref="T:System.ArgumentException">
          La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ottiene un oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso per l'evento di sistema denominato rappresentato dall'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente.</summary>
        <returns>Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso per l'evento di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> metodo utilizza la seguente combinazione di flag (combinati mediante un'operazione OR bit per bit) per cercare le autorizzazioni: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 L'utente deve disporre <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e l'evento devono essere aperto con il <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo aver letto le autorizzazioni, utilizzando il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> (metodo), e l'evento modificato, viene aperto con i diritti necessari per l'attesa e la segnalazione. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente rappresenta un evento di sistema denominato e l'utente non dispone di <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
 oppure  
  
 L'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente rappresenta un evento di sistema denominato e non è stato aperto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Non supportato per Windows 98 o Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> non è stato chiamato precedentemente in questo oggetto <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un evento di sincronizzazione denominato specificato, se esistente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
        <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente.</summary>
        <returns>Oggetto che rappresenta l'evento di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metodo tenta di aprire l'evento di sistema denominato specificato. Se l'evento di sistema non esiste, questo metodo genera un'eccezione anziché creare l'evento di sistema. Per creare l'evento di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo e specificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> diritti, combinati utilizzando l'operazione OR bit per bit.  
  
 Specifica il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa dell'evento di sistema denominato e specificando il <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag consente a un thread di chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, l'evento viene aperto con i diritti necessari per l'attesa e la segnalazione. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento di sistema denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per utilizzarlo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente, con l'accesso di sicurezza desiderato.</summary>
        <returns>Oggetto che rappresenta l'evento di sistema denominato.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa dell'evento e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.  
  
 Il <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metodo tenta di aprire un evento di sistema denominato esistente. Se l'evento di sistema non esiste, questo metodo genera un'eccezione anziché creare l'evento di sistema. Per creare l'evento di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, l'evento viene aperto con i diritti necessari per l'attesa e la segnalazione. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'evento di sistema denominato non esiste.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta lo stato dell'evento come non segnalato, provocando il blocco dei thread.</summary>
        <returns>
          <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> non è stato chiamato precedentemente in questo oggetto <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Imposta lo stato dell'evento su segnalato, per consentire a uno più thread in attesa di continuare.</summary>
        <returns>
          <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Per un <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (inclusi <xref:System.Threading.AutoResetEvent>), il <xref:System.Threading.EventWaitHandle.Set%2A> metodo rilascia un singolo thread. Se non sono presenti thread in attesa, l'handle di attesa rimane segnalato fino un thread in attesa su di esso o fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato.  
  
> [!IMPORTANT]
>  Non è possibile garantire che ogni chiamata al <xref:System.Threading.EventWaitHandle.Set%2A> metodo verrà rilasciato un thread da un <xref:System.Threading.EventWaitHandle> la cui modalità di ripristino è <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Se due chiamate sono troppo vicini, in modo che la seconda chiamata si verifica prima che un thread è stato rilasciato, viene rilasciato un solo thread. È come se la seconda chiamata non è stata eseguita. Inoltre, se <xref:System.Threading.EventWaitHandle.Set%2A> viene chiamato quando non sono presenti thread in attesa e <xref:System.Threading.EventWaitHandle> già segnalato, la chiamata non ha alcun effetto.  
  
 Per un <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (inclusi <xref:System.Threading.ManualResetEvent>), la chiamata di <xref:System.Threading.EventWaitHandle.Set%2A> metodo lascia l'handle di attesa in stato segnalato fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato.  
  
   
  
## Examples  
 Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere finché il thread termina un'attività.  
  
 L'esempio avvia cinque thread e permette il blocco su un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, quindi rilascia un thread ogni volta l'utente preme il tasto INVIO. Nell'esempio viene quindi Accoda un altro thread cinque e vengono rilasciati tutti utilizzando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> non è stato chiamato precedentemente in questo oggetto <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare all'evento di sistema denominato.</param>
        <summary>Imposta la sicurezza del controllo di accesso per un evento di sistema denominato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L'utente deve disporre <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e l'evento devono essere aperto con il <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso. Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.  
  
 Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.  
  
 Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.  
  
 Dopo la modifica delle autorizzazioni, utilizzando il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> (metodo), l'evento viene aperto con i diritti necessari per l'attesa e la segnalazione. Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> è <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'utente non dispone di <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
 oppure  
  
 L'evento non è stato aperto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">L'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente non rappresenta un evento di sistema denominato.</exception>
        <exception cref="T:System.ObjectDisposedException">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> non è stato chiamato precedentemente in questo oggetto <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Apre un evento di sincronizzazione denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è stata completata.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
        <param name="result">Quando restituisce il controllo, questo metodo contiene un oggetto <see cref="T:System.Threading.EventWaitHandle" /> che rappresenta l'evento di sincronizzazione denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</summary>
        <returns>
          <see langword="true" /> se l'evento di sincronizzazione denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'evento di sincronizzazione denominato non esiste, questo metodo non crearlo. Per creare l'evento di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi dell'esistenza di un evento di sincronizzazione denominato, utilizzare questo overload del metodo anziché il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo che genera un'eccezione se l'evento di sincronizzazione non esiste.  
  
 Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> overload del metodo e specificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> diritti, combinati utilizzando l'operazione OR bit per bit. Specifica il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa dell'evento di sistema denominato e specificando il <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag consente a un thread di chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nome dell'evento di sincronizzazione del sistema da aprire.</param>
        <param name="rights">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</param>
        <param name="result">Quando restituisce il controllo, questo metodo contiene un oggetto <see cref="T:System.Threading.EventWaitHandle" /> che rappresenta l'evento di sincronizzazione denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita. Questo parametro viene trattato come non inizializzato.</param>
        <summary>Apre l'evento di sincronizzazione denominato specificato, se esistente, con l'accesso di sicurezza desiderato e restituisce un valore che indica se l'operazione è riuscita.</summary>
        <returns>
          <see langword="true" /> se l'evento di sincronizzazione denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se l'evento di sincronizzazione denominato non esiste, questo metodo non crearlo. Per creare l'evento di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.  
  
 Se non si è certi dell'esistenza di un evento di sincronizzazione denominato, utilizzare questo overload del metodo anziché il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo che genera un'eccezione se l'evento di sincronizzazione non esiste.  
  
 Il `rights` parametro deve includere il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa dell'evento e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.  
  
 Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Il parametro <paramref name="name" /> è una stringa vuota.  
  
 oppure  
  
 La lunghezza di <paramref name="name" /> supera i 260 caratteri.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Errore Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">richiede l'attendibilità totale per il chiamante immediato. Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>