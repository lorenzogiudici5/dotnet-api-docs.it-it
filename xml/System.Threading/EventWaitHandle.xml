<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="04ca1c444cfd772670659b4609b267628b38c728" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="7088d-101">Rappresenta un evento di sincronizzazione dei thread.</span>
      <span class="sxs-lookup">
        <span data-stu-id="7088d-101">Represents a thread synchronization event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-102">La <xref:System.Threading.EventWaitHandle> classe consente ai thread di comunicare tra loro mediante la segnalazione.</span><span class="sxs-lookup"><span data-stu-id="7088d-102">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling.</span></span> <span data-ttu-id="7088d-103">In genere, uno o più thread bloccati in un <xref:System.Threading.EventWaitHandle> fino a quando un thread sbloccato chiama il <xref:System.Threading.EventWaitHandle.Set%2A> metodo, rilasciando uno o più thread bloccati.</span><span class="sxs-lookup"><span data-stu-id="7088d-103">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, releasing one or more of the blocked threads.</span></span> <span data-ttu-id="7088d-104">Un thread può segnalare un <xref:System.Threading.EventWaitHandle> e quindi bloccare su di esso, chiamando la `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="7088d-104">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, by calling the `static` (`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7088d-105">La <xref:System.Threading.EventWaitHandle> classe fornisce accesso agli eventi di sincronizzazione di sistema denominati.</span><span class="sxs-lookup"><span data-stu-id="7088d-105">The <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.</span></span>  
  
 <span data-ttu-id="7088d-106">Il comportamento di un <xref:System.Threading.EventWaitHandle> che è stato segnalato dipende dalla modalità di reimpostazione.</span><span class="sxs-lookup"><span data-stu-id="7088d-106">The behavior of an <xref:System.Threading.EventWaitHandle> that has been signaled depends on its reset mode.</span></span> <span data-ttu-id="7088d-107">Un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag viene reimpostato automaticamente quando viene segnalato, dopo il rilascio di un singolo thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="7088d-107">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="7088d-108">Un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag rimane segnalato fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="7088d-108">An <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="7088d-109">Gli eventi di reimpostazione automatica forniscono l'accesso esclusivo a una risorsa.</span><span class="sxs-lookup"><span data-stu-id="7088d-109">Automatic reset events provide exclusive access to a resource.</span></span> <span data-ttu-id="7088d-110">Se un evento di reimpostazione automatica viene segnalato quando nessun thread è in attesa, rimane segnalato finché un thread non prova ad attenderlo.</span><span class="sxs-lookup"><span data-stu-id="7088d-110">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="7088d-111">L'evento rilascia il thread e viene immediatamente reimpostato, bloccando i thread successivi.</span><span class="sxs-lookup"><span data-stu-id="7088d-111">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
 <span data-ttu-id="7088d-112">Gli eventi sono simili gate di reimpostazione manuale.</span><span class="sxs-lookup"><span data-stu-id="7088d-112">Manual reset events are like gates.</span></span> <span data-ttu-id="7088d-113">L'evento non viene segnalato, bloccherà i thread in attesa su di esso.</span><span class="sxs-lookup"><span data-stu-id="7088d-113">When the event is not signaled, threads that wait on it will block.</span></span> <span data-ttu-id="7088d-114">Quando l'evento viene segnalato, vengono rilasciati tutti i thread in attesa e l'evento rimane segnalato (vale a dire attese successive non bloccano) fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="7088d-114">When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="7088d-115">Eventi di reimpostazione manuale sono utili quando un thread deve completare un'attività prima di procedere altri thread.</span><span class="sxs-lookup"><span data-stu-id="7088d-115">Manual reset events are useful when one thread must complete an activity before other threads can proceed.</span></span>  
  
 <span data-ttu-id="7088d-116"><xref:System.Threading.EventWaitHandle> gli oggetti possono essere utilizzati con il `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="7088d-116"><xref:System.Threading.EventWaitHandle> objects can be used with the `static`(`Shared` in Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="7088d-117">Per ulteriori informazioni sui meccanismi di sincronizzazione di thread, vedere [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="7088d-117">For more information about thread synchronization mechanisms, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7088d-118">Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere finché il thread termina un'attività.</span><span class="sxs-lookup"><span data-stu-id="7088d-118">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="7088d-119">L'esempio avvia cinque thread e permette il blocco su un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, quindi rilascia un thread ogni volta l'utente preme il tasto INVIO.</span><span class="sxs-lookup"><span data-stu-id="7088d-119">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="7088d-120">Nell'esempio viene quindi Accoda un altro thread cinque e vengono rilasciati tutti utilizzando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="7088d-120">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="7088d-121">Questo tipo è thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="7088d-121">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7088d-122">Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-122">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="7088d-123">
            <see langword="true" /> per impostare lo stato iniziale su segnalato; <see langword="false" /> per impostarlo su non segnalato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-123">
              <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="7088d-124">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-124">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7088d-125">Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato e se la reimpostazione viene eseguita automaticamente o manualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-125">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-126">Se lo stato iniziale dell'evento è impostato su non segnalato, i thread in attesa dell'evento verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-126">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="7088d-127">Se viene segnalato lo stato iniziale e <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-127">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="7088d-128">Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread in attesa dell'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e i thread successivi verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-128">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7088d-129">Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere finché il thread termina un'attività.</span><span class="sxs-lookup"><span data-stu-id="7088d-129">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="7088d-130">L'esempio avvia cinque thread e permette il blocco su un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, quindi rilascia un thread ogni volta l'utente preme il tasto INVIO.</span><span class="sxs-lookup"><span data-stu-id="7088d-130">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses ENTER key.</span></span> <span data-ttu-id="7088d-131">Nell'esempio viene quindi Accoda un altro thread cinque e vengono rilasciati tutti utilizzando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="7088d-131">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="7088d-132">
            <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-132">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="7088d-133">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-133">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="7088d-134">Nome di un evento di sincronizzazione a livello di sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-134">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7088d-135">Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, specificando se l'handle di attesa è inizialmente segnalato se creato a seguito di questa chiamata e se la reimpostazione viene eseguita automaticamente o manualmente e indicando il nome di un evento di sincronizzazione di sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-135">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-136">Se `name` è `null` o una stringa vuota, una variabile locale <xref:System.Threading.EventWaitHandle> viene creato.</span><span class="sxs-lookup"><span data-stu-id="7088d-136">If `name` is `null` or an empty string, a local <xref:System.Threading.EventWaitHandle> is created.</span></span>  
  
 <span data-ttu-id="7088d-137">Se un evento di sistema con il nome specificato per il `name` parametro esiste già, il `initialState` parametro viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="7088d-137">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="7088d-138">Quando si utilizza questo costruttore per gli eventi di sistema denominato, specificare `false` per `initialState`.</span><span class="sxs-lookup"><span data-stu-id="7088d-138">When using this constructor for named system events, specify `false` for `initialState`.</span></span> <span data-ttu-id="7088d-139">Questo costruttore fornisce un modo per determinare se è stato creato un evento di sistema denominato, in modo non è possibile apportare tutte le premesse sullo stato dell'evento denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-139">This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event.</span></span> <span data-ttu-id="7088d-140">Per determinare se è stato creato un evento denominato, utilizzare il <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> costruttore o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> costruttore.</span><span class="sxs-lookup"><span data-stu-id="7088d-140">To determine whether a named event was created, use the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> constructor or the <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> constructor.</span></span>  
  
 <span data-ttu-id="7088d-141">Se lo stato iniziale dell'evento è impostato su non segnalato, i thread in attesa dell'evento verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-141">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="7088d-142">Se viene segnalato lo stato iniziale e <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-142">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="7088d-143">Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread in attesa dell'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e i thread successivi verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-143">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="7088d-144">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-144">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7088d-145">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-145">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="7088d-146">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-146">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7088d-147">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-147">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7088d-148">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-148">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7088d-149">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-149">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="7088d-150">
            <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-150">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="7088d-151">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-151">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="7088d-152">Nome di un evento di sincronizzazione a livello di sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-152">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="7088d-153">Quando restituisce il controllo, questo metodo contiene <see langword="true" /> se è stato creato un evento locale (ovvero, se <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato l'evento di sistema denominato specificato. <see langword="false" /> se l'evento di sistema denominato specificato è già esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-153">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="7088d-154">Questo parametro viene passato non inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-154">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7088d-155">Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, che specifica se l'handle di attesa viene inizialmente segnalato se creato in seguito alla chiamata, se viene reimpostato automaticamente o manualmente, nonché il nome di un evento di sincronizzazione di sistema e una variabile Boolean il cui valore dopo la chiamata indica se è stato creato l'evento di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-155">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-156">Se un evento di sistema con il nome specificato per il `name` parametro esiste già, il `initialState` parametro viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="7088d-156">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="7088d-157">Dopo aver chiamato questo costruttore, utilizzare il valore della variabile specificata per il `ref` parametro (`ByRef` parametro in Visual Basic)`createdNew` per determinare se l'evento di sistema denominato già esistente o se è stato creato.</span><span class="sxs-lookup"><span data-stu-id="7088d-157">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic)`createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="7088d-158">Se lo stato iniziale dell'evento è impostato su non segnalato, i thread in attesa dell'evento verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-158">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="7088d-159">Se viene segnalato lo stato iniziale e <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-159">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="7088d-160">Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread in attesa dell'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e i thread successivi verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-160">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="7088d-161">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-161">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7088d-162">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-162">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="7088d-163">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-163">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7088d-164">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-164">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7088d-165">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-165">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7088d-166">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-166">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <span data-ttu-id="7088d-167">
            <see langword="true" /> per impostare lo stato iniziale su segnalato se l'evento denominato viene creato come risultato della chiamata; <see langword="false" /> per impostarlo su non segnalato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-167">
              <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="7088d-168">Ottiene uno dei valori di <see cref="T:System.Threading.EventResetMode" /> che determina se l'evento viene reimpostato manualmente o automaticamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-168">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="7088d-169">Nome di un evento di sincronizzazione a livello di sistema.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-169">The name of a system-wide synchronization event.</span>
          </span>
        </param>
        <param name="createdNew">
          <span data-ttu-id="7088d-170">Quando restituisce il controllo, questo metodo contiene <see langword="true" /> se è stato creato un evento locale (ovvero, se <c>name</c> è <see langword="null" /> o una stringa vuota) oppure se è stato creato l'evento di sistema denominato specificato. <see langword="false" /> se l'evento di sistema denominato specificato è già esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-170">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed.</span>
          </span>
          <span data-ttu-id="7088d-171">Questo parametro viene passato non inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-171">This parameter is passed uninitialized.</span>
          </span>
        </param>
        <param name="eventSecurity">
          <span data-ttu-id="7088d-172">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare all'evento di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-172">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7088d-173">Inizializza una nuova istanza della classe <see cref="T:System.Threading.EventWaitHandle" />, che specifica se l'handle di attesa viene inizialmente segnalato se creato in seguito alla chiamata, se viene reimpostato automaticamente o manualmente, nonché il nome di un evento di sincronizzazione di sistema, una variabile Boolean il cui valore dopo la chiamata indica se è stato creato l'evento di sistema denominato e la sicurezza del controllo di accesso da applicare all'evento denominato, se è stato creato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-173">Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-174">Utilizzare questo costruttore per applicare la sicurezza del controllo di accesso a un evento di sistema denominato quando viene creato, impedendo ad altro codice di assumere il controllo dell'evento.</span><span class="sxs-lookup"><span data-stu-id="7088d-174">Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.</span></span>  
  
 <span data-ttu-id="7088d-175">Questo costruttore inizializza un <xref:System.Threading.EventWaitHandle> oggetto che rappresenta un evento di sistema.</span><span class="sxs-lookup"><span data-stu-id="7088d-175">This constructor initializes an <xref:System.Threading.EventWaitHandle> object that represents a system event.</span></span> <span data-ttu-id="7088d-176">È possibile creare più <xref:System.Threading.EventWaitHandle> gli oggetti che rappresentano lo stesso evento di sistema.</span><span class="sxs-lookup"><span data-stu-id="7088d-176">You can create multiple <xref:System.Threading.EventWaitHandle> objects that represent the same system event.</span></span>  
  
 <span data-ttu-id="7088d-177">Se l'evento di sistema non esiste, viene creato con la sicurezza del controllo di accesso specificato.</span><span class="sxs-lookup"><span data-stu-id="7088d-177">If the system event does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="7088d-178">Se l'evento non esiste, la sicurezza del controllo di accesso specificato viene ignorata.</span><span class="sxs-lookup"><span data-stu-id="7088d-178">If the event exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7088d-179">Il chiamante ha il controllo completo su appena creato <xref:System.Threading.EventWaitHandle> oggetto anche se `eventSecurity` nega o non concede alcuni diritti di accesso per l'utente corrente.</span><span class="sxs-lookup"><span data-stu-id="7088d-179">The caller has full control over the newly created <xref:System.Threading.EventWaitHandle> object even if `eventSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="7088d-180">Tuttavia, se l'utente corrente tenta di ottenere un altro <xref:System.Threading.EventWaitHandle> per rappresentare lo stesso evento denominato, utilizzando un costruttore dell'oggetto o <xref:System.Threading.EventWaitHandle.OpenExisting%2A> (metodo), viene applicata la sicurezza del controllo di accesso di Windows.</span><span class="sxs-lookup"><span data-stu-id="7088d-180">However, if the current user attempts to get another <xref:System.Threading.EventWaitHandle> object to represent the same named event, using either a constructor or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="7088d-181">Se un evento di sistema con il nome specificato per il `name` parametro esiste già, il `initialState` parametro viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="7088d-181">If a system event with the name specified for the `name` parameter already exists, the `initialState` parameter is ignored.</span></span> <span data-ttu-id="7088d-182">Dopo aver chiamato questo costruttore, utilizzare il valore della variabile specificata per il `ref` parametro (`ByRef` parametro in Visual Basic) `createdNew` per determinare se l'evento di sistema denominato già esistente o se è stato creato.</span><span class="sxs-lookup"><span data-stu-id="7088d-182">After calling this constructor, use the value in the variable specified for the `ref` parameter (`ByRef` parameter in Visual Basic) `createdNew` to determine whether the named system event already existed or was created.</span></span>  
  
 <span data-ttu-id="7088d-183">Se lo stato iniziale dell'evento è impostato su non segnalato, i thread in attesa dell'evento verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-183">If the initial state of the event is nonsignaled, threads that wait on the event will block.</span></span> <span data-ttu-id="7088d-184">Se viene segnalato lo stato iniziale e <xref:System.Threading.EventResetMode.ManualReset> viene specificato il flag `mode`, i thread in attesa dell'evento non verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-184">If the initial state is signaled, and the <xref:System.Threading.EventResetMode.ManualReset> flag is specified for `mode`, threads that wait on the event will not block.</span></span> <span data-ttu-id="7088d-185">Se viene segnalato lo stato iniziale, e `mode` è <xref:System.Threading.EventResetMode.AutoReset>, il primo thread in attesa dell'evento verrà rilasciato immediatamente dopo il quale l'evento viene reimpostato e i thread successivi verranno bloccata.</span><span class="sxs-lookup"><span data-stu-id="7088d-185">If the initial state is signaled, and `mode` is <xref:System.Threading.EventResetMode.AutoReset>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7088d-186">Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso.</span><span class="sxs-lookup"><span data-stu-id="7088d-186">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="7088d-187">Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-187">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="7088d-188">Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.</span><span class="sxs-lookup"><span data-stu-id="7088d-188">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="7088d-189">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="7088d-189">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="7088d-190">L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-190">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7088d-191">Dopo la modifica delle autorizzazioni, l'evento viene aperto con i diritti necessari per l'attesa e la segnalazione.</span><span class="sxs-lookup"><span data-stu-id="7088d-191">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="7088d-192">Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-192">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="7088d-193">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-193">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7088d-194">L'evento denominato esiste e include sicurezza del controllo di accesso, ma l'utente non ha <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-194">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="7088d-195">L'evento denominato non può essere creato, forse perché ha lo stesso nome di un handle di attesa di tipo diverso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-195">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7088d-196">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-196">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7088d-197">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-197">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7088d-198">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-198">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7088d-199">Ottiene un oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso per l'evento di sistema denominato rappresentato dall'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-199">Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7088d-200">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso per l'evento di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-200">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-201">Il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> metodo utilizza la seguente combinazione di flag (combinati mediante un'operazione OR bit per bit) per cercare le autorizzazioni: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7088d-201">The <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="7088d-202">L'utente deve disporre <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e l'evento devono essere aperto con il <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="7088d-202">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7088d-203">Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso.</span><span class="sxs-lookup"><span data-stu-id="7088d-203">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="7088d-204">Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-204">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="7088d-205">Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.</span><span class="sxs-lookup"><span data-stu-id="7088d-205">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="7088d-206">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="7088d-206">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="7088d-207">L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-207">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7088d-208">Dopo aver letto le autorizzazioni, utilizzando il <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> (metodo), e l'evento modificato, viene aperto con i diritti necessari per l'attesa e la segnalazione.</span><span class="sxs-lookup"><span data-stu-id="7088d-208">After the permissions have been read, using the <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> method, and changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="7088d-209">Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-209">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7088d-210">L'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente rappresenta un evento di sistema denominato e l'utente non dispone di <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-210">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
          <span data-ttu-id="7088d-211">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-211">-or-</span>
          </span>
          <span data-ttu-id="7088d-212">L'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente rappresenta un evento di sistema denominato e non è stato aperto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-212">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="7088d-213">Non supportato per Windows 98 o Windows Millennium Edition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-213">Not supported for Windows 98 or Windows Millennium Edition.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7088d-214">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> non è stato chiamato precedentemente in questo oggetto <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-214">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7088d-215">Apre un evento di sincronizzazione denominato specificato, se esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-215">Opens a specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="7088d-216">Nome dell'evento di sincronizzazione del sistema da aprire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-216">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7088d-217">Apre l'evento di sincronizzazione denominato specificato, se esistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-217">Opens the specified named synchronization event, if it already exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7088d-218">Oggetto che rappresenta l'evento di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-218">An  object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-219">Il <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metodo tenta di aprire l'evento di sistema denominato specificato.</span><span class="sxs-lookup"><span data-stu-id="7088d-219">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open the specified named system event.</span></span> <span data-ttu-id="7088d-220">Se l'evento di sistema non esiste, questo metodo genera un'eccezione anziché creare l'evento di sistema.</span><span class="sxs-lookup"><span data-stu-id="7088d-220">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="7088d-221">Per creare l'evento di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.</span><span class="sxs-lookup"><span data-stu-id="7088d-221">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7088d-222">Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-222">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 <span data-ttu-id="7088d-223">Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo e specificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> diritti, combinati utilizzando l'operazione OR bit per bit.</span><span class="sxs-lookup"><span data-stu-id="7088d-223">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="7088d-224">Specifica il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa dell'evento di sistema denominato e specificando il <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag consente a un thread di chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="7088d-224">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7088d-225">Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso.</span><span class="sxs-lookup"><span data-stu-id="7088d-225">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="7088d-226">Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-226">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="7088d-227">Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.</span><span class="sxs-lookup"><span data-stu-id="7088d-227">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="7088d-228">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="7088d-228">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="7088d-229">L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-229">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7088d-230">Dopo la modifica delle autorizzazioni, l'evento viene aperto con i diritti necessari per l'attesa e la segnalazione.</span><span class="sxs-lookup"><span data-stu-id="7088d-230">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="7088d-231">Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-231">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7088d-232">Il parametro <paramref name="name" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-232">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="7088d-233">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-233">-or-</span>
          </span>
          <span data-ttu-id="7088d-234">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-234">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7088d-235">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-235">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="7088d-236">L'evento di sistema denominato non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-236">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="7088d-237">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-237">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7088d-238">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza necessario per utilizzarlo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-238">The named event exists, but the user does not have the security access required to use it.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7088d-239">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-239">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7088d-240">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-240">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="7088d-241">Nome dell'evento di sincronizzazione del sistema da aprire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-241">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="7088d-242">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-242">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7088d-243">Apre l'evento di sincronizzazione denominato specificato, se esistente, con l'accesso di sicurezza desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-243">Opens the specified named synchronization event, if it already exists, with the desired security access.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7088d-244">Oggetto che rappresenta l'evento di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-244">An object that represents the named system event.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-245">Il `rights` parametro deve includere il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa dell'evento e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="7088d-245">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="7088d-246">Il <xref:System.Threading.EventWaitHandle.OpenExisting%2A> metodo tenta di aprire un evento di sistema denominato esistente.</span><span class="sxs-lookup"><span data-stu-id="7088d-246">The <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method tries to open an existing named system event.</span></span> <span data-ttu-id="7088d-247">Se l'evento di sistema non esiste, questo metodo genera un'eccezione anziché creare l'evento di sistema.</span><span class="sxs-lookup"><span data-stu-id="7088d-247">If the system event does not exist, this method throws an exception instead of creating the system event.</span></span> <span data-ttu-id="7088d-248">Per creare l'evento di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.</span><span class="sxs-lookup"><span data-stu-id="7088d-248">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7088d-249">Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-249">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7088d-250">Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso.</span><span class="sxs-lookup"><span data-stu-id="7088d-250">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="7088d-251">Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-251">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="7088d-252">Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.</span><span class="sxs-lookup"><span data-stu-id="7088d-252">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="7088d-253">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="7088d-253">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="7088d-254">L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-254">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7088d-255">Dopo la modifica delle autorizzazioni, l'evento viene aperto con i diritti necessari per l'attesa e la segnalazione.</span><span class="sxs-lookup"><span data-stu-id="7088d-255">After the permissions are changed, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="7088d-256">Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-256">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7088d-257">Il parametro <paramref name="name" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-257">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="7088d-258">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-258">-or-</span>
          </span>
          <span data-ttu-id="7088d-259">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-259">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7088d-260">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-260">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
          <span data-ttu-id="7088d-261">L'evento di sistema denominato non esiste.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-261">The named system event does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="7088d-262">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-262">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7088d-263">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-263">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7088d-264">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-264">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7088d-265">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-265">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7088d-266">Imposta lo stato dell'evento come non segnalato, provocando il blocco dei thread.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-266">Sets the state of the event to nonsignaled, causing threads to block.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7088d-267">
            <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-267">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7088d-268">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> non è stato chiamato precedentemente in questo oggetto <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-268">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7088d-269">Imposta lo stato dell'evento su segnalato, per consentire a uno più thread in attesa di continuare.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-269">Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7088d-270">
            <see langword="true" /> se l'operazione ha esito positivo; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-270">
              <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-271">Per un <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (inclusi <xref:System.Threading.AutoResetEvent>), il <xref:System.Threading.EventWaitHandle.Set%2A> metodo rilascia un singolo thread.</span><span class="sxs-lookup"><span data-stu-id="7088d-271">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (including <xref:System.Threading.AutoResetEvent>), the <xref:System.Threading.EventWaitHandle.Set%2A> method releases a single thread.</span></span> <span data-ttu-id="7088d-272">Se non sono presenti thread in attesa, l'handle di attesa rimane segnalato fino un thread in attesa su di esso o fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="7088d-272">If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="7088d-273">Non è possibile garantire che ogni chiamata al <xref:System.Threading.EventWaitHandle.Set%2A> metodo verrà rilasciato un thread da un <xref:System.Threading.EventWaitHandle> la cui modalità di ripristino è <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7088d-273">There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread from an <xref:System.Threading.EventWaitHandle> whose reset mode is <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7088d-274">Se due chiamate sono troppo vicini, in modo che la seconda chiamata si verifica prima che un thread è stato rilasciato, viene rilasciato un solo thread.</span><span class="sxs-lookup"><span data-stu-id="7088d-274">If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.</span></span> <span data-ttu-id="7088d-275">È come se la seconda chiamata non è stata eseguita.</span><span class="sxs-lookup"><span data-stu-id="7088d-275">It is as if the second call did not happen.</span></span> <span data-ttu-id="7088d-276">Inoltre, se <xref:System.Threading.EventWaitHandle.Set%2A> viene chiamato quando non sono presenti thread in attesa e <xref:System.Threading.EventWaitHandle> già segnalato, la chiamata non ha alcun effetto.</span><span class="sxs-lookup"><span data-stu-id="7088d-276">Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.EventWaitHandle> is already signaled, the call has no effect.</span></span>  
  
 <span data-ttu-id="7088d-277">Per un <xref:System.Threading.EventWaitHandle> con <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (inclusi <xref:System.Threading.ManualResetEvent>), la chiamata di <xref:System.Threading.EventWaitHandle.Set%2A> metodo lascia l'handle di attesa in stato segnalato fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="7088d-277">For an <xref:System.Threading.EventWaitHandle> with <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (including <xref:System.Threading.ManualResetEvent>), calling the <xref:System.Threading.EventWaitHandle.Set%2A> method leaves the wait handle in a signaled state until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7088d-278">Nell'esempio di codice viene illustrato come utilizzare il <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> overload del metodo per consentire al thread principale di segnalare un thread bloccato e quindi attendere finché il thread termina un'attività.</span><span class="sxs-lookup"><span data-stu-id="7088d-278">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="7088d-279">L'esempio avvia cinque thread e permette il blocco su un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, quindi rilascia un thread ogni volta l'utente preme il tasto INVIO.</span><span class="sxs-lookup"><span data-stu-id="7088d-279">The example starts five threads and allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="7088d-280">Nell'esempio viene quindi Accoda un altro thread cinque e vengono rilasciati tutti utilizzando un <xref:System.Threading.EventWaitHandle> creato con il <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="7088d-280">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7088d-281">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> non è stato chiamato precedentemente in questo oggetto <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-281">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">
          <span data-ttu-id="7088d-282">Oggetto <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> che rappresenta la sicurezza del controllo di accesso da applicare all'evento di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-282">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7088d-283">Imposta la sicurezza del controllo di accesso per un evento di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-283">Sets the access control security for a named system event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-284">L'utente deve disporre <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> diritti per chiamare questo metodo e l'evento devono essere aperto con il <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span><span class="sxs-lookup"><span data-stu-id="7088d-284">The user must have <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the event must have been opened with the <xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType> flag.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7088d-285">Esempio di codice seguente viene illustrato il comportamento di processi di un evento di sistema denominato con sicurezza del controllo di accesso.</span><span class="sxs-lookup"><span data-stu-id="7088d-285">The following code example demonstrates the cross-process behavior of a named system event with access control security.</span></span> <span data-ttu-id="7088d-286">Nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo per verificare l'esistenza di un evento denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-286">The example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload to test for the existence of a named event.</span></span>  
  
 <span data-ttu-id="7088d-287">Se l'evento non esiste, viene creato con la proprietà iniziale del controllo di accesso che nega l'utente corrente il diritto di utilizzare l'evento, ma concede il diritto di leggere e modificare le autorizzazioni per l'evento.</span><span class="sxs-lookup"><span data-stu-id="7088d-287">If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.</span></span>  
  
 <span data-ttu-id="7088d-288">Se si esegue l'esempio compilato da due finestre di comando, la seconda copia genererà un'eccezione di violazione di accesso durante la chiamata a <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="7088d-288">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="7088d-289">L'eccezione viene intercettata e nell'esempio viene utilizzato il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo per attendere l'evento con i diritti necessari per leggere e modificare le autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-289">The exception is caught, and the example uses the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload to wait on the event with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7088d-290">Dopo la modifica delle autorizzazioni, utilizzando il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> (metodo), l'evento viene aperto con i diritti necessari per l'attesa e la segnalazione.</span><span class="sxs-lookup"><span data-stu-id="7088d-290">After the permissions are changed, using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, the event is opened with the rights required to wait on it and signal it.</span></span> <span data-ttu-id="7088d-291">Se si esegue l'esempio compilato da una terza finestra di comando, nell'esempio viene eseguito con le nuove autorizzazioni.</span><span class="sxs-lookup"><span data-stu-id="7088d-291">If you run the compiled example from a third command window, the example runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7088d-292">
            <paramref name="eventSecurity" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-292">
              <paramref name="eventSecurity" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7088d-293">L'utente non dispone di <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-293">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
          <span data-ttu-id="7088d-294">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-294">-or-</span>
          </span>
          <span data-ttu-id="7088d-295">L'evento non è stato aperto con <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-295">The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</span>
          </span>
        </exception>
        <exception cref="T:System.SystemException">
          <span data-ttu-id="7088d-296">L'oggetto <see cref="T:System.Threading.EventWaitHandle" /> corrente non rappresenta un evento di sistema denominato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-296">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</span>
          </span>
        </exception>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="7088d-297">Il metodo <see cref="M:System.Threading.WaitHandle.Close" /> non è stato chiamato precedentemente in questo oggetto <see cref="T:System.Threading.EventWaitHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-297">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7088d-298">Apre un evento di sincronizzazione denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è stata completata.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-298">Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="7088d-299">Nome dell'evento di sincronizzazione del sistema da aprire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-299">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="7088d-300">Quando restituisce il controllo, questo metodo contiene un oggetto <see cref="T:System.Threading.EventWaitHandle" /> che rappresenta l'evento di sincronizzazione denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-300">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="7088d-301">Questo parametro viene trattato come non inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-301">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7088d-302">Apre l'evento di sincronizzazione denominato specificato, se esistente, e restituisce un valore che indica se l'operazione è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-302">Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7088d-303">
            <see langword="true" /> se l'evento di sincronizzazione denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-303">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-304">Se l'evento di sincronizzazione denominato non esiste, questo metodo non crearlo.</span><span class="sxs-lookup"><span data-stu-id="7088d-304">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="7088d-305">Per creare l'evento di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.</span><span class="sxs-lookup"><span data-stu-id="7088d-305">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7088d-306">Se non si è certi dell'esistenza di un evento di sincronizzazione denominato, utilizzare questo overload del metodo anziché il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> overload del metodo che genera un'eccezione se l'evento di sincronizzazione non esiste.</span><span class="sxs-lookup"><span data-stu-id="7088d-306">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="7088d-307">Questo overload del metodo è equivalente alla chiamata di <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> overload del metodo e specificando <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> diritti, combinati utilizzando l'operazione OR bit per bit.</span><span class="sxs-lookup"><span data-stu-id="7088d-307">This method overload is equivalent to calling the <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> method overload and specifying <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="7088d-308">Specifica il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag consente a un thread in attesa dell'evento di sistema denominato e specificando il <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag consente a un thread di chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="7088d-308">Specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the named system event, and specifying the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="7088d-309">Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-309">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7088d-310">Il parametro <paramref name="name" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-310">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="7088d-311">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-311">-or-</span>
          </span>
          <span data-ttu-id="7088d-312">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-312">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7088d-313">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-313">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="7088d-314">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-314">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7088d-315">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-315">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7088d-316">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-316">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7088d-317">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-317">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="7088d-318">Nome dell'evento di sincronizzazione del sistema da aprire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-318">The name of the system synchronization event to open.</span>
          </span>
        </param>
        <param name="rights">
          <span data-ttu-id="7088d-319">Combinazione bit per bit dei valori di enumerazione che rappresentano l'accesso di sicurezza desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-319">A bitwise combination of the enumeration values that represent the desired security access.</span>
          </span>
        </param>
        <param name="result">
          <span data-ttu-id="7088d-320">Quando restituisce il controllo, questo metodo contiene un oggetto <see cref="T:System.Threading.EventWaitHandle" /> che rappresenta l'evento di sincronizzazione denominato se la chiamata è riuscita o <see langword="null" /> se la chiamata non è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-320">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed.</span>
          </span>
          <span data-ttu-id="7088d-321">Questo parametro viene trattato come non inizializzato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-321">This parameter is treated as uninitialized.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7088d-322">Apre l'evento di sincronizzazione denominato specificato, se esistente, con l'accesso di sicurezza desiderato e restituisce un valore che indica se l'operazione è riuscita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-322">Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7088d-323">
            <see langword="true" /> se l'evento di sincronizzazione denominato è stato aperto correttamente; in caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-323">
              <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7088d-324">Se l'evento di sincronizzazione denominato non esiste, questo metodo non crearlo.</span><span class="sxs-lookup"><span data-stu-id="7088d-324">If the named synchronization event does not exist, this method does not create it.</span></span> <span data-ttu-id="7088d-325">Per creare l'evento di sistema quando non esiste già, utilizzare uno del <xref:System.Threading.EventWaitHandle.%23ctor%2A> costruttori che dispone di un `name` parametro.</span><span class="sxs-lookup"><span data-stu-id="7088d-325">To create the system event when it does not already exist, use one of the <xref:System.Threading.EventWaitHandle.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7088d-326">Se non si è certi dell'esistenza di un evento di sincronizzazione denominato, utilizzare questo overload del metodo anziché il <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> overload del metodo che genera un'eccezione se l'evento di sincronizzazione non esiste.</span><span class="sxs-lookup"><span data-stu-id="7088d-326">If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> method overload, which throws an exception if the synchronization event does not exist.</span></span>  
  
 <span data-ttu-id="7088d-327">Il `rights` parametro deve includere il <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag per consentire ai thread in attesa dell'evento e <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag per consentire ai thread di chiamare il <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> metodi.</span><span class="sxs-lookup"><span data-stu-id="7088d-327">The `rights` parameter must include the <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the event, and the <xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.EventWaitHandle.Set%2A> and <xref:System.Threading.EventWaitHandle.Reset%2A> methods.</span></span>  
  
 <span data-ttu-id="7088d-328">Più chiamate al metodo che utilizzano lo stesso valore per `name` non restituiscono necessariamente lo stesso <xref:System.Threading.EventWaitHandle> dell'oggetto, anche se gli oggetti restituiti rappresentano lo stesso evento di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="7088d-328">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.EventWaitHandle> object, even though the objects that are returned represent the same named system event.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="7088d-329">Il parametro <paramref name="name" /> è una stringa vuota.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-329">
              <paramref name="name" /> is an empty string.</span>
          </span>
          <span data-ttu-id="7088d-330">oppure</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-330">-or-</span>
          </span>
          <span data-ttu-id="7088d-331">La lunghezza di <paramref name="name" /> supera i 260 caratteri.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-331">
              <paramref name="name" /> is longer than 260 characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7088d-332">
            <paramref name="name" /> è <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-332">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="7088d-333">Errore Win32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-333">A Win32 error occurred.</span>
          </span>
        </exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <span data-ttu-id="7088d-334">L'evento denominato esiste, ma l'utente non dispone dell'accesso di sicurezza desiderato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-334">The named event exists, but the user does not have the desired security access.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7088d-335">richiede l'attendibilità totale per il chiamante immediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-335">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7088d-336">Questo membro non può essere utilizzato da codice parzialmente attendibile o trasparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7088d-336">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>