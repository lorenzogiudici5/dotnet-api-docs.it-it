<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Timer.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac567fe19429800288028bf5585c9bd4f03134790db.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67fe19429800288028bf5585c9bd4f03134790db</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Provides a mechanism for executing a method on a thread pool thread at specified intervals.</source>
          <target state="translated">Fornisce un meccanismo per eseguire un metodo su un thread del pool di thread a intervalli specificati.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>This class cannot be inherited.</source>
          <target state="translated">Questa classe non può essere ereditata.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Use a <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate to specify the method you want the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to execute.</source>
          <target state="translated">Utilizzare un <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegato per specificare il metodo desiderato di <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> da eseguire.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The signature of the <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate is:</source>
          <target state="translated">La firma del <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegato è:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The timer delegate is specified when the timer is constructed, and cannot be changed.</source>
          <target state="translated">Il delegato timer viene specificato quando il timer viene creato e non può essere modificato.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The method does not execute on the thread that created the timer; it executes on a <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread supplied by the system.</source>
          <target state="translated">Il metodo non viene eseguito sul thread che ha creato il timer; viene eseguito per un <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread fornito dal sistema.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>.NET includes four classes named <ph id="ph1">`Timer`</ph>, each of which offers different functionality:</source>
          <target state="translated">.NET include quattro classi denominate <ph id="ph1">`Timer`</ph>in ognuno dei quali offre diverse funzionalità:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, which fires an event and executes the code in one or more event sinks at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, che viene generato un evento e viene eseguito il codice in uno o più eventi sink a intervalli regolari.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">La classe è destinata all'utilizzo come basato su server o il componente del servizio in un ambiente con multithreading non dispone di alcuna interfaccia utente e non è visibile in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>, which executes a single callback method on a thread pool thread at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph>, che esegue un metodo di callback singolo in un pool di thread a intervalli regolari.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback method is defined when the timer is instantiated and cannot be changed.</source>
          <target state="translated">Il metodo di callback viene definito quando il timer viene creata un'istanza e non può essere modificato.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Like the <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> class, this class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</source>
          <target state="translated">Ad esempio il <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph> (classe), questa classe è destinata all'utilizzo come un componente basato su server o servizio in un ambiente con multithreading, ma senza un'interfaccia utente e non è visibile in fase di esecuzione.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only), a Windows Forms component that fires an event and executes the code in one or more event sinks at regular intervals.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> (Solo .NET framework), un componente di Windows Form che genera un evento ed esegue il codice in uno o più sink di evento a intervalli regolari.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The component has no user interface and is designed for use in a single-threaded environment; it executes on the UI thread.</source>
          <target state="translated">Il componente non dispone di alcuna interfaccia utente ed è progettato per l'utilizzo in un ambiente a thread singolo viene eseguito nel thread UI.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (.NET Framework only), an ASP.NET component that performs asynchronous or synchronous web page postbacks at a regular interval.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Web.UI.Timer?displayProperty=nameWithType&gt;</ph> (Solo .NET framework), un componente ASP.NET che esegue i postback asincroni o sincroni di pagina web a intervalli regolari.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When you create a timer, you can specify an amount of time to wait before the first execution of the method (due time), and an amount of time to wait between subsequent executions (period).</source>
          <target state="translated">Quando si crea un timer, è possibile specificare un periodo di tempo di attesa prima della prima esecuzione del metodo (ora di scadenza) e una quantità di tempo di attesa tra le esecuzioni successive (punto).</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe ha la stessa risoluzione l'orologio di sistema.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>This means that if the period is less than the resolution of the system clock, the <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate will execute at intervals defined by the resolution of the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems.</source>
          <target state="translated">Ciò significa che se il periodo è minore rispetto alla risoluzione del clock di sistema di <ph id="ph1">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegato verrà eseguito a intervalli definiti per la risoluzione del clock di sistema, è di circa 15 millisecondi nei sistemi Windows 7 e Windows 8.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>You can change the due time and period, or disable the timer, by using the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">È possibile modificare la data di scadenza ora e periodo o disabilitare il timer, usando il <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>As long as you are using a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph>, you must keep a reference to it.</source>
          <target state="translated">Come si utilizza un <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph>, è necessario mantenere un riferimento a esso.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>As with any managed object, a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> is subject to garbage collection when there are no references to it.</source>
          <target state="translated">Come con qualsiasi oggetto gestito, un <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> è sottoposte a garbage collection quando non sono presenti riferimenti a esso.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The fact that a <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> is still active does not prevent it from being collected.</source>
          <target state="translated">Il fatto che un <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> è ancora attivo non impedisce che venga raccolto.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When a timer is no longer needed, use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method to free the resources held by the timer.</source>
          <target state="translated">Quando un timer non è più necessario, utilizzare il <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> metodo per liberare le risorse utilizzate dal timer.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Note that callbacks can occur after the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</source>
          <target state="translated">Si noti che i callback possono verificarsi dopo il <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> overload del metodo è stato chiamato, perché il timer accoda i callback per l'esecuzione dal thread del pool.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload to wait until all callbacks have completed.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> overload del metodo per attendere il completamento di tutti i callback.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback method executed by the timer should be reentrant, because it is called on <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">Il metodo di callback eseguito dal timer deve essere rientrante, perché viene chiamato su <ph id="ph1">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The callback can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the callback, or if all thread pool threads are in use and the callback is queued multiple times.</source>
          <target state="translated">Il callback può essere eseguito contemporaneamente in due thread di pool di thread se l'intervallo del timer è inferiore al tempo necessario per eseguire il callback, o se tutti i thread del pool sono in uso e il callback è in coda più volte.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> is a simple, lightweight timer that uses callback methods and is served by thread pool threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Timer?displayProperty=nameWithType&gt;</ph> è un timer semplice e leggero che utilizza i metodi di callback e viene servito dal thread del pool.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>It is not recommended for use with Windows Forms, because its callbacks do not occur on the user interface thread.</source>
          <target state="translated">Non è consigliabile per l'uso con Windows Form, in quanto il callback non vengono eseguiti nel thread dell'interfaccia utente.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> is a better choice for use with Windows Forms.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Forms.Timer?displayProperty=nameWithType&gt;</ph> è una scelta migliore per l'uso con Windows Form.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>For server-based timer functionality, you might consider using <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, which raises events and has additional features.</source>
          <target state="translated">Per la funzionalità di timer basate su server, è possibile utilizzare <ph id="ph1">&lt;xref:System.Timers.Timer?displayProperty=nameWithType&gt;</ph>, che genera eventi e dispone di funzionalità aggiuntive.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The following example defines a <ph id="ph1">`StatusChecker`</ph> class  that includes a <ph id="ph2">`CheckStatus`</ph> method whose signature is the same as the <ph id="ph3">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">L'esempio seguente definisce un <ph id="ph1">`StatusChecker`</ph> classe che include un <ph id="ph2">`CheckStatus`</ph> la cui firma corrisponde al metodo come la <ph id="ph3">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegato.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The  <ph id="ph1">`state`</ph> argument of the <ph id="ph2">`CheckStatus`</ph> method is an <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object that is used to synchronize the application thread and the thread pool thread that executes the callback delegate.</source>
          <target state="translated">Il <ph id="ph1">`state`</ph> argomento del <ph id="ph2">`CheckStatus`</ph> metodo è un <ph id="ph3">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> oggetto utilizzato per sincronizzare i thread dell'applicazione e il pool di thread che esegue il delegato di callback.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The <ph id="ph1">`StatusChecker`</ph> class also includes two state variables:</source>
          <target state="translated">La <ph id="ph1">`StatusChecker`</ph> classe include anche due variabili di stato:</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Indicates the number of times the callback method has been invoked.</source>
          <target state="translated">Indica il numero di volte in cui che è stato richiamato il metodo di callback.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>Determines the maximum number of times the callback method should be invoked.</source>
          <target state="translated">Determina il numero massimo di volte in cui che deve essere richiamato il metodo di callback.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The application thread creates the timer, which waits one second and then executes  the <ph id="ph1">`CheckStatus`</ph> callback method every 250 milliseconds.</source>
          <target state="translated">Il thread dell'applicazione crea il timer, che attende un secondo e quindi esegue il <ph id="ph1">`CheckStatus`</ph> metodo di callback ogni 250 millisecondi.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The application thread then blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object is signaled.</source>
          <target state="translated">Il thread dell'applicazione viene bloccato fino a quando il <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> oggetto è stato segnalato.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When the <ph id="ph1">`CheckStatus`</ph> callback method executes <ph id="ph2">`maxCount`</ph> times, it calls the <ph id="ph3">`AutoResetEvent.Set`</ph> method to set the state of the <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object to signaled.</source>
          <target state="translated">Quando il <ph id="ph1">`CheckStatus`</ph> esecuzione del metodo di callback <ph id="ph2">`maxCount`</ph> volte, chiama il <ph id="ph3">`AutoResetEvent.Set`</ph> per impostare lo stato del <ph id="ph4">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> oggetto segnalato.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>The first time this happens, the application thread calls the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29&gt;</ph> method so that the callback method now executes every half second.</source>
          <target state="translated">La prima volta in questo caso, il thread dell'applicazione chiama il <ph id="ph1">&lt;xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29&gt;</ph> metodo in modo che il metodo di callback verrà eseguito ogni mezzo secondo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>It once again blocks until the <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> object is signaled.</source>
          <target state="translated">Ancora una volta si blocca fino a quando il <ph id="ph1">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> oggetto è stato segnalato.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>When this happens, the timer is destroyed by calling its <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method, and the application terminates.</source>
          <target state="translated">In questo caso, il timer viene eliminato definitivamente chiamando il relativo <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> (metodo) e l'applicazione termina.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Timer">
          <source>This type is thread safe.</source>
          <target state="translated">Questo tipo è thread-safe.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Delegato <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> che rappresenta un metodo da eseguire.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> class with an infinite period and an infinite due time, using the newly created <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> object as the state object.</source>
          <target state="translated">Inizializza una nuova istanza della classe <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> con un periodo e un' ora di esecuzione infiniti, utilizzando l'oggetto <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> appena creato come oggetto di stato.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>Call this constructor when you want to use the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> object itself as the state object.</source>
          <target state="translated">Chiamare questo costruttore quando si desidera utilizzare il <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> oggetto stesso come oggetto di stato.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>After creating the timer, use the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method to set the interval and due time.</source>
          <target state="translated">Dopo avere creato il timer, utilizzare il <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> per impostare l'intervallo e l'ora di scadenza.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>This constructor specifies an infinite due time before the first callback and an infinite interval between callbacks, in order to prevent the first callback from occurring before the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> object is assigned to the state object.</source>
          <target state="translated">Questo costruttore viene specificato un infiniti prima il primo callback e un intervallo infinito tra i callback, per impedire che il primo callback che precedono il <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> oggetto viene assegnato all'oggetto di stato.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">Il metodo specificato per <ph id="ph1">`callback`</ph> deve essere rientrante, perché viene chiamato su <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">Il metodo può essere eseguito simultaneamente in due thread di pool di thread se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo, o se tutti i thread del pool sono in uso e il metodo viene accodato più volte.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The following code example creates a new timer, using the timer itself as the state object.</source>
          <target state="translated">Esempio di codice seguente crea un nuovo timer utilizzando il timer stesso come oggetto di stato.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method is used to start the timer.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo viene utilizzato per avviare il timer.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)">
          <source>When the timer callback occurs, the state object is used to turn the timer off.</source>
          <target state="translated">Quando si verifica il callback del timer, l'oggetto stato viene utilizzato per disattivare il timer.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Delegato <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> che rappresenta un metodo da eseguire.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback, oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">Intervallo di attesa, in millisecondi, prima che venga chiamato <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per impedire l'avvio del timer.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Specificare zero (0) per avviare il timer immediatamente.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">Intervallo di tempo, in millisecondi, tra le chiamate di <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per disabilitare la segnalazione periodica.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using a 32-bit signed integer to specify the time interval.</source>
          <target state="translated">Consente di inizializzare una nuova istanza della classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilizzando un integer con segno a 32 bit per specificare l'intervallo di tempo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">Il delegato specificato per il <ph id="ph1">`callback`</ph> parametro viene richiamato una volta dopo <ph id="ph2">`dueTime`</ph> scade e successivamente ogni volta che il <ph id="ph3">`period`</ph> dell'intervallo di tempo.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è zero (0), <ph id="ph2">`callback`</ph> viene richiamato immediatamente.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> non viene richiamato; il timer è disabilitato, ma possono essere riabilitato tramite la chiamata di <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Poiché il <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe ha la stessa risoluzione l'orologio di sistema, è di circa 15 millisecondi nei sistemi Windows 7 e Windows 8, il <ph id="ph2">`callback`</ph> delegato viene eseguito a intervalli definiti per la risoluzione del clock di sistema se <ph id="ph3">`period`</ph>è minore rispetto alla risoluzione del clock di sistema.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> è zero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">`dueTime`</ph> non <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> viene richiamato una volta; il comportamento periodico del timer è disabilitato, ma può essere riattivato tramite il <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">Il metodo specificato per <ph id="ph1">`callback`</ph> deve essere rientrante, perché viene chiamato su <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">Il metodo può essere eseguito simultaneamente in due thread di pool di thread se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo, o se tutti i thread del pool sono in uso e il metodo viene accodato più volte.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The following code example shows how to create a <ph id="ph1">`TimerCallback`</ph> delegate and initialize a new instance of the <ph id="ph2">`Timer`</ph> class.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare un <ph id="ph1">`TimerCallback`</ph> delegato e inizializzare una nuova istanza di <ph id="ph2">`Timer`</ph> classe.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è negativo e non è uguale a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> delegate representing a method to be executed.</source>
          <target state="translated">Delegato <ph id="ph1">&lt;see cref="T:System.Threading.TimerCallback" /&gt;</ph> che rappresenta un metodo da eseguire.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback, oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">Intervallo di attesa, in millisecondi, prima che venga chiamato <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per impedire l'avvio del timer.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Specificare zero (0) per avviare il timer immediatamente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">Intervallo di tempo, in millisecondi, tra le chiamate di <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per disabilitare la segnalazione periodica.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using 64-bit signed integers to measure time intervals.</source>
          <target state="translated">Consente l'inizializzazione di una nuova istanza della classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilizzando integer con segno a 64 bit per misurare gli intervalli di tempo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">Il delegato specificato per il <ph id="ph1">`callback`</ph> parametro viene richiamato una volta dopo <ph id="ph2">`dueTime`</ph> scade e successivamente ogni volta che il <ph id="ph3">`period`</ph> dell'intervallo di tempo.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è zero (0), <ph id="ph2">`callback`</ph> viene richiamato immediatamente.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> non viene richiamato; il timer è disabilitato, ma possono essere riabilitato tramite la chiamata di <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Poiché il <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe ha la stessa risoluzione l'orologio di sistema, è di circa 15 millisecondi nei sistemi Windows 7 e Windows 8, il <ph id="ph2">`callback`</ph> delegato viene eseguito a intervalli definiti per la risoluzione del clock di sistema se <ph id="ph3">`period`</ph>è minore rispetto alla risoluzione del clock di sistema.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> è zero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">`dueTime`</ph> non <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> viene richiamato una volta; il comportamento periodico del timer è disabilitato, ma può essere riattivato tramite il <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">Il metodo specificato per <ph id="ph1">`callback`</ph> deve essere rientrante, perché viene chiamato su <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">Il metodo può essere eseguito simultaneamente in due thread di pool di thread se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo, o se tutti i thread del pool sono in uso e il metodo viene accodato più volte.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è negativo e non è uguale a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is greater than 4294967294.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è maggiore di 4294967294.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>A delegate representing a method to be executed.</source>
          <target state="translated">Delegato che rappresenta un metodo da eseguire.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback, oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The amount of time to delay before the <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> parameter invokes its methods.</source>
          <target state="translated">Intervallo di attesa prima che il parametro <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> chiami i relativi metodi.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to prevent the timer from starting.</source>
          <target state="translated">Specificare il valore uno negativo (-1) in millisecondi per impedire l'avvio del timer.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Specificare zero (0) per avviare il timer immediatamente.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The time interval between invocations of the methods referenced by <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Intervallo di tempo tra le chiamate dei metodi a cui fa riferimento <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to disable periodic signaling.</source>
          <target state="translated">Specificare il valore uno negativo (-1) in millisecondi per disabilitare la segnalazione periodica.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> values to measure time intervals.</source>
          <target state="translated">Consente l'inizializzazione di una nuova istanza della classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilizzando i valori <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> per misurare gli intervalli di tempo.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">Il delegato specificato per il <ph id="ph1">`callback`</ph> parametro viene richiamato una volta dopo <ph id="ph2">`dueTime`</ph> scade e successivamente ogni volta che il <ph id="ph3">`period`</ph> dell'intervallo di tempo.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è zero (0), <ph id="ph2">`callback`</ph> viene richiamato immediatamente.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is negative one (-1) milliseconds, <ph id="ph2">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è uno negativo (-1) in millisecondi, <ph id="ph2">`callback`</ph> non viene richiamato; il timer è disabilitato, ma possono essere riabilitato tramite la chiamata di <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Poiché il <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe ha la stessa risoluzione l'orologio di sistema, è di circa 15 millisecondi nei sistemi Windows 7 e Windows 8, il <ph id="ph2">`callback`</ph> delegato viene eseguito a intervalli definiti per la risoluzione del clock di sistema se <ph id="ph3">`period`</ph>è minore rispetto alla risoluzione del clock di sistema.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or negative one (-1) milliseconds and <ph id="ph2">`dueTime`</ph> is positive, <ph id="ph3">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> è zero (0) o negativo (-1) in millisecondi e <ph id="ph2">`dueTime`</ph> è positivo, <ph id="ph3">`callback`</ph> viene richiamato una volta; il comportamento periodico del timer è disabilitato, ma può essere riattivato tramite il <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">Il metodo specificato per <ph id="ph1">`callback`</ph> deve essere rientrante, perché viene chiamato su <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">Il metodo può essere eseguito simultaneamente in due thread di pool di thread se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo, o se tutti i thread del pool sono in uso e il metodo viene accodato più volte.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The following code example shows how to create a <ph id="ph1">`TimerCallback`</ph> delegate and initialize a new instance of the <ph id="ph2">`Timer`</ph> class.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come creare un <ph id="ph1">`TimerCallback`</ph> delegato e inizializzare una nuova istanza di <ph id="ph2">`Timer`</ph> classe.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The number of milliseconds in the value of <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> is negative and not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>, or is greater than <ph id="ph4">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Il numero di millisecondi nel valore di <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è negativo e non è uguale a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>, oppure è maggiore di <ph id="ph4">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>A delegate representing a method to be executed.</source>
          <target state="translated">Delegato che rappresenta un metodo da eseguire.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>An object containing information to be used by the callback method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback, oppure <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The amount of time to delay before <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept> is invoked, in milliseconds.</source>
          <target state="translated">Intervallo di attesa, in millisecondi, prima che venga chiamato <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from starting.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per impedire l'avvio del timer.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify zero (0) to start the timer immediately.</source>
          <target state="translated">Specificare zero (0) per avviare il timer immediatamente.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The time interval between invocations of <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>, in milliseconds.</source>
          <target state="translated">Intervallo di tempo, in millisecondi, tra le chiamate di <bpt id="p1">&lt;c&gt;</bpt>callback<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per disabilitare la segnalazione periodica.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> class, using 32-bit unsigned integers to measure time intervals.</source>
          <target state="translated">Consente l'inizializzazione di una nuova istanza della classe <ph id="ph1">&lt;see langword="Timer" /&gt;</ph> utilizzando integer senza segno a 32 bit per misurare gli intervalli di tempo.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The delegate specified by the <ph id="ph1">`callback`</ph> parameter is invoked once after <ph id="ph2">`dueTime`</ph> elapses, and thereafter each time the <ph id="ph3">`period`</ph> time interval elapses.</source>
          <target state="translated">Il delegato specificato per il <ph id="ph1">`callback`</ph> parametro viene richiamato una volta dopo <ph id="ph2">`dueTime`</ph> scade e successivamente ogni volta che il <ph id="ph3">`period`</ph> dell'intervallo di tempo.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), <ph id="ph2">`callback`</ph> is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è zero (0), <ph id="ph2">`callback`</ph> viene richiamato immediatamente.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> is not invoked; the timer is disabled, but can be re-enabled by calling the <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">`callback`</ph> non viene richiamato; il timer è disabilitato, ma possono essere riabilitato tramite la chiamata di <ph id="ph4">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>Because the <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the <ph id="ph2">`callback`</ph> delegate executes at intervals defined by the resolution of the system clock if <ph id="ph3">`period`</ph> is less than the resolution of the system clock.</source>
          <target state="translated">Poiché il <ph id="ph1">&lt;xref:System.Threading.Timer&gt;</ph> classe ha la stessa risoluzione l'orologio di sistema, è di circa 15 millisecondi nei sistemi Windows 7 e Windows 8, il <ph id="ph2">`callback`</ph> delegato viene eseguito a intervalli definiti per la risoluzione del clock di sistema se <ph id="ph3">`period`</ph>è minore rispetto alla risoluzione del clock di sistema.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> è zero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph> e <ph id="ph3">`dueTime`</ph> non <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">`callback`</ph> viene richiamato una volta; il comportamento periodico del timer è disabilitato, ma può essere riattivato tramite il <ph id="ph6">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The method specified for <ph id="ph1">`callback`</ph> should be reentrant, because it is called on <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> threads.</source>
          <target state="translated">Il metodo specificato per <ph id="ph1">`callback`</ph> deve essere rientrante, perché viene chiamato su <ph id="ph2">&lt;xref:System.Threading.ThreadPool&gt;</ph> thread.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</source>
          <target state="translated">Il metodo può essere eseguito simultaneamente in due thread di pool di thread se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo, o se tutti i thread del pool sono in uso e il metodo viene accodato più volte.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è negativo e non è uguale a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="callback" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Changes the start time and the interval between method invocations for a timer.</source>
          <target state="translated">Modifica l'ora di inizio e l'intervallo tra le chiamate dei metodi di un timer.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Intervallo di attesa, in millisecondi, prima di richiamare il metodo di callback specificato quando <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> è stato costruito.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per impedire il riavvio del timer.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Specificare zero (0) per riavviare il timer immediatamente.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Intervallo di tempo, in millisecondi, tra le chiamate del metodo di callback specificato quando è stato costruito <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per disabilitare la segnalazione periodica.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>Changes the start time and the interval between method invocations for a timer, using 32-bit signed integers to measure time intervals.</source>
          <target state="translated">Modifica l'ora di inizio e l'intervallo tra le chiamate dei metodi di un timer, usando interi con segno a 32 bit per misurare gli intervalli di tempo.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il timer è stato aggiornato correttamente, in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">Il metodo di callback viene richiamato una volta dopo <ph id="ph1">`dueTime`</ph> allo scadere dell'intervallo e successivamente ogni volta l'intervallo di tempo specificato da <ph id="ph2">`period`</ph> scade.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è zero (0), il metodo di callback viene richiamato immediatamente.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, il metodo di callback non viene mai richiamato; il timer è disabilitato, ma può essere riattivato chiamando <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e specificando un valore positivo per <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> è zero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">`dueTime`</ph> non <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, il metodo di callback viene richiamato una volta; il comportamento periodico del timer è disabilitato, ma può essere riattivato chiamando <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e specificando un valore positivo per <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo può essere chiamato dal <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegato.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The following code example demonstrates how to start a <ph id="ph1">`Timer`</ph> and, after a set number of invocations, change its period.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come avviare un <ph id="ph1">`Timer`</ph> e, dopo un numero di set di chiamate, modificarne il periodo.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated">L'istanza <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> è già stata eliminata.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is negative and is not equal to <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è negativo e non è uguale a <ph id="ph3">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Intervallo di attesa, in millisecondi, prima di richiamare il metodo di callback specificato quando <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> è stato costruito.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per impedire il riavvio del timer.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Specificare zero (0) per riavviare il timer immediatamente.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Intervallo di tempo, in millisecondi, tra le chiamate del metodo di callback specificato quando è stato costruito <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per disabilitare la segnalazione periodica.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>Changes the start time and the interval between method invocations for a timer, using 64-bit signed integers to measure time intervals.</source>
          <target state="translated">Modifica l'ora di inizio e l'intervallo tra le chiamate dei metodi di un timer, usando interi con segno a 64 bit per misurare gli intervalli di tempo.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il timer è stato aggiornato correttamente, in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">Il metodo di callback viene richiamato una volta dopo <ph id="ph1">`dueTime`</ph> allo scadere dell'intervallo e successivamente ogni volta l'intervallo di tempo specificato da <ph id="ph2">`period`</ph> scade.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è zero (0), il metodo di callback viene richiamato immediatamente.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, il metodo di callback non viene mai richiamato; il timer è disabilitato, ma può essere riattivato chiamando <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e specificando un valore positivo per <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> è zero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">`dueTime`</ph> non <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, il metodo di callback viene richiamato una volta; il comportamento periodico del timer è disabilitato, ma può essere riattivato chiamando <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e specificando un valore positivo per <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo può essere chiamato dal <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegato.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated">L'istanza <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> è già stata eliminata.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is less than -1.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è minore di -1.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter is greater than 4294967294.</source>
          <target state="translated">Il parametro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è maggiore di 4294967294.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> representing the amount of time to delay before invoking the callback method specified when the <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed.</source>
          <target state="translated">Parametro <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> che rappresenta l'intervallo di attesa prima di richiamare il metodo di callback specificato quando <ph id="ph2">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> è stato costruito.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to prevent the timer from restarting.</source>
          <target state="translated">Specificare il valore uno negativo (-1) in millisecondi per impedire il riavvio del timer.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Specificare zero (0) per riavviare il timer immediatamente.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed.</source>
          <target state="translated">Intervallo di tempo tra le chiamate del metodo di callback specificato quando è stato costruito <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Specify negative one (-1) milliseconds to disable periodic signaling.</source>
          <target state="translated">Specificare il valore uno negativo (-1) in millisecondi per disabilitare la segnalazione periodica.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>Changes the start time and the interval between method invocations for a timer, using <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> values to measure time intervals.</source>
          <target state="translated">Consente di modificare il tempo di attesa e gli intervalli tra i richiami di un timer utilizzando i valori di <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> per misurare gli intervalli di tempo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il timer è stato aggiornato correttamente, in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">Il metodo di callback viene richiamato una volta dopo <ph id="ph1">`dueTime`</ph> allo scadere dell'intervallo e successivamente ogni volta l'intervallo di tempo specificato da <ph id="ph2">`period`</ph> scade.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è zero (0), il metodo di callback viene richiamato immediatamente.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`dueTime`</ph> is negative one (-1) milliseconds, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph2">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph3">`dueTime`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è negativo (-1) in millisecondi, il metodo di callback non viene mai richiamato; il timer è disabilitato, ma può essere riattivato chiamando <ph id="ph2">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e specificando un valore positivo per <ph id="ph3">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or negative one (-1) milliseconds, and <ph id="ph2">`dueTime`</ph> is positive, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a value greater than zero for <ph id="ph4">`period`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> è zero (0) o uno negativo (-1) in millisecondi, e <ph id="ph2">`dueTime`</ph> è positivo, il metodo di callback viene richiamato una volta; il comportamento periodico del timer è disabilitato, ma può essere riattivato chiamando <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e specificando un valore maggiore di zero per <ph id="ph4">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo può essere chiamato dal <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegato.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The following code example demonstrates how to start a <ph id="ph1">`Timer`</ph> and, after a set number of invocations, change its period.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come avviare un <ph id="ph1">`Timer`</ph> e, dopo un numero di set di chiamate, modificarne il periodo.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated">L'istanza <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> è già stata eliminata.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter, in milliseconds, is less than -1.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è inferiore a -1, in millisecondi.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> or <ph id="ph2">&lt;paramref name="period" /&gt;</ph> parameter, in milliseconds, is greater than 4294967294.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="dueTime" /&gt;</ph> o <ph id="ph2">&lt;paramref name="period" /&gt;</ph> è superiore a 4294967294, in millisecondi.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The amount of time to delay before the invoking the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Intervallo di attesa, in millisecondi, prima di richiamare il metodo di callback specificato quando <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> è stato costruito.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to prevent the timer from restarting.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per impedire il riavvio del timer.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify zero (0) to restart the timer immediately.</source>
          <target state="translated">Specificare zero (0) per riavviare il timer immediatamente.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The time interval between invocations of the callback method specified when the <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> was constructed, in milliseconds.</source>
          <target state="translated">Intervallo di tempo, in millisecondi, tra le chiamate del metodo di callback specificato quando è stato costruito <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Specify <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> to disable periodic signaling.</source>
          <target state="translated">Specificare <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> per disabilitare la segnalazione periodica.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>Changes the start time and the interval between method invocations for a timer, using 32-bit unsigned integers to measure time intervals.</source>
          <target state="translated">Modifica l'ora di inizio e l'intervallo tra le chiamate dei metodi di un timer, usando interi senza segno a 32 bit per misurare gli intervalli di tempo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the timer was successfully updated; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se il timer è stato aggiornato correttamente, in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The callback method is invoked once after <ph id="ph1">`dueTime`</ph> elapses, and thereafter each time the time interval specified by <ph id="ph2">`period`</ph> elapses.</source>
          <target state="translated">Il metodo di callback viene richiamato una volta dopo <ph id="ph1">`dueTime`</ph> allo scadere dell'intervallo e successivamente ogni volta l'intervallo di tempo specificato da <ph id="ph2">`period`</ph> scade.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is zero (0), the callback method is invoked immediately.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è zero (0), il metodo di callback viene richiamato immediatamente.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`dueTime`</ph> is <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph4">`dueTime`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`dueTime`</ph> è <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, il metodo di callback non viene mai richiamato; il timer è disabilitato, ma può essere riattivato chiamando <ph id="ph3">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e specificando un valore positivo per <ph id="ph4">`dueTime`</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>If <ph id="ph1">`period`</ph> is zero (0) or <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">`dueTime`</ph> is not <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> and specifying a positive value for <ph id="ph6">`period`</ph>.</source>
          <target state="translated">Se <ph id="ph1">`period`</ph> è zero (0) o <ph id="ph2">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, e <ph id="ph3">`dueTime`</ph> non <ph id="ph4">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType&gt;</ph>, il metodo di callback viene richiamato una volta; il comportamento periodico del timer è disabilitato, ma può essere riattivato chiamando <ph id="ph5">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> e specificando un valore positivo per <ph id="ph6">`period`</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method can be called from the <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegate.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo può essere chiamato dal <ph id="ph2">&lt;xref:System.Threading.TimerCallback&gt;</ph> delegato.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> has already been disposed.</source>
          <target state="translated">L'istanza <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> è già stata eliminata.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="T:System.Threading.Timer">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</source>
          <target state="translated">Consente di rilasciare tutte le risorse utilizzate dall'istanza corrente di <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</source>
          <target state="translated">Consente di rilasciare tutte le risorse utilizzate dall'istanza corrente di <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>Calling <ph id="ph1">`Dispose`</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to be reallocated for other purposes.</source>
          <target state="translated">La chiamata <ph id="ph1">`Dispose`</ph> le risorse utilizzate da di <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> riallocazione per altri scopi.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>For more information about <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`Dispose`</ph>, vedere <bpt id="p1">[</bpt>la pulizia di risorse non gestite<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>Callbacks can occur after the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</source>
          <target state="translated">I callback possono verificarsi dopo il <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose&gt;</ph> overload del metodo è stato chiamato, perché il timer accoda i callback per l'esecuzione dal thread del pool.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>You can use the <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload to wait until all callbacks have completed.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> overload del metodo per attendere il completamento di tutti i callback.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose">
          <source>The following code example shows how to free the resources held by a <ph id="ph1">`Timer`</ph>.</source>
          <target state="translated">Esempio di codice seguente viene illustrato come liberare le risorse utilizzate da un <ph id="ph1">`Timer`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> to be signaled when the <ph id="ph2">&lt;see langword="Timer" /&gt;</ph> has been disposed of.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> da segnalare quando <ph id="ph2">&lt;see langword="Timer" /&gt;</ph> è stato eliminato.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>Releases all resources used by the current instance of <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> and signals when the timer has been disposed of.</source>
          <target state="translated">Consente di rilasciare tutte le risorse utilizzate dall'istanza corrente di <ph id="ph1">&lt;see cref="T:System.Threading.Timer" /&gt;</ph> segnalando l'ora dell'eliminazione del timer.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the function succeeds; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Viene restituito <ph id="ph1">&lt;see langword="true" /&gt;</ph> se la funzione viene eseguita correttamente; in caso contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>Calling <ph id="ph1">`Dispose`</ph> allows the resources used by the <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> to be reallocated for other purposes.</source>
          <target state="translated">La chiamata <ph id="ph1">`Dispose`</ph> le risorse utilizzate da di <ph id="ph2">&lt;xref:System.Threading.Timer&gt;</ph> riallocazione per altri scopi.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>For more information about <ph id="ph1">`Dispose`</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</source>
          <target state="translated">Per ulteriori informazioni su <ph id="ph1">`Dispose`</ph>, vedere <bpt id="p1">[</bpt>la pulizia di risorse non gestite<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>When this method completes, it signals the <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> specified by the <ph id="ph2">`notifyObject`</ph> parameter.Use this overload of the <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> method if you want to be able to block until you are certain that the timer has been disposed.</source>
          <target state="translated">Quando questo metodo viene completato, viene segnalato il <ph id="ph1">&lt;xref:System.Threading.WaitHandle&gt;</ph> specificato per il <ph id="ph2">`notifyObject`</ph> parametro. Utilizzare questo overload del metodo di <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%2A&gt;</ph> metodo se si desidera essere in grado di bloccare fino a quando non si è certi che il timer è stato eliminato.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The timer is not disposed until all currently queued callbacks have completed.</source>
          <target state="translated">Il timer non viene eliminato fino al completamento di tutte le richiamate attualmente in coda.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>If the callback uses the <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method to set the <ph id="ph2">`dueTime`</ph> parameter to zero, a race condition can occur when the <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload is called: If the timer queues a new callback before the <ph id="ph4">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> method overload detects that there are no callbacks queued, <ph id="ph5">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> continues to block; otherwise, the timer is disposed while the new callback is being queued, and an <ph id="ph6">&lt;xref:System.ObjectDisposedException&gt;</ph> is thrown when the new callback calls the <ph id="ph7">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> method.</source>
          <target state="translated">Se il callback utilizza il <ph id="ph1">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> per impostare il <ph id="ph2">`dueTime`</ph> parametro a zero, che può verificarsi una race condition quando il <ph id="ph3">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> overload del metodo viene chiamato: se il timer Accoda un callback di nuovo prima il <ph id="ph4">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> overload del metodo rileva che non esiste alcun callback non vengono accodati, <ph id="ph5">&lt;xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29&gt;</ph> continua a bloccare; in caso contrario, il timer è stato eliminato durante il callback nuovo accodato e un <ph id="ph6">&lt;xref:System.ObjectDisposedException&gt;</ph> viene generata quando viene chiamato il callback di nuovo il <ph id="ph7">&lt;xref:System.Threading.Timer.Change%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)">
          <source>The <ph id="ph1">&lt;paramref name="notifyObject" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Il valore del parametro <ph id="ph1">&lt;paramref name="notifyObject" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>