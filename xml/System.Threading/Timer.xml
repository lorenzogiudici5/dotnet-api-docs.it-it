<Type Name="Timer" FullName="System.Threading.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="850f98ec99dc9ee3a5817298d122036b8c83722a" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39778622" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Timer : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Timer extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Timer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Timer&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer sealed : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Timer</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornisce un meccanismo per eseguire un metodo su un thread del pool di thread a intervalli specificati. Questa classe non può essere ereditata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usare un <xref:System.Threading.TimerCallback> delegato per specificare il metodo desiderato di <xref:System.Threading.Timer> da eseguire. La firma del <xref:System.Threading.TimerCallback> delegato è:  
  
```csharp  
void TimerCallback(Object state)  
```  
  
```cpp  
void TimerCallback(Object state)  
```  
  
```vb  
Sub TimerCallback(state As Object)  
```  
  
 Il delegato di timer viene specificato quando il timer viene costruito e non può essere modificato. Il metodo non viene eseguito sul thread che ha creato il timer; bensì su una <xref:System.Threading.ThreadPool> thread fornito dal sistema.  
  
> [!TIP]
> .NET include quattro classi denominate `Timer`, ognuno dei quali offre diverse funzionalità:  
>
> - <xref:System.Timers.Timer?displayProperty=nameWithType>, che genera un evento e viene eseguito il codice in uno o più eventi sink a intervalli regolari. La classe è destinata da utilizzare come un server basato su o componente del servizio in un ambiente a thread multipli; non dispone di alcuna interfaccia utente e non è visibile in fase di esecuzione.
> - <xref:System.Threading.Timer?displayProperty=nameWithType>, che viene eseguito un metodo di callback singolo in un pool di thread a intervalli regolari. Il metodo di callback viene definito quando il timer viene creata un'istanza e non può essere modificato. Ad esempio il <xref:System.Timers.Timer?displayProperty=nameWithType> (classe), questa classe è destinata all'utilizzo come un componente basato su server o del servizio in un ambiente multithreading, ma senza un'interfaccia utente e non è visibile in fase di esecuzione.
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Solo .NET framework), un componente di Windows Form che genera un evento ed esegue il codice in uno o più sink di evento a intervalli regolari. Il componente non dispone di alcuna interfaccia utente ed è progettato per l'uso in un ambiente a thread singolo viene eseguito sul thread UI.
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Solo .NET framework), un componente ASP.NET che esegue postback asincroni o sincroni pagine web a intervalli regolari.
  
 Quando si crea un timer, è possibile specificare un periodo di tempo di attesa prima della prima esecuzione del metodo (scadenza) e un periodo di tempo di attesa tra le esecuzioni successive (punto). Il <xref:System.Threading.Timer> classe avrà la stessa risoluzione come l'orologio di sistema. Ciò significa che se il periodo è minore rispetto alla risoluzione dell'orologio di sistema, il <xref:System.Threading.TimerCallback> delegato verrà eseguita a intervalli definiti mediante la risoluzione dell'orologio di sistema, è di circa 15 millisecondi nei sistemi Windows 7 e Windows 8. È possibile modificare la data di scadenza tempo e punto o disabilita il timer, usando il <xref:System.Threading.Timer.Change%2A> (metodo).  
  
> [!NOTE]
>  Fino a quando si usa un <xref:System.Threading.Timer>, è necessario mantenere un riferimento a esso. Come con qualsiasi oggetto gestito, un <xref:System.Threading.Timer> è sottoposte a garbage collection quando non sono presenti riferimenti a esso. Il fatto che un <xref:System.Threading.Timer> è ancora attivo non impedisce che venga raccolto.  
  
 Quando un timer non è più necessario, usare il <xref:System.Threading.Timer.Dispose%2A> metodo per liberare le risorse detenute dal timer. Si noti che i callback possono verificarsi dopo il <xref:System.Threading.Timer.Dispose> overload del metodo è stato chiamato, perché il timer accoda i callback per l'esecuzione dal thread del pool. È possibile usare il <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> overload del metodo per attendere fino al completamento di tutte le richiamate.  
  
 Il metodo di callback eseguito dal timer deve essere rientrante, perché viene chiamato su <xref:System.Threading.ThreadPool> thread. Il callback può essere eseguito contemporaneamente su due thread del pool se l'intervallo del timer è inferiore al tempo necessario per eseguire il callback, o se tutti i thread del pool sono in uso e il callback è in coda più volte.  
  
> [!NOTE]
>  <xref:System.Threading.Timer?displayProperty=nameWithType> è un timer semplice e leggero che usa i metodi di callback e viene servito dal pool di thread. Si consiglia di non per l'uso con Windows Form, in quanto il callback non vengono eseguiti nel thread dell'interfaccia utente. <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> è una scelta migliore per l'uso con Windows Form. Per la funzionalità di timer basate su server, è possibile considerare l'uso <xref:System.Timers.Timer?displayProperty=nameWithType>, che genera eventi e include funzionalità aggiuntive.  
  
   
  
## Examples  
 L'esempio seguente definisce una `StatusChecker` classe che include un `CheckStatus` metodo la cui firma è lo stesso come il <xref:System.Threading.TimerCallback> delegare. Il `state` argomento del `CheckStatus` metodo è un <xref:System.Threading.AutoResetEvent> oggetto utilizzato per sincronizzare i thread dell'applicazione e il pool di thread che esegue il delegato di callback. Il `StatusChecker` classe include anche due variabili di stato:  
  
 `invokeCount`  
 Indica il numero di volte in cui che è stato richiamato il metodo di callback.  
  
 `maxCount`  
 Determina il numero massimo di volte in cui che deve essere richiamato il metodo di callback.  
  
 Il thread dell'applicazione consente di creare il timer, che rimane in attesa un secondo, quindi viene eseguita la `CheckStatus` metodo di callback ogni 250 millisecondi. Il thread dell'applicazione quindi blocca fino a quando il <xref:System.Threading.AutoResetEvent> oggetto viene segnalato. Quando la `CheckStatus` esecuzione del metodo di callback `maxCount` volte, chiama il `AutoResetEvent.Set` metodo per impostare lo stato del <xref:System.Threading.AutoResetEvent> oggetto segnalato. La prima volta in questo caso, il thread dell'applicazione chiama il <xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29> metodo in modo che il metodo di callback viene ora eseguita ogni mezzo secondo. Ancora una volta blocca fino a quando il <xref:System.Threading.AutoResetEvent> oggetto viene segnalato. In questo caso, il timer viene eliminato definitivamente chiamando relativo <xref:System.Threading.Timer.Dispose%2A> (metodo) e l'applicazione termina.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Questo tipo è thread-safe.</threadsafe>
    <altmember cref="T:System.Threading.TimerCallback" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see langword="Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback -&gt; System.Threading.Timer" Usage="new System.Threading.Timer callback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato <see cref="T:System.Threading.TimerCallback" /> che rappresenta un metodo da eseguire.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Threading.Timer" /> con un periodo e un' ora di esecuzione infiniti, utilizzando l'oggetto <see cref="T:System.Threading.Timer" /> appena creato come oggetto di stato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chiamare questo costruttore quando si desidera utilizzare il <xref:System.Threading.Timer> oggetto stesso come oggetto di stato. Dopo aver creato il timer, usare il <xref:System.Threading.Timer.Change%2A> metodo per impostare l'intervallo e l'ora di scadenza.  
  
 Questo costruttore specifica una scadenza infinite ora precedente il callback prima e un intervallo infinito tra i callback, allo scopo di impedire che il callback prima che si verificano prima il <xref:System.Threading.Timer> oggetto viene assegnato all'oggetto stato.  
  
 Il metodo specificato per `callback` deve essere rientrante, poiché viene chiamato su <xref:System.Threading.ThreadPool> thread. Il metodo può essere eseguito simultaneamente in due thread del pool se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo o se tutti i thread del pool sono in uso e il metodo è in coda più volte.  
  
   
  
## Examples  
 Esempio di codice seguente crea un nuovo timer, usando il timer di se stesso come oggetto di stato. Il <xref:System.Threading.Timer.Change%2A> metodo viene utilizzato per avviare il timer. Quando si verifica il callback di timer, l'oggetto di stato consente di disattivare il timer.  
  
 [!code-csharp[TimerSelfCtor#1](~/samples/snippets/csharp/VS_Snippets_Misc/timerSelfCtor/CS/source.cs#1)]
 [!code-vb[TimerSelfCtor#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/timerSelfCtor/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Integer, period As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, int dueTime, int period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int * int -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato <see cref="T:System.Threading.TimerCallback" /> che rappresenta un metodo da eseguire.</param>
        <param name="state">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback, oppure <see langword="null" />.</param>
        <param name="dueTime">Intervallo di attesa, in millisecondi, prima che venga chiamato <c>callback</c>. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per impedire l'avvio del timer. Specificare zero (0) per avviare il timer immediatamente.</param>
        <param name="period">Intervallo di tempo, in millisecondi, tra le chiamate di <c>callback</c>. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per disabilitare la segnalazione periodica.</param>
        <summary>Consente di inizializzare una nuova istanza della classe <see langword="Timer" /> utilizzando un integer con segno a 32 bit per specificare l'intervallo di tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il delegato specificato per il `callback` parametro viene richiamato una volta dopo `dueTime` scade e successivamente ogni volta che il `period` scadenza dell'intervallo di tempo.  
  
 Se `dueTime` è zero (0), `callback` viene richiamato immediatamente. Se `dueTime` viene <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` non viene richiamato, il timer è disabilitato, ma possono essere riabilitato tramite una chiamata di <xref:System.Threading.Timer.Change%2A> (metodo).  
  
 Poiché il <xref:System.Threading.Timer> classe avrà la stessa risoluzione come l'orologio di sistema, ovvero circa 15 millisecondi nei sistemi Windows 7 e Windows 8, il `callback` delegato viene eseguito a intervalli definiti mediante la risoluzione del clock di sistema se `period`è minore rispetto alla risoluzione del clock di sistema. Se `period` è zero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` non è <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` viene richiamato una sola volta; il comportamento periodico del timer è disabilitato, ma possono essere riabilitato tramite il <xref:System.Threading.Timer.Change%2A> (metodo).  
  
 Il metodo specificato per `callback` deve essere rientrante, poiché viene chiamato su <xref:System.Threading.ThreadPool> thread. Il metodo può essere eseguito simultaneamente in due thread del pool se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo o se tutti i thread del pool sono in uso e il metodo è in coda più volte.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come creare un `TimerCallback` delegare e inizializzare una nuova istanza di `Timer` classe.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="dueTime" /> o <paramref name="period" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="callback" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Long, period As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, long dueTime, long period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * int64 * int64 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato <see cref="T:System.Threading.TimerCallback" /> che rappresenta un metodo da eseguire.</param>
        <param name="state">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback, oppure <see langword="null" />.</param>
        <param name="dueTime">Intervallo di attesa, in millisecondi, prima che venga chiamato <c>callback</c>. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per impedire l'avvio del timer. Specificare zero (0) per avviare il timer immediatamente.</param>
        <param name="period">Intervallo di tempo, in millisecondi, tra le chiamate di <c>callback</c>. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per disabilitare la segnalazione periodica.</param>
        <summary>Consente l'inizializzazione di una nuova istanza della classe <see langword="Timer" /> utilizzando integer con segno a 64 bit per misurare gli intervalli di tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il delegato specificato per il `callback` parametro viene richiamato una volta dopo `dueTime` scade e successivamente ogni volta che il `period` scadenza dell'intervallo di tempo.  
  
 Se `dueTime` è zero (0), `callback` viene richiamato immediatamente. Se `dueTime` viene <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` non viene richiamato, il timer è disabilitato, ma possono essere riabilitato tramite una chiamata di <xref:System.Threading.Timer.Change%2A> (metodo).  
  
 Poiché il <xref:System.Threading.Timer> classe avrà la stessa risoluzione come l'orologio di sistema, ovvero circa 15 millisecondi nei sistemi Windows 7 e Windows 8, il `callback` delegato viene eseguito a intervalli definiti mediante la risoluzione del clock di sistema se `period`è minore rispetto alla risoluzione del clock di sistema. Se `period` è zero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` non è <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` viene richiamato una sola volta; il comportamento periodico del timer è disabilitato, ma possono essere riabilitato tramite il <xref:System.Threading.Timer.Change%2A> (metodo).  
  
 Il metodo specificato per `callback` deve essere rientrante, poiché viene chiamato su <xref:System.Threading.ThreadPool> thread. Il metodo può essere eseguito simultaneamente in due thread del pool se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo o se tutti i thread del pool sono in uso e il metodo è in coda più volte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="dueTime" /> o <paramref name="period" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.NotSupportedException">Il parametro <paramref name="dueTime" /> o <paramref name="period" /> è maggiore di 4294967294.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As TimeSpan, period As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * TimeSpan * TimeSpan -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato che rappresenta un metodo da eseguire.</param>
        <param name="state">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback, oppure <see langword="null" />.</param>
        <param name="dueTime">Intervallo di attesa prima che il parametro <c>callback</c> chiami i relativi metodi. Specificare il valore uno negativo (-1) in millisecondi per impedire l'avvio del timer. Specificare zero (0) per avviare il timer immediatamente.</param>
        <param name="period">Intervallo di tempo tra le chiamate dei metodi a cui fa riferimento <c>callback</c>. Specificare il valore uno negativo (-1) in millisecondi per disabilitare la segnalazione periodica.</param>
        <summary>Consente l'inizializzazione di una nuova istanza della classe <see langword="Timer" /> utilizzando i valori <see cref="T:System.TimeSpan" /> per misurare gli intervalli di tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il delegato specificato per il `callback` parametro viene richiamato una volta dopo `dueTime` scade e successivamente ogni volta che il `period` scadenza dell'intervallo di tempo.  
  
 Se `dueTime` è zero (0), `callback` viene richiamato immediatamente. Se `dueTime` è uno negativo (-1) in millisecondi, `callback` non viene richiamato, il timer è disabilitato, ma possono essere riabilitato tramite una chiamata di <xref:System.Threading.Timer.Change%2A> (metodo).  
  
 Poiché il <xref:System.Threading.Timer> classe avrà la stessa risoluzione come l'orologio di sistema, ovvero circa 15 millisecondi nei sistemi Windows 7 e Windows 8, il `callback` delegato viene eseguito a intervalli definiti mediante la risoluzione del clock di sistema se `period`è minore rispetto alla risoluzione del clock di sistema. Se `period` è zero (0) o negativo (-1) in millisecondi e `dueTime` è un valore positivo, `callback` viene richiamato una sola volta; il comportamento periodico del timer è disabilitato, ma possono essere riabilitato tramite il <xref:System.Threading.Timer.Change%2A> (metodo).  
  
 Il metodo specificato per `callback` deve essere rientrante, poiché viene chiamato su <xref:System.Threading.ThreadPool> thread. Il metodo può essere eseguito simultaneamente in due thread del pool se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo o se tutti i thread del pool sono in uso e il metodo è in coda più volte.  
  
   
  
## Examples  
 Il codice seguente viene illustrato come creare un `TimerCallback` delegare e inizializzare una nuova istanza di `Timer` classe.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il numero di millisecondi nel valore di <paramref name="dueTime" /> o <paramref name="period" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />, oppure è maggiore di <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="callback" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As UInteger, period As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="new System.Threading.Timer : System.Threading.TimerCallback * obj * uint32 * uint32 -&gt; System.Threading.Timer" Usage="new System.Threading.Timer (callback, state, dueTime, period)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="callback">Delegato che rappresenta un metodo da eseguire.</param>
        <param name="state">Oggetto contenente informazioni che devono essere utilizzate dal metodo di callback, oppure <see langword="null" />.</param>
        <param name="dueTime">Intervallo di attesa, in millisecondi, prima che venga chiamato <c>callback</c>. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per impedire l'avvio del timer. Specificare zero (0) per avviare il timer immediatamente.</param>
        <param name="period">Intervallo di tempo, in millisecondi, tra le chiamate di <c>callback</c>. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per disabilitare la segnalazione periodica.</param>
        <summary>Consente l'inizializzazione di una nuova istanza della classe <see langword="Timer" /> utilizzando integer senza segno a 32 bit per misurare gli intervalli di tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il delegato specificato per il `callback` parametro viene richiamato una volta dopo `dueTime` scade e successivamente ogni volta che il `period` scadenza dell'intervallo di tempo.  
  
 Se `dueTime` è zero (0), `callback` viene richiamato immediatamente. Se `dueTime` viene <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` non viene richiamato, il timer è disabilitato, ma possono essere riabilitato tramite una chiamata di <xref:System.Threading.Timer.Change%2A> (metodo).  
  
 Poiché il <xref:System.Threading.Timer> classe avrà la stessa risoluzione come l'orologio di sistema, ovvero circa 15 millisecondi nei sistemi Windows 7 e Windows 8, il `callback` delegato viene eseguito a intervalli definiti mediante la risoluzione del clock di sistema se `period`è minore rispetto alla risoluzione del clock di sistema. Se `period` è zero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> e `dueTime` non è <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` viene richiamato una sola volta; il comportamento periodico del timer è disabilitato, ma possono essere riabilitato tramite il <xref:System.Threading.Timer.Change%2A> (metodo).  
  
 Il metodo specificato per `callback` deve essere rientrante, poiché viene chiamato su <xref:System.Threading.ThreadPool> thread. Il metodo può essere eseguito simultaneamente in due thread del pool se l'intervallo del timer è inferiore al tempo necessario per eseguire il metodo o se tutti i thread del pool sono in uso e il metodo è in coda più volte.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="dueTime" /> o <paramref name="period" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="callback" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Change">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Modifica l'ora di inizio e l'intervallo tra le chiamate dei metodi di un timer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Integer, period As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(int dueTime, int period);" />
      <MemberSignature Language="F#" Value="member this.Change : int * int -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dueTime">Intervallo di attesa, in millisecondi, prima di richiamare il metodo di callback specificato quando <see cref="T:System.Threading.Timer" /> è stato costruito. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per impedire il riavvio del timer. Specificare zero (0) per riavviare il timer immediatamente.</param>
        <param name="period">Intervallo di tempo, in millisecondi, tra le chiamate del metodo di callback specificato quando è stato costruito <see cref="T:System.Threading.Timer" />. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per disabilitare la segnalazione periodica.</param>
        <summary>Modifica l'ora di inizio e l'intervallo tra le chiamate dei metodi di un timer, usando interi con segno a 32 bit per misurare gli intervalli di tempo.</summary>
        <returns>
          <see langword="true" /> se il timer è stato aggiornato correttamente, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo di callback viene richiamato una volta dopo `dueTime` scade e successivamente ogni volta che l'intervallo di tempo specificato da `period` scade.  
  
 Se `dueTime` è zero (0), il metodo di callback viene richiamato immediatamente. Se `dueTime` viene <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, il metodo di callback non viene mai richiamato, il timer è disabilitato, ma può essere riabilitata chiamando <xref:System.Threading.Timer.Change%2A> e specificare un valore positivo per `dueTime`.  
  
 Se `period` è zero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` non è <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, il metodo di callback viene richiamato una volta; è disabilitato il comportamento del timer periodico, ma può essere riabilitata chiamando <xref:System.Threading.Timer.Change%2A> e specificando un valore positivo per `period`.  
  
 Il <xref:System.Threading.Timer.Change%2A> metodo può essere chiamato dal <xref:System.Threading.TimerCallback> delegare.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come avviare un `Timer` e, dopo un determinato numero di chiamate, modificare il periodo.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza <see cref="T:System.Threading.Timer" /> è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="dueTime" /> o <paramref name="period" /> è negativo e non è uguale a <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Long, period As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(long dueTime, long period);" />
      <MemberSignature Language="F#" Value="member this.Change : int64 * int64 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="dueTime">Intervallo di attesa, in millisecondi, prima di richiamare il metodo di callback specificato quando <see cref="T:System.Threading.Timer" /> è stato costruito. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per impedire il riavvio del timer. Specificare zero (0) per riavviare il timer immediatamente.</param>
        <param name="period">Intervallo di tempo, in millisecondi, tra le chiamate del metodo di callback specificato quando è stato costruito <see cref="T:System.Threading.Timer" />. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per disabilitare la segnalazione periodica.</param>
        <summary>Modifica l'ora di inizio e l'intervallo tra le chiamate dei metodi di un timer, usando interi con segno a 64 bit per misurare gli intervalli di tempo.</summary>
        <returns>
          <see langword="true" /> se il timer è stato aggiornato correttamente, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo di callback viene richiamato una volta dopo `dueTime` scade e successivamente ogni volta che l'intervallo di tempo specificato da `period` scade.  
  
 Se `dueTime` è zero (0), il metodo di callback viene richiamato immediatamente. Se `dueTime` viene <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, il metodo di callback non viene mai richiamato, il timer è disabilitato, ma può essere riabilitata chiamando <xref:System.Threading.Timer.Change%2A> e specificare un valore positivo per `dueTime`.  
  
 Se `period` è zero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` non è <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, il metodo di callback viene richiamato una volta; è disabilitato il comportamento del timer periodico, ma può essere riabilitata chiamando <xref:System.Threading.Timer.Change%2A> e specificando un valore positivo per `period`.  
  
 Il <xref:System.Threading.Timer.Change%2A> metodo può essere chiamato dal <xref:System.Threading.TimerCallback> delegare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza <see cref="T:System.Threading.Timer" /> è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="dueTime" /> o <paramref name="period" /> è minore di -1.</exception>
        <exception cref="T:System.NotSupportedException">Il parametro <paramref name="dueTime" /> o <paramref name="period" /> è maggiore di 4294967294.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As TimeSpan, period As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="F#" Value="member this.Change : TimeSpan * TimeSpan -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dueTime">Parametro <see cref="T:System.TimeSpan" /> che rappresenta l'intervallo di attesa prima di richiamare il metodo di callback specificato quando <see cref="T:System.Threading.Timer" /> è stato costruito. Specificare il valore uno negativo (-1) in millisecondi per impedire il riavvio del timer. Specificare zero (0) per riavviare il timer immediatamente.</param>
        <param name="period">Intervallo di tempo tra le chiamate del metodo di callback specificato quando è stato costruito <see cref="T:System.Threading.Timer" />. Specificare il valore uno negativo (-1) in millisecondi per disabilitare la segnalazione periodica.</param>
        <summary>Consente di modificare il tempo di attesa e gli intervalli tra i richiami di un timer utilizzando i valori di <see cref="T:System.TimeSpan" /> per misurare gli intervalli di tempo.</summary>
        <returns>
          <see langword="true" /> se il timer è stato aggiornato correttamente, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo di callback viene richiamato una volta dopo `dueTime` scade e successivamente ogni volta che l'intervallo di tempo specificato da `period` scade.  
  
 Se `dueTime` è zero (0), il metodo di callback viene richiamato immediatamente. Se `dueTime` è negativo (-1) in millisecondi, il metodo di callback non viene mai richiamato, il timer è disabilitato, ma può essere riabilitata chiamando <xref:System.Threading.Timer.Change%2A> e specificare un valore positivo per `dueTime`.  
  
 Se `period` è zero (0) o uno negativo (-1) in millisecondi, e `dueTime` è un valore positivo, il metodo di callback viene richiamato una volta; è disabilitato il comportamento del timer periodico, ma può essere riabilitato tramite una chiamata <xref:System.Threading.Timer.Change%2A> e specificando un valore maggiore di zero per `period`.  
  
 Il <xref:System.Threading.Timer.Change%2A> metodo può essere chiamato dal <xref:System.Threading.TimerCallback> delegare.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come avviare un `Timer` e, dopo un determinato numero di chiamate, modificare il periodo.  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza <see cref="T:System.Threading.Timer" /> è già stata eliminata.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore del parametro <paramref name="dueTime" /> o <paramref name="period" /> è inferiore a -1, in millisecondi.</exception>
        <exception cref="T:System.NotSupportedException">Il valore del parametro <paramref name="dueTime" /> o <paramref name="period" /> è superiore a 4294967294, in millisecondi.</exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As UInteger, period As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(System::UInt32 dueTime, System::UInt32 period);" />
      <MemberSignature Language="F#" Value="member this.Change : uint32 * uint32 -&gt; bool" Usage="timer.Change (dueTime, period)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="dueTime">Intervallo di attesa, in millisecondi, prima di richiamare il metodo di callback specificato quando <see cref="T:System.Threading.Timer" /> è stato costruito. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per impedire il riavvio del timer. Specificare zero (0) per riavviare il timer immediatamente.</param>
        <param name="period">Intervallo di tempo, in millisecondi, tra le chiamate del metodo di callback specificato quando è stato costruito <see cref="T:System.Threading.Timer" />. Specificare <see cref="F:System.Threading.Timeout.Infinite" /> per disabilitare la segnalazione periodica.</param>
        <summary>Modifica l'ora di inizio e l'intervallo tra le chiamate dei metodi di un timer, usando interi senza segno a 32 bit per misurare gli intervalli di tempo.</summary>
        <returns>
          <see langword="true" /> se il timer è stato aggiornato correttamente, in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo di callback viene richiamato una volta dopo `dueTime` scade e successivamente ogni volta che l'intervallo di tempo specificato da `period` scade.  
  
 Se `dueTime` è zero (0), il metodo di callback viene richiamato immediatamente. Se `dueTime` viene <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, il metodo di callback non viene mai richiamato, il timer è disabilitato, ma può essere riabilitata chiamando <xref:System.Threading.Timer.Change%2A> e specificare un valore positivo per `dueTime`.  
  
 Se `period` è zero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, e `dueTime` non è <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, il metodo di callback viene richiamato una volta; è disabilitato il comportamento del timer periodico, ma può essere riabilitata chiamando <xref:System.Threading.Timer.Change%2A> e specificando un valore positivo per `period`.  
  
 Il <xref:System.Threading.Timer.Change%2A> metodo può essere chiamato dal <xref:System.Threading.TimerCallback> delegare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">L'istanza <see cref="T:System.Threading.Timer" /> è già stata eliminata.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Consente di rilasciare tutte le risorse utilizzate dall'istanza corrente di <see cref="T:System.Threading.Timer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="timer.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Consente di rilasciare tutte le risorse utilizzate dall'istanza corrente di <see cref="T:System.Threading.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `Dispose` consente le risorse usate dal <xref:System.Threading.Timer> riallocazione per altri scopi. Per altre informazioni sulle `Dispose`, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).  
  
> [!NOTE]
>  I callback possono verificarsi dopo il <xref:System.Threading.Timer.Dispose> overload del metodo è stato chiamato, perché il timer accoda i callback per l'esecuzione dal thread del pool. È possibile usare il <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> overload del metodo per attendere fino al completamento di tutte le richiamate.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato come liberare le risorse utilizzate da un `Timer`.  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public bool Dispose (System.Threading.WaitHandle notifyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Dispose(class System.Threading.WaitHandle notifyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dispose (notifyObject As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Dispose(System::Threading::WaitHandle ^ notifyObject);" />
      <MemberSignature Language="F#" Value="member this.Dispose : System.Threading.WaitHandle -&gt; bool" Usage="timer.Dispose notifyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notifyObject" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="notifyObject">
          <see cref="T:System.Threading.WaitHandle" /> da segnalare quando <see langword="Timer" /> è stato eliminato.</param>
        <summary>Consente di rilasciare tutte le risorse utilizzate dall'istanza corrente di <see cref="T:System.Threading.Timer" /> segnalando l'ora dell'eliminazione del timer.</summary>
        <returns>Viene restituito <see langword="true" /> se la funzione viene eseguita correttamente; in caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La chiamata `Dispose` consente le risorse usate dal <xref:System.Threading.Timer> riallocazione per altri scopi. Per altre informazioni sulle `Dispose`, vedere [pulizia di risorse non gestite](~/docs/standard/garbage-collection/unmanaged.md).  
  
 Quando questo metodo viene completato, viene segnalato il <xref:System.Threading.WaitHandle> specificato da di `notifyObject` parametro. Utilizzare questo overload del metodo di <xref:System.Threading.Timer.Dispose%2A> metodo se si desidera essere in grado di bloccare fino a quando non si è certi che il timer è stato eliminato. Il timer non viene eliminato fino al completamento di tutte le richiamate attualmente in coda.  
  
> [!NOTE]
>  Se Usa il callback il <xref:System.Threading.Timer.Change%2A> metodo per impostare il `dueTime` parametri su zero, una race condition può verificarsi quando il <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> overload del metodo viene chiamato: se il timer Accoda un callback di nuovo prima il <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> overload del metodo rileva che non esiste Nessuno callback vengono accodati, <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> continua a bloccare; in caso contrario, il timer viene eliminato mentre è accodato il callback di nuovo e una <xref:System.ObjectDisposedException> generata quando viene chiamato il callback di nuovo il <xref:System.Threading.Timer.Change%2A> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore del parametro <paramref name="notifyObject" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Timer ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="timer.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>