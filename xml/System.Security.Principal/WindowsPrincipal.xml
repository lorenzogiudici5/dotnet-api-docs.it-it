<Type Name="WindowsPrincipal" FullName="System.Security.Principal.WindowsPrincipal">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a765a326d05a5dd5386d19dff04e6097dc5f9cae" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49139454" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WindowsPrincipal : System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit WindowsPrincipal extends System.Security.Claims.ClaimsPrincipal" />
  <TypeSignature Language="DocId" Value="T:System.Security.Principal.WindowsPrincipal" />
  <TypeSignature Language="VB.NET" Value="Public Class WindowsPrincipal&#xA;Inherits ClaimsPrincipal" />
  <TypeSignature Language="C++ CLI" Value="public ref class WindowsPrincipal : System::Security::Claims::ClaimsPrincipal" />
  <TypeSignature Language="F#" Value="type WindowsPrincipal = class&#xA;    inherit ClaimsPrincipal" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Principal.Windows</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Claims.ClaimsPrincipal</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Consente al codice di verificare se un utente Windows appartiene a un gruppo Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.Principal.WindowsPrincipal> classe viene utilizzata principalmente per controllare il ruolo di un utente di Windows. Il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> overload del metodo consentono di controllare il ruolo utente utilizzando diversi contesti di ruolo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> overload del metodo. Il <xref:System.Security.Principal.WindowsBuiltInRole> enumerazione viene utilizzata come origine per gli identificatori relativi (RID) che identificano i ruoli predefiniti. I RID consentono di determinare i ruoli dell'oggetto principal corrente.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WindowsPrincipal (System.Security.Principal.WindowsIdentity ntIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Principal.WindowsIdentity ntIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.#ctor(System.Security.Principal.WindowsIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (ntIdentity As WindowsIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WindowsPrincipal(System::Security::Principal::WindowsIdentity ^ ntIdentity);" />
      <MemberSignature Language="F#" Value="new System.Security.Principal.WindowsPrincipal : System.Security.Principal.WindowsIdentity -&gt; System.Security.Principal.WindowsPrincipal" Usage="new System.Security.Principal.WindowsPrincipal ntIdentity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="ntIdentity" Type="System.Security.Principal.WindowsIdentity" />
      </Parameters>
      <Docs>
        <param name="ntIdentity">Oggetto da cui costruire la nuova istanza di <see cref="T:System.Security.Principal.WindowsPrincipal" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Security.Principal.WindowsPrincipal" /> usando l'oggetto <see cref="T:System.Security.Principal.WindowsIdentity" /> specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'esempio seguente crea una nuova <xref:System.Security.Principal.WindowsPrincipal> oggetto dall'insieme corrente <xref:System.Security.Principal.WindowsIdentity> oggetto.  
  
 [!code-cpp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.WindowsPrincipal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.WindowsPrincipal Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ntIdentity" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeviceClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; DeviceClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; DeviceClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeviceClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ DeviceClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.DeviceClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__13))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_DeviceClaims&gt;d__1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene tutte le attestazioni di dispositivi di Windows da questa entità.</summary>
        <value>Raccolta di tutte le attestazioni di dispositivi di Windows da questa entità.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public override System.Security.Principal.IIdentity Identity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity Identity" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Identity As IIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Principal::IIdentity ^ Identity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Identity : System.Security.Principal.IIdentity" Usage="System.Security.Principal.WindowsPrincipal.Identity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'identità dell'oggetto Principal corrente.</summary>
        <value>Oggetto <see cref="T:System.Security.Principal.WindowsIdentity" /> dell'entità corrente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Nell'esempio seguente recupera il nome dell'utente utilizzando il <xref:System.Security.Principal.WindowsPrincipal.Identity%2A> proprietà del <xref:System.Security.Principal.WindowsPrincipal> oggetto.  
  
 [!code-cpp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/CS/source.cs#1)]
 [!code-vb[Classic WindowsPrincipal.Identity Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic WindowsPrincipal.Identity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsInRole">
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se l'oggetto Principal corrente appartiene al gruppo di utenti Windows specificato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sono disponibili quattro overload per questo metodo. Per motivi di prestazioni il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> overload è fortemente consigliato.  
  
> [!IMPORTANT]
>  Il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo non è supportato in Windows 98 o Windows Millennium Edition.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (int rid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(int32 rid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (rid As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(int rid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : int -&gt; bool" Usage="windowsPrincipal.IsInRole rid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rid" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rid">RID del gruppo di utenti Windows nel quale controllare lo stato di appartenenza dell'oggetto Principal.</param>
        <summary>Determina se l'oggetto Principal corrente appartiene al gruppo di utenti Windows con l'identificatore relativo (RID) specificato.</summary>
        <returns>
          <see langword="true" /> se l'entità corrente è un membro del gruppo di utenti Windows specificato, ossia, è assegnato a un ruolo specifico; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si verificano le informazioni di ruolo appena creato, ad esempio un nuovo utente o un nuovo gruppo, è importante effettuare la disconnessione e accesso per forzare la propagazione delle informazioni sui ruoli all'interno del dominio. Non in questo modo può causare il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test per restituire `false`. Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.  
  
 Per motivi di prestazioni il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> overload consigliato è l'overload per determinare il ruolo dell'utente.  
  
> [!NOTE]
>  In Windows Vista, 	la funzionalità Controllo dell'account utente determina i privilegi di un utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Quando si prova a eseguire un'attività che richiede privilegi di amministratore, è possibile elevare in modo dinamico il ruolo utilizzando la finestra di dialogo di consenso. Il codice che esegue il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo non visualizza la finestra di dialogo di consenso. Il codice restituisce false se si utilizza il ruolo di utente standard, anche se trovano in gruppo Administrators predefinito. È possibile elevare i privilegi dell'utente prima di eseguire il codice facendo clic sull'icona dell'applicazione e che indica che si desidera eseguire come amministratore.  
  
 Identificatori relativi (RID) fanno parte di ID di sicurezza del gruppo di utenti di Windows (SID) e sono supportati per aiutare a prevenire problemi di localizzazione multipiattaforma. Molti degli account utente, i gruppi locali e gruppi globali di avere un valore RID predefinito che è una costante in tutte le versioni di Windows.  
  
 Ad esempio, il RID per il ruolo BUILTIN\Administrators è 0x220. Utilizzando 0x220 come parametro di input per il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> i metodi restituiscono `true` being restituito se l'oggetto principal corrente è un amministratore.  
  
 Le tabelle seguenti elencano le impostazioni predefinite RID.  
  
|Utenti predefiniti|RID|  
|---------------------|---------|  
|DOMAINNAME\Administrator|0x1F4|  
|DOMAINNAME\Guest|0x1F5|  
  
|Gruppi globali predefiniti|RID|  
|-----------------------------|---------|  
|Amministratori DOMAINNAME\Domain|0x200|  
|Utenti DOMAINNAME\Domain|0x201|  
|Utenti guest DOMAINNAME\Domain|0x202|  
  
|Gruppi locali predefiniti|RID|  
|----------------------------|---------|  
|BUILTIN\Administrators|0x220|  
|BUILTIN\Users.|0x221|  
|BUILTIN\Guests|0x222|  
|Operatori BUILTIN\Account|0x224|  
|Operatori BUILTIN\Server|0x225|  
|Operatori BUILTIN\Print|0x226|  
|Operatori BUILTIN\Backup|0x227|  
|BUILTIN\Replicator|0x228|  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodi. Il <xref:System.Security.Principal.WindowsBuiltInRole> enumerazione viene utilizzata come origine per i RID che identificano i ruoli predefiniti. I RID consentono di determinare i ruoli dell'oggetto principal corrente.  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.SecurityIdentifier sid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(class System.Security.Principal.SecurityIdentifier sid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.SecurityIdentifier)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (sid As SecurityIdentifier) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::SecurityIdentifier ^ sid);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.SecurityIdentifier -&gt; bool" Usage="windowsPrincipal.IsInRole sid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sid" Type="System.Security.Principal.SecurityIdentifier" />
      </Parameters>
      <Docs>
        <param name="sid">Oggetto <see cref="T:System.Security.Principal.SecurityIdentifier" /> che identifica in modo univoco un gruppo di utenti Windows.</param>
        <summary>Determina se l'entità corrente appartiene al gruppo di utenti Windows con l'identificatore di sicurezza (SID) specificato.</summary>
        <returns>
          <see langword="true" /> se l'oggetto Principal corrente è un membro del gruppo di utenti Windows specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Security.Principal.SecurityIdentifier> identifica in modo univoco un utente o gruppo su implementazioni Windows 2000, Windows Server e Windows XP. Quando si verificano le informazioni di ruolo appena creato, ad esempio un nuovo utente o un nuovo gruppo, è importante effettuare la disconnessione e accesso per forzare la propagazione delle informazioni sui ruoli all'interno del dominio. Non in questo modo può causare il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test per restituire `false`. Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.  
  
> [!NOTE]
>  In Windows Vista, 	la funzionalità Controllo dell'account utente determina i privilegi di un utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Quando si prova a eseguire un'attività che richiede privilegi di amministratore, è possibile elevare in modo dinamico il ruolo utilizzando la finestra di dialogo di consenso. Il codice che esegue il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo non visualizza la finestra di dialogo di consenso. Il codice restituisce false se si utilizza il ruolo di utente standard, anche se trovano in gruppo Administrators predefinito. È possibile elevare i privilegi dell'utente prima di eseguire il codice facendo clic sull'icona dell'applicazione e che indica che si desidera eseguire come amministratore.  
  
 Per motivi di prestazioni, questo è l'overload per determinare un ruolo utente.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29?displayProperty=nameWithType> (metodo). Il <xref:System.Security.Principal.WellKnownSidType.BuiltinAdministratorsSid> valore di enumerazione viene utilizzata per determinare se l'oggetto principal corrente è un amministratore. Per l'esempio di codice completo, vedere il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> (metodo).  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#5)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sid" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Windows ha restituito un errore Win32.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public virtual bool IsInRole (System.Security.Principal.WindowsBuiltInRole role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInRole(valuetype System.Security.Principal.WindowsBuiltInRole role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.Security.Principal.WindowsBuiltInRole)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInRole (role As WindowsBuiltInRole) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInRole(System::Security::Principal::WindowsBuiltInRole role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : System.Security.Principal.WindowsBuiltInRole -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.Security.Principal.WindowsBuiltInRole" />
      </Parameters>
      <Docs>
        <param name="role">Uno dei valori di <see cref="T:System.Security.Principal.WindowsBuiltInRole" />.</param>
        <summary>Determina se l'entità corrente appartiene al gruppo di utenti Windows con il nome specificato <see cref="T:System.Security.Principal.WindowsBuiltInRole" />.</summary>
        <returns>
          <see langword="true" /> se l'oggetto Principal corrente è un membro del gruppo di utenti Windows specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si verificano le informazioni di ruolo appena creato, ad esempio un nuovo utente o un nuovo gruppo, è importante effettuare la disconnessione e accesso per forzare la propagazione delle informazioni sui ruoli all'interno del dominio. Non in questo modo può causare il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test per restituire `false`. Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.  
  
 Per motivi di prestazioni il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> overload consigliato è l'overload per determinare il ruolo dell'utente.  
  
> [!NOTE]
>  In Windows Vista, 	la funzionalità Controllo dell'account utente determina i privilegi di un utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Quando si prova a eseguire un'attività che richiede privilegi di amministratore, è possibile elevare in modo dinamico il ruolo utilizzando la finestra di dialogo di consenso. Il codice che esegue il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo non visualizza la finestra di dialogo di consenso. Il codice restituisce false se si utilizza il ruolo di utente standard, anche se trovano in gruppo Administrators predefinito. È possibile elevare i privilegi dell'utente prima di eseguire il codice facendo clic sull'icona dell'applicazione e che indica che si desidera eseguire come amministratore.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Security.Principal.WindowsBuiltInRole> enumerazione viene utilizzata per determinare se l'oggetto principal corrente è un <xref:System.Security.Principal.WindowsBuiltInRole.Administrator>. Per l'esempio di codice completo, vedere il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> (metodo).  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#4)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="role" /> non è un valore valido di <see cref="T:System.Security.Principal.WindowsBuiltInRole" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInRole">
      <MemberSignature Language="C#" Value="public override bool IsInRole (string role);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsInRole(string role) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Principal.WindowsPrincipal.IsInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsInRole (role As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsInRole(System::String ^ role);" />
      <MemberSignature Language="F#" Value="override this.IsInRole : string -&gt; bool" Usage="windowsPrincipal.IsInRole role" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="role" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="role">Nome del gruppo di utenti Windows per il quale verificare l'appartenenza.</param>
        <summary>Determina se l'entità corrente appartiene al gruppo di utenti Windows con il nome specificato.</summary>
        <returns>
          <see langword="true" /> se l'oggetto Principal corrente è un membro del gruppo di utenti Windows specificato; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando si verificano le informazioni di ruolo appena creato, ad esempio un nuovo utente o un nuovo gruppo, è importante effettuare la disconnessione e accesso per forzare la propagazione delle informazioni sui ruoli all'interno del dominio. Non in questo modo può causare il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> test per restituire `false`. Questo metodo non è supportato in Windows 98 o Windows Millennium Edition.  
  
 Per motivi di prestazioni il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Security.Principal.SecurityIdentifier%29> overload consigliato è l'overload per determinare il ruolo dell'utente.  
  
> [!NOTE]
>  In Windows Vista, 	la funzionalità Controllo dell'account utente determina i privilegi di un utente. Ai membri del gruppo Administrators predefinito vengono assegnati due token di accesso in fase di esecuzione, ovvero un token di accesso utente standard e un token di accesso amministratore. Per impostazione predefinita, viene assegnato il ruolo dell'utente standard. Quando si prova a eseguire un'attività che richiede privilegi di amministratore, è possibile elevare in modo dinamico il ruolo utilizzando la finestra di dialogo di consenso. Il codice che esegue il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> metodo non visualizza la finestra di dialogo di consenso. Il codice restituisce false se si utilizza il ruolo di utente standard, anche se trovano in gruppo Administrators predefinito. È possibile elevare i privilegi dell'utente prima di eseguire il codice facendo clic sull'icona dell'applicazione e che indica che si desidera eseguire come amministratore.  
  
 Per i ruoli predefiniti, il `role` stringa deve essere nel formato "BUILTIN\\*NomeRuolo*". Ad esempio, per verificare l'appartenenza al ruolo di amministratore di Windows, la stringa che rappresenta il ruolo deve essere "BUILTIN\Administrators". Si noti che la barra rovesciata potrebbe essere necessario utilizzare caratteri di escape. La tabella seguente elenca i ruoli predefiniti.  
  
> [!NOTE]
>  L'ortografici per i ruoli incorporati in formato stringa è diversa da quella utilizzata nel <xref:System.Security.Principal.WindowsBuiltInRole> enumerazione. Ad esempio, l'ortografia di un amministratore nell'enumerazione è "Administrator", non "amministratori". Quando si utilizza questo overload, usare il controllo ortografico per il ruolo contenute nella tabella seguente.  
  
|Gruppi locali predefiniti|  
|----------------------------|  
|BUILTIN\Administrators|  
|BUILTIN\Users.|  
|BUILTIN\Guests|  
|Operatori BUILTIN\Account|  
|Operatori BUILTIN\Server|  
|Operatori BUILTIN\Print|  
|Operatori BUILTIN\Backup|  
|BUILTIN\Replicator|  
  
 Per i ruoli specifici del computer, il `role` stringa deve essere nel formato "nomecomputer\\*NomeRuolo*".  
  
 Per i ruoli specifici del dominio, il `role` stringa deve essere nel formato "NomeDominio\\*NomeRuolo*", ad esempio `"SomeDomain\Domain Users`".  
  
> [!NOTE]
>  In .NET Framework versione 1.0, la `role` parametro è tra maiuscole e minuscole. In .NET Framework 1.1 e versioni successive, il `role` parametro è tra maiuscole e minuscole.  
  
   
  
## Examples  
 Esempio di codice seguente viene illustrato l'utilizzo del <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> (metodo).  
  
 Le stringhe `BUILTIN\Administrators` e `BUILTIN\Users` vengono usate per determinare se l'oggetto principal corrente è un amministratore o un utente. Per l'esempio di codice completo, vedere il <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.Int32%29?displayProperty=nameWithType> (metodo).  
  
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#3)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">per la possibilità di modificare l'oggetto principal. Enumerazione associata: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /></permission>
        <altmember cref="T:System.Security.Principal.WindowsBuiltInRole" />
      </Docs>
    </Member>
    <Member MemberName="UserClaims">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt; UserClaims { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Security.Claims.Claim&gt; UserClaims" />
      <MemberSignature Language="DocId" Value="P:System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UserClaims As IEnumerable(Of Claim)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ UserClaims { System::Collections::Generic::IEnumerable&lt;System::Security::Claims::Claim ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserClaims : seq&lt;System.Security.Claims.Claim&gt;" Usage="System.Security.Principal.WindowsPrincipal.UserClaims" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Principal.Windows</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__11))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Security.Principal.WindowsPrincipal/&lt;get_UserClaims&gt;d__1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Security.Claims.Claim&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene tutte le attestazioni di utenti di Windows da questa entità.</summary>
        <value>Raccolta di tutte le attestazioni di utenti Windows da questa entità.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>