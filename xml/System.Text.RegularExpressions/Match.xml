<Type Name="Match" FullName="System.Text.RegularExpressions.Match">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c886bcea5d17b2ba683b40687e65b1b31de9ad20" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36408137" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Match : System.Text.RegularExpressions.Group" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Match extends System.Text.RegularExpressions.Group" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Match" />
  <TypeSignature Language="VB.NET" Value="Public Class Match&#xA;Inherits Group" />
  <TypeSignature Language="C++ CLI" Value="public ref class Match : System::Text::RegularExpressions::Group" />
  <TypeSignature Language="F#" Value="type Match = class&#xA;    inherit Group" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.RegularExpressions.Group</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Rappresenta i risultati di una singola corrispondenza di un'espressione regolare.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Match> oggetto non è modificabile e non include alcun costruttore pubblico. Un'istanza del <xref:System.Text.RegularExpressions.Match> classe viene restituita dal <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> (metodo) e rappresenta il primo criterio di corrispondenza in una stringa. Corrispondenze successive sono rappresentate <xref:System.Text.RegularExpressions.Match> gli oggetti restituiti dal <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metodo. Inoltre, una <xref:System.Text.RegularExpressions.MatchCollection> oggetto costituito da zero, uno o più <xref:System.Text.RegularExpressions.Match> oggetti restituito dal <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> metodo.  
  
 Se il <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> metodo non riesce a trovare un criterio di espressione regolare in una stringa di input, restituisce un oggetto vuoto <xref:System.Text.RegularExpressions.MatchCollection> oggetto. È quindi possibile utilizzare un `foreach` costruire in c# o `For Each` costruire in Visual Basic per scorrere la raccolta.  
  
 Se il <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> metodo non riesce a trovare il criterio di espressione regolare, restituisce un <xref:System.Text.RegularExpressions.Match> oggetto è uguale a <xref:System.Text.RegularExpressions.Match.Empty%2A?displayProperty=nameWithType>. È possibile utilizzare il <xref:System.Text.RegularExpressions.Group.Success%2A> proprietà per determinare se la corrispondenza ha avuto esito positivo. Nell'esempio seguente viene illustrato questo concetto.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/cs/Match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Match.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/vb/Match1.vb#1)]  
  
 Se un criterio di ricerca ha esito positivo, il <xref:System.Text.RegularExpressions.Capture.Value%2A> proprietà contiene la sottostringa corrispondente, il <xref:System.Text.RegularExpressions.Capture.Index%2A> proprietà indica la posizione iniziale in base zero della sottostringa corrispondente nella stringa di input e il <xref:System.Text.RegularExpressions.Capture.Length%2A> proprietà indica il lunghezza della sottostringa corrispondente nella stringa di input.  
  
 Poiché una singola corrispondenza può implicare più gruppi di acquisizione <xref:System.Text.RegularExpressions.Match> ha un <xref:System.Text.RegularExpressions.Match.Groups%2A> proprietà che restituisce il <xref:System.Text.RegularExpressions.GroupCollection>. Il <xref:System.Text.RegularExpressions.Match> istanza è equivalente al primo oggetto nella raccolta, in `Match.Groups[0]` (`Match.Groups(0)` in Visual Basic), che rappresenta l'intera corrispondenza. È possibile accedere i gruppi acquisiti in una corrispondenza nei modi seguenti:  
  
-   È possibile scorrere i membri del <xref:System.Text.RegularExpressions.GroupCollection> oggetto utilizzando un `foreach` (c#) o `For Each` costrutto (Visual Basic).  
  
-   È possibile utilizzare il <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29?displayProperty=nameWithType> proprietà consente di recuperare gruppi dal numero del gruppo di acquisizione. Si noti che è possibile determinare quali gruppi numerati sono presenti in un'espressione regolare chiamando l'istanza <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType> metodo.  
  
-   È possibile utilizzare il <xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29?displayProperty=nameWithType> proprietà consente di recuperare gruppi dal nome del gruppo di acquisizione. Si noti che è possibile determinare quali gruppi denominati sono presenti in un'espressione regolare chiamando l'istanza <xref:System.Text.RegularExpressions.Regex.GetGroupNames?displayProperty=nameWithType> metodo.  
  
   
  
## Examples  
 L'esempio seguente usa l'espressione regolare `Console\.Write(Line)?`. L'espressione regolare viene interpretata nel modo seguente.  
  
|||  
|-|-|  
|Console\\. Scrittura|Trova la corrispondenza con la stringa "Console.Write". Si noti che il "." è sottoposto a escape in modo che viene interpretato come un periodo di valore letterale anziché come carattere jolly che corrisponde a qualsiasi carattere.|  
|(Riga)?|Trova la corrispondenza con zero o una occorrenza della stringa "Line".|  
  
 **Esempio 1**  
  
 L'esempio seguente chiama il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> metodo per recuperare tutte le corrispondenze in una stringa di input. Scorre quindi il <xref:System.Text.RegularExpressions.Match> oggetti nell'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> oggetto per visualizzare informazioni su ogni corrispondenza.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/cs/Match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Match.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/vb/Match2.vb#2)]  
  
 **Esempio 2**  
  
 L'esempio seguente chiama il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> e <xref:System.Text.RegularExpressions.Match.NextMatch%2A> metodi per recuperare una corrispondenza in una fase.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/cs/Match3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Match.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Match.Class/vb/Match3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.RegularExpressions.MatchCollection" />
    <altmember cref="T:System.Text.RegularExpressions.Regex" />
  </Docs>
  <Members>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.RegularExpressions.Match Empty" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Match.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::RegularExpressions::Match ^ Empty { System::Text::RegularExpressions::Match ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Match.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene il gruppo vuoto. Tutte le corrispondenze non riuscite restituiscono questa corrispondenza vuota.</summary>
        <value>Corrispondenza vuota.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questa proprietà non deve essere utilizzata per determinare se una corrispondenza ha esito positivo. In alternativa, usare il `Match.Success` proprietà (che viene ereditata dalla <xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public virtual System.Text.RegularExpressions.GroupCollection Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.RegularExpressions.GroupCollection Groups" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Match.Groups" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Groups As GroupCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::RegularExpressions::GroupCollection ^ Groups { System::Text::RegularExpressions::GroupCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Groups : System.Text.RegularExpressions.GroupCollection" Usage="System.Text.RegularExpressions.Match.Groups" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.GroupCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene una raccolta di gruppi corrispondenti all'espressione regolare.</summary>
        <value>Gruppi di caratteri corrispondenti al criterio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un criterio di espressione regolare può includere sottoesspressioni, che sono definiti da una parte del criterio di espressione regolare di inclusione tra parentesi. Ogni sottoespressione forma un gruppo. Il <xref:System.Text.RegularExpressions.Match.Groups%2A> proprietà fornisce l'accesso alle informazioni su queste sottoespressioni. Ad esempio, il criterio di espressione regolare `(\d{3})-(\d{3}-\d{4})`, che corrisponde a numeri di telefono America del Nord, ha due sottoespressioni. Il primo è costituito da codice di area, che riunisce le prime tre cifre del numero di telefono. Questo gruppo viene acquisito dalla prima parte dell'espressione regolare, `(\d{3})`. Il secondo è costituito il numero di telefono singolo, che riunisce le ultime sette cifre del numero di telefono. Questo gruppo viene acquisito dalla seconda parte dell'espressione regolare, `(\d{3}-\d{4})`. Questi due gruppi possono quindi essere recuperati i <xref:System.Text.RegularExpressions.GroupCollection> oggetto restituito dal <xref:System.Text.RegularExpressions.Match.Groups%2A> proprietà, come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Groups#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.match.groups/cs/groups1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Match.Groups#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.match.groups/vb/groups1.vb#1)]  
  
 Il <xref:System.Text.RegularExpressions.GroupCollection> oggetto restituito dal <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> proprietà è un oggetto della raccolta in base zero che ha sempre almeno un membro. Se il motore delle espressioni regolari non vengono trovate corrispondenze in una determinata stringa di input, il <xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType> proprietà dell'unico <xref:System.Text.RegularExpressions.Group> oggetto della raccolta (l'oggetto in corrispondenza dell'indice 0) è impostata su `false` e il <xref:System.Text.RegularExpressions.Group> dell'oggetto <xref:System.Text.RegularExpressions.Capture.Value%2A>è impostata su <xref:System.String.Empty?displayProperty=nameWithType>. Se il motore delle espressioni regolari trova una corrispondenza, il primo elemento di <xref:System.Text.RegularExpressions.GroupCollection> oggetto (l'elemento in corrispondenza dell'indice 0) restituito dal <xref:System.Text.RegularExpressions.Match.Groups%2A> proprietà contiene una stringa corrispondente al criterio di espressione regolare intera. Ogni elemento successivo, dall'indice uno verso l'alto, rappresenta un gruppo di acquisizione, se l'espressione regolare include i gruppi di acquisizione. Per altre informazioni, vedere la sezione "Raggruppamento costrutti e oggetti di espressione regolare" del [costrutti di raggruppamento](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md) articolo.  
  
   
  
## Examples  
 Nell'esempio seguente tenta di corrispondono a un criterio di espressione regolare con una stringa di esempio. Nell'esempio viene utilizzato il <xref:System.Text.RegularExpressions.Match.Groups%2A> proprietà per archiviare le informazioni recuperate dalla corrispondenza per la visualizzazione nella console.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextMatch">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match NextMatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match NextMatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Match.NextMatch" />
      <MemberSignature Language="VB.NET" Value="Public Function NextMatch () As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ NextMatch();" />
      <MemberSignature Language="F#" Value="member this.NextMatch : unit -&gt; System.Text.RegularExpressions.Match" Usage="match.NextMatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce un nuovo oggetto <see cref="T:System.Text.RegularExpressions.Match" /> con i risultati relativi alla corrispondenza successiva, partendo dalla posizione in cui terminava l'ultima corrispondenza (dal carattere dopo l'ultimo carattere corrispondente).</summary>
        <returns>Corrispondenza dell'espressione regolare successiva.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Questo metodo è simile alla chiamata al metodo <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> e al passaggio (`Index+Length`) come la nuova posizione iniziale.  
  
> [!NOTE]
>  Questo metodo non modifica l'istanza corrente. Al contrario, restituisce un nuovo <xref:System.Text.RegularExpressions.Match> oggetto che contiene informazioni sulla corrispondenza successiva.  
  
 Tentativo di recuperare la corrispondenza successiva potrebbe generare un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> se un valore di timeout per operazioni di corrispondenza è attiva e il tentativo di trovare la corrispondenza successiva supera tale intervallo di timeout.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.RegularExpressions.Match.NextMatch%2A> metodo per acquisire l'espressione regolare corrisponde oltre la prima corrispondenza.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout.</exception>
        <block subset="none" type="usage">
          <para>Quando un tentativo di corrispondenza viene ripetuto chiamando il <see cref="M:System.Text.RegularExpressions.Match.NextMatch" /> metodo, il motore delle espressioni regolari corrispondenze vuote un trattamento speciale. In genere, <see cref="M:System.Text.RegularExpressions.Match.NextMatch" /> inizia la ricerca per la corrispondenza successiva esattamente dove la corrispondenza precedente era stata arrestata. Tuttavia, dopo una corrispondenza vuota, il <see cref="M:System.Text.RegularExpressions.Match.NextMatch" /> metodo fa avanza un carattere prima di tentare la corrispondenza successiva. Questo comportamento garantisce che il motore delle espressioni regolari avanzamento tramite la stringa. In caso contrario, poiché una corrispondenza vuota non comporta uno spostamento in avanti, la corrispondenza successiva avvia esattamente la stessa posizione come la corrispondenza precedente e corrisponderebbe ripetutamente la stessa stringa vuota.  Nell'esempio seguente viene illustrato questo concetto. Il criterio di espressione regolare <c>un *</c> cerca zero o più occorrenze della lettera "a" nella stringa "abaabb". Come illustrato nell'output dell'esempio, vengono trovate sei corrispondenze. Il primo tentativo di corrispondenza viene cercato il primo "a". Il secondo corrispondenza inizia nel punto in cui il primo corrispondono esattamente termina prima della prima b; trovata alcuna occorrenza di "a" e restituisce una stringa vuota. La terza corrispondenza non inizia esattamente dove secondo è terminata la corrispondenza, perché la seconda ha restituito una stringa vuota. Inizia invece di un carattere in un secondo momento, dopo la prima "b". La terza corrispondenza individua due occorrenze di "a" e restituisce "aa". Il quarto tentativo di ricerca ha inizio in cui è terminata la corrispondenza terzo, prima della seconda "b" e restituisce una stringa vuota. Il tentativo di corrispondenza quinto anticipa nuovamente un carattere in modo che inizia prima della terza "b" e restituisce una stringa vuota. Il sesto corrispondenza inizia dopo l'ultima "b" e restituisce nuovamente una stringa vuota.  [! code-csharp[System.Text.RegularExpressions.Match.NextMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.match.nextmatch/cs/nextmatch1.cs#1)] [! code-vb[System.Text.RegularExpressions.Match.NextMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.match.nextmatch/vb/nextmatch1.vb#1)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public virtual string Result (string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string Result(string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Match.Result(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Result (replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ Result(System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="abstract member Result : string -&gt; string&#xA;override this.Result : string -&gt; string" Usage="match.Result replacement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="replacement">Criterio di sostituzione da usare.</param>
        <summary>Restituisce l'espansione del criterio di sostituzione specificato.</summary>
        <returns>Versione espansa del parametro <paramref name="replacement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mentre il <xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType> metodo sostituisce tutte le corrispondenze in una stringa di input con un criterio di sostituzione specificato, il <xref:System.Text.RegularExpressions.Match.Result%2A> metodo sostituisce una singola corrispondenza con un criterio di sostituzione specificata. Dal momento che opera su una corrispondenza singola, è anche possibile eseguire l'elaborazione sulla stringa corrispondente prima di chiamare il <xref:System.Text.RegularExpressions.Match.Result%2A> metodo.  
  
 Il `replacement` parametro è un criterio di sostituzione di espressioni regolari standard. Può essere costituito da caratteri letterali e le sostituzioni di espressione regolare. Per altre informazioni, vedere [Sostituzioni](~/docs/standard/base-types/substitutions-in-regular-expressions.md).  
  
   
  
## Examples  
 Nell'esempio seguente sostituisce i trattini iniziale e finale di un'espressione tra parentesi con parentesi.  
  
 [!code-csharp[System.Text.RegularExpressions.Match.Result#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.match.result/cs/result1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Match.Result#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.match.result/vb/result1.vb#1)]  
  
 Il criterio di ricerca di espressioni regolari `--(.+?)--` è interpretato nel modo illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`--`|Corrisponde a due trattini.|  
|`(.+?)`|Corrispondi a qualsiasi carattere una o più volte, ma il minor numero di volte possibile. Equivale al primo gruppo di acquisizione.|  
|`--`|Corrisponde a due trattini.|  
  
 Si noti che il criterio di espressione regolare `--(.+?)--` Usa un quantificatore lazy `+?`. Se il quantificatore greedy `+` utilizzati in alternativa, il motore delle espressioni regolari cercherebbe solo una singola corrispondenza nella stringa di input.  
  
 La stringa di sostituzione `($1)` sostituisce la corrispondenza con il primo gruppo acquisito che è racchiuso tra parentesi.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="replacement" /> è <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L'espansione non è consentita per questo criterio.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Synchronized (System.Text.RegularExpressions.Match inner);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Synchronized(class System.Text.RegularExpressions.Match inner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Synchronized (inner As Match) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Synchronized(System::Text::RegularExpressions::Match ^ inner);" />
      <MemberSignature Language="F#" Value="static member Synchronized : System.Text.RegularExpressions.Match -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Match.Synchronized inner" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inner" Type="System.Text.RegularExpressions.Match" />
      </Parameters>
      <Docs>
        <param name="inner">Corrispondenza di un'espressione regolare equivalente a quella prevista.</param>
        <summary>Restituisce un'istanza di <see cref="T:System.Text.RegularExpressions.Match" /> equivalente a quella fornita che può essere condivisa tra più thread.</summary>
        <returns>Corrispondenza di un'espressione regolare che può essere condivisa tra più thread.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inner" /> è <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>