<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Match.xml" source-language="en-US" target-language="it-IT">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5fb63372e2192302c84aaf2b9879a89ead4000664.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fb63372e2192302c84aaf2b9879a89ead4000664</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.RegularExpressions.Match">
          <source>Represents the results from a single regular expression match.</source>
          <target state="translated">Rappresenta i risultati di una singola corrispondenza di un'espressione regolare.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object is immutable and has no public constructor.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> oggetto non è modificabile e non ha costruttore pubblico.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> class is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> method and represents the first pattern match in a string.</source>
          <target state="translated">Un'istanza del <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> restituita dalla classe di <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> (metodo) e rappresenta il primo criterio di corrispondenza in una stringa.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Subsequent matches are represented by <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Le corrispondenze successive sono rappresentate da <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> gli oggetti restituiti dal <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>In addition, a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object that consists of zero, one, or more <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects is returned by the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Inoltre, un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> oggetto costituito da zero, uno o più <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> oggetti restituito dal <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> method fails to match a regular expression pattern in an input string, it returns an empty <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType&gt;</ph> metodo non riesce a trovare un criterio di espressione regolare in una stringa di input, restituisce un oggetto vuoto <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> oggetto.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can then use a <ph id="ph1">`foreach`</ph> construct in C# or a <ph id="ph2">`For Each`</ph> construct in Visual Basic to iterate the collection.</source>
          <target state="translated">È quindi possibile utilizzare un <ph id="ph1">`foreach`</ph> in c# o <ph id="ph2">`For Each`</ph> costruire in Visual Basic per scorrere la raccolta.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>If the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> method fails to match the regular expression pattern, it returns a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that is equal to <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.Empty%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType&gt;</ph> metodo non riesce a trovare il criterio di espressione regolare, restituisce un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> è uguale all'oggetto <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Match.Empty%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> property to determine whether the match was successful.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A&gt;</ph> proprietà per determinare se la corrispondenza ha avuto esito positivo.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following example provides an illustration.</source>
          <target state="translated">Nell'esempio seguente viene illustrato questo concetto.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>If a pattern match is successful, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property contains the matched substring, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Index%2A&gt;</ph> property indicates the zero-based starting position of the matched substring in the input string, and the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Capture.Length%2A&gt;</ph> property indicates the length of matched substring in the input string.</source>
          <target state="translated">Se un criterio di ricerca ha esito positivo, il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> proprietà contiene la sottostringa corrispondente, il <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Capture.Index%2A&gt;</ph> proprietà indica la posizione iniziale in base zero della sottostringa corrispondente nella stringa di input e <ph id="ph3">&lt;xref:System.Text.RegularExpressions.Capture.Length%2A&gt;</ph> proprietà indica il lunghezza della sottostringa corrispondente nella stringa di input.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Because a single match can involve multiple capturing groups, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> has a <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property that returns the <ph id="ph3">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph>.</source>
          <target state="translated">Poiché una singola corrispondenza può implicare più gruppi di acquisizione, <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> ha un <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> proprietà che restituisce il <ph id="ph3">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> instance itself is equivalent to the first object in the collection, at <ph id="ph2">`Match.Groups[0]`</ph> (<ph id="ph3">`Match.Groups(0)`</ph> in Visual Basic), which represents the entire match.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> istanza è equivalente al primo oggetto nella raccolta, in <ph id="ph2">`Match.Groups[0]`</ph> (<ph id="ph3">`Match.Groups(0)`</ph> in Visual Basic), che rappresenta l'intera corrispondenza.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can access the captured groups in a match in the following ways:</source>
          <target state="translated">È possibile accedere i gruppi acquisiti in una corrispondenza nei modi seguenti:</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can iterate the members of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object  by using a <ph id="ph2">`foreach`</ph> (C#) or <ph id="ph3">`For Each`</ph> (Visual Basic) construct.</source>
          <target state="translated">È possibile scorrere i membri del <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> oggetto utilizzando un <ph id="ph2">`foreach`</ph> (c#) o <ph id="ph3">`For Each`</ph> costrutto (Visual Basic).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29?displayProperty=nameWithType&gt;</ph> property to retrieve groups by the number of the capturing group.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.Int32%29?displayProperty=nameWithType&gt;</ph> proprietà per recuperare i gruppi per il numero del gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Note that you can determine which numbered groups are present in a regular expression by calling the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si noti che è possibile determinare quali gruppi numerati sono presenti in un'espressione regolare chiamando l'istanza <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29?displayProperty=nameWithType&gt;</ph> property to retrieve groups by the name of the capturing group.</source>
          <target state="translated">È possibile utilizzare il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection.Item%28System.String%29?displayProperty=nameWithType&gt;</ph> proprietà da recuperare gruppi dal nome del gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Note that you can determine which named groups are present in a regular expression by calling the instance <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNames?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Si noti che è possibile determinare quali gruppi denominati sono presenti in un'espressione regolare chiamando l'istanza <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.GetGroupNames?displayProperty=nameWithType&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following examples use the regular expression <ph id="ph1">`Console\.Write(Line)?`</ph>.</source>
          <target state="translated">Nell'esempio viene utilizzata l'espressione regolare <ph id="ph1">`Console\.Write(Line)?`</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The regular expression is interpreted as follows:</source>
          <target state="translated">L'espressione regolare viene interpretata nel modo seguente.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Console<ph id="ph1">\\</ph>.Write</source>
          <target state="translated">Console<ph id="ph1">\\</ph>.Write</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Match the string "Console.Write".</source>
          <target state="translated">Trova la corrispondenza con la stringa "Console.Write".</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Note that the "." character is escaped so that it is interpreted as a literal period rather than as a wildcard that matches any character.</source>
          <target state="translated">Si noti che il "." è sottoposto a escape in modo che viene interpretato come un periodo di valore letterale anziché come un carattere jolly che corrisponde a qualsiasi carattere.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>(Line)?</source>
          <target state="translated">(Riga)?</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>Match zero or one occurrence of the string "Line".</source>
          <target state="translated">Trova la corrispondenza con zero o una occorrenza della stringa "Line".</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source><bpt id="p1">**</bpt>Example 1<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Esempio 1<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method to retrieve all pattern matches in an input string.</source>
          <target state="translated">L'esempio seguente chiama il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> metodo per recuperare tutte le corrispondenze in una stringa di input.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>It then iterates the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> objects in the returned <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> object to display information about each match.</source>
          <target state="translated">Viene quindi eseguita l'iterazione di <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> oggetti nell'oggetto restituito <ph id="ph2">&lt;xref:System.Text.RegularExpressions.MatchCollection&gt;</ph> oggetto per visualizzare informazioni su ogni corrispondenza.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source><bpt id="p1">**</bpt>Example 2<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Esempio 2<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.RegularExpressions.Match">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> methods to retrieve one match at a time.</source>
          <target state="translated">L'esempio seguente chiama il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29&gt;</ph> e <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> metodi per recuperare una corrispondenza per volta.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>Gets the empty group.</source>
          <target state="translated">Ottiene il gruppo vuoto.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>All failed matches return this empty match.</source>
          <target state="translated">Tutte le corrispondenze non riuscite restituiscono questa corrispondenza vuota.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>An empty match.</source>
          <target state="translated">Corrispondenza vuota.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>This property should not be used to determine if a match is successful.</source>
          <target state="translated">Questa proprietà non deve essere utilizzata per determinare se una corrispondenza ha esito positivo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Empty">
          <source>Instead, use the <ph id="ph1">`Match.Success`</ph> property (which is inherited from <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Utilizzare invece il <ph id="ph1">`Match.Success`</ph> proprietà (ereditata da <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>Gets a collection of groups matched by the regular expression.</source>
          <target state="translated">Ottiene una raccolta di gruppi corrispondenti all'espressione regolare.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The character groups matched by the pattern.</source>
          <target state="translated">Gruppi di caratteri corrispondenti al criterio.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>A regular expression pattern can include subexpressions, which are defined by enclosing a portion of the regular expression pattern in parentheses.</source>
          <target state="translated">Un criterio di espressione regolare può includere sottoesspressioni, che sono definiti da una parte del criterio di espressione regolare di inclusione tra parentesi.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>Every such subexpression forms a group.</source>
          <target state="translated">Ogni sottoespressione forma un gruppo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property provides access to information about those subexpression matches.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> proprietà fornisce l'accesso a informazioni su queste sottoespressioni.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>For example, the regular expression pattern <ph id="ph1">`(\d{3})-(\d{3}-\d{4})`</ph>, which matches North American telephone numbers, has two subexpressions.</source>
          <target state="translated">Ad esempio, il criterio di espressione regolare <ph id="ph1">`(\d{3})-(\d{3}-\d{4})`</ph>, che corrisponde a numeri di telefono Nord America, ha due sottoespressioni.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The first consists of the area code, which composes the first three digits of the telephone number.</source>
          <target state="translated">Il primo è costituito da codice di area, che riunisce le prime tre cifre del numero di telefono.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>This group is captured by the first portion of the regular expression, <ph id="ph1">`(\d{3})`</ph>.The second consists of the individual telephone number, which composes the last seven digits of the telephone number.</source>
          <target state="translated">Questo gruppo viene acquisito dalla prima parte dell'espressione regolare, <ph id="ph1">`(\d{3})`</ph>. Il secondo è costituito il numero di telefono singolo, che riunisce le ultime sette cifre del numero di telefono.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>This group is captured by the second portion of the regular expression, <ph id="ph1">`(\d{3}-\d{4})`</ph>.</source>
          <target state="translated">Questo gruppo viene acquisito dalla seconda parte dell'espressione regolare, <ph id="ph1">`(\d{3}-\d{4})`</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>These two groups can then be retrieved from the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object that is returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property, as the following example shows.</source>
          <target state="translated">Questi due gruppi possono quindi essere recuperati i <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> oggetto restituito dal <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> proprietà, come illustrato nell'esempio seguente.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> property is a zero-based collection object that always has at least one member.</source>
          <target state="translated">Il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> oggetto restituito dal <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType&gt;</ph> proprietà è un oggetto raccolta in base zero che ha sempre almeno un membro.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>If the regular expression engine cannot find any matches in a particular input string, the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph> property of the single <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object in the collection (the object at index 0) is set to <ph id="ph3">`false`</ph> and the <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> object's <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph> property is set to <ph id="ph6">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Se il motore delle espressioni regolari non vengono trovate corrispondenze in una determinata stringa di input, il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Group.Success%2A?displayProperty=nameWithType&gt;</ph> proprietà dell'unico <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> oggetto nella raccolta (l'oggetto in corrispondenza dell'indice 0) è impostato su <ph id="ph3">`false`</ph> e <ph id="ph4">&lt;xref:System.Text.RegularExpressions.Group&gt;</ph> oggetto <ph id="ph5">&lt;xref:System.Text.RegularExpressions.Capture.Value%2A&gt;</ph>è impostata su <ph id="ph6">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>If the regular expression engine can find a match, the first element of the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> object (the element at index 0) returned by the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property contains a string that matches the entire regular expression pattern.</source>
          <target state="translated">Se il motore delle espressioni regolari trova una corrispondenza, il primo elemento del <ph id="ph1">&lt;xref:System.Text.RegularExpressions.GroupCollection&gt;</ph> oggetto (l'elemento in corrispondenza dell'indice 0) restituito dal <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> proprietà contiene una stringa che corrisponde al criterio di espressione regolare intera.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>Each subsequent element, from index one upward, represents a captured group, if the regular expression includes capturing groups.</source>
          <target state="translated">Ogni elemento successivo, dall'indice uno verso l'alto, rappresenta un gruppo di acquisizione, se l'espressione regolare include gruppi di acquisizione.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>For more information, see the "Grouping Constructs and Regular Expression Objects" section of the <bpt id="p1">[</bpt>Grouping Constructs<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept> article.</source>
          <target state="translated">Per ulteriori informazioni, vedere la sezione "Raggruppamento costrutti e oggetti di espressione regolare" del <bpt id="p1">[</bpt>costrutti di raggruppamento<ept id="p1">](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</ept> articolo.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The following example attempts to match a regular expression pattern against a sample string.</source>
          <target state="translated">Nell'esempio seguente cerca una corrispondenza di un criterio di espressione regolare con una stringa di esempio.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Text.RegularExpressions.Match.Groups">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> property to store information that is retrieved by the match for display to the console.</source>
          <target state="translated">Nell'esempio viene utilizzata la <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Groups%2A&gt;</ph> proprietà per archiviare le informazioni recuperate dalla corrispondenza da visualizzare nella console.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Returns a new <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> object with the results for the next match, starting at the position at which the last match ended (at the character after the last matched character).</source>
          <target state="translated">Restituisce un nuovo oggetto <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> con i risultati relativi alla corrispondenza successiva, partendo dalla posizione in cui terminava l'ultima corrispondenza (dal carattere dopo l'ultimo carattere corrispondente).</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The next regular expression match.</source>
          <target state="translated">Corrispondenza dell'espressione regolare successiva.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>This method is similar to calling <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> again and passing (<ph id="ph2">`Index+Length`</ph>) as the new starting position.</source>
          <target state="translated">Questo metodo è simile alla chiamata <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> e al passaggio (<ph id="ph2">`Index+Length`</ph>) come la nuova posizione iniziale.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>This method does not modify the current instance.</source>
          <target state="translated">Questo metodo non modifica l'istanza corrente.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Instead, it returns a new <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> object that contains information about the next match.</source>
          <target state="translated">Al contrario, restituisce un nuovo <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match&gt;</ph> oggetto che contiene informazioni sulla corrispondenza successiva.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Attempting to retrieve the next match may throw a <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> if a time-out value for matching operations is in effect and the attempt to find the next match exceeds that time-out interval.</source>
          <target state="translated">Il tentativo di recuperare la corrispondenza successiva potrebbe generare un <ph id="ph1">&lt;xref:System.Text.RegularExpressions.RegexMatchTimeoutException&gt;</ph> se un valore di timeout per operazioni di corrispondenza è attiva e il tentativo di trovare la corrispondenza successiva supera tale intervallo di timeout.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> method to capture regular expression matches beyond the first match.</source>
          <target state="translated">L'esempio seguente usa il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.NextMatch%2A&gt;</ph> metodo per acquisire l'espressione regolare corrisponde oltre la prima corrispondenza.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>A time-out occurred.</source>
          <target state="translated">Si è verificato un timeout.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>When a match attempt is repeated by calling the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> method, the regular expression engine gives empty matches special treatment.</source>
          <target state="translated">Quando un tentativo di corrispondenza viene ripetuto chiamando il <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> (metodo), il motore delle espressioni regolari corrispondenze vuote un trattamento speciale.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Usually, <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> begins the search for the next match exactly where the previous match left off.</source>
          <target state="translated">In genere, <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> inizia la ricerca della corrispondenza successiva esattamente dove la corrispondenza precedente è stata interrotta.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>However, after an empty match, the <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> method advances by one character before trying the next match.</source>
          <target state="translated">Tuttavia, dopo una corrispondenza vuota, il <ph id="ph1">&lt;see cref="M:System.Text.RegularExpressions.Match.NextMatch" /&gt;</ph> metodo fa avanzare di un carattere prima di tentare la corrispondenza successiva.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>This behavior guarantees that the regular expression engine will progress through the string.</source>
          <target state="translated">Questo comportamento garantisce che il motore delle espressioni regolari avanzamento tramite la stringa.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Otherwise, because an empty match does not result in any forward movement, the next match would start in exactly the same place as the previous match, and it would match the same empty string repeatedly.</source>
          <target state="translated">In caso contrario, perché non produce una corrispondenza vuota uno spostamento in avanti, la corrispondenza successiva inizierebbe esattamente nello stesso punto la corrispondenza precedente e corrisponderebbe ripetutamente la stessa stringa vuota.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The following example provides an illustration.</source>
          <target state="translated">Nell'esempio seguente viene illustrato questo concetto.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The regular expression pattern <bpt id="p1">&lt;c&gt;</bpt>a*<ept id="p1">&lt;/c&gt;</ept> searches for zero or more occurrences of the letter "a" in the string "abaabb".</source>
          <target state="translated">Criterio di espressione regolare <bpt id="p1">&lt;c&gt;</bpt>un *<ept id="p1">&lt;/c&gt;</ept> cerca zero o più occorrenze della lettera "a" nella stringa "abaabb".</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>As the output from the example shows, the search finds six matches.</source>
          <target state="translated">Come illustrato nell'output dell'esempio, vengono trovate sei corrispondenze.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The first match attempt finds the first "a".</source>
          <target state="translated">Il primo tentativo di corrispondenza viene cercato il primo "a".</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The second match starts exactly where the first match ends, before the first b; it finds zero occurrences of "a" and returns an empty string.</source>
          <target state="translated">La seconda corrispondenza inizia in cui il primo corrispondere esattamente, termina prima della prima b. trovata alcuna occorrenza di "a" e restituisce una stringa vuota.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The third match does not begin exactly where the second match ended, because the second match returned an empty string.</source>
          <target state="translated">La terza corrispondenza non inizia esattamente dove secondo è terminata la corrispondenza, perché la seconda ha restituito una stringa vuota.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>Instead, it begins one character later, after the first "b".</source>
          <target state="translated">Inizia invece di un carattere in un secondo momento, dopo la prima "b".</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The third match finds two occurrences of "a" and returns "aa".</source>
          <target state="translated">La terza corrispondenza individua due occorrenze di "a" e restituisce "aa".</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The fourth match attempt begins where the third match ended, before the second "b", and returns an empty string.</source>
          <target state="translated">Il quarto tentativo di ricerca ha inizio in cui è terminata la corrispondenza terzo, prima della seconda "b" e restituisce una stringa vuota.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The fifth match attempt again advances one character so that it begins before the third "b" and returns an empty string.</source>
          <target state="translated">Il quinto tentativo di corrispondenza anticipa nuovamente un carattere in modo che inizia prima della terza "b" e restituisce una stringa vuota.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.NextMatch">
          <source>The sixth match begins after the last "b" and returns an empty string again.</source>
          <target state="translated">La sesta corrispondenza inizia dopo l'ultima "b" e restituisce nuovamente una stringa vuota.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The replacement pattern to use.</source>
          <target state="translated">Criterio di sostituzione da usare.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Returns the expansion of the specified replacement pattern.</source>
          <target state="translated">Restituisce l'espansione del criterio di sostituzione specificato.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The expanded version of the <ph id="ph1">&lt;paramref name="replacement" /&gt;</ph> parameter.</source>
          <target state="translated">Versione espansa del parametro <ph id="ph1">&lt;paramref name="replacement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Whereas the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType&gt;</ph> method replaces all matches in an input string with a specified replacement pattern, the <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> method replaces a single match with a specified replacement pattern.</source>
          <target state="translated">Mentre il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Replace%2A?displayProperty=nameWithType&gt;</ph> metodo sostituisce tutte le corrispondenze in una stringa di input con un criterio di sostituzione specificato, il <ph id="ph2">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> metodo sostituisce una singola corrispondenza con un criterio di sostituzione specificata.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Because it operates on an individual match, it is also possible to perform processing on the matched string before you call the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> method.</source>
          <target state="translated">Quanto opera su una corrispondenza singola, è inoltre possibile eseguire operazioni di elaborazione sulla stringa corrispondente prima di chiamare il <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Match.Result%2A&gt;</ph> metodo.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The <ph id="ph1">`replacement`</ph> parameter is a standard regular expression replacement pattern.</source>
          <target state="translated">Il <ph id="ph1">`replacement`</ph> parametro è un criterio di sostituzione di espressioni regolari standard.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>It can consist of literal characters and regular expression substitutions.</source>
          <target state="translated">Può essere costituito da caratteri letterali e le sostituzioni di espressione regolare.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Substitutions<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</source>
          <target state="translated">Per altre informazioni, vedere <bpt id="p1">[</bpt>Sostituzioni<ept id="p1">](~/docs/standard/base-types/substitutions-in-regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The following example replaces the hyphens that begin and end a parenthetical expression with parentheses.</source>
          <target state="translated">Nell'esempio seguente sostituisce il trattino che avviano e terminano con parentesi un'espressione con parentesi.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The regular expression pattern <ph id="ph1">`--(.+?)--`</ph> is interpreted as shown in the following table.</source>
          <target state="translated">Il criterio di ricerca di espressioni regolari <ph id="ph1">`--(.+?)--`</ph> è interpretato nel modo illustrato nella tabella seguente.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Pattern</source>
          <target state="translated">Modello</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Description</source>
          <target state="translated">Descrizione</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Match two hyphens.</source>
          <target state="translated">Corrisponde a due segni meno.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Match any character one or more times, but as few times as possible.</source>
          <target state="translated">Corrisponde a qualsiasi carattere una o più volte, ma il minor numero di volte possibile.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>This is the first capturing group.</source>
          <target state="translated">Equivale al primo gruppo di acquisizione.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Match two hyphens.</source>
          <target state="translated">Corrisponde a due segni meno.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Note that the regular expression pattern <ph id="ph1">`--(.+?)--`</ph> uses the lazy quantifier <ph id="ph2">`+?`</ph>.</source>
          <target state="translated">Si noti che il criterio di espressione regolare <ph id="ph1">`--(.+?)--`</ph> utilizza un quantificatore lazy <ph id="ph2">`+?`</ph>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>If the greedy quantifier <ph id="ph1">`+`</ph> were used instead, the regular expression engine would find only a single match in the input string.</source>
          <target state="translated">Se il quantificatore greedy <ph id="ph1">`+`</ph> utilizzati in alternativa, il motore delle espressioni regolari cercherebbe solo una singola corrispondenza nella stringa di input.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>The replacement string <ph id="ph1">`($1)`</ph> replaces the match with the first captured group, which is enclosed in parentheses.</source>
          <target state="translated">La stringa di sostituzione <ph id="ph1">`($1)`</ph> sostituisce la corrispondenza con il primo gruppo acquisito che è racchiuso tra parentesi.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source><ph id="ph1">&lt;paramref name="replacement" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="replacement" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Result(System.String)">
          <source>Expansion is not allowed for this pattern.</source>
          <target state="translated">L'espansione non è consentita per questo criterio.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source>A regular expression match equivalent to the one expected.</source>
          <target state="translated">Corrispondenza di un'espressione regolare equivalente a quella prevista.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> instance equivalent to the one supplied that is suitable to share between multiple threads.</source>
          <target state="translated">Restituisce un'istanza di <ph id="ph1">&lt;see cref="T:System.Text.RegularExpressions.Match" /&gt;</ph> equivalente a quella fornita che può essere condivisa tra più thread.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source>A regular expression match that is suitable to share between multiple threads.</source>
          <target state="translated">Corrispondenza di un'espressione regolare che può essere condivisa tra più thread.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)">
          <source><ph id="ph1">&lt;paramref name="inner" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="inner" /&gt;</ph> è <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>