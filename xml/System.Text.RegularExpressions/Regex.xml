<Type Name="Regex" FullName="System.Text.RegularExpressions.Regex">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="177f3dc5025e68b346e54aa526aba68a1073cecf" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="it-IT" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52603530" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Regex : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Regex extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.RegularExpressions.Regex" />
  <TypeSignature Language="VB.NET" Value="Public Class Regex&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Regex : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Regex = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.RegularExpressions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Rappresenta un'espressione regolare non modificabile.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex> classe rappresenta motore delle espressioni regolari di .NET Framework. Può essere utilizzato per analizzare rapidamente grandi quantità di testo per trovare combinazioni di caratteri specifica; Per estrarre, modificare, sostituire o eliminare sottostringhe di testo e aggiungere le stringhe estratte a una raccolta per generare un report.  
  
> [!NOTE]
>  Se l'obiettivo principale consiste nel convalidare una stringa per determinare se è conforme a un modello specifico, è possibile usare il <xref:System.Configuration.RegexStringValidator?displayProperty=nameWithType> classe.  
  
 Per usare le espressioni regolari, si definisce il modello che si desidera identificare in un flusso di testo usando la sintassi riportata in [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Successivamente, è possibile, facoltativamente, creare un'istanza di un <xref:System.Text.RegularExpressions.Regex> oggetto. Infine, si chiama un metodo che esegue alcune operazioni, ad esempio la sostituzione di testo che corrisponde al criterio di espressione regolare o identificare un criterio di ricerca.  
  
> [!NOTE]
>  Per alcuni modelli di espressione regolare comuni, vedere [esempi di espressioni regolari](~/docs/standard/base-types/regular-expression-examples.md). Esistono inoltre numerose raccolte online dei modelli di espressione regolare, ad esempio quella disponibile [Regular Expressions.info](https://www.regular-expressions.info/examples.html).  
  
<a name="remarks"></a> Per altre informazioni sull'uso di <xref:System.Text.RegularExpressions.Regex> di classi, vedere le sezioni seguenti in questo argomento:  
  
-   [Visual Studio di espressione regolare. Metodi di stringhe](#regex_vs_string)  
  
-   [Porte statiche e Metodi di istanza](#static_vs_instance)  
  
-   [Esecuzione di operazioni di espressione regolare](#regex_ops)  
  
-   [Definizione di un valore di timeout](#define_timeout)  
  
 Per altre informazioni sul linguaggio delle espressioni regolari, vedere [Linguaggio di espressioni regolari - Riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md) o scaricare e stampare una delle brochure seguenti:  
  
 [Riferimento rapido in formato Word (DOCX)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.docx)  
 [Riferimento rapido in formato PDF (PDF)](https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular%20expressions%20quick%20reference.pdf)  
  
<a name="regex_vs_string"></a>   
## <a name="regex-vs-string-methods"></a>Visual Studio di espressione regolare. Metodi di stringhe  
 Il <xref:System.String?displayProperty=nameWithType> classe include diversi metodi di ricerca e confronto che è possibile usare per eseguire corrispondenze con il testo. Ad esempio, il <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.EndsWith%2A?displayProperty=nameWithType>, e <xref:System.String.StartsWith%2A?displayProperty=nameWithType> metodi di determinano se un'istanza di stringa contiene una sottostringa specificata; e il <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, <xref:System.String.IndexOfAny%2A?displayProperty=nameWithType>, <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>, e <xref:System.String.LastIndexOfAny%2A?displayProperty=nameWithType> metodi restituiscono il valore iniziale posizione di una sottostringa specificata in una stringa. Usare i metodi del <xref:System.String?displayProperty=nameWithType> classe quando cerca una stringa specifica. Usare il <xref:System.Text.RegularExpressions.Regex> classe quando si esegue la ricerca per un criterio specifico in una stringa. Per altre informazioni ed esempi, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
 [Torna a osservazioni](#remarks)  
  
<a name="static_vs_instance"></a>   
## <a name="static-vs-instance-methods"></a>Porte statiche e Metodi di istanza  
 Dopo aver definito un criterio di espressione regolare, è possibile fornirlo al motore delle espressioni regolari in uno dei due modi:  
  
-   Creando un <xref:System.Text.RegularExpressions.Regex> oggetto che rappresenta l'espressione regolare. A tale scopo, si passa il modello di espressione regolare a una <xref:System.Text.RegularExpressions.Regex.%23ctor%2A> costruttore. Oggetto <xref:System.Text.RegularExpressions.Regex> oggetto non è modificabile; quando crea un'istanza un <xref:System.Text.RegularExpressions.Regex> dell'oggetto con un'espressione regolare, che non venga modificato l'espressione regolare dell'oggetto.  
  
-   Specificando sia l'espressione regolare che il testo da includere nella ricerca una `static` (`Shared` in Visual Basic) <xref:System.Text.RegularExpressions.Regex> (metodo). In questo modo è possibile usare un'espressione regolare senza creare esplicitamente un <xref:System.Text.RegularExpressions.Regex> oggetto.  
  
 Tutti i <xref:System.Text.RegularExpressions.Regex> metodi identificazione del modello includono sia statici e l'istanza di overload.  
  
 Il motore delle espressioni regolari deve compilare un modello specifico prima di poter usare il modello. In quanto <xref:System.Text.RegularExpressions.Regex> gli oggetti non sono modificabili, si tratta di una procedura singola che si verifica quando un <xref:System.Text.RegularExpressions.Regex> costruttore di classe o un metodo statico viene chiamato. Per eliminare la necessità di compilare ripetutamente una singola espressione regolare, il motore delle espressioni regolari memorizza nella cache le espressioni regolari compilate usate nelle chiamate al metodo statico. Di conseguenza, i metodi di corrispondenza di espressione regolare offrono prestazioni paragonabili a quelle per statici e metodi di istanza.  
  
> [!IMPORTANT]
>  In espressioni regolari di .NET Framework versioni 1.0 e 1.1, tutte compilate, se sono stati usati nel metodo statico o istanza chiama, sono stati memorizzati nella cache. A partire da .NET Framework 2.0, vengono memorizzati nella cache solo le espressioni regolari usate nelle chiamate al metodo statico.  
  
 Tuttavia, la memorizzazione nella cache può influire negativamente sulle prestazioni in due casi seguenti:  
  
-   Quando si utilizzano chiamate al metodo statico con un numero elevato di espressioni regolari. Per impostazione predefinita, il motore delle espressioni regolari memorizza nella cache il 15 usate più recentemente espressioni regolari statiche. Se l'applicazione usa più di 15 espressioni regolari statiche, è necessario ricompilare alcune espressioni regolari. Per evitare la ricompilazione, è possibile aumentare il <xref:System.Text.RegularExpressions.Regex.CacheSize%2A?displayProperty=nameWithType> proprietà.  
  
-   Quando crea un'istanza nuova <xref:System.Text.RegularExpressions.Regex> oggetti con espressioni regolari che in precedenza sono stati compilati. Ad esempio, il codice seguente definisce un'espressione regolare per individuare eventuali parole duplicate in un flusso di testo. Anche se l'esempio Usa una singola espressione regolare, crea un'istanza di un nuovo <xref:System.Text.RegularExpressions.Regex> oggetto da elaborare ogni riga di testo. Ciò comporta la ricompilazione dell'espressione regolare con ogni iterazione del ciclo.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#1)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#1)]  
  
     Per evitare la ricompilazione, è consigliabile creare un'istanza di un singolo <xref:System.Text.RegularExpressions.Regex> oggetto che è possibile accedere a tutto il codice che lo richiede, come illustrato nell'esempio seguente riscritto.  
  
     [!code-csharp[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/cs/caching1.cs#2)]
     [!code-vb[System.Text.RegularExpressions.Class.Caching#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.class.caching/vb/caching1.vb#2)]  
  
 [Torna a osservazioni](#remarks)  
  
<a name="regex_ops"></a>   
## <a name="performing-regular-expression-operations"></a>Esecuzione di operazioni di espressione regolare  
 Se si decide di creare un'istanza di un <xref:System.Text.RegularExpressions.Regex> dell'oggetto e chiamarne i metodi o chiamare metodi statici, il <xref:System.Text.RegularExpressions.Regex> classe offre le funzionalità di corrispondenza dei modelli seguenti:  
  
-   Convalida di una corrispondenza. Si chiama il <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> metodo per determinare se è presente una corrispondenza.  
  
-   Recupero di una singola corrispondenza. Si chiama il <xref:System.Text.RegularExpressions.Regex.Match%2A> metodo per recuperare un <xref:System.Text.RegularExpressions.Match> oggetto che rappresenta la prima corrispondenza in una stringa o in parte di una stringa. Corrispondenze successive possono essere recuperate chiamando il <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (metodo).  
  
-   Recupero di tutte le corrispondenze. Si chiama il <xref:System.Text.RegularExpressions.Regex.Matches%2A> metodo per recuperare un <xref:System.Text.RegularExpressions.MatchCollection?displayProperty=nameWithType> oggetto che rappresenta tutte le corrispondenze trovate in una stringa o in parte di una stringa.  
  
-   Sostituzione di testo corrispondente. Si chiama il <xref:System.Text.RegularExpressions.Regex.Replace%2A> metodo per sostituire testo corrispondente. Il testo di sostituzione può anche essere definito da un'espressione regolare. Inoltre, alcune delle <xref:System.Text.RegularExpressions.Regex.Replace%2A> metodi includono un <xref:System.Text.RegularExpressions.MatchEvaluator> parametro che consente di definire a livello di codice il testo di sostituzione.  
  
-   Creazione di una matrice di stringhe che è costituita dalle parti di una stringa di input. Si chiama il <xref:System.Text.RegularExpressions.Regex.Split%2A> metodo per suddividere una stringa di input in corrispondenza delle posizioni definite all'espressione regolare.  
  
 Oltre ai relativi metodi di corrispondenza, il <xref:System.Text.RegularExpressions.Regex> classe include metodi per scopi diversi:  
  
-   Il <xref:System.Text.RegularExpressions.Regex.Escape%2A> metodo esegue l'escape di caratteri che possono essere interpretati come operatori di espressione regolare in una stringa di input o l'espressione regolare.  
  
-   Il <xref:System.Text.RegularExpressions.Regex.Unescape%2A> metodo rimuove i caratteri di escape.  
  
-   Il <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> metodo crea un assembly che contiene espressioni regolari predefinite. .NET Framework sono disponibili esempi di tali assembly speciali nel <xref:System.Web.RegularExpressions?displayProperty=nameWithType> dello spazio dei nomi.  
  
 [Torna a osservazioni](#remarks)  
  
<a name="define_timeout"></a>   
## <a name="defining-a-time-out-value"></a>Definizione di un valore di timeout  
 .NET Framework supporta un linguaggio delle espressioni regolari completa che fornisce sostanziale potenza e flessibilità nei criteri di ricerca. Tuttavia, la potenza e flessibilità hanno un costo: il rischio di riduzione delle prestazioni. Le espressioni regolari che scarse sono sorprendentemente facile da creare. In alcuni casi, le operazioni di espressione regolare che si basano su un backtracking eccessivo possono bloccarsi durante l'elaborazione di testo che corrisponde quasi al modello di espressione regolare. Per altre informazioni sul motore di espressioni regolari di .NET Framework, vedere [dettagli del comportamento delle espressioni regolari](~/docs/standard/base-types/details-of-regular-expression-behavior.md). Per altre informazioni sull'uso eccessivo del backtracking, vedere [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 A partire dal [!INCLUDE[net_v45](~/includes/net-v45-md.md)], è possibile definire un intervallo di timeout per le corrispondenze di espressione regolare. Se il motore delle espressioni regolari non riesce a identificare una corrispondenza all'interno di questo intervallo di tempo, l'operazione di corrispondenza genera una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. Nella maggior parte dei casi, ciò impedisce al motore delle espressioni regolari inutile consumo di potenza di elaborazione da ricerca di corrispondenza con il testo che corrisponde quasi al modello di espressione regolare. È stato possibile ritenuta è, tuttavia, che l'intervallo di timeout è stato impostato un valore troppo basso oppure che il carico corrente del computer ha causato una riduzione generale delle prestazioni.  
  
 Come si gestisce l'eccezione dipende dalla causa dell'eccezione. Se l'eccezione si verifica perché l'intervallo di timeout viene impostato un valore troppo basso o a causa di carico eccessivo computer, è possibile aumentare l'intervallo di timeout e ritentare l'operazione corrispondente. Se l'eccezione si verifica perché l'espressione regolare si basa su un backtracking eccessivo, si può presupporre che non esiste una corrispondenza e, facoltativamente, è possibile registrare le informazioni che consentiranno di modificare il criterio di espressione regolare.  
  
 È possibile impostare un intervallo di timeout chiamando il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> costruttore quando si crea un'istanza di un oggetto di espressione regolare. Per i metodi statici, è possibile impostare un intervallo di timeout chiamando un overload del metodo corrisponda con un `matchTimeout` parametro. Se non si imposta un valore di timeout in modo esplicito, il valore di timeout predefinito viene determinato come segue:  
  
-   Utilizzando il timeout a livello di applicazione valore, se uno è presente. Può trattarsi di qualsiasi valore di timeout si applica al dominio dell'applicazione in cui il <xref:System.Text.RegularExpressions.Regex> viene creata un'istanza di oggetto oppure è stata eseguita la chiamata al metodo statico. È possibile impostare il valore di timeout a livello di applicazione chiamando il <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> metodo a cui assegnare la rappresentazione di stringa di un <xref:System.TimeSpan> valore alla proprietà "REGEX_DEFAULT_MATCH_TIMEOUT".  
  
-   Usando il valore <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout>, se non è stato impostato alcun valore di timeout a livello di applicazione.  
  
> [!IMPORTANT]
>  È consigliabile impostare un valore di timeout in tutte le operazioni di corrispondenza espressione regolare. Per altre informazioni, vedere [procedure consigliate per le espressioni regolari](~/docs/standard/base-types/best-practices.md).  
  
 [Torna a osservazioni](#remarks)  
  
   
  
## Examples  
 Nell'esempio seguente usa un'espressione regolare per verificare la presenza di occorrenze ripetute di parole in una stringa. L'espressione regolare `\b(?<word>\w+)\s+(\k<word>)\b` può essere interpretato come illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`(?<word>\w+)`|Trova una o più caratteri alfanumerici fino a un confine di parola. Questo gruppo acquisito `word`.|  
|`\s+`|Corrisponde a uno o più caratteri spazio vuoto.|  
|`(\k<word>)`|Corrisponde al gruppo acquisito denominato `word`.|  
|`\b`|Trova la corrispondenza di un confine di parola.|  
  
 [!code-cpp[Regex_Words#0](~/samples/snippets/cpp/VS_Snippets_CLR/Regex_Words/CPP/words.cpp#0)]
 [!code-csharp[Regex_Words#0](~/samples/snippets/csharp/VS_Snippets_CLR/Regex_Words/CS/words.cs#0)]
 [!code-vb[Regex_Words#0](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex_Words/VB/words.vb#0)]  
  
 Nell'esempio seguente viene illustrato l'utilizzo di un'espressione regolare per verificare se una stringa rappresenta un valore di valuta o ha il formato corretto per rappresentare un valore di valuta. In questo caso, l'espressione regolare viene compilata in modo dinamico dal <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> proprietà per impostazioni cultura correnti dell'utente. Se il sistema corrente delle impostazioni cultura è en-US, l'espressione regolare risulta è `^\s*[\+-]?\s?\$?\s?(\d*\.?\d{2}?){1}$`. Questa espressione regolare può essere interpretata come illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`^`|Dall'inizio della stringa.|  
|`\s*`|Trovare la corrispondenza di zero o più spazi vuoti.|  
|`[\+-]?`|Trova zero o una occorrenza del segno positivo o il segno negativo.|  
|`\s?`|Trova la corrispondenza di uno o nessuno spazio vuoto.|  
|`\$?`|Trova zero o una occorrenza del segno di dollaro.|  
|`\s?`|Trova la corrispondenza di uno o nessuno spazio vuoto.|  
|`\d*`|Ricerca la corrispondenza di zero o di più cifre decimali.|  
|`\.?`|Corrisponde a zero o un simbolo di separatore decimale.|  
|`\d{2}?`|Corrisponde a due cifre decimali pari a zero o una volta.|  
|`(\d*\.?\d{2}?){1}`|Corrisponde al modello di cifre integrali e frazionarie separati da un simbolo di separatore decimale almeno una volta.|  
|`$`|Trovare la fine della stringa.|  
  
 In questo caso, l'espressione regolare si presuppone che una stringa di valuta validi non contiene i simboli separatori di gruppo e che abbia senza cifre frazionarie o il numero di cifre frazionarie definite dalle impostazioni cultura correnti <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalDigits%2A> proprietà.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/cs/regex_example1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.class/vb/regex_example1.vb#1)]  
  
 Poiché l'espressione regolare in questo esempio viene compilato in modo dinamico, non si sa in fase di progettazione se il simbolo di valuta di cultura correnti, segno decimale o segni positivi e negativi mal interpretate dal motore delle espressioni regolari come regolare operatori di linguaggio di espressione. Per evitare il problema, nell'esempio vengono passate ogni stringa generata in modo dinamico per il <xref:System.Text.RegularExpressions.Regex.Escape%2A> (metodo).  
  
 ]]></format>
    </remarks>
    <threadsafe>Il <see cref="T:System.Text.RegularExpressions.Regex" /> classe non è modificabile (sola lettura) e thread-safe. <see cref="T:System.Text.RegularExpressions.Regex" /> gli oggetti possono essere creati su qualsiasi thread e condividerli fra i thread. Per altre informazioni, vedere [Thread Safety](~/docs/standard/base-types/thread-safety-in-regular-expressions.md).</threadsafe>
    <altmember cref="T:System.Configuration.RegexStringValidator" />
    <related type="Article" href="~/docs/standard/base-types/regular-expressions.md">Espressioni regolari di .NET Framework</related>
    <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.docx">Espressioni regolari - Guida di riferimento rapido (download in formato Word)</related>
    <related type="ExternalDocumentation" href="https://download.microsoft.com/download/D/2/4/D240EBF6-A9BA-4E4F-A63F-AEB6DA0B921C/Regular expressions quick reference.pdf">Espressioni regolari - Guida di riferimento rapido (download in formato PDF)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che questo costruttore è protetto; può essere chiamato solo dalle classi derivate dal <xref:System.Text.RegularExpressions.Regex> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex pattern" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.RegularExpressions.Regex" /> per l'espressione regolare specificata.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere la [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md) argomenti.  
  
 Chiama il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%29> è equivalente alla chiamata al costruttore il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> costruttore con un valore di <xref:System.Text.RegularExpressions.RegexOptions.None> per il `options` argomento.  
  
 Oggetto <xref:System.Text.RegularExpressions.Regex> oggetto non è modificabile, il che significa che può essere utilizzato solo per il modello di corrispondenza è definire durante la creazione. Tuttavia, può essere usato qualsiasi numero di volte senza vengano ricompilate.  
  
 Questo costruttore crea un'istanza di un oggetto espressione regolare tenta una corrispondenza tra maiuscole e minuscole di tutti i caratteri alfabetici definiti `pattern`. Per trovare una corrispondenza tra maiuscole e minuscole, usare il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> costruttore.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare questo costruttore per creare un'istanza di un'espressione regolare che corrisponde a qualsiasi parola che inizia con le lettere "a" o "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/constructors1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/constructors1.vb#1)]  
  
 Si noti che il criterio di espressione regolare non corrisponda alla parola "The" all'inizio del testo, in quanto i confronti sono tra maiuscole e minuscole per impostazione predefinita. Per un esempio di confronto tra maiuscole e minuscole, vedere il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> costruttore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Questo costruttore crea un <see cref="T:System.Text.RegularExpressions.Regex" /> oggetto che utilizza il valore di timeout predefinito del dominio dell'applicazione in cui viene creato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il <see cref="T:System.Text.RegularExpressions.Regex" /> oggetto utilizza il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, impedendo l'operazione di timeout. Il costruttore consigliato per la creazione di un <see cref="T:System.Text.RegularExpressions.Regex" /> oggetto <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Regex (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Regex(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Oggetto in cui sono contenuti un modello serializzato e le informazioni relative a <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</param>
        <param name="context">Destinazione per questa serializzazione. Questo parametro non viene usato; specificare <see langword="null" />.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.RegularExpressions.Regex" /> usando i dati serializzati.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">Il criterio contenuto nel parametro <paramref name="info" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="info" /> contiene un flag <see cref="T:System.Text.RegularExpressions.RegexOptions" /> non valido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che modificano l'espressione regolare.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.RegularExpressions.Regex" /> per l'espressione regolare specificata, con opzioni che modificano il criterio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere la [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md) argomenti.  
  
 Oggetto <xref:System.Text.RegularExpressions.Regex> oggetto non è modificabile, il che significa che può essere utilizzato solo per i parametri di corrispondenza è definire durante la creazione. Tuttavia, può essere usato qualsiasi numero di volte senza vengano ricompilate.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato come utilizzare questo costruttore per creare un'istanza di un'espressione regolare che corrisponde a qualsiasi parola che inizia con le lettere "a" o "t".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/cs/Constructors2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Constructors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Constructors/vb/Constructors2.vb#2)]  
  
 Si noti che la raccolta di corrispondenza include la parola "The" che inizia il testo, in quanto il `options` parametro ha definito i confronti tra maiuscole e minuscole.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Il parametro <paramref name="options" /> contiene un flag non valido.</exception>
        <block subset="none" type="usage">
          <para>Questo costruttore crea un <see cref="T:System.Text.RegularExpressions.Regex" /> oggetto che utilizza il valore di timeout predefinito del dominio dell'applicazione in cui viene creato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il <see cref="T:System.Text.RegularExpressions.Regex" /> oggetto utilizza il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, impedendo l'operazione di timeout. Il costruttore consigliato per la creazione di un <see cref="T:System.Text.RegularExpressions.Regex" /> oggetto <see cref="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Regex (string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pattern As String, options As RegexOptions, matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Regex(System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="new System.Text.RegularExpressions.Regex : string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Regex" Usage="new System.Text.RegularExpressions.Regex (pattern, options, matchTimeout)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che modificano l'espressione regolare.</param>
        <param name="matchTimeout">Intervallo di timeout o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> per indicare che per il metodo non è previsto un timeout.</param>
        <summary>Inizializza una nuova istanza della classe <see cref="T:System.Text.RegularExpressions.Regex" /> per l'espressione regolare specificata, con le opzioni che modificano il criterio e un valore che specifica per quanto tempo un metodo di criteri di ricerca deve provare a trovare una corrispondenza prima del timeout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere la [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md) argomenti.  
  
 Oggetto <xref:System.Text.RegularExpressions.Regex> oggetto non è modificabile, il che significa che può essere utilizzato solo per definire quando si crea il modello di corrispondenza. Tuttavia, può essere usato qualsiasi numero di volte senza vengano ricompilate.  
  
 Il `matchTimeout` parametro specifica quanto tempo una corrispondenza metodo deve effettuare per trovare una corrispondenza prima del timeout. Se viene trovata alcuna corrispondenza in tale intervallo di tempo, il metodo di corrispondenza genera una <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. `matchTimeout` esegue l'override di qualsiasi valore di timeout predefinito definito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. I metodi di istanza corrispondenti al criterio che osservano le `matchTimeout` intervallo di timeout includono quanto segue:  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%2A>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%2A>  
  
-   <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType>  
  
 L'impostazione di un intervallo di timeout impedisce le espressioni regolari che si basano su un backtracking eccessivo che venga visualizzato il blocco quando elaborano un input che contiene corrispondenze. Per altre informazioni, vedere [procedure consigliate per le espressioni regolari](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Per impostare un intervallo di tempo ragionevole, considerare quanto segue:  
  
-   La lunghezza e complessità del modello di espressione regolare. Le espressioni regolari più lunghi e più complesse richiedono più tempo rispetto a quelli più breve e semplice.  
  
-   Il carico di lavoro previsto. L'elaborazione richiede più tempo nei sistemi che dispongono di un utilizzo elevato della CPU e memoria.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> costruttore per creare un'istanza di un <xref:System.Text.RegularExpressions.Regex> oggetto con un valore di timeout di un secondo. Il modello di espressione regolare `(a+)+$`, che corrisponde a uno o più sequenze di uno o più caratteri "a" alla fine di una riga, è soggetto all'utilizzo eccessivo del backtracking. Se un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> viene generata un'eccezione, l'esempio aumenta il valore di timeout fino al valore massimo di tre secondi. In caso contrario, ignora il tentativo di corrispondere al modello.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è un valore valido di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
oppure 
 <paramref name="matchTimeout" /> è negativo, zero o maggiore di circa 24 giorni.</exception>
        <block subset="none" type="usage">
          <para>È consigliabile impostare il <paramref name="matchTimeout" /> parametro su un valore appropriato, ad esempio due secondi. Se si disabilita i timeout specificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, il motore delle espressioni regolari offre prestazioni leggermente migliori. Tuttavia, è necessario disabilitare i timeout solo nelle condizioni seguenti: 
-Quando l'input elaborata da un'espressione regolare è derivato da un'origine conosciuta e attendibile o è costituito da testo statico. Esclude il testo che è stato in modo dinamico inseriti dagli utenti.  
  
-Quando il criterio di espressione regolare è stata accuratamente testato per verificare che gestisca in modo efficiente trova, mancate corrispondenze e a breve.  
  
-Quando il criterio di espressione regolare non contiene alcun elemento di linguaggio che potrebbero causare un backtracking eccessivo durante l'elaborazione di una corrispondenza più vicino.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Backtracking</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="CacheSize">
      <MemberSignature Language="C#" Value="public static int CacheSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CacheSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CacheSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CacheSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CacheSize : int with get, set" Usage="System.Text.RegularExpressions.Regex.CacheSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta il numero massimo di voci nella cache statica corrente di espressioni regolari compilate.</summary>
        <value>Numero massimo di voci nella cache statica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex> classe mantiene una cache interna di espressioni regolari compilate usato nelle chiamate al metodo statico. Se il valore specificato in un'operazione set è minore rispetto alla dimensione della cache corrente, le voci della cache vengono eliminate fino a quando le dimensioni della cache sono uguale al valore specificato.  
  
 Per impostazione predefinita, la cache contiene 15 espressioni regolari statiche compilate. L'applicazione in genere non dovrà modificare la dimensione della cache. Usare il <xref:System.Text.RegularExpressions.Regex.CacheSize%2A> proprietà solo quando si desidera disattivare la memorizzazione nella cache o quando si dispone di un'istanza di cache insolitamente ampio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Il valore in un'operazione set è minore di zero.</exception>
        <block subset="none" type="usage">
          <para>In .NET Framework precedenti al [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], le espressioni regolari usate entrambe statico e chiamate ai metodi di istanza sono stati memorizzati nella cache. A partire dal [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)], regular solo le espressioni usate nelle chiamate al metodo statico vengono memorizzate nella cache.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="capnames">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable capnames;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable capnames" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capnames" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capnames As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ capnames;" />
      <MemberSignature Language="F#" Value="val mutable capnames : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.capnames" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CapNames">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary CapNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary CapNames" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.CapNames" />
      <MemberSignature Language="VB.NET" Value="Protected Property CapNames As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ CapNames { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CapNames : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.CapNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un dizionario che esegue il mapping di gruppi di acquisizione denominati ai valori di indice corrispondenti.</summary>
        <value>Dizionario che esegue il mapping di gruppi di acquisizione denominati ai valori di indice corrispondenti.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che questa proprietà è protetto; essere accessibile solo da una classe derivata dal <xref:System.Text.RegularExpressions.Regex> classe.  
  
 Un'operazione di impostazione tenta di convertire il valore assegnato alla proprietà da un <xref:System.Collections.Hashtable> oggetto; in caso di questa conversione, chiama il <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> costruttore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore assegnato alla proprietà <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> in un'operazione set è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="caps">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Hashtable caps;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Collections.Hashtable caps" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.caps" />
      <MemberSignature Language="VB.NET" Value="Protected Friend caps As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Collections::Hashtable ^ caps;" />
      <MemberSignature Language="F#" Value="val mutable caps : System.Collections.Hashtable" Usage="System.Text.RegularExpressions.Regex.caps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Caps">
      <MemberSignature Language="C#" Value="protected System.Collections.IDictionary Caps { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Caps" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Caps" />
      <MemberSignature Language="VB.NET" Value="Protected Property Caps As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::IDictionary ^ Caps { System::Collections::IDictionary ^ get(); void set(System::Collections::IDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Caps : System.Collections.IDictionary with get, set" Usage="System.Text.RegularExpressions.Regex.Caps" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netstandard-2.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene o imposta un dizionario che esegue il mapping di gruppi di acquisizione numerati nei relativi valori di indice.</summary>
        <value>Un dizionario che esegue il mapping di gruppi di acquisizione numerati nei relativi valori di indice.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si noti che questa proprietà è protetto; essere accessibile solo da una classe derivata dal <xref:System.Text.RegularExpressions.Regex> classe.  
  
 Un'operazione di impostazione tenta di convertire il valore assegnato alla proprietà da un <xref:System.Collections.Hashtable> oggetto; in caso di questa conversione, chiama il <xref:System.Collections.Hashtable.%23ctor%28System.Collections.IDictionary%29?displayProperty=nameWithType> costruttore.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Il valore assegnato alla proprietà <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> in un'operazione set è <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="capsize">
      <MemberSignature Language="C#" Value="protected internal int capsize;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly int32 capsize" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capsize" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capsize As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected public: int capsize;" />
      <MemberSignature Language="F#" Value="val mutable capsize : int" Usage="System.Text.RegularExpressions.Regex.capsize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="capslist">
      <MemberSignature Language="C#" Value="protected internal string[] capslist;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string[] capslist" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.capslist" />
      <MemberSignature Language="VB.NET" Value="Protected Friend capslist As String() " />
      <MemberSignature Language="C++ CLI" Value="protected public: cli::array &lt;System::String ^&gt; ^ capslist;" />
      <MemberSignature Language="F#" Value="val mutable capslist : string[]" Usage="System.Text.RegularExpressions.Regex.capslist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompileToAssembly">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compila espressioni regolari e le salva su disco in un singolo assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

In .NET Core, le chiamate al `Regex.CompileToAssembly` metodo throw un <xref:System.PlatformNotSupportedException>; la scrittura di un assembly non è supportata.
  
       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Matrice che descrive le espressioni regolari da compilare.</param>
        <param name="assemblyname">Nome file dell'assembly.</param>
        <summary>Compila uno o più oggetti <see cref="T:System.Text.RegularExpressions.Regex" /> specificati in un assembly denominato.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> metodo genera un assembly .NET Framework in cui ogni espressione regolare definiti nella `regexinfos` matrice è rappresentata da una classe. In genere, il <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%29> viene chiamato da un'applicazione separata che genera un assembly delle espressioni regolari compilate. Ogni espressione regolare inclusi nell'assembly presenta le caratteristiche seguenti:  
  
-   Da cui derivano i <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Viene assegnato il nome completo è definito per il `fullnamespace` e `name` i parametri del relativo valore corrispondente <xref:System.Text.RegularExpressions.RegexCompilationInfo> oggetto.  
  
-   Ha un' predefinita (o senza parametri) costruttore.  
  
 In genere, il codice che crea e Usa l'espressione regolare compilata è disponibile in un assembly o applicazione che è separato dal codice che crea l'assembly.  
  
   
  
## Examples  
 L'esempio seguente crea un assembly denominato RegexLib. dll. L'assembly include due espressioni regolari compilate. Il primo, `Utilities.RegularExpressions.DuplicatedString`, corrisponde a due parole contigue identiche. Il secondo, `Utilities.RegularExpressions.EmailAddress`, verifica se una stringa ha il formato corretto per essere un indirizzo di posta elettronica.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile1.vb#1)]  
  
 L'espressione regolare che controlla una stringa per le parole duplicate viene quindi creata un'istanza e usato nell'esempio seguente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilazione riuscita di questo secondo esempio richiede un riferimento a RegexLib. dll (assembly creato dal primo esempio) da aggiungere al progetto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore della proprietà <see cref="P:System.Reflection.AssemblyName.Name" /> del parametro <paramref name="assemblyname" /> è una stringa vuota o null.  
  
oppure 
Il criterio di ricerca di espressioni regolari di uno o più oggetti in <paramref name="regexinfos" /> contiene una sintassi non valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> o <paramref name="regexinfos" /> è <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET core solo: la creazione di un assembly di espressioni regolari compilate non è supportata.</exception>
        <block subset="none" type="usage">
          <para>Se si sta sviluppando in un sistema dotato [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o relative versioni intermedie installati, sono destinati [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], e userai il <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> metodo per creare un assembly che contiene espressioni regolari compilate. Tentativo di utilizzare una delle espressioni regolari in assembly in un sistema che dispone di [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] genera un'eccezione. Per risolvere il problema, è possibile eseguire una delle operazioni seguenti: 
-Compilazione dell'assembly che contiene le espressioni regolari compilate in un sistema che ha [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] anziché versioni successive installato.  
  
-Invece di chiamare <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> e recuperando l'espressione regolare compilata da un assembly, usare statico o istanza <see cref="T:System.Text.RegularExpressions.Regex" /> metodi con la <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opzione quando crea un'istanza un <see cref="T:System.Text.RegularExpressions.Regex" /> di oggetti o chiamare un'espressione regolare metodo corrispondente al modello.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Compilazione e riutilizzo</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Matrice che descrive le espressioni regolari da compilare.</param>
        <param name="assemblyname">Nome file dell'assembly.</param>
        <param name="attributes">Matrice che definisce gli attributi da applicare all'assembly.</param>
        <summary>Compila uno o più oggetti <see cref="T:System.Text.RegularExpressions.Regex" /> specificati in un assembly denominato con gli attributi specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> metodo genera un assembly .NET Framework in cui ogni espressione regolare definiti nella `regexinfos` matrice è rappresentata da una classe. In genere, il <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29> viene chiamato da un'applicazione separata che genera un assembly delle espressioni regolari compilate. Ogni espressione regolare inclusi nell'assembly presenta le caratteristiche seguenti:  
  
-   Da cui derivano i <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Viene assegnato il nome completo è definito per il `fullnamespace` e `name` i parametri del relativo valore corrispondente <xref:System.Text.RegularExpressions.RegexCompilationInfo> oggetto.  
  
-   Ha un' predefinita (o senza parametri) costruttore.  
  
 In genere, il codice che crea e Usa l'espressione regolare compilata è disponibile in un assembly o applicazione che è separato dal codice che crea l'assembly.  
  
 Poiché il <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> metodo genera un assembly .NET Framework da una chiamata al metodo anziché la parola chiave della definizione del linguaggio particolare classe (ad esempio `class` in c# o `Class`...`End Class` in Visual Basic), non consente gli attributi di .NET Framework da assegnare all'assembly usando la sintassi di attributo standard del linguaggio di sviluppo. Il `attributes` parametro fornisce un metodo alternativo per la definizione di attributi da applicare all'assembly. Per ogni attributo che si desidera applicare all'assembly, eseguire le operazioni seguenti:  
  
1.  Creare una matrice di <xref:System.Type> gli oggetti che rappresentano i tipi di parametro del costruttore dell'attributo che si desidera chiamare.  
  
2.  Recuperare un <xref:System.Type> oggetto che rappresenta la classe di attributo che si desidera applicare al nuovo assembly.  
  
3.  Chiamare il <xref:System.Type.GetConstructor%2A> metodo dell'attributo <xref:System.Type> oggetto per recuperare un <xref:System.Reflection.ConstructorInfo> oggetto che rappresenta il costruttore dell'attributo che si desidera chiamare. Passare il <xref:System.Type.GetConstructor%2A> metodo la matrice di <xref:System.Type> gli oggetti che rappresentano i tipi di parametro del costruttore.  
  
4.  Creare un <xref:System.Object> matrice che definisce i parametri da passare al costruttore dell'attributo.  
  
5.  Creare un'istanza di un <xref:System.Reflection.Emit.CustomAttributeBuilder> oggetto passando al costruttore il <xref:System.Reflection.ConstructorInfo> oggetto recuperato nel passaggio 3 e <xref:System.Object> matrice creata nel passaggio 4.  
  
 È quindi possibile passare una matrice di questi <xref:System.Reflection.Emit.CustomAttributeBuilder> oggetti anziché il `attributes` parametro per il <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5B%5D%29?displayProperty=nameWithType> (metodo).  
  
   
  
## Examples  
 Nell'esempio seguente crea un assembly denominato RegexLib. dll e si applica il <xref:System.Reflection.AssemblyTitleAttribute> attributo ad esso. L'assembly include due espressioni regolari compilate. Il primo, `Utilities.RegularExpressions.DuplicatedString`, corrisponde a due parole contigue identiche. Il secondo, `Utilities.RegularExpressions.EmailAddress`, verifica se una stringa ha il formato corretto per essere un indirizzo di posta elettronica.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile3.vb#3)]  
  
 È possibile verificare che il <xref:System.Reflection.AssemblyTitleAttribute> attributi applicati all'assembly esaminando il manifesto con un'utilità di reflection, ad esempio ILDasm.  
  
 L'espressione regolare che controlla una stringa per le parole duplicate viene quindi creata un'istanza e usato nell'esempio seguente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/cs/Compile2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.CompileToAssembly#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.CompileToAssembly/vb/Compile2.vb#2)]  
  
 Compilazione riuscita di questo secondo esempio richiede un riferimento a RegexLib. dll (assembly creato dal primo esempio) da aggiungere al progetto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore della proprietà <see cref="P:System.Reflection.AssemblyName.Name" /> del parametro <paramref name="assemblyname" /> è una stringa vuota o null.  
  
oppure 
Il criterio di ricerca di espressioni regolari di uno o più oggetti in <paramref name="regexinfos" /> contiene una sintassi non valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> o <paramref name="regexinfos" /> è <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET core solo: la creazione di un assembly di espressioni regolari compilate non è supportata.</exception>
        <block subset="none" type="usage">
          <para>Se si sta sviluppando in un sistema dotato [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o relative versioni intermedie installati, sono destinati [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], e userai il <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> metodo per creare un assembly che contiene espressioni regolari compilate. Tentativo di utilizzare una delle espressioni regolari in assembly in un sistema che dispone di [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] genera un'eccezione. Per risolvere il problema, è possibile eseguire una delle operazioni seguenti: 
-Compilazione dell'assembly che contiene le espressioni regolari compilate in un sistema che ha [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] anziché versioni successive installato.  
  
-Invece di chiamare <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> e recuperando l'espressione regolare compilata da un assembly, usare statico o istanza <see cref="T:System.Text.RegularExpressions.Regex" /> metodi con la <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opzione quando crea un'istanza un <see cref="T:System.Text.RegularExpressions.Regex" /> di oggetti o chiamare un'espressione regolare metodo corrispondente al modello.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Compilazione e riutilizzo</related>
      </Docs>
    </Member>
    <Member MemberName="CompileToAssembly">
      <MemberSignature Language="C#" Value="public static void CompileToAssembly (System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, System.Reflection.AssemblyName assemblyname, System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CompileToAssembly(class System.Text.RegularExpressions.RegexCompilationInfo[] regexinfos, class System.Reflection.AssemblyName assemblyname, class System.Reflection.Emit.CustomAttributeBuilder[] attributes, string resourceFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CompileToAssembly(cli::array &lt;System::Text::RegularExpressions::RegexCompilationInfo ^&gt; ^ regexinfos, System::Reflection::AssemblyName ^ assemblyname, cli::array &lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ attributes, System::String ^ resourceFile);" />
      <MemberSignature Language="F#" Value="static member CompileToAssembly : System.Text.RegularExpressions.RegexCompilationInfo[] * System.Reflection.AssemblyName * System.Reflection.Emit.CustomAttributeBuilder[] * string -&gt; unit" Usage="System.Text.RegularExpressions.Regex.CompileToAssembly (regexinfos, assemblyname, attributes, resourceFile)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regexinfos" Type="System.Text.RegularExpressions.RegexCompilationInfo[]" />
        <Parameter Name="assemblyname" Type="System.Reflection.AssemblyName" />
        <Parameter Name="attributes" Type="System.Reflection.Emit.CustomAttributeBuilder[]" />
        <Parameter Name="resourceFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regexinfos">Matrice che descrive le espressioni regolari da compilare.</param>
        <param name="assemblyname">Nome file dell'assembly.</param>
        <param name="attributes">Matrice che definisce gli attributi da applicare all'assembly.</param>
        <param name="resourceFile">Nome del file di risorse Win32 da includere nell'assembly.</param>
        <summary>Compila uno o più oggetti <see cref="T:System.Text.RegularExpressions.Regex" /> specificati e un file di risorse specificato in un assembly denominato con gli attributi specificati.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D%2CSystem.Reflection.AssemblyName% 2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > metodo genera un assembly .NET Framework in cui ogni espressione regolare definiti nella `regexinfos` matrice è rappresentata da una classe. In genere, il [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%28System.Text.RegularExpressions.RegexCompilationInfo%5B%5D% 2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > viene chiamato da un'applicazione separata che genera un assembly delle espressioni regolari compilate. Ogni espressione regolare inclusi nell'assembly presenta le caratteristiche seguenti:  
  
-   Da cui derivano i <xref:System.Text.RegularExpressions.Regex> classe.  
  
-   Viene assegnato il nome completo è definito per il `fullnamespace` e `name` i parametri del relativo valore corrispondente <xref:System.Text.RegularExpressions.RegexCompilationInfo> oggetto.  
  
-   Ha un' predefinita (o senza parametri) costruttore.  
  
 In genere, il codice che crea e Usa l'espressione regolare compilata è disponibile in un assembly o applicazione che è separato dal codice che crea l'assembly.  
  
 Poiché il <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A> metodo genera un assembly .NET Framework da una chiamata al metodo anziché la parola chiave della definizione del linguaggio particolare classe (ad esempio `class` in c# o `Class`...`End Class` in Visual Basic), non consente gli attributi di .NET Framework da assegnare all'assembly usando la sintassi di attributo standard del linguaggio di sviluppo. Il `attributes` parametro fornisce un metodo alternativo per la definizione di attributi da applicare all'assembly. Per ogni attributo che si desidera applicare all'assembly, eseguire le operazioni seguenti:  
  
1.  Creare una matrice di <xref:System.Type> gli oggetti che rappresentano i tipi di parametro del costruttore dell'attributo che si desidera chiamare.  
  
2.  Recuperare un <xref:System.Type> oggetto che rappresenta la classe di attributo che si desidera applicare al nuovo assembly.  
  
3.  Chiamare il <xref:System.Type.GetConstructor%2A> metodo dell'attributo <xref:System.Type> oggetto per recuperare un <xref:System.Reflection.ConstructorInfo> oggetto che rappresenta il costruttore dell'attributo che si desidera chiamare. Passare il <xref:System.Type.GetConstructor%2A> metodo la matrice di <xref:System.Type> gli oggetti che rappresentano i tipi di parametro del costruttore  
  
4.  Creare un <xref:System.Object> matrice che definisce i parametri da passare al costruttore dell'attributo.  
  
5.  Creare un'istanza di un <xref:System.Reflection.Emit.CustomAttributeBuilder> oggetto passando al costruttore il <xref:System.Reflection.ConstructorInfo> oggetto recuperato nel passaggio 3 e <xref:System.Object> matrice creata nel passaggio 4.  
  
 È quindi possibile passare una matrice di questi <xref:System.Reflection.Emit.CustomAttributeBuilder> oggetti anziché il `attributes` parametro per il [\], AssemblyName, CustomAttributeBuilder\<xref:System.Text.RegularExpressions.Regex.CompileToAssembly% 28System.Text.RegularExpressions.RegexCompilationInfo%5b%5D%2CSystem.Reflection.AssemblyName%2CSystem.Reflection.Emit.CustomAttributeBuilder%5b%5D%2CSystem.String%29 > metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Il valore della proprietà <see cref="P:System.Reflection.AssemblyName.Name" /> del parametro <paramref name="assemblyname" /> è una stringa vuota o null.  
  
oppure 
Il criterio di ricerca di espressioni regolari di uno o più oggetti in <paramref name="regexinfos" /> contiene una sintassi non valida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyname" /> o <paramref name="regexinfos" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Il parametro <paramref name="resourceFile" /> definisce un file di risorse Win32 non valido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Impossibile trovare il file designato dal parametro <paramref name="resourceFile" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">.NET core solo: la creazione di un assembly di espressioni regolari compilate non è supportata.</exception>
        <block subset="none" type="usage">
          <para>Se si sta sviluppando in un sistema dotato [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o relative versioni intermedie installati, sono destinati [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], e userai il <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> metodo per creare un assembly che contiene espressioni regolari compilate. Tentativo di utilizzare una delle espressioni regolari in assembly in un sistema che dispone di [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] genera un'eccezione. Per risolvere il problema, è possibile eseguire una delle operazioni seguenti: 
-Compilazione dell'assembly che contiene le espressioni regolari compilate in un sistema che ha [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] anziché versioni successive installato.  
  
-Invece di chiamare <see cref="M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)" /> e recuperando l'espressione regolare compilata da un assembly, usare statico o istanza <see cref="T:System.Text.RegularExpressions.Regex" /> metodi con la <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> opzione quando crea un'istanza un <see cref="T:System.Text.RegularExpressions.Regex" /> di oggetti o chiamare un'espressione regolare metodo corrispondente al modello.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md">Compilazione e riutilizzo</related>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="public static string Escape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Escape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Escape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Escape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Escape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Escape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa di input che contiene il testo da convertire.</param>
        <summary>Converte un set minimo di caratteri (\\, *, +, ?, |, {, [, (,), ^, $,., # e spazio) sostituendoli con i relativi codici di escape. In questo modo il motore delle espressioni regolari interpreta questi caratteri letteralmente anziché come metacaratteri.</summary>
        <returns>Stringa di caratteri con metacaratteri convertiti nel relativo formato di escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.Escape%2A> Converte una stringa in modo che il motore delle espressioni regolari interpreta qualsiasi metacaratteri che può contenere come valori letterali carattere. Ad esempio, si consideri un'espressione regolare che è progettata per estrarre i commenti sono delimitati dalla retta di apertura e chiusura tra parentesi quadre ([e]) dal testo. Nell'esempio seguente, l'espressione regolare "[(.*?)]" viene interpretato come una classe di caratteri. Invece di commenti incorporati nel testo di input di ricerca, l'espressione regolare corrisponde a ogni apertura o la parentesi di chiusura, periodo, asterisco o punto interrogativo.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#1)]  
  
 Tuttavia, se la parentesi di apertura viene sottoposto a escape passandolo al <xref:System.Text.RegularExpressions.Regex.Escape%2A> metodo, l'espressione regolare ha esito positivo nei commenti incorporati nella stringa di input di corrispondenza. Questa condizione è illustrata nell'esempio seguente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape1.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape1.vb#2)]  
  
 In un'espressione regolare definita con testo statico, possono essere applicati anche caratteri che devono essere interpretate letteralmente anziché come metacaratteri precedendole con un simbolo di barra rovesciata (\\), nonché come tramite la chiamata di <xref:System.Text.RegularExpressions.Regex.Escape%2A> (metodo). In un'espressione regolare definita in modo dinamico utilizzando caratteri che non sono noti in fase di progettazione, la chiamata di <xref:System.Text.RegularExpressions.Regex.Escape%2A> metodo è particolarmente importante per garantire che il motore delle espressioni regolari interpreta caratteri singoli come valori letterali piuttosto rispetto a come metacaratteri.  
  
> [!NOTE]
>  Se un criterio di espressione regolare include il simbolo di cancelletto (#) o i caratteri letterali di spazi vuoti, deve essere sottoposto a escape se viene analizzato il testo di input con il <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opzione è abilitata.  
  
 Mentre il <xref:System.Text.RegularExpressions.Regex.Escape%2A> metodo rimuove aprendo tra parentesi quadre ([) e caratteri di parentesi graffe ({), rimuove i corrispondenti caratteri di chiusura (] e}). Nella maggior parte dei casi, escape di tali caratteri non necessari. Se una parentesi quadra o una parentesi graffa non è preceduto da carattere di apertura corrispondente, il motore delle espressioni regolari interpreta letteralmente. Se una parentesi quadra o parentesi graffe viene interpretate come metacaratteri, il motore delle espressioni regolari interpreta corrispondente primo carattere come un metacarattere di chiusura. Se non si tratta del comportamento desiderato, la parentesi quadra o una parentesi graffa deve essere raddoppiata anteponendo in modo esplicito la barra rovesciata (\\) caratteri. Per informazioni generali, vedere la sezione esempio.  
  
   
  
## Examples  
 L'esempio seguente estrae i commenti dal testo. Si presuppone che i commenti sono delimitati da un simbolo di commento begin e un simbolo di commento finale selezionato dall'utente. Poiché i simboli di commento devono essere interpretate letteralmente, vengono passati al <xref:System.Text.RegularExpressions.Regex.Escape%2A> metodo per garantire che essi non possono essere erroneamente interpretati come metacaratteri. Inoltre, l'esempio controlla in modo esplicito se il simbolo di commento di fine immesso dall'utente è una parentesi quadra di chiusura (]) o parentesi graffa (}). Se è, un carattere barra rovesciata (\\) viene anteposta alla parentesi graffa in modo che viene interpretato letteralmente. Si noti che l'esempio Usa anche il <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> raccolta per visualizzare solo il commento, anziché il commento insieme ai relativi simboli di commento di apertura e chiusura.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/cs/Escape3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Escape#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Escape/vb/Escape3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
        <related type="Article" href="https://msdn.microsoft.com/library/f49cc9cc-db7d-4058-8b8a-422bc08b29b0">Caratteri di escape nelle espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="factory">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexRunnerFactory factory;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly class System.Text.RegularExpressions.RegexRunnerFactory factory" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.factory" />
      <MemberSignature Language="VB.NET" Value="Protected Friend factory As RegexRunnerFactory " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexRunnerFactory ^ factory;" />
      <MemberSignature Language="F#" Value="val mutable factory : System.Text.RegularExpressions.RegexRunnerFactory" Usage="System.Text.RegularExpressions.Regex.factory" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexRunnerFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Regex ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Regex ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="regex.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Questo membro esegue l'override di <see cref="M:System.Object.Finalize" />. L'argomento corrispondente può contenere documentazione più completa.

Consente a un oggetto <see cref="T:System.Object" /> di provare a liberare risorse ed eseguire altre operazioni di pulizia prima che l'oggetto <see cref="T:System.Object" /> stesso venga recuperato dalla procedura di Garbage Collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNames">
      <MemberSignature Language="C#" Value="public string[] GetGroupNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetGroupNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetGroupNames();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNames : unit -&gt; string[]" Usage="regex.GetGroupNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di nomi di gruppi di acquisizione per l'espressione regolare.</summary>
        <returns>Matrice di stringhe di nomi di gruppi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La raccolta di nomi di gruppo contiene il set di stringhe utilizzate per nome ai gruppi di acquisizione nell'espressione. Anche se i gruppi di acquisizione non sono denominati in modo esplicito, vengono assegnati automaticamente nomi numerici ("0", "1", "2", "3" e così via). Il valore "0" denominato gruppo rappresenta tutto il testo corrispondono al criterio di espressione regolare. I gruppi numerati precedono i gruppi denominati in modo esplicito nella raccolta e i gruppi denominati vengono visualizzati nell'ordine in cui sono definiti nel modello di espressione regolare.  
  
 È possibile usare il <xref:System.Array.Length%2A> proprietà nella matrice restituita da questo metodo per determinare il numero di gruppi in un'espressione regolare.  
  
   
  
## Examples  
 L'esempio seguente definisce un uso generico `ShowMatches` metodo che visualizza i nomi dei gruppi di espressione regolare e il testo corrispondente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/cs/getgroupnames1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnames/vb/getgroupnames1.vb#1)]  
  
 In questo caso, il criterio di espressione regolare `\b(?<FirstWord>\w+)\s?((\w+)\s)*(?<LastWord>\w+)?(?<Punctuation>\p{Po})` ha lo scopo di analizzare una frase semplice e per identificare la prima parola, ultima parola e il segno di punteggiatura finale. La tabella seguente illustra come viene interpretata la ricerca di espressioni regolari:  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`(?<FirstWord>\w+)`|Trova la corrispondenza di uno o più caratteri alfanumerici. Si tratta di `FirstWord` gruppo denominato.|  
|\s?|Trova la corrispondenza di uno o nessuno spazio vuoto.|  
|(\w+)|Trova la corrispondenza di uno o più caratteri alfanumerici. Equivale al secondo gruppo di acquisizione.|  
|\s|Trova la corrispondenza con uno spazio vuoto.|  
|((\w+)\s)*|Trova la corrispondenza zero o più occorrenze di uno o più caratteri alfanumerici seguiti da uno spazio vuoto. Equivale al primo gruppo di acquisizione.|  
|(? \<LastWord > \w+)?|Trova zero o una occorrenza di uno o più caratteri alfanumerici. Si tratta di `LastWord` gruppo denominato.|  
|(? \<Punteggiatura > \p{Po})|Corrisponde a un carattere la cui categoria Unicode è Punctuation, altri. Si tratta di `Punctuation` gruppo denominato.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Costrutti di raggruppamento nelle espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="GetGroupNumbers">
      <MemberSignature Language="C#" Value="public int[] GetGroupNumbers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] GetGroupNumbers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetGroupNumbers () As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ GetGroupNumbers();" />
      <MemberSignature Language="F#" Value="member this.GetGroupNumbers : unit -&gt; int[]" Usage="regex.GetGroupNumbers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce una matrice di numeri di gruppi di acquisizione che corrispondono ai nomi dei gruppi in una matrice.</summary>
        <returns>Matrice di interi di numeri di gruppi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 I gruppi di acquisizione denominati e non sono accessibili tramite un numero. I gruppi non denominati sono numerati da sinistra a destra iniziando da 1. (Il gruppo di acquisizione in corrispondenza dell'indice 0 (zero) rappresenta la corrispondenza nel suo complesso).  I gruppi denominati quindi sono numerati da sinistra a destra iniziando da un numero maggiore di uno rispetto al numero di non denominati gruppi di acquisizione.  
  
 Che fanno riferimento a un gruppo dal relativo numero anziché in base al nome di stringa, è possibile fornire un accesso più rapido.  
  
   
  
## Examples  
 L'esempio seguente definisce un'espressione regolare, `\b((?<word>\w+)\s*)+(?<end>[.?!])`, che corrisponde a una frase. L'espressione regolare include tre gruppi di acquisizione: un gruppo senza nome per l'acquisizione di una singola parola con un carattere di spazio che può seguirlo; un gruppo denominato `word` che consente di acquisire le singole parole nella frase; e un gruppo denominato `end` che acquisisce il segno di punteggiatura che termina la frase. Nell'esempio viene chiamato il <xref:System.Text.RegularExpressions.Regex.GetGroupNumbers%2A> metodo per ottenere i numeri di acquisizione di tutti i gruppi e quindi Visualizza la stringa acquisita. Inoltre, il <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> metodo viene utilizzato per indicare se un gruppo numerato specifico corrisponde a un gruppo denominato.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/cs/getgroupnumbers1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GetGroupNumbers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.getgroupnumbers/vb/getgroupnumbers1.vb#1)]  
  
 Il criterio di ricerca di espressioni regolari viene interpretato come illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`(?<word>\w+)`|Corrispondenza con uno o più caratteri alfanumerici e assegnare le stringhe corrispondenti a un gruppo denominato `word`.|  
|`\s*`|Trovare la corrispondenza di zero o più spazi vuoti.|  
|`((?<word>\w+)\s*)`|Assegnare il `word` gruppo acquisito seguita da qualsiasi acquisiti caratteri di spazio per il primo gruppo acquisito.|  
|`((?<word>\w+)\s*)+`|Corrisponde al modello di uno o più caratteri alfanumerici seguiti da spazi vuoti una o più volte.|  
|`(?<end>[.?!])`|Trova la corrispondenza di un punto, un punto interrogativo o un punto esclamativo. Assegnare il carattere corrispondente per il `end` gruppo di acquisizione.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Costrutti di raggruppamento nelle espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNameFromNumber">
      <MemberSignature Language="C#" Value="public string GroupNameFromNumber (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GroupNameFromNumber(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNameFromNumber (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GroupNameFromNumber(int i);" />
      <MemberSignature Language="F#" Value="member this.GroupNameFromNumber : int -&gt; string" Usage="regex.GroupNameFromNumber i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Numero di gruppo da convertire nel nome di gruppo corrispondente.</param>
        <summary>Ottiene un nome di gruppo che corrisponde al numero di gruppo specificato.</summary>
        <returns>Stringa contenente il nome di gruppo associato al numero di gruppo specificato. Se nessun nome di gruppo corrisponde a <paramref name="i" />, il metodo restituisce <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un criterio di espressione regolare può contenere sia denominati o numerati i gruppi di acquisizione, che delineano sottoespressioni all'interno di un criterio di ricerca. I gruppi numerati sono delimitati dalla sintassi (*sottoespressione*) e vengono assegnati numeri in base all'ordine nell'espressione regolare. I gruppi denominati sono delimitati dalla sintassi (?`<` *name*`>`*sottoespressione*) o (?' *name*'*subexpression*), dove *nome* è il nome con cui verrà identificata la sottoespressione. Per altre informazioni, vedere [Costrutti di raggruppamento](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md). Il <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> metodo identifica i gruppi denominati e i gruppi numerati mediante le relative posizioni ordinali nell'espressione regolare. Posizione ordinale da zero rappresenta sempre l'intera espressione regolare. Numerato tutti i gruppi vengono conteggiati quindi prima i gruppi denominati, indipendentemente dalla loro posizione effettivo nel criterio di espressione regolare.  
  
 Se `i` è il numero di un gruppo denominato, il metodo restituisce il nome del gruppo. Se `i` è il numero di un gruppo senza nome, il metodo restituisce la rappresentazione di stringa del numero. Ad esempio, se `i` è 1, il metodo restituisce "1". Se `i` non è il numero di un gruppo di acquisizione, il metodo restituisce <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Se un criterio di ricerca viene trovato, il valore restituito da questo metodo è quindi utilizzabile per recuperare il <xref:System.Text.RegularExpressions.Group> oggetto che rappresenta il gruppo acquisito dal <xref:System.Text.RegularExpressions.GroupCollection.Item%2A?displayProperty=nameWithType> proprietà. Il <xref:System.Text.RegularExpressions.GroupCollection> viene restituito dal <xref:System.Text.RegularExpressions.Match.Groups%2A?displayProperty=nameWithType> proprietà.  
  
   
  
## Examples  
 L'esempio seguente definisce un criterio di espressione regolare che corrisponde a una riga dell'indirizzo che contiene un nome di città degli Stati Uniti, il nome di stato e CAP. Nell'esempio viene usato il <xref:System.Text.RegularExpressions.Regex.GroupNameFromNumber%2A> metodo per recuperare i nomi dei gruppi di acquisizione. Questi nomi viene quindi utilizzato per recuperare i gruppi acquisiti corrispondenti per le corrispondenze.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/cs/groupnamefromnumberex.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.GroupNameFromNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.groupnamefromnumber/vb/groupnamefromnumberex.vb#1)]  
  
 Criterio di espressione regolare viene definito dall'espressione seguente:  
  
 `(?<city>[A-Za-z\s]+), (?<state>[A-Za-z]{2}) (?<zip>\d{5}(-\d{4})?)`  
  
 Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`(?<city>[A-Za-z\s]+)`|Corrisponde a uno o più caratteri alfabetici o spazi vuoti. Assegnare il nome di questo gruppo acquisito `city`.|  
|`,`|Trova una virgola (,) seguita da un carattere di spazio vuoto.|  
|`(?<state>[A-Za-z]{2})`|Corrisponde a due caratteri alfabetici. Assegnare il nome di questo gruppo acquisito `state`. Questo gruppo deve essere seguito da un carattere di spazio vuoto.|  
|`(?<zip>\d{5}(-\d{4})?)`|Corrisponde a cinque cifre seguite da zero o una occorrenza di un trattino seguita da quattro cifre. Assegnare il nome di questo gruppo acquisito `zip`.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNumbers" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Costrutti di raggruppamento</related>
      </Docs>
    </Member>
    <Member MemberName="GroupNumberFromName">
      <MemberSignature Language="C#" Value="public int GroupNumberFromName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GroupNumberFromName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GroupNumberFromName (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GroupNumberFromName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GroupNumberFromName : string -&gt; int" Usage="regex.GroupNumberFromName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nome di gruppo da convertire nel numero di gruppo corrispondente.</param>
        <summary>Restituisce il numero di gruppo che corrisponde al nome di gruppo specificato.</summary>
        <returns>Numero di gruppo che corrisponde al nome di gruppo specificato o -1 se <paramref name="name" /> non è un nome di gruppo valido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un criterio di espressione regolare può contenere sia denominati o numerati i gruppi di acquisizione, che delineano sottoespressioni all'interno di un criterio di ricerca. I gruppi numerati sono delimitati dalla sintassi (*sottoespressione*) e vengono assegnati numeri in base all'ordine nell'espressione regolare. I gruppi denominati sono delimitati dalla sintassi (?`<` *name*`>`*sottoespressione*) o (?' *name*'*subexpression*), dove *nome* è il nome con cui verrà identificata la sottoespressione. Per altre informazioni, vedere [Costrutti di raggruppamento](~/docs/standard/base-types/grouping-constructs-in-regular-expressions.md). Il <xref:System.Text.RegularExpressions.Regex.GroupNumberFromName%2A> metodo identifica i gruppi denominati e i gruppi numerati mediante le relative posizioni ordinali nell'espressione regolare. Posizione ordinale da zero rappresenta sempre l'intera espressione regolare. Numerato tutti i gruppi vengono conteggiati quindi prima i gruppi denominati, indipendentemente dalla loro posizione effettivo nel criterio di espressione regolare.  
  
 Se `name` è la rappresentazione di stringa di un numero di gruppo che è presente nel modello di espressione regolare, il metodo restituisce numero in questione. Se `name` corrisponde a un oggetto denominato gruppo che è presente nel modello di espressione regolare di acquisizione, il metodo restituisce il numero corrispondente. Il confronto di `name` gruppo nome fa distinzione maiuscole/minuscole. Se `name` non corrisponde al nome di un gruppo di acquisizione o la rappresentazione di stringa del numero di un gruppo di acquisizione, il metodo restituisce -1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> è <see langword="null" />.</exception>
        <altmember cref="T:System.Text.RegularExpressions.GroupCollection" />
        <altmember cref="M:System.Text.RegularExpressions.Regex.GetGroupNames" />
        <related type="Article" href="https://msdn.microsoft.com/library/0fc18634-f590-4062-8d5c-f0b71abe405b">Costrutti di raggruppamento</related>
      </Docs>
    </Member>
    <Member MemberName="InfiniteMatchTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteMatchTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifica che per un'operazione di criteri di ricerca non è previsto un timeout.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> classe costruttore e un numero di utilizzo di metodi corrispondenti statico di <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> costante per indicare che il tentativo di trovare un criterio di ricerca non deve scadere.  
  
> [!WARNING]
>  Impostare il valore di timeout del motore delle espressioni regolari <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> può causare le espressioni regolari che si basano su un backtracking eccessivo per il blocco durante l'elaborazione di testo che corrisponde quasi al modello di espressione regolare. Se si disabilita i timeout, è necessario assicurarsi che l'espressione regolare non si basa su un backtracking eccessivo e che consente di gestire testo che corrisponde quasi al modello di espressione regolare.  
>   
>  Per altre informazioni sulla gestione di backtracking, vedere [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md).  
  
 Il <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout> costante può essere fornita come valore del `matchTimeout` argomento dei membri seguenti:  
  
-   <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.RegexCompilationInfo.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.String%2CSystem.String%2CSystem.Boolean%2CSystem.TimeSpan%29?displayProperty=nameWithType>  
  
-   <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
-   <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      </Docs>
    </Member>
    <Member MemberName="InitializeReferences">
      <MemberSignature Language="C#" Value="protected void InitializeReferences ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeReferences() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.InitializeReferences" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeReferences ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeReferences();" />
      <MemberSignature Language="F#" Value="member this.InitializeReferences : unit -&gt; unit" Usage="regex.InitializeReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">I riferimenti sono già stati inizializzati.</exception>
      </Docs>
    </Member>
    <Member MemberName="internalMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.TimeSpan internalMatchTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Friend internalMatchTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="protected public: TimeSpan internalMatchTimeout;" />
      <MemberSignature Language="F#" Value="val mutable internalMatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.internalMatchTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OptionalField(VersionAdded=2)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Il tempo massimo che può trascorrere in un'operazione di criteri di ricerca prima del timeout dell'operazione.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsMatch">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se l'espressione regolare individua una corrispondenza nella stringa di input.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string -&gt; bool" Usage="regex.IsMatch input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <summary>Indica se l'espressione regolare specificata nel costruttore <see cref="T:System.Text.RegularExpressions.Regex" /> trova una corrispondenza in una stringa di input specificata.</summary>
        <returns>
          <see langword="true" /> se l'espressione regolare individua una corrispondenza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> metodo viene in genere utilizzato per convalidare una stringa o per garantire che una stringa sia conforme a un modello specifico senza recuperare tale stringa per la manipolazione dei successivi. Se si desidera determinare se una o più stringhe corrispondenti a un criterio di espressione regolare e quindi recupero per la manipolazione dei successivi, chiamata di <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> (metodo).  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di corrispondenza supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> metodo per determinare se una stringa è un numero valido. L'espressione regolare si presuppone che il numero di parte ha un formato specifico che è costituito da tre set di caratteri separati da trattini. Il primo set, che contiene quattro caratteri, deve essere costituito da un carattere alfanumerico seguito da due caratteri numerici seguiti da un carattere alfanumerico. Il secondo set, che è costituito da tre caratteri, deve essere numerico. Il terzo set, che è costituito da quattro caratteri, deve avere tre caratteri numerici seguiti da un carattere alfanumerico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch2.vb#2)]  
  
 Il criterio di ricerca di espressioni regolari è:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`^`|Inizia la corrispondenza all'inizio della riga.|  
|`[a-zA-Z0-9]`|Corrisponde a un singolo carattere alfabetico (`a` attraverso `z` oppure `A` tramite `Z`) o un carattere numerico.|  
|`\d{2}`|Corrisponde a due caratteri numerici.|  
|`[a-zA-Z0-9]`|Corrisponde a un singolo carattere alfabetico (`a` attraverso `z` oppure `A` tramite `Z`) o un carattere numerico.|  
|`-`|Trova la corrispondenza con un segno meno.|  
|`\d{3}`|Corrisponde esattamente tre caratteri numerici.|  
|`(-\d{3}){2}`|Individuare un trattino seguita da tre caratteri numerici le due occorrenze di questo modello.|  
|`[a-zA-Z0-9]`|Corrisponde a un singolo carattere alfabetico (`a` attraverso `z` oppure `A` tramite `Z`) o un carattere numerico.|  
|`$`|Termina la corrispondenza alla fine della riga.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public bool IsMatch (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsMatch(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsMatch (input As String, startat As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsMatch(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.IsMatch : string * int -&gt; bool" Usage="regex.IsMatch (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="startat">Posizione del carattere dalla quale iniziare la ricerca.</param>
        <summary>Indica se l'espressione regolare specificata nel costruttore <see cref="T:System.Text.RegularExpressions.Regex" /> trova una corrispondenza nella stringa di input specificata, a partire dalla posizione iniziale specificata nella stringa.</summary>
        <returns>
          <see langword="true" /> se l'espressione regolare individua una corrispondenza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> metodo viene in genere utilizzato per convalidare una stringa o per garantire che una stringa sia conforme a un modello specifico senza recuperare tale stringa per la manipolazione dei successivi. Se si desidera determinare se una o più stringhe corrispondenti a un criterio di espressione regolare e quindi recupero per la manipolazione dei successivi, chiamata di <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> (metodo).  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di corrispondenza supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> metodo per determinare se una stringa è un numero valido. La ricerca di un numero di parte che segue un carattere due punti (:) in una stringa. Il <xref:System.String.IndexOf%28System.Char%29> metodo viene utilizzato per determinare la posizione del carattere due punti, che viene quindi passato al <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.Int32%29> (metodo). L'espressione regolare si presuppone che il numero di parte ha un formato specifico che è costituito da tre set di caratteri separati da trattini. Il primo set, che contiene quattro caratteri, deve essere costituito da un carattere alfanumerico seguito da due caratteri numerici seguiti da un carattere alfanumerico. Il secondo set, che è costituito da tre caratteri, deve essere numerico. Il terzo set, che è costituito da quattro caratteri, deve avere tre caratteri numerici seguiti da un carattere alfanumerico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch3.vb#3)]  
  
 Il criterio di ricerca di espressioni regolari è:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`[a-zA-Z0-9]`|Corrisponde a un singolo carattere alfabetico (`a` attraverso `z` oppure `A` tramite `Z`) o un carattere numerico.|  
|`\d{2}`|Corrisponde a due caratteri numerici.|  
|`[a-zA-Z0-9]`|Corrisponde a un singolo carattere alfabetico (`a` attraverso `z` oppure `A` tramite `Z`) o un carattere numerico.|  
|`-`|Trova la corrispondenza con un segno meno.|  
|`\d{3}`|Corrisponde esattamente tre caratteri numerici.|  
|`(-\d{3}){2}`|Individuare un trattino seguita da tre caratteri numerici le due occorrenze di questo modello.|  
|`[a-zA-Z0-9]`|Corrisponde a un singolo carattere alfabetico (`a` attraverso `z` oppure `A` tramite `Z`) o un carattere numerico.|  
|`$`|Termina la corrispondenza alla fine della riga.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> è minore di zero o maggiore della lunghezza di <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <summary>Indica se l'espressione regolare specificata trova una corrispondenza nella stringa di input specificata.</summary>
        <returns>
          <see langword="true" /> se l'espressione regolare individua una corrispondenza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> metodo viene in genere utilizzato per convalidare una stringa o per garantire che una stringa sia conforme a un modello specifico senza recuperare tale stringa per la manipolazione dei successivi. Se si desidera determinare se una o più stringhe corrispondenti a un criterio di espressione regolare e quindi recupero per la manipolazione dei successivi, chiamata di <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> (metodo).  
  
 Il metodo statico <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metodo è equivalente alla costruzione di un <xref:System.Text.RegularExpressions.Regex> oggetto con il modello di espressione regolare specificato da `pattern` e chiamando il <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> metodo di istanza. Questo criterio di espressione regolare viene memorizzato nella cache per il recupero rapido dal motore delle espressioni regolari.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di corrispondenza supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metodo per determinare se una stringa è un numero valido. L'espressione regolare si presuppone che il numero di parte ha un formato specifico che è costituito da tre set di caratteri separati da trattini. Il primo set, che contiene quattro caratteri, deve essere costituito da un carattere alfanumerico seguito da due caratteri numerici seguiti da un carattere alfanumerico. Il secondo set, che è costituito da tre caratteri, deve essere numerico. Il terzo set, che è costituito da quattro caratteri, deve avere tre caratteri numerici seguiti da un carattere alfanumerico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch1.vb#1)]  
  
 Il criterio di ricerca di espressioni regolari è:  
  
```  
^[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]$  
```  
  
 Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`^`|Inizia la corrispondenza all'inizio della riga.|  
|`[a-zA-Z0-9]`|Corrisponde a un singolo carattere alfabetico (`a` attraverso `z` oppure `A` tramite `Z`) o un carattere numerico.|  
|`\d{2}`|Corrisponde a due caratteri numerici.|  
|`[a-zA-Z0-9]`|Corrisponde a un singolo carattere alfabetico (`a` attraverso `z` oppure `A` tramite `Z`) o un carattere numerico.|  
|`-`|Trova la corrispondenza con un segno meno.|  
|`\d{3}`|Corrisponde esattamente tre caratteri numerici.|  
|`(-\d{3}){2}`|Individuare un trattino seguita da tre caratteri numerici le due occorrenze di questo modello.|  
|`[a-zA-Z0-9]`|Corrisponde a un singolo carattere alfabetico (`a` attraverso `z` oppure `A` tramite `Z`) o un carattere numerico.|  
|`$`|Termina la corrispondenza alla fine della riga.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato il metodo. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per la verifica per determinare se un criterio di ricerca è <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <summary>Indica se l'espressione regolare specificata trova una corrispondenza nella stringa di input specificata usando le opzioni di corrispondenza specificate.</summary>
        <returns>
          <see langword="true" /> se l'espressione regolare individua una corrispondenza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> metodo viene in genere utilizzato per convalidare una stringa o per garantire che una stringa sia conforme a un modello specifico senza recuperare tale stringa per la manipolazione dei successivi. Se si desidera determinare se una o più stringhe corrispondenti a un criterio di espressione regolare e quindi recupero per la manipolazione dei successivi, chiamata di <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> (metodo).  
  
 Il metodo statico <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo è equivalente alla costruzione di un <xref:System.Text.RegularExpressions.Regex> oggetto con il modello di espressione regolare specificato da `pattern` e le opzioni di espressione regolare specificate da `options` e chiamando il <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> istanza metodo. Questo criterio di espressione regolare viene memorizzato nella cache per il recupero rapido dal motore delle espressioni regolari.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di corrispondenza supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> metodo per determinare se una stringa è un numero valido. L'espressione regolare si presuppone che il numero di parte ha un formato specifico che è costituito da tre set di caratteri separati da trattini. Il primo set, che contiene quattro caratteri, deve essere costituito da un carattere alfanumerico seguito da due caratteri numerici seguiti da un carattere alfanumerico. Il secondo set, che è costituito da tre caratteri, deve essere numerico. Il terzo set, che è costituito da quattro caratteri, deve avere tre caratteri numerici seguiti da un carattere alfanumerico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch4.vb#4)]  
  
 Il criterio di ricerca di espressioni regolari è:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`^`|Inizia la ricerca della corrispondenza all'inizio della stringa.|  
|`[A-Z0-9]`|Qualsiasi carattere alfabetico da corrispondere `A` tramite `Z`, oppure di qualsiasi carattere numerico.|  
|`\d{2}`|Corrisponde a due caratteri numerici.|  
|`[A-Z0-9]`|Qualsiasi carattere alfabetico da corrispondere `A` tramite `Z`, oppure di qualsiasi carattere numerico.|  
|`-`|Trova la corrispondenza con un segno meno.|  
|`\d{3}`|Corrisponde esattamente tre caratteri numerici.|  
|`(-\d{3}){2}`|Individuare un trattino seguito da tre caratteri numerici le due occorrenze di questo modello..|  
|`[A-Z0-9]`|Qualsiasi carattere alfabetico da corrispondere `A` tramite `Z`, oppure di qualsiasi carattere numerico.|  
|`$`|Terminare la corrispondenza alla fine della stringa.|  
  
 Chiama il <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo con il `options` parametro impostato su <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> è equivalente alla definizione di espressione regolare seguente:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Per il confronto, vedere l'esempio per il <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è un valore valido di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per la verifica per determinare se un criterio di ricerca è <see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="IsMatch">
      <MemberSignature Language="C#" Value="public static bool IsMatch (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMatch(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMatch (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMatch(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member IsMatch : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; bool" Usage="System.Text.RegularExpressions.Regex.IsMatch (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <param name="matchTimeout">Intervallo di timeout o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> per indicare che per il metodo non è previsto un timeout.</param>
        <summary>Indica se l'espressione regolare specificata trova una corrispondenza nella stringa di input specificata usando le opzioni di corrispondenza specificate e l'intervallo di timeout.</summary>
        <returns>
          <see langword="true" /> se l'espressione regolare individua una corrispondenza; in caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.IsMatch%2A> metodo viene in genere utilizzato per convalidare una stringa o per garantire che una stringa sia conforme a un modello specifico senza recuperare tale stringa per la manipolazione dei successivi. Se si desidera determinare se una o più stringhe corrispondenti a un criterio di espressione regolare e quindi recupero per la manipolazione dei successivi, chiamata di <xref:System.Text.RegularExpressions.Regex.Match%2A> o <xref:System.Text.RegularExpressions.Regex.Matches%2A> (metodo).  
  
 Il metodo statico <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodo è equivalente alla costruzione di un <xref:System.Text.RegularExpressions.Regex> oggetto con il modello di espressione regolare specificato da `pattern` e le opzioni di espressione regolare specificate da `options` e chiamando il <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%29> istanza metodo. Questo criterio di espressione regolare viene memorizzato nella cache per il recupero rapido dal motore delle espressioni regolari.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il `matchTimeout` parametro specifica il modo in cui lungo un modello corrispondente metodo deve effettuare per trovare una corrispondenza prima del timeout. L'impostazione di un intervallo di timeout impedisce le espressioni regolari che si basano su un backtracking eccessivo che venga visualizzato il blocco quando elaborano un input che contiene corrispondenze. Per altre informazioni, vedere [procedure consigliate per le espressioni regolari](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se viene trovata alcuna corrispondenza in tale intervallo di tempo, il metodo genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. `matchTimeout` esegue l'override di qualsiasi valore di timeout predefinito definito per il dominio applicazione in cui viene eseguito il metodo.  
  
   
  
## Examples  
 Nell'esempio seguente viene illustrato l'utilizzo del <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodo per determinare se una stringa è un numero valido. L'espressione regolare si presuppone che il numero di parte ha un formato specifico che è costituito da tre set di caratteri separati da trattini. Il primo set, che contiene quattro caratteri, deve essere costituito da un carattere alfanumerico seguito da due caratteri numerici seguiti da un carattere alfanumerico. Il secondo set, che è costituito da tre caratteri, deve essere numerico. Il terzo set, che è costituito da quattro caratteri, deve avere tre caratteri numerici seguiti da un carattere alfanumerico. Corrispondenti al criterio di espressione regolare deve comportare la ricerca minimo tramite la stringa di input, in modo che il metodo imposta un intervallo di timeout di 500 millisecondi.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/cs/ismatch5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.IsMatch#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ismatch/vb/ismatch5.vb#5)]  
  
 Il criterio di ricerca di espressioni regolari è:  
  
```  
^[A-Z0-9]\d{2}[A-Z0-9](-\d{3}){2}[A-Z0-9]$  
```  
  
 Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`^`|Inizia la ricerca della corrispondenza all'inizio della stringa.|  
|`[A-Z0-9]`|Qualsiasi carattere alfabetico da corrispondere `A` tramite `Z`, oppure di qualsiasi carattere numerico.|  
|`\d{2}`|Corrisponde a due caratteri numerici.|  
|`[A-Z0-9]`|Qualsiasi carattere alfabetico da corrispondere `A` tramite `Z`, oppure di qualsiasi carattere numerico.|  
|`-`|Trova la corrispondenza con un segno meno.|  
|`\d{3}`|Corrisponde esattamente tre caratteri numerici.|  
|`(-\d{3}){2}`|Individuare un trattino seguita da tre caratteri numerici le due occorrenze di questo modello.|  
|`[A-Z0-9]`|Qualsiasi carattere alfabetico da corrispondere `A` tramite `Z`, oppure di qualsiasi carattere numerico.|  
|`$`|Terminare la corrispondenza alla fine della stringa.|  
  
 Chiama il <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodo con il `options` parametro impostato su <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> è equivalente alla definizione di espressione regolare seguente:  
  
```  
[a-zA-Z0-9]\d{2}[a-zA-Z0-9](-\d{3}){2}[A-Za-z0-9]  
```  
  
 Per il confronto, vedere l'esempio per il <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%29> (metodo).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è un valore valido di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
oppure 
 <paramref name="matchTimeout" /> è negativo, zero o maggiore di circa 24 giorni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout.</exception>
        <block subset="none" type="usage">
          <para>È consigliabile impostare il <paramref name="matchTimeout" /> parametro su un valore appropriato, ad esempio due secondi. Se si disabilita i timeout specificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, il motore delle espressioni regolari offre prestazioni leggermente migliori. Tuttavia, è necessario disabilitare i timeout solo nelle condizioni seguenti: 
-Quando l'input elaborata da un'espressione regolare è derivato da un'origine conosciuta e attendibile o è costituito da testo statico. Esclude il testo che è stato in modo dinamico inseriti dagli utenti.  
  
-Quando il criterio di espressione regolare è stata accuratamente testato per verificare che gestisca in modo efficiente trova, mancate corrispondenze e a breve.  
  
-Quando il criterio di espressione regolare non contiene alcun elemento di linguaggio che potrebbero causare un backtracking eccessivo durante l'elaborazione di una corrispondenza più vicino.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Match">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cerca in una stringa di input una sottostringa che corrisponda al criterio di espressione regolare e restituisce la prima ricorrenza come singolo oggetto <see cref="T:System.Text.RegularExpressions.Match" />.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Match : string -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <summary>Cerca nella stringa di input specificata la prima ricorrenza dell'espressione regolare specificata nel costruttore <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Oggetto contenente informazioni sulla corrispondenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metodo restituisce la prima sottostringa corrispondente a un criterio di espressione regolare in una stringa di input. Per informazioni sugli elementi del linguaggio usati per compilare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 È possibile determinare se il criterio di espressione regolare è stato trovato nella stringa di input controllando il valore dell'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Group.Success%2A> proprietà. Se viene trovata una corrispondenza, l'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Capture.Value%2A> proprietà contiene la sottostringa da `input` che corrisponde al criterio di espressione regolare. Se viene trovata alcuna corrispondenza, il relativo valore è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Questo metodo restituisce la prima sottostringa nella `input` che corrisponde al criterio di espressione regolare. È possibile recuperare le corrispondenze successive chiamando restituito ripetutamente <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (metodo). È anche possibile recuperare tutte le corrispondenze in una singola chiamata al metodo chiamando il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> (metodo).  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di corrispondenza supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
   
  
## Examples  
 Nell'esempio seguente consente di trovare modello di espressione regolare corrisponde a una stringa, viene fornito l'elenco corrispondente gruppi, le acquisizioni e le posizioni di acquisizione.  
  
 [!code-cpp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/cpp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cpp/snippet8.cpp#8)]
 [!code-csharp[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/csharp/VS_Snippets_CLR/regex match, nextmatch, groups, captures/cs/snippet8.cs#8)]
 [!code-vb[Regex Match, NextMatch, Groups, Captures#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/regex match, nextmatch, groups, captures/vb/snippet8.vb#8)]  
  
 Criterio di espressione regolare `(\w+)\s+(car)` le occorrenze della parola "car" contenente la parola che la precede. Viene interpretato come illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`(\w+)`|Trova la corrispondenza di uno o più caratteri alfanumerici. Equivale al primo gruppo di acquisizione.|  
|`\s+`|Corrisponde a uno o più caratteri spazio vuoto.|  
|(Auto)|Corrisponde alla stringa letterale "automobile". Equivale al secondo gruppo di acquisizione.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, startat As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="startat">Posizione del carattere in base zero dalla quale iniziare la ricerca.</param>
        <summary>Cerca nella stringa di input la prima occorrenza di un'espressione regolare, a partire dalla posizione iniziale specificata nella stringa.</summary>
        <returns>Oggetto contenente informazioni sulla corrispondenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> metodo restituisce la prima sottostringa corrispondente a un criterio di espressione regolare, partire o dopo il `startat` posizione del carattere, in una stringa di input. Per informazioni sugli elementi del linguaggio usati per compilare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Criterio di espressione regolare per cui il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> ricerche metodo è definito dalla chiamata a uno del <xref:System.Text.RegularExpressions.Regex> costruttori della classe. Per altre informazioni sugli elementi che possono formare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 È facoltativamente possibile specificare una posizione iniziale nella stringa usando il `startat` parametro. Quando il motore delle espressioni regolari analizza da sinistra a destra (predefinito), la corrispondenza e l'analisi di spostamento verso destra, iniziando in corrispondenza del carattere specificato in `startat`. Quando il motore delle espressioni regolari analizza da destra a sinistra (quando il criterio di espressione regolare viene costruito con la <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opzione), la corrispondenza e l'analisi sposta nella direzione opposta e iniziare con il carattere alla `startat` -1. Se non si specifica una posizione iniziale, la ricerca inizia in corrispondenza il valore predefinito `startat` posizione. Se l'espressione regolare effettua la ricerca da sinistra a destra, il valore predefinito `startat` si trova in fondo a sinistra `input`; se esegue la ricerca da destra a sinistra, il valore predefinito `startat` si trova all'estremità destra della `input`.  
  
 Se si desidera limitare una corrispondenza in modo che inizi da una posizione particolare carattere nella stringa e il motore delle espressioni regolari non esegue la scansione il resto della stringa per trovare una corrispondenza, agganciare l'espressione regolare con una `\G` (a sinistra per un da sinistra a destra modello o a destra per un modello di right-to-left). Questo limita la corrispondenza in modo che abbia inizio esattamente da `startat`.  
  
 È possibile determinare se il criterio di espressione regolare è stato trovato nella stringa di input controllando il valore dell'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Group.Success%2A> proprietà. Se viene trovata una corrispondenza, l'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Capture.Value%2A> proprietà contiene la sottostringa da `input` che corrisponde al criterio di espressione regolare. Se viene trovata alcuna corrispondenza, il relativo valore è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Questo metodo restituisce la prima sottostringa trovata o dopo il `startat` posizione del carattere in `input` che corrisponde al criterio di espressione regolare. È possibile recuperare le corrispondenze successive chiamando restituito ripetutamente <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (metodo). È anche possibile recuperare tutte le corrispondenze in una singola chiamata al metodo chiamando il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> (metodo).  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di corrispondenza supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se supera la l'operazione qualsiasi valore di timeout stabilita per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> è minore di zero o maggiore della lunghezza di <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Match : string * string -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <summary>Cerca nella stringa di input specificata la prima occorrenza dell'espressione regolare specificata.</summary>
        <returns>Oggetto contenente informazioni sulla corrispondenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> metodo restituisce la prima sottostringa corrispondente a un criterio di espressione regolare in una stringa di input. Per informazioni sugli elementi del linguaggio usati per compilare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il metodo statico <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> metodo è equivalente alla costruzione di un <xref:System.Text.RegularExpressions.Regex> con il modello di espressione regolare specificata dell'oggetto e chiamare l'istanza <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> (metodo). In questo caso, il motore delle espressioni regolari memorizza nella cache il criterio di espressione regolare.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 È possibile determinare se il criterio di espressione regolare è stato trovato nella stringa di input controllando il valore dell'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Group.Success%2A> proprietà. Se viene trovata una corrispondenza, l'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Capture.Value%2A> proprietà contiene la sottostringa da `input` che corrisponde al criterio di espressione regolare. Se viene trovata alcuna corrispondenza, il relativo valore è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Questo metodo restituisce la prima sottostringa nella `input` che corrisponde al criterio di espressione regolare. È possibile recuperare le corrispondenze successive chiamando restituito ripetutamente <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (metodo). È anche possibile recuperare tutte le corrispondenze in una singola chiamata al metodo chiamando il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> (metodo).  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di corrispondenza supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> metodo per trovare la prima parola che contiene almeno uno `z` carattere e quindi chiama il <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> metodo per trovare altre corrispondenze.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match1.vb#1)]  
  
 Il criterio di ricerca di espressioni regolari `\b\w*z+\w*\b` è interpretato nel modo illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`\w*`|Corrisponde a zero, uno o più caratteri alfanumerici.|  
|`z+`|Trova la corrispondenza una o più occorrenze del `z` carattere.|  
|`\w*`|Corrisponde a zero, uno o più caratteri alfanumerici.|  
|`\b`|Termina la corrispondenza sul confine di parola.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per il recupero di un criterio di ricerca è <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.Match Match (string input, int beginning, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.Match Match(string input, int32 beginning, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Match (input As String, beginning As Integer, length As Integer) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::Match ^ Match(System::String ^ input, int beginning, int length);" />
      <MemberSignature Language="F#" Value="member this.Match : string * int * int -&gt; System.Text.RegularExpressions.Match" Usage="regex.Match (input, beginning, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="beginning" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="beginning">Posizione del carattere in base zero nella stringa di input che definisce la posizione più a sinistra in cui cercare.</param>
        <param name="length">Numero di caratteri nella sottostringa da includere nella ricerca.</param>
        <summary>Cerca nella stringa di input la prima occorrenza di un'espressione regolare, a partire dalla posizione iniziale specificata e cercando solo nel numero di caratteri specificato.</summary>
        <returns>Oggetto contenente informazioni sulla corrispondenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> metodo restituisce la prima sottostringa corrispondente a un criterio di espressione regolare in una parte di una stringa di input. Per informazioni sugli elementi del linguaggio usati per compilare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Criterio di espressione regolare per cui il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> ricerche metodo è definito dalla chiamata a uno del <xref:System.Text.RegularExpressions.Regex> costruttori della classe. Per altre informazioni sugli elementi che possono formare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%2CSystem.Int32%29> Cerca la parte del `input` definiti dal `beginning` e `length` parametri per il criterio di espressione regolare. `beginning` sempre definisce l'indice del carattere più a sinistra da includere nella ricerca, e `length` definisce il numero massimo di caratteri da cercare. Insieme, definiscono l'intervallo della ricerca. Se la ricerca procede da sinistra a destra (predefinito), il motore delle espressioni regolari Cerca dal carattere in corrispondenza dell'indice `beginning` per il carattere in corrispondenza dell'indice `beginning`  +  `length` – 1. Se il motore delle espressioni regolari è stata creata un'istanza usando il <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> opzione in modo che la ricerca procede da destra a sinistra, le ricerche di motore di espressioni regolari tra il carattere in corrispondenza dell'indice `beginning`  +  `length` – 1 per il carattere in corrispondenza dell'indice `beginning`. Questo metodo restituisce la prima corrispondenza trovata all'interno di questo intervallo. È possibile recuperare le corrispondenze successive chiamando restituito ripetutamente <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> (metodo).  
  
 È possibile determinare se il criterio di espressione regolare è stato trovato nella stringa di input controllando il valore dell'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Group.Success%2A> proprietà. Se viene trovata una corrispondenza, l'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Capture.Value%2A> proprietà contiene la sottostringa da `input` che corrisponde al criterio di espressione regolare. Se viene trovata alcuna corrispondenza, il relativo valore è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di corrispondenza supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un valore di timeout quando si chiama il costruttore, l'eccezione viene generata un'eccezione se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="beginning" /> è minore di zero o maggiore della lunghezza di <paramref name="input" />.  
  
oppure 
 <paramref name="length" /> è minore di zero o maggiore della lunghezza di <paramref name="input" />.  
  
oppure 
 <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="–1" /> identifica una posizione esterna all'intervallo di <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <summary>Cerca nella stringa di input la prima occorrenza dell'espressione regolare specificata usando le opzioni di corrispondenza specificate.</summary>
        <returns>Oggetto contenente informazioni sulla corrispondenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo restituisce la prima sottostringa corrispondente a un criterio di espressione regolare in una stringa di input. Per informazioni sugli elementi del linguaggio usati per compilare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il metodo statico <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo è equivalente alla costruzione di un <xref:System.Text.RegularExpressions.Regex> dell'oggetto con il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> costruttore e chiamare l'istanza <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> (metodo).  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 È possibile determinare se il criterio di espressione regolare è stato trovato nella stringa di input controllando il valore dell'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Group.Success%2A> proprietà. Se viene trovata una corrispondenza, l'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Capture.Value%2A> proprietà contiene la sottostringa da `input` che corrisponde al criterio di espressione regolare. Se viene trovata alcuna corrispondenza, il relativo valore è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Questo metodo restituisce la prima sottostringa trovata `input` che corrisponde al criterio di espressione regolare. È possibile recuperare le corrispondenze successive chiamando restituito ripetutamente <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> (metodo). È anche possibile recuperare tutte le corrispondenze in una singola chiamata al metodo chiamando il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> (metodo).  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di corrispondenza supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
   
  
## Examples  
 L'esempio seguente definisce un'espressione regolare che corrisponde a parole che iniziano con la lettera "a". Usa il <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> opzione per assicurarsi che l'espressione regolare individua parole che iniziano con entrambi maiuscolo minuscolo di "a" e a "a".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/cs/match2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Match#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.match/vb/match2.vb#2)]  
  
 Il criterio di ricerca di espressioni regolari `\ba\w*\b` è interpretato nel modo illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`a`|Corrispondenza con il carattere "a".|  
|`\w*`|Corrisponde a zero, uno o più caratteri alfanumerici.|  
|`\b`|Termina la corrispondenza sul confine di parola.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per il recupero di un criterio di ricerca è <see cref="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <altmember cref="M:System.Text.RegularExpressions.Match.NextMatch" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.Match Match (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.Match Match(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Match (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As Match" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::Match ^ Match(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Match : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.Match" Usage="System.Text.RegularExpressions.Regex.Match (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.Match</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <param name="matchTimeout">Intervallo di timeout o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> per indicare che per il metodo non è previsto un timeout.</param>
        <summary>Cerca nella stringa di input la prima occorrenza dell'espressione regolare specificata usando le opzioni di corrispondenza e l'intervallo di timeout specificati.</summary>
        <returns>Oggetto contenente informazioni sulla corrispondenza.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodo restituisce la prima sottostringa corrispondente a un criterio di espressione regolare in una stringa di input. Per informazioni sugli elementi del linguaggio usati per compilare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il metodo statico <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodo è equivalente alla costruzione di un <xref:System.Text.RegularExpressions.Regex> dell'oggetto con il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> costruttore e chiamare l'istanza <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> (metodo).  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 È possibile determinare se il criterio di espressione regolare è stato trovato nella stringa di input controllando il valore dell'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Group.Success%2A> proprietà. Se viene trovata una corrispondenza, l'oggetto restituito <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Capture.Value%2A> proprietà contiene la sottostringa da `input` che corrisponde al criterio di espressione regolare. Se viene trovata alcuna corrispondenza, il relativo valore è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 Questo metodo restituisce la prima sottostringa trovata `input` che corrisponde al criterio di espressione regolare. È possibile recuperare le corrispondenze successive chiamando restituito ripetutamente <xref:System.Text.RegularExpressions.Match> dell'oggetto <xref:System.Text.RegularExpressions.Match.NextMatch%2A> (metodo). È anche possibile recuperare tutte le corrispondenze in una singola chiamata al metodo chiamando il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> (metodo).  
  
 Il `matchTimeout` parametro specifica il modo in cui lungo un modello corrispondente metodo deve effettuare per trovare una corrispondenza prima del timeout. L'impostazione di un intervallo di timeout impedisce le espressioni regolari che si basano su un backtracking eccessivo che venga visualizzato il blocco quando elaborano un input che contiene corrispondenze. Per altre informazioni, vedere [procedure consigliate per le espressioni regolari](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se viene trovata alcuna corrispondenza in tale intervallo di tempo, il metodo genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. `matchTimeout` esegue l'override di qualsiasi valore di timeout predefinito definito per il dominio applicazione in cui viene eseguito il metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
oppure 
 <paramref name="matchTimeout" /> è negativo, zero o maggiore di circa 24 giorni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>È consigliabile impostare il <paramref name="matchTimeout" /> parametro su un valore appropriato, ad esempio due secondi. Se si disabilita i timeout specificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, il motore delle espressioni regolari offre prestazioni leggermente migliori. Tuttavia, è necessario disabilitare i timeout solo nelle condizioni seguenti: 
-Quando l'input elaborata da un'espressione regolare è derivato da un'origine conosciuta e attendibile o è costituito da testo statico. Esclude il testo che è stato in modo dinamico inseriti dagli utenti.  
  
-Quando il criterio di espressione regolare è stata accuratamente testato per verificare che gestisca in modo efficiente trova, mancate corrispondenze e a breve.  
  
-Quando il criterio di espressione regolare non contiene alcun elemento di linguaggio che potrebbero causare un backtracking eccessivo durante l'elaborazione di una corrispondenza più vicino.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Matches">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cerca in una stringa di input tutte le occorrenze di un'espressione regolare e restituisce tutte le corrispondenze.</summary>
        <block subset="none" type="usage">
          <para>Quando viene ripetuto un tentativo di corrispondenza chiamando il <see cref="Overload:System.Text.RegularExpressions.Regex.Matches" /> metodo, il motore delle espressioni regolari corrispondenze vuote un trattamento speciale. In genere, il motore delle espressioni regolari inizia la ricerca della corrispondenza successiva esattamente dove la corrispondenza precedente è stata interrotta. Tuttavia, dopo una corrispondenza vuota, il motore delle espressioni regolari avanza di un carattere prima di tentare la corrispondenza successiva. Questo comportamento garantisce che il motore delle espressioni regolari procedura sarà formata da stringa. In caso contrario, poiché una corrispondenza vuota non comporta uno spostamento in avanti, la corrispondenza successiva inizierebbe nella stessa posizione come la corrispondenza precedente e corrisponderebbe ripetutamente la stessa stringa vuota.  
  
Nell'esempio seguente, il criterio di espressione regolare <c>un *</c> cerca zero o più occorrenze della lettera "a" nella stringa "abaabb". Come l'output illustrato nell'esempio, l'oggetto risultante <see cref="T:System.Text.RegularExpressions.MatchCollection" /> oggetto contiene sei <see cref="T:System.Text.RegularExpressions.Match" /> oggetti. Il primo tentativo di ricerca trova il primo "a". La seconda corrispondenza inizia in cui il primo corrispondono esattamente le estremità, prima della prima b. trovata alcuna occorrenza di "a" e restituisce una stringa vuota. La terza corrispondenza non avvia esattamente dove la seconda corrispondenza è terminata, perché la seconda ha restituito una stringa vuota. Inizia invece di un carattere in un secondo momento, dopo il primo "b". La terza corrispondenza trova le due occorrenze di "a" e restituisce "aa". Il quarto tentativo di ricerca inizia in cui è terminata la corrispondenza terzo, prima della seconda "b" e restituisce una stringa vuota. Il quinto tentativo di corrispondenza sposta nuovamente un carattere che inizia prima il terzo "b" e restituisce una stringa vuota. La corrispondenza sesta inizia dopo l'ultima "b" e restituisce una stringa vuota anche in questo caso.  
  
[! codice-csharp[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/emptymatches1.cs#9)] [! codice vb[System.Text.RegularExpressions.Regex.Matches#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/emptymatches1.vb#9)]</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Matches : string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <summary>Cerca nella stringa di input specificata tutte le occorrenze di un'espressione regolare.</summary>
        <returns>Raccolta di oggetti <see cref="T:System.Text.RegularExpressions.Match" /> trovati dalla ricerca. Se non vengono trovate corrispondenze, il metodo restituisce un oggetto raccolta vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metodo è simile al <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> trovato un metodo, ad eccezione del fatto che restituisce informazioni su tutte le corrispondenze nella stringa di input, anziché una singola corrispondenza. È equivalente al codice seguente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#5)]  
  
 La raccolta include solo le corrispondenze e termina in corrispondenza non prima.  
  
 Criterio di espressione regolare per cui il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> ricerche metodo è definito dalla chiamata a uno del <xref:System.Text.RegularExpressions.Regex> costruttori della classe. Per altre informazioni sugli elementi che possono formare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%2A> metodo viene utilizzato evaluation lazy per popolare l'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> oggetto. L'accesso ai membri di questa raccolta, ad esempio <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> fa sì che la raccolta in cui inserire immediatamente. Per sfruttare i vantaggi della valutazione lenta, è necessario l'iterazione della raccolta utilizzando un costrutto quale `foreach` in c# e `For Each`...`Next` in Visual Basic.  
  
 A causa la valutazione lazy, chiama il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metodo non genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. Tuttavia, l'eccezione viene generata quando viene eseguita un'operazione sul <xref:System.Text.RegularExpressions.MatchCollection> oggetto restituito da questo metodo, se il <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> proprietà non <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> e un'operazione di corrispondenza supera l'intervallo di timeout.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29> metodo per identificare le eventuali parole di una frase che terminano in "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches1.vb#1)]  
  
 Il criterio di ricerca di espressioni regolari `\b\w+es\b` è definito nel modo illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`\w+`|Trova la corrispondenza di uno o più caratteri alfanumerici.|  
|`es`|Corrisponde alla stringa letterale "es".|  
|`\b`|Termina la corrispondenza sul confine di parola.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.MatchCollection Matches (string input, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.RegularExpressions.MatchCollection Matches(string input, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Matches (input As String, startat As Integer) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, int startat);" />
      <MemberSignature Language="F#" Value="member this.Matches : string * int -&gt; System.Text.RegularExpressions.MatchCollection" Usage="regex.Matches (input, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="startat">Posizione del carattere nella stringa di input dalla quale iniziare la ricerca.</param>
        <summary>Cerca nella stringa di input specificata tutte le occorrenze di un'espressione regolare, partendo dalla posizione iniziale specificata nella stringa.</summary>
        <returns>Raccolta di oggetti <see cref="T:System.Text.RegularExpressions.Match" /> trovati dalla ricerca. Se non vengono trovate corrispondenze, il metodo restituisce un oggetto raccolta vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> metodo è simile al <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29> trovato un metodo, ad eccezione del fatto che restituisce informazioni su tutte le corrispondenze nella stringa di input, anziché una singola corrispondenza. È equivalente al codice seguente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#6)]  
  
 Criterio di espressione regolare per cui il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> ricerche metodo è definito dalla chiamata a uno del <xref:System.Text.RegularExpressions.Regex> costruttori della classe. Per altre informazioni sugli elementi che possono formare un modello di espressione regolare, vedere [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%2A> metodo viene utilizzato evaluation lazy per popolare l'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> oggetto. L'accesso ai membri di questa raccolta, ad esempio <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> fa sì che la raccolta in cui inserire immediatamente. Per sfruttare i vantaggi della valutazione lenta, è necessario l'iterazione della raccolta utilizzando un costrutto quale `foreach` in c# e `For Each`...`Next` in Visual Basic.  
  
 A causa la valutazione lazy, chiama il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> metodo non genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. Tuttavia, l'eccezione viene generata quando viene eseguita un'operazione sul <xref:System.Text.RegularExpressions.MatchCollection> oggetto restituito da questo metodo, se il <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> proprietà non è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> e un'operazione di corrispondenza supera l'intervallo di timeout..  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metodo per trovare la prima parola di una frase che termina con "es" e quindi chiama il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29> metodo per identificare le eventuali parole aggiuntive che terminano in "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches3.vb#3)]  
  
 Il criterio di ricerca di espressioni regolari `\b\w+es\b` è definito nel modo illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`\w+`|Trova la corrispondenza di uno o più caratteri alfanumerici.|  
|`es`|Corrisponde alla stringa letterale "es".|  
|`\b`|Termina la corrispondenza sul confine di parola.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> è minore di zero o maggiore della lunghezza di <paramref name="input" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <summary>Cerca nella stringa di input specificata tutte le occorrenze di un'espressione regolare specificata.</summary>
        <returns>Raccolta di oggetti <see cref="T:System.Text.RegularExpressions.Match" /> trovati dalla ricerca. Se non vengono trovate corrispondenze, il metodo restituisce un oggetto raccolta vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metodo è simile al <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%29> trovato un metodo, ad eccezione del fatto che restituisce informazioni su tutte le corrispondenze nella stringa di input, anziché una singola corrispondenza. È equivalente al codice seguente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#7)]  
  
 Il metodo statico `Matches` metodi sono equivalenti alla costruzione di un <xref:System.Text.RegularExpressions.Regex> con il modello di espressione regolare specificata dell'oggetto e chiamare il metodo di istanza `Matches`.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%2A> metodo viene utilizzato evaluation lazy per popolare l'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> oggetto. L'accesso ai membri di questa raccolta, ad esempio <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> fa sì che la raccolta in cui inserire immediatamente. Per sfruttare i vantaggi della valutazione lenta, è necessario l'iterazione della raccolta utilizzando un costrutto quale `foreach` in c# e `For Each`...`Next` in Visual Basic.  
  
 A causa la valutazione lazy, chiama il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metodo non genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. Tuttavia, l'eccezione viene generata quando viene eseguita un'operazione sul <xref:System.Text.RegularExpressions.MatchCollection> oggetto restituito da questo metodo, se un intervallo di timeout è definito dalla proprietà "REGEX_DEFAULT_MATCH_TIMEOUT" di un'operazione di corrispondenza e il dominio applicazione corrente supera questo intervallo di timeout.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metodo per identificare qualsiasi parola di una frase che termina con "es".  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches2.vb#2)]  
  
 Il criterio di ricerca di espressioni regolari `\b\w+es\b` è definito nel modo illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`\w+`|Trova la corrispondenza di uno o più caratteri alfanumerici.|  
|`es`|Corrisponde alla stringa letterale "es".|  
|`\b`|Termina la corrispondenza sul confine di parola.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per il recupero di pattern più corrisponde al è <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di specificare l'intervallo di timeout.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che specificano le opzioni per la corrispondenza.</param>
        <summary>Cerca nella stringa di input specificata tutte le occorrenze di un'espressione regolare specificata usando le opzioni di corrispondenza specificate.</summary>
        <returns>Raccolta di oggetti <see cref="T:System.Text.RegularExpressions.Match" /> trovati dalla ricerca. Se non vengono trovate corrispondenze, il metodo restituisce un oggetto raccolta vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo è simile al <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> trovato un metodo, ad eccezione del fatto che restituisce informazioni su tutte le corrispondenze nella stringa di input, anziché una singola corrispondenza. È equivalente al codice seguente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#8)]  
  
 Il metodo statico `Matches` metodi sono equivalenti alla costruzione di un <xref:System.Text.RegularExpressions.Regex> con il modello di espressione regolare specificata dell'oggetto e chiamare il metodo di istanza `Matches`.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%2A> metodo viene utilizzato evaluation lazy per popolare l'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> oggetto. L'accesso ai membri di questa raccolta, ad esempio <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> fa sì che la raccolta in cui inserire immediatamente. Per sfruttare i vantaggi della valutazione lenta, è necessario l'iterazione della raccolta utilizzando un costrutto quale `foreach` in c# e `For Each`...`Next` in Visual Basic.  
  
 A causa la valutazione lazy, chiama il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metodo non genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. Tuttavia, l'eccezione viene generata quando viene eseguita un'operazione sul <xref:System.Text.RegularExpressions.MatchCollection> oggetto restituito da questo metodo, se un intervallo di timeout è definito dalla proprietà "REGEX_DEFAULT_MATCH_TIMEOUT" di un'operazione di corrispondenza e il dominio applicazione corrente supera questo intervallo di timeout.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> metodo per identificare qualsiasi parola di una frase che termina con "es" e quindi chiama il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo per eseguire un confronto tra maiuscole e minuscole del modello con la stringa di input. Come illustrato nell'output, i due metodi restituiscono risultati diversi.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches4.vb#4)]  
  
 Il criterio di ricerca di espressioni regolari `\b\w+es\b` è definito nel modo illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`\w+`|Trova la corrispondenza di uno o più caratteri alfanumerici.|  
|`es`|Corrisponde alla stringa letterale "es".|  
|`\b`|Termina la corrispondenza sul confine di parola.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per il recupero di pattern più corrisponde al è <see cref="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Matches">
      <MemberSignature Language="C#" Value="public static System.Text.RegularExpressions.MatchCollection Matches (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.RegularExpressions.MatchCollection Matches(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Matches (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As MatchCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::RegularExpressions::MatchCollection ^ Matches(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Matches : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; System.Text.RegularExpressions.MatchCollection" Usage="System.Text.RegularExpressions.Regex.Matches (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.MatchCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che specificano le opzioni per la corrispondenza.</param>
        <param name="matchTimeout">Intervallo di timeout o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> per indicare che per il metodo non è previsto un timeout.</param>
        <summary>Cerca nella stringa di input specificata tutte le occorrenze di un'espressione regolare specificata usando le opzioni di corrispondenza e l'intervallo di timeout specificati.</summary>
        <returns>Raccolta di oggetti <see cref="T:System.Text.RegularExpressions.Match" /> trovati dalla ricerca. Se non vengono trovate corrispondenze, il metodo restituisce un oggetto raccolta vuoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodo è simile al <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> trovato un metodo, ad eccezione del fatto che restituisce informazioni su tutte le corrispondenze nella stringa di input, anziché una singola corrispondenza. È equivalente al codice seguente:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matchespattern.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matchespattern.vb#10)]  
  
 Il metodo statico `Matches` metodi sono equivalenti alla costruzione di un <xref:System.Text.RegularExpressions.Regex> con il modello di espressione regolare specificata dell'oggetto e chiamare il metodo di istanza `Matches`.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il <xref:System.Text.RegularExpressions.Regex.Matches%2A> metodo viene utilizzato evaluation lazy per popolare l'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> oggetto. L'accesso ai membri di questa raccolta, ad esempio <xref:System.Text.RegularExpressions.MatchCollection.Count%2A?displayProperty=nameWithType> e <xref:System.Text.RegularExpressions.MatchCollection.CopyTo%2A?displayProperty=nameWithType> fa sì che la raccolta in cui inserire immediatamente. Per sfruttare i vantaggi della valutazione lenta, è necessario l'iterazione della raccolta utilizzando un costrutto quale `foreach` in c# e `For Each`...`Next` in Visual Basic.  
  
 A causa la valutazione lazy, chiama il <xref:System.Text.RegularExpressions.Regex.Matches%2A> metodo non genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. Tuttavia, viene generata un'eccezione quando viene eseguita un'operazione sul <xref:System.Text.RegularExpressions.MatchCollection> restituito da questo metodo, se un'operazione di corrispondenza supera questo intervallo di timeout specificato dall'oggetto di`matchTimeout` parametro.  
  
   
  
## Examples  
 L'esempio seguente chiama il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodo per eseguire un confronto tra maiuscole e minuscole che corrisponde a qualsiasi parola di una frase che termina con "es". Chiama quindi il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodo per eseguire un confronto tra maiuscole e minuscole del modello con la stringa di input. In entrambi i casi, l'intervallo di timeout è impostato su un secondo. Come illustrato nell'output, i due metodi restituiscono risultati diversi.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/cs/matches5.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Matches#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matches/vb/matches5.vb#11)]  
  
 Il criterio di ricerca di espressioni regolari `\b\w+es\b` è definito nel modo illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\b`|Inizia la corrispondenza sul confine di parola.|  
|`\w+`|Trova la corrispondenza di uno o più caratteri alfanumerici.|  
|`es`|Corrisponde alla stringa letterale "es".|  
|`\b`|Termina la corrispondenza sul confine di parola.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
oppure 
 <paramref name="matchTimeout" /> è negativo, zero o maggiore di circa 24 giorni.</exception>
        <block subset="none" type="usage">
          <para>È consigliabile impostare il <paramref name="matchTimeout" /> parametro su un valore appropriato, ad esempio due secondi. Se si disabilita i timeout specificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, il motore delle espressioni regolari offre prestazioni leggermente migliori. Tuttavia, è necessario disabilitare i timeout solo nelle condizioni seguenti: 
-Quando l'input elaborata da un'espressione regolare è derivato da un'origine conosciuta e attendibile o è costituito da testo statico. Esclude il testo che è stato in modo dinamico inseriti dagli utenti.  
  
-Quando il criterio di espressione regolare è stata accuratamente testato per verificare che gestisca in modo efficiente trova, mancate corrispondenze e a breve.  
  
-Quando il criterio di espressione regolare non contiene alcun elemento di linguaggio che potrebbero causare un backtracking eccessivo durante l'elaborazione di una corrispondenza più vicino.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="MatchTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan MatchTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MatchTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MatchTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MatchTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MatchTimeout : TimeSpan" Usage="System.Text.RegularExpressions.Regex.MatchTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene l'intervallo di timeout dell'istanza corrente.</summary>
        <value>Intervallo di tempo massimo che può trascorrere in un'operazione di criteri di ricerca prima che venga generata un'eccezione <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> se i timeout sono disabilitati.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A> proprietà definisce l'intervallo di tempo massimo approssimativo per un <xref:System.Text.RegularExpressions.Regex> istanza per eseguire una singola operazione di corrispondenza prima del timeout dell'operazione. Il motore delle espressioni regolari genera un' <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione durante il successivo controllo di temporizzazione dopo che è trascorso l'intervallo di timeout. Ciò impedisce al motore delle espressioni regolari di elaborare le stringhe di input che richiedono un backtracking eccessivo. Per altre informazioni, vedere [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md) e [procedure consigliate per le espressioni regolari](~/docs/standard/base-types/best-practices.md).  
  
 Questa proprietà è di sola lettura. È possibile impostare il relativo valore in modo esplicito per un singolo <xref:System.Text.RegularExpressions.Regex> chiamando il <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore; ed è possibile impostarne il valore per tutte le <xref:System.Text.RegularExpressions.Regex> corrispondenti operazioni in un dominio dell'applicazione chiamando il <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> (metodo) e fornendo un <xref:System.TimeSpan> valore della proprietà "REGEX_DEFAULT_MATCH_TIMEOUT", come illustrato nell'esempio seguente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/cs/regexmatchtimeout1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.MatchTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.matchtimeout/vb/regexmatchtimeout1.vb#1)]  
  
 Se si non si imposta esplicitamente un intervallo di timeout, il valore predefinito <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> operazioni utilizzate e di corrispondenza non presentano alcun timeout.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Options">
      <MemberSignature Language="C#" Value="public System.Text.RegularExpressions.RegexOptions Options { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.RegularExpressions.RegexOptions Options" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.Options" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Options As RegexOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::RegularExpressions::RegexOptions Options { System::Text::RegularExpressions::RegexOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.Options : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.Options" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene le opzioni passate al costruttore <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <value>Uno o più membri dell'enumerazione <see cref="T:System.Text.RegularExpressions.RegexOptions" /> che rappresentano le opzioni passate al costruttore <see cref="T:System.Text.RegularExpressions.Regex" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il valore della <xref:System.Text.RegularExpressions.Regex.Options%2A> proprietà è costituita da uno o più membri del <xref:System.Text.RegularExpressions.RegexOptions> enumerazione. Se nessuna opzione sono stata definita nel <xref:System.Text.RegularExpressions.Regex> costruttore di classe, il relativo valore è <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>. Le opzioni disponibili sono descritti dettagliatamente i [Regular Expression Options](~/docs/standard/base-types/regular-expression-options.md) argomento.  
  
 Si noti che il <xref:System.Text.RegularExpressions.Regex.Options%2A> proprietà non rispecchia le opzioni inline definite nell'espressione regolare modello stesso.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> è la classe base delle espressioni regolari creata il <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> (metodo). Queste espressioni regolari compilate utilizzano l'implementazione della classe base di <see cref="P:System.Text.RegularExpressions.Regex.Options" /> proprietà. Se viene chiamato da una classe derivata, il <see cref="P:System.Text.RegularExpressions.Regex.Options" /> proprietà vengono restituite le opzioni passate al <paramref name="options" /> parametro del <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> costruttore di classe usato per definire l'espressione regolare.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/c82dc689-7e82-4767-a18d-cd24ce5f05e9">Opzioni di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="pattern">
      <MemberSignature Language="C#" Value="protected internal string pattern;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly string pattern" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.pattern" />
      <MemberSignature Language="VB.NET" Value="Protected Friend pattern As String " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::String ^ pattern;" />
      <MemberSignature Language="F#" Value="val mutable pattern : string" Usage="System.Text.RegularExpressions.Regex.pattern" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>In una stringa di input specificata, sostituisce le stringhe corrispondenti a un criterio di espressione regolare con una stringa di sostituzione specificata.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="regex.Replace (input, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="replacement">Stringa di sostituzione.</param>
        <summary>In una stringa di input specificata, sostituisce tutte le stringhe corrispondenti a un criterio di espressione regolare con una stringa di sostituzione specificata.</summary>
        <returns>Stringa nuova identica alla stringa di input, a eccezione del fatto che ogni stringa corrispondente viene sostituita dalla stringa di sostituzione. Se il criterio di espressione regolare non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inizia la ricerca le corrispondenze all'inizio del `input` stringa. L'espressione regolare corrisponde al criterio definito dal costruttore corrente <xref:System.Text.RegularExpressions.Regex> oggetto.  
  
 Il `replacement` parametro specifica la stringa che consiste nel sostituire ogni corrispondenza nella `input`. `replacement` può contenere qualsiasi combinazione di testo letterale e [sostituzioni](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Ad esempio, il criterio di sostituzione `a*${test}b` inserisce la stringa "un *" aggiungendo la sottostringa a cui corrisponde il `test` acquisizione gruppo, se presente, seguito dalla stringa "b". Il * carattere non è riconosciuto come un metacarattere all'interno di un criterio di sostituzione.  
  
> [!NOTE]
>  Le sostituzioni sono gli elementi del linguaggio espressione regolare solo riconosciute in un criterio di sostituzione. Tutti gli elementi di linguaggio altre espressioni regolari, tra cui [carattere di escape](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sono consentiti in solo modelli di espressione regolare e non vengono riconosciute nei modelli di sostituzione.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 L'esempio seguente definisce un'espressione regolare, `\s+`, che corrisponde a uno o più caratteri spazio vuoto. La stringa di sostituzione, "", li sostituisce con un singolo carattere spazio.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample5.vb#5)]  
  
 L'esempio seguente definisce un'espressione regolare `(\p{Sc}\s?)?(\d+\.?((?<=\.)\d+)?)(?(1)|\s?\p{Sc})?`e un criterio di sostituzione `$2`, che rimuove una barra iniziale o finale di un simbolo di valuta da un valore numerico.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample7.vb#7)]  
  
 L'espressione regolare viene interpretata come illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\p{Sc}`|Corrisponde a un simbolo di valuta. `{Sc}` indica qualsiasi carattere che è un membro di Unicode Symbol, categoria di valuta.|  
|`\s?`|Trova la corrispondenza di uno o nessuno spazio vuoto.|  
|`(\p{Sc}\s?)?`|Trova zero o una occorrenza della combinazione di un simbolo di valuta seguito da zero o un carattere di spazio vuoto. Equivale al primo gruppo di acquisizione.|  
|`\d+`|Trova la corrispondenza con una o più cifre decimali.|  
|`\.?`|Trova zero o una occorrenza di un periodo (usato come carattere separatore decimale).|  
|`((?<=\.)\d+)?`|Se un periodo è il carattere precedente, corrisponde a uno o più cifre decimali. Questo modello può essere trovato zero o una volta.|  
|`(\d+\.?((?<=\.)\d+)?)`|Corrisponde al modello di uno o più cifre decimali seguite da un punto facoltativo e ulteriori cifre decimali. Equivale al secondo gruppo di acquisizione. La chiamata al <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%29> metodo sostituisce l'intera corrispondenza con il valore di questo gruppo acquisito.|  
|<code>(?(1)&#124;\s?\p{Sc})?</code>|Se il primo gruppo acquisito esiste, corrispondere a una stringa vuota. In caso contrario, trova la corrispondenza zero o uno spazio vuoto seguito da un simbolo di valuta.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="replacement" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="regex.Replace (input, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="evaluator">Metodo personalizzato che esamina ogni corrispondenza e restituisce la stringa corrispondente originale o una stringa di sostituzione.</param>
        <summary>In una stringa di input specificata, sostituisce tutte le stringhe corrispondenti a un'espressione regolare specificata con una stringa restituita da un delegato <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Stringa nuova identica alla stringa di input, ad eccezione del fatto che ogni stringa corrispondente viene sostituita da una stringa di sostituzione. Se il criterio di espressione regolare non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> metodo è utile per la sostituzione di una corrispondenza di espressione regolare se una delle condizioni seguenti è vera:  
  
-   La stringa di sostituzione non è possibile specificare immediatamente da un criterio di sostituzione di espressioni regolari.  
  
-   La stringa di sostituzione i risultati da alcune operazioni di elaborazione eseguita nella stringa corrispondente.  
  
-   I risultati di stringa di sostituzione di un'elaborazione condizionale.  
  
 Il metodo è equivalente alla chiamata il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> metodo e passando ognuno <xref:System.Text.RegularExpressions.Match> oggetto nell'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> insieme al `evaluator` delegare.  
  
 L'espressione regolare corrisponde al criterio definito dal costruttore corrente <xref:System.Text.RegularExpressions.Regex> oggetto.  
  
 Il `evaluator` parametro è il delegato per un metodo personalizzato definito dall'utente e che esamina ogni corrispondenza. Il metodo personalizzato deve avere la firma seguente in modo che corrisponda il <xref:System.Text.RegularExpressions.MatchEvaluator> delegare.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Il metodo personalizzato restituisce una stringa che sostituisce l'input corrispondente.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 Esempio di codice seguente consente di visualizzare una stringa originale, corrisponde a ogni parola nella stringa originale, converte il primo carattere di ogni corrispondenza in lettere maiuscole, quindi Visualizza la stringa convertita.  
  
 [!code-csharp[Regex.Replace-Instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Regex.Replace-Instance/cs/sample.cs#1)]
 [!code-vb[Regex.Replace-Instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Regex.Replace-Instance/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="evaluator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int -&gt; string" Usage="regex.Replace (input, replacement, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="replacement">Stringa di sostituzione.</param>
        <param name="count">Numero massimo di volte in cui la sostituzione può aver luogo.</param>
        <summary>In una stringa di input specificata, sostituisce un numero massimo di stringhe specificato corrispondenti a un criterio di espressione regolare con una stringa di sostituzione specificata.</summary>
        <returns>Stringa nuova identica alla stringa di input, a eccezione del fatto che ogni stringa corrispondente viene sostituita dalla stringa di sostituzione. Se il criterio di espressione regolare non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inizia la ricerca le corrispondenze all'inizio del `input` stringa. L'espressione regolare è il criterio definito dal costruttore corrente <xref:System.Text.RegularExpressions.Regex> oggetto. Se `count` è negativo, le sostituzioni continuano fino alla fine della stringa. Se `count` supera il numero di corrispondenze, vengono sostituite tutte le corrispondenze.  
  
 Il `replacement` parametro specifica la stringa che consiste nel sostituire il primo `count` corrispondenze nel `input`. `replacement` può contenere qualsiasi combinazione di testo letterale e [sostituzioni](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Ad esempio, il criterio di sostituzione `a*${test}b` inserisce la stringa "un *" aggiungendo la sottostringa a cui corrisponde il `test` acquisizione gruppo, se presente, seguito dalla stringa "b". Il * carattere non è riconosciuto come un metacarattere all'interno di un criterio di sostituzione.  
  
> [!NOTE]
>  Le sostituzioni sono gli elementi del linguaggio espressione regolare solo riconosciute in un criterio di sostituzione. Tutti gli elementi di linguaggio altre espressioni regolari, tra cui [carattere di escape](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sono consentiti in solo modelli di espressione regolare e non vengono riconosciute nei modelli di sostituzione.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 Nell'esempio seguente sostituisce le prime cinque occorrenze dei caratteri duplicati con un singolo carattere. Criterio di espressione regolare `(\w)\1` le occorrenze consecutive di un singolo carattere e assegna la prima occorrenza al primo gruppo di acquisizione. Il criterio di sostituzione `$1` sostituisce l'intera corrispondenza con il primo gruppo acquisito.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="replacement" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="replacement">Stringa di sostituzione.</param>
        <summary>In una stringa di input specificata, sostituisce tutte le stringhe corrispondenti a un'espressione regolare specificata con una stringa di sostituzione specificata.</summary>
        <returns>Stringa nuova identica alla stringa di input, a eccezione del fatto che ogni stringa corrispondente viene sostituita dalla stringa di sostituzione. Se <paramref name="pattern" /> non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo statico `Replace` metodi sono equivalenti alla costruzione di un <xref:System.Text.RegularExpressions.Regex> con il modello di espressione regolare specificata dell'oggetto e chiamare il metodo di istanza `Replace`.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Inizia la ricerca le corrispondenze all'inizio del `input` stringa.  
  
 Il `replacement` parametro specifica la stringa che consiste nel sostituire ogni corrispondenza nella `input`. `replacement` può contenere qualsiasi combinazione di testo letterale e [sostituzioni](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Ad esempio, il criterio di sostituzione `a*${test}b` inserisce la stringa "un *" aggiungendo la sottostringa a cui corrisponde il `test` acquisizione gruppo, se presente, seguito dalla stringa "b". Il * carattere non è riconosciuto come un metacarattere all'interno di un criterio di sostituzione.  
  
> [!NOTE]
>  Le sostituzioni sono gli elementi del linguaggio espressione regolare solo riconosciute in un criterio di sostituzione. Tutti gli elementi di linguaggio altre espressioni regolari, tra cui [carattere di escape](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sono consentiti in solo modelli di espressione regolare e non vengono riconosciute nei modelli di sostituzione.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 L'esempio seguente definisce un'espressione regolare, `\s+`, che corrisponde a uno o più caratteri spazio vuoto. La stringa di sostituzione, "", li sostituisce con un singolo carattere spazio.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample6.cs#6)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample6.vb#6)]  
  
 L'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> metodo per sostituire i nomi di computer e unità locali in un percorso UNC con un percorso file locale. L'espressione regolare utilizza il <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> proprietà da includere il nome del computer locale e il <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> metodo per includere i nomi delle unità logiche. Per eseguire correttamente l'esempio, è consigliabile sostituire la stringa letterale "MyMachine" con il nome del computer locale.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace3.vb#3)]  
  
 Criterio di espressione regolare viene definito dall'espressione seguente:  
  
 `"\\\\(?i:" + Environment.MachineName + ")(?:\.\w+)*\\((?i:[" + driveNames + "]))\$"`  
  
 Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\\\\`|Barra rovesciata consecutivo corrispondenza due (`\`) caratteri. Poiché il carattere barra rovesciata viene interpretato come carattere di escape, ogni barra rovesciata deve essere preceduta da un'altra barra rovesciata.|  
|`(?i:" + Environment.MachineName + ")`|Eseguire una corrispondenza tra maiuscole e minuscole della stringa restituita dal <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> proprietà.|  
|`(?:\.\w+)*`|Corrisponde al periodo (`.`) carattere seguito da uno o più caratteri alfanumerici. Questa corrispondenza può verificarsi zero o più volte. La sottoespressione corrispondente non viene acquisita.|  
|`\\`|Corrisponde a una barra rovesciata (`\`) caratteri.|  
|`((?i:[" + driveNames + "]))`|Eseguire una corrispondenza tra maiuscole e minuscole della classe di caratteri costituito lettters le singole unità. Questa corrispondenza è della prima sottoespressione acquisita.|  
|`\$`|Corrisponde al valore letterale segno di dollaro (`$`) caratteri.|  
  
 Il criterio di sostituzione `$1` sostituito l'intera corrispondenza della prima sottoespressione acquisita. Vale a dire, sostituisce il nome di computer e unità UNC con la lettera di unità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="replacement" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per la sostituzione di un criterio di ricerca è <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="evaluator">Metodo personalizzato che esamina ogni corrispondenza e restituisce la stringa corrispondente originale o una stringa di sostituzione.</param>
        <summary>In una stringa di input specificata, sostituisce tutte le stringhe corrispondenti a un'espressione regolare specificata con una stringa restituita da un delegato <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Stringa nuova identica alla stringa di input, ad eccezione del fatto che ogni stringa corrispondente viene sostituita da una stringa di sostituzione. Se <paramref name="pattern" /> non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> metodo è utile per la sostituzione di una corrispondenza di espressione regolare se una delle condizioni seguenti è vera:  
  
-   La stringa di sostituzione non è possibile specificare immediatamente da un criterio di sostituzione di espressioni regolari.  
  
-   La stringa di sostituzione i risultati da alcune operazioni di elaborazione eseguita nella stringa corrispondente.  
  
-   I risultati di stringa di sostituzione di un'elaborazione condizionale.  
  
 Il metodo è equivalente alla chiamata il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> metodo e passando ognuno <xref:System.Text.RegularExpressions.Match> oggetto nell'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> insieme al `evaluator` delegare.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il `evaluator` parametro è il delegato per un metodo personalizzato definito dall'utente e che esamina ogni corrispondenza. Il metodo personalizzato deve avere la firma seguente in modo che corrisponda il <xref:System.Text.RegularExpressions.MatchEvaluator> delegare.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Il metodo personalizzato restituisce una stringa che sostituisce l'input corrispondente.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 Nell'esempio seguente usa un'espressione regolare per estrarre le singole parole da una stringa e quindi Usa un' <xref:System.Text.RegularExpressions.MatchEvaluator> delegato da chiamare un metodo denominato `WordScramble` che codificata le lettere singole all'interno della parola. A tale scopo, il `WordScramble` metodo crea una matrice che contiene i caratteri nella corrispondenza. Crea anche una matrice parallela che popola con numeri a virgola mobile casuale. Le matrici vengono ordinate chiamando il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metodo e la matrice ordinata viene fornito come argomento a un <xref:System.String> costruttore della classe. Questa stringa appena creata viene quindi restituita dal `WordScramble` (metodo). Criterio di espressione regolare `\w+` corrisponde a uno o più caratteri alfanumerici; il motore delle espressioni regolari continueranno a aggiungere caratteri alla corrispondenza finché non viene rilevato un carattere non alfanumerico, ad esempio un carattere di spazio vuoto.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace5.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="evaluator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per la valutazione e la sostituzione di un criterio di ricerca è <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int -&gt; string" Usage="regex.Replace (input, evaluator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="evaluator">Metodo personalizzato che esamina ogni corrispondenza e restituisce la stringa corrispondente originale o una stringa di sostituzione.</param>
        <param name="count">Numero massimo di volte in cui la sostituzione avrà luogo.</param>
        <summary>In una stringa di input specificata, sostituisce un numero massimo di stringhe specificato corrispondenti a un criterio di espressione regolare con una stringa restituita da un delegato <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Stringa nuova identica alla stringa di input, ad eccezione del fatto che ogni stringa corrispondente viene sostituita da una stringa di sostituzione. Se il criterio di espressione regolare non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%29?displayProperty=nameWithType> metodo è utile per la sostituzione di una corrispondenza di espressione regolare se una delle condizioni seguenti è vera:  
  
-   La stringa di sostituzione non è possibile specificare immediatamente da un criterio di sostituzione di espressioni regolari.  
  
-   La stringa di sostituzione i risultati da alcune operazioni di elaborazione eseguita nella stringa corrispondente.  
  
-   I risultati di stringa di sostituzione di un'elaborazione condizionale.  
  
 Il metodo è equivalente alla chiamata il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%29?displayProperty=nameWithType> metodo e passando il primo `count` <xref:System.Text.RegularExpressions.Match> oggetti nell'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> raccolta per il `evaluator` delegare.  
  
 L'espressione regolare corrisponde al criterio definito dal costruttore corrente <xref:System.Text.RegularExpressions.Regex> oggetto.  
  
 Il `evaluator` parametro è il delegato per un metodo personalizzato definito dall'utente e che esamina ogni corrispondenza. Il metodo personalizzato deve avere la firma seguente in modo che corrisponda il <xref:System.Text.RegularExpressions.MatchEvaluator> delegare.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Il metodo personalizzato restituisce una stringa che sostituisce l'input corrispondente.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 Nell'esempio seguente usa un'espressione regolare per deliberatamente in modo errato la metà delle parole in un elenco. Usa l'espressione regolare `\w*(ie|ei)\w*` per corrispondere a parole che includono i caratteri "Internet Explorer" o "ei". Passa la prima metà delle parole corrispondenti per il `ReverseLetter` metodo, che, a sua volta, utilizza il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo per invertire "i" e "e" nella stringa corrispondente. Le parole rimanenti rimangono invariate.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace7.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace7.vb#11)]  
  
 L'espressione regolare `\w*(ie|ei)\w*` viene definita come illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\w*`|Trova la corrispondenza di zero o più caratteri alfanumerici.|  
|<code>(ie&#124;ei)</code>|Corrisponde a "Internet Explorer" o "ei".|  
|`\w*`|Trova la corrispondenza di zero o più caratteri alfanumerici.|  
  
 Criterio di espressione regolare `([ie])([ie])` nella `ReverseLetter` metodo corrisponde il primo "i" o "e" in dittongo "Internet Explorer" o "ei" e assegna la lettera al primo gruppo di acquisizione. Corrisponde alla secondario "i" o "e" e assegna la lettera a secondo gruppo di acquisizione. I due caratteri sono invertiti chiamando il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%29> metodo con il criterio di sostituzione `$2$1`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="evaluator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, string replacement, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, string replacement, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, replacement As String, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::String ^ replacement, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; string" Usage="regex.Replace (input, replacement, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="replacement">Stringa di sostituzione.</param>
        <param name="count">Numero massimo di volte in cui la sostituzione può aver luogo.</param>
        <param name="startat">Posizione del carattere nella stringa di input da cui avrà inizio la ricerca.</param>
        <summary>In una sottostringa di input specificata, sostituisce un numero massimo di stringhe specificato corrispondenti a un criterio di espressione regolare con una stringa di sostituzione specificata.</summary>
        <returns>Stringa nuova identica alla stringa di input, a eccezione del fatto che ogni stringa corrispondente viene sostituita dalla stringa di sostituzione. Se il criterio di espressione regolare non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viene avviata la ricerca le corrispondenze `input` stringa in corrispondenza della posizione specificata dal `startat` parametro. L'espressione regolare corrisponde al criterio definito dal costruttore corrente <xref:System.Text.RegularExpressions.Regex> oggetto. Se `count` è negativo, le sostituzioni continuano fino alla fine della stringa. Se `count` supera il numero di corrispondenze, vengono sostituite tutte le corrispondenze.  
  
 Il `replacement` parametro specifica la stringa che consiste nel sostituire ogni corrispondenza nella `input`. `replacement` può contenere qualsiasi combinazione di testo letterale e [sostituzioni](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Ad esempio, il criterio di sostituzione `a*${test}b` inserisce la stringa "un *" aggiungendo la sottostringa a cui corrisponde il `test` acquisizione gruppo, se presente, seguito dalla stringa "b". Il * carattere non è riconosciuto come un metacarattere all'interno di un criterio di sostituzione.  
  
> [!NOTE]
>  Le sostituzioni sono gli elementi del linguaggio espressione regolare solo riconosciute in un criterio di sostituzione. Tutti gli elementi di linguaggio altre espressioni regolari, tra cui [carattere di escape](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sono consentiti in solo modelli di espressione regolare e non vengono riconosciute nei modelli di sostituzione.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 Nell'esempio seguente double-spaces tutto tranne la prima riga di una stringa. Definisce un modello di espressione regolare, `^.*$`, che corrisponde a una riga di testo, le chiamate di <xref:System.Text.RegularExpressions.Regex.Match%28System.String%29> metodo corrisponda alla prima riga della stringa e Usa le `Match.Index` e `Match.Count` proprietà per determinare la posizione iniziale del secondo riga.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replaceexample9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replaceexample9.vb#9)]  
  
 Il criterio di ricerca di espressioni regolari `^.*$` è definito nel modo illustrato nella tabella seguente.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`^`|Corrisponde all'inizio di una riga. (Si noti che il <xref:System.Text.RegularExpressions.Regex> è stata creata un'istanza di oggetto utilizzando il <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opzione; in caso contrario, questa classe di caratteri corrisponderebbe solo l'inizio della stringa di input.)|  
|`.*`|Corrispondenza con qualsiasi carattere zero o più volte.|  
|`$`|Trovare la fine di una riga. (Si noti che il <xref:System.Text.RegularExpressions.Regex> è stata creata un'istanza di oggetto utilizzando il <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> opzione; in caso contrario, questa classe di caratteri corrisponderebbe solo l'inizio della stringa di input.)|  
  
 La stringa di sostituzione (`vbCrLf + "$&"` in Visual Basic `"\n$&"` in c#) consente di aggiungere una nuova riga prima della stringa corrispondente. Si noti che `\n` in c# riportato viene interpretato come carattere di nuova riga dal compilatore c#; non rappresenta un carattere di escape di espressione regolare.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="replacement" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> è minore di zero o maggiore della lunghezza di <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="replacement">Stringa di sostituzione.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <summary>In una stringa di input specificata, sostituisce tutte le stringhe corrispondenti a un'espressione regolare specificata con una stringa di sostituzione specificata. Le opzioni specificate modificano l'operazione di corrispondenza.</summary>
        <returns>Stringa nuova identica alla stringa di input, a eccezione del fatto che ogni stringa corrispondente viene sostituita dalla stringa di sostituzione. Se <paramref name="pattern" /> non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo statico `Replace` metodi sono equivalenti alla costruzione di un <xref:System.Text.RegularExpressions.Regex> con il modello di espressione regolare specificata dell'oggetto e chiamare il metodo di istanza `Replace`.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Se si specifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> per il `options` parametro, la ricerca di corrispondenze inizia alla fine della stringa di input e viene spostato a sinistra; in caso contrario, la ricerca inizia all'inizio della stringa di input e viene spostato verso destra.  
  
 Il `replacement` parametro specifica la stringa che consiste nel sostituire ogni corrispondenza nella `input`. `replacement` può contenere qualsiasi combinazione di testo letterale e [sostituzioni](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Ad esempio, il criterio di sostituzione `a*${test}b` inserisce la stringa "un *" aggiungendo la sottostringa a cui corrisponde il `test` acquisizione gruppo, se presente, seguito dalla stringa "b". Il * carattere non è riconosciuto come un metacarattere all'interno di un criterio di sostituzione.  
  
> [!NOTE]
>  Le sostituzioni sono gli elementi del linguaggio espressione regolare solo riconosciute in un criterio di sostituzione. Tutti gli elementi di linguaggio altre espressioni regolari, tra cui [carattere di escape](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sono consentiti in solo modelli di espressione regolare e non vengono riconosciute nei modelli di sostituzione.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo per sostituire i nomi di computer e unità locali in un percorso UNC con un percorso file locale. L'espressione regolare utilizza il <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> proprietà da includere il nome del computer locale e il <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> metodo per includere i nomi delle unità logiche. Tutti i confronti di stringhe di espressione regolare sono tra maiuscole e minuscole. Per eseguire correttamente l'esempio, è consigliabile sostituire la stringa letterale "MyMachine" con il nome del computer locale.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace4.vb#4)]  
  
 Criterio di espressione regolare viene definito dall'espressione seguente:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\\\\`|Barra rovesciata consecutivo corrispondenza due (`\`) caratteri. Poiché il carattere barra rovesciata viene interpretato come carattere di escape, ogni barra rovesciata deve essere preceduta da un'altra barra rovesciata.|  
|`+ Environment.MachineName +`|Corrisponde alla stringa restituita dal <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> proprietà.|  
|`(?:\.\w+)*`|Corrisponde al periodo (`.`) carattere seguito da uno o più caratteri alfanumerici. Questa corrispondenza può verificarsi zero o più volte. La sottoespressione corrispondente non viene acquisita.|  
|`\\`|Corrisponde a una barra rovesciata (`\`) caratteri.|  
|`([" + driveNames + "])`|Corrisponde alla classe di caratteri costituito da lettere di unità singola. Questa corrispondenza è della prima sottoespressione acquisita.|  
|`\$`|Corrisponde al valore letterale segno di dollaro (`$`) caratteri.|  
  
 Il criterio di sostituzione `$1` sostituito l'intera corrispondenza della prima sottoespressione acquisita. Vale a dire, sostituisce il nome di computer e unità UNC con la lettera di unità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="replacement" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per la sostituzione di un criterio di ricerca è <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="evaluator">Metodo personalizzato che esamina ogni corrispondenza e restituisce la stringa corrispondente originale o una stringa di sostituzione.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <summary>In una stringa di input specificata, sostituisce tutte le stringhe corrispondenti a un'espressione regolare specificata con una stringa restituita da un delegato <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. Le opzioni specificate modificano l'operazione di corrispondenza.</summary>
        <returns>Stringa nuova identica alla stringa di input, ad eccezione del fatto che ogni stringa corrispondente viene sostituita da una stringa di sostituzione. Se <paramref name="pattern" /> non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metodo è utile per la sostituzione di una corrispondenza di espressione regolare in se una delle condizioni seguenti è vera:  
  
-   La stringa di sostituzione non è possibile specificare immediatamente da un criterio di sostituzione di espressioni regolari.  
  
-   La stringa di sostituzione i risultati da alcune operazioni di elaborazione eseguita nella stringa corrispondente.  
  
-   I risultati di stringa di sostituzione di un'elaborazione condizionale.  
  
 Il metodo è equivalente alla chiamata il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metodo e passando ognuno <xref:System.Text.RegularExpressions.Match> oggetto nell'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> insieme al `evaluator` delegare.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il `evaluator` parametro è il delegato per un metodo personalizzato definito dall'utente e che esamina ogni corrispondenza. Il metodo personalizzato deve avere la firma seguente in modo che corrisponda il <xref:System.Text.RegularExpressions.MatchEvaluator> delegare.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Il metodo personalizzato restituisce una stringa che sostituisce l'input corrispondente.  
  
 Se si specifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> per il `options` parametro, la ricerca di corrispondenze inizia alla fine della stringa di input e viene spostato a sinistra; in caso contrario, la ricerca inizia all'inizio della stringa di input e viene spostato verso destra.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 Nell'esempio seguente usa un'espressione regolare per estrarre le singole parole da una stringa e quindi Usa un' <xref:System.Text.RegularExpressions.MatchEvaluator> delegato da chiamare un metodo denominato `WordScramble` che codificata le lettere singole all'interno della parola. A tale scopo, il `WordScramble` metodo crea una matrice che contiene i caratteri nella corrispondenza. Crea anche una matrice parallela che popola con numeri a virgola mobile casuale. Le matrici vengono ordinate chiamando il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metodo e la matrice ordinata viene fornito come argomento a un <xref:System.String> costruttore della classe. Questa stringa appena creata viene quindi restituita dal `WordScramble` (metodo). Criterio di espressione regolare `\w+` corrisponde a uno o più caratteri alfanumerici; il motore delle espressioni regolari continueranno a aggiungere caratteri alla corrispondenza finché non viene rilevato un carattere non alfanumerico, ad esempio un carattere di spazio vuoto. La chiamata ai <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo include le <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opzione in modo che il commento nel criterio di espressione regolare `\w+  # Matches all the characters in a word.` viene ignorata dal motore delle espressioni regolari.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace6.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace6.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="evaluator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string input, System.Text.RegularExpressions.MatchEvaluator evaluator, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string input, class System.Text.RegularExpressions.MatchEvaluator evaluator, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (input As String, evaluator As MatchEvaluator, count As Integer, startat As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ input, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * System.Text.RegularExpressions.MatchEvaluator * int * int -&gt; string" Usage="regex.Replace (input, evaluator, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="evaluator">Metodo personalizzato che esamina ogni corrispondenza e restituisce la stringa corrispondente originale o una stringa di sostituzione.</param>
        <param name="count">Numero massimo di volte in cui la sostituzione avrà luogo.</param>
        <param name="startat">Posizione del carattere nella stringa di input da cui avrà inizio la ricerca.</param>
        <summary>In una sottostringa di input specificata, sostituisce un numero massimo di stringhe specificato corrispondenti a un criterio di espressione regolare con una stringa restituita da un delegato <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />.</summary>
        <returns>Stringa nuova identica alla stringa di input, ad eccezione del fatto che ogni stringa corrispondente viene sostituita da una stringa di sostituzione. Se il criterio di espressione regolare non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metodo è utile per la sostituzione di una corrispondenza di espressione regolare se una delle condizioni seguenti è vera:  
  
-   La stringa di sostituzione non è possibile specificare immediatamente da un criterio di sostituzione di espressioni regolari.  
  
-   La stringa di sostituzione i risultati da alcune operazioni di elaborazione eseguita nella stringa corrispondente.  
  
-   I risultati di stringa di sostituzione di un'elaborazione condizionale.  
  
 Il metodo è equivalente alla chiamata il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> metodo e passando il primo `count` <xref:System.Text.RegularExpressions.Match> oggetti nell'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> raccolta per il `evaluator` delegare.  
  
 L'espressione regolare corrisponde al criterio definito dal costruttore corrente <xref:System.Text.RegularExpressions.Regex> oggetto.  
  
 Il `evaluator` parametro è il delegato per un metodo personalizzato definito dall'utente e che esamina ogni corrispondenza. Il metodo personalizzato deve avere la firma seguente in modo che corrisponda il <xref:System.Text.RegularExpressions.MatchEvaluator> delegare.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Il metodo personalizzato restituisce una stringa che sostituisce l'input corrispondente.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione di sostituzione supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="evaluator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> è minore di zero o maggiore della lunghezza di <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <altmember cref="T:System.Text.RegularExpressions.MatchEvaluator" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, string replacement, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, string replacement, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, replacement As String, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::String ^ replacement, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, replacement, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="replacement" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="replacement">Stringa di sostituzione.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <param name="matchTimeout">Intervallo di timeout o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> per indicare che per il metodo non è previsto un timeout.</param>
        <summary>In una stringa di input specificata, sostituisce tutte le stringhe corrispondenti a un'espressione regolare specificata con una stringa di sostituzione specificata. I parametri aggiuntivi specificano le opzioni che modificano l'operazione di corrispondenza e un intervallo di timeout se non viene trovata alcuna corrispondenza.</summary>
        <returns>Stringa nuova identica alla stringa di input, a eccezione del fatto che ogni stringa corrispondente viene sostituita dalla stringa di sostituzione. Se <paramref name="pattern" /> non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il metodo statico `Replace` metodi sono equivalenti alla costruzione di un <xref:System.Text.RegularExpressions.Regex> con il modello di espressione regolare specificata dell'oggetto e chiamare il metodo di istanza `Replace`.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md). Se si specifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> per il `options` parametro, la ricerca di corrispondenze inizia alla fine della stringa di input e viene spostato a sinistra; in caso contrario, la ricerca inizia all'inizio della stringa di input e viene spostato verso destra.  
  
 Il `replacement` parametro specifica la stringa che consiste nel sostituire ogni corrispondenza nella `input`. `replacement` può contenere qualsiasi combinazione di testo letterale e [sostituzioni](~/docs/standard/base-types/substitutions-in-regular-expressions.md). Ad esempio, il criterio di sostituzione `a*${test}b` inserisce la stringa "un *" aggiungendo la sottostringa a cui corrisponde il `test` acquisizione gruppo, se presente, seguito dalla stringa "b". Il * carattere non è riconosciuto come un metacarattere all'interno di un criterio di sostituzione.  
  
> [!NOTE]
>  Le sostituzioni sono gli elementi del linguaggio espressione regolare solo riconosciute in un criterio di sostituzione. Tutti gli elementi di linguaggio altre espressioni regolari, tra cui [carattere di escape](~/docs/standard/base-types/character-escapes-in-regular-expressions.md), sono consentiti in solo modelli di espressione regolare e non vengono riconosciute nei modelli di sostituzione.  
  
 Il `matchTimeout` parametro specifica il modo in cui lungo un modello corrispondente metodo deve effettuare per trovare una corrispondenza prima del timeout. L'impostazione di un intervallo di timeout impedisce le espressioni regolari che si basano su un backtracking eccessivo che venga visualizzato il blocco quando elaborano un input che contiene corrispondenze. Per altre informazioni, vedere [procedure consigliate per le espressioni regolari](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se viene trovata alcuna corrispondenza in tale intervallo di tempo, il metodo genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. `matchTimeout` esegue l'override di qualsiasi valore di timeout predefinito definito per il dominio applicazione in cui viene eseguito il metodo.  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 L'esempio seguente usa il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29> metodo per sostituire i nomi di computer e unità locali in un percorso UNC con un percorso file locale. L'espressione regolare utilizza il <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> proprietà da includere il nome del computer locale e il <xref:System.Environment.GetLogicalDrives%2A?displayProperty=nameWithType> metodo per includere i nomi delle unità logiche. Tutti i confronti di stringhe di espressione regolare sono tra maiuscole e minuscole e qualsiasi operazione di sostituzione singola scade se non è possibile trovare una corrispondenza nel secondo 0,5. Per eseguire correttamente l'esempio, è consigliabile sostituire la stringa letterale "MyMachine" con il nome del computer locale.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace12.cs#12)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace12.vb#12)]  
  
 Criterio di espressione regolare viene definito dall'espressione seguente:  
  
 `"\\\\" + Environment.MachineName + "(?:\.\w+)*\\([" + driveNames + "])\$"`  
  
 Nella tabella seguente è illustrata l'interpretazione del criterio di ricerca di espressioni regolari.  
  
|Modello|Descrizione|  
|-------------|-----------------|  
|`\\\\`|Barra rovesciata consecutivo corrispondenza due (`\`) caratteri. Poiché il carattere barra rovesciata viene interpretato come carattere di escape, ogni barra rovesciata deve essere preceduta da un'altra barra rovesciata.|  
|`+ Environment.MachineName +`|Corrisponde alla stringa restituita dal <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> proprietà.|  
|`(?:\.\w+)*`|Corrisponde al periodo (`.`) carattere seguito da uno o più caratteri alfanumerici. Questa corrispondenza può verificarsi zero o più volte. La sottoespressione corrispondente non viene acquisita.|  
|`\\`|Corrisponde a una barra rovesciata (`\`) caratteri.|  
|`([" + driveNames + "])`|Corrisponde alla classe di caratteri costituito da lettere di unità singola. Questa corrispondenza è della prima sottoespressione acquisita.|  
|`\$`|Corrisponde al valore letterale segno di dollaro (`$`) caratteri.|  
  
 Il criterio di sostituzione `$1` sostituito l'intera corrispondenza della prima sottoespressione acquisita. Vale a dire, sostituisce il nome di computer e unità UNC con la lettera di unità.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="replacement" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
oppure 
 <paramref name="matchTimeout" /> è negativo, zero o maggiore di circa 24 giorni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>È consigliabile impostare il <paramref name="matchTimeout" /> parametro su un valore appropriato, ad esempio due secondi. Se si disabilita i timeout specificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, il motore delle espressioni regolari offre prestazioni leggermente migliori. Tuttavia, è necessario disabilitare i timeout solo nelle condizioni seguenti: 
-Quando l'input elaborata da un'espressione regolare è derivato da un'origine conosciuta e attendibile o è costituito da testo statico. Esclude il testo che è stato in modo dinamico inseriti dagli utenti.  
  
-Quando il criterio di espressione regolare è stata accuratamente testato per verificare che gestisca in modo efficiente trova, mancate corrispondenze e a breve.  
  
-Quando il criterio di espressione regolare non contiene alcun elemento di linguaggio che potrebbero causare un backtracking eccessivo durante l'elaborazione di una corrispondenza più vicino.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Backtracking</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Procedure consigliate per le espressioni regolari in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static string Replace (string input, string pattern, System.Text.RegularExpressions.MatchEvaluator evaluator, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Replace(string input, string pattern, class System.Text.RegularExpressions.MatchEvaluator evaluator, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replace (input As String, pattern As String, evaluator As MatchEvaluator, options As RegexOptions, matchTimeout As TimeSpan) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Replace(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::MatchEvaluator ^ evaluator, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Replace : string * string * System.Text.RegularExpressions.MatchEvaluator * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string" Usage="System.Text.RegularExpressions.Regex.Replace (input, pattern, evaluator, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="evaluator" Type="System.Text.RegularExpressions.MatchEvaluator" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Stringa nella quale cercare una corrispondenza.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="evaluator">Metodo personalizzato che esamina ogni corrispondenza e restituisce la stringa corrispondente originale o una stringa di sostituzione.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <param name="matchTimeout">Intervallo di timeout o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> per indicare che per il metodo non è previsto un timeout.</param>
        <summary>In una stringa di input specificata, sostituisce tutte le sottostringhe corrispondenti a un'espressione regolare specificata con una stringa restituita da un delegato <see cref="T:System.Text.RegularExpressions.MatchEvaluator" />. I parametri aggiuntivi specificano le opzioni che modificano l'operazione di corrispondenza e un intervallo di timeout se non viene trovata alcuna corrispondenza.</summary>
        <returns>Stringa nuova identica alla stringa di input, a eccezione del fatto che ogni stringa corrispondente viene sostituita dalla stringa di sostituzione. Se <paramref name="pattern" /> non trova corrispondenza nell'istanza corrente, il metodo restituisce l'istanza corrente invariata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metodo è utile per la sostituzione di una corrispondenza di espressione regolare se una delle condizioni seguenti è vera:  
  
-   Se la stringa di sostituzione non è possibile specificare immediatamente da un criterio di sostituzione di espressioni regolari.  
  
-   Se la stringa di sostituzione rileva da alcune operazioni di elaborazione eseguita nella stringa corrispondente.  
  
-   Se la stringa di sostituzione è dovuto a un'elaborazione condizionale.  
  
 Il metodo è equivalente alla chiamata il <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> metodo e passando ognuno <xref:System.Text.RegularExpressions.Match> oggetto nell'oggetto restituito <xref:System.Text.RegularExpressions.MatchCollection> insieme al `evaluator` delegare.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 Il `evaluator` parametro è il delegato per un metodo personalizzato definito dall'utente e che esamina ogni corrispondenza. Il metodo personalizzato deve avere la firma seguente in modo che corrisponda il <xref:System.Text.RegularExpressions.MatchEvaluator> delegare.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/syntax1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/syntax1.vb#1)]  
  
 Il metodo personalizzato restituisce una stringa che sostituisce l'input corrispondente.  
  
 Se si specifica <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> per il `options` parametro, la ricerca di corrispondenze inizia alla fine della stringa di input e viene spostato a sinistra; in caso contrario, la ricerca inizia all'inizio della stringa di input e viene spostato verso destra.  
  
 Il `matchTimeout` parametro specifica il modo in cui lungo un modello corrispondente metodo deve effettuare per trovare una corrispondenza prima del timeout. L'impostazione di un intervallo di timeout impedisce le espressioni regolari che si basano su un backtracking eccessivo venga visualizzato agli "smettere di funzionare quando elaborano un input che contiene corrispondenze. Per altre informazioni, vedere [procedure consigliate per le espressioni regolari](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se viene trovata alcuna corrispondenza in tale intervallo di tempo, il metodo genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. `matchTimeout` esegue l'override di qualsiasi valore di timeout predefinito definito per il dominio applicazione in cui viene eseguito il metodo.  
  
 Poiché il metodo restituisce `input` invariati se non esiste alcuna corrispondenza, è possibile usare il <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metodo per determinare se il metodo ha reso qualsiasi sostituzione alla stringa di input.  
  
   
  
## Examples  
 Nell'esempio seguente usa un'espressione regolare per estrarre le singole parole da una stringa e quindi Usa un' <xref:System.Text.RegularExpressions.MatchEvaluator> delegato da chiamare un metodo denominato `WordScramble` che codificata le lettere singole all'interno della parola. A tale scopo, il `WordScramble` metodo crea una matrice che contiene i caratteri nella corrispondenza. Crea anche una matrice parallela che popola con numeri a virgola mobile casuale. Le matrici vengono ordinate chiamando il <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> metodo e la matrice ordinata viene fornito come argomento a un <xref:System.String> costruttore della classe. Questa stringa appena creata viene quindi restituita dal `WordScramble` (metodo). Criterio di espressione regolare `\w+` corrisponde a uno o più caratteri alfanumerici; il motore delle espressioni regolari continueranno a aggiungere caratteri alla corrispondenza finché non viene rilevato un carattere non alfanumerico, ad esempio un carattere di spazio vuoto. La chiamata ai <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%2CSystem.Text.RegularExpressions.RegexOptions%29> metodo include le <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> opzione in modo che il commento nel criterio di espressione regolare `\w+  # Matches all the characters in a word.` viene ignorata dal motore delle espressioni regolari.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/cs/replace13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Replace#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.replace/vb/replace13.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" />, <paramref name="pattern" /> o <paramref name="evaluator" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
oppure 
 <paramref name="matchTimeout" /> è negativo, zero o maggiore di circa 24 giorni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>È consigliabile impostare il <paramref name="matchTimeout" /> parametro su un valore appropriato, ad esempio due secondi. Se si disabilita i timeout specificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, il motore delle espressioni regolari offre prestazioni leggermente migliori. Tuttavia, è necessario disabilitare i timeout solo nelle condizioni seguenti: 
-Quando l'input elaborata da un'espressione regolare è derivato da un'origine conosciuta e attendibile o è costituito da testo statico. Esclude il testo che è stato in modo dinamico inseriti dagli utenti.  
  
-Quando il criterio di espressione regolare è stata accuratamente testato per verificare che gestisca in modo efficiente trova, mancate corrispondenze e a breve.  
  
-Quando il criterio di espressione regolare non contiene alcun elemento di linguaggio che potrebbero causare un backtracking eccessivo durante l'elaborazione di una corrispondenza più vicino.</para>
        </block>
        <altmember cref="T:System.Text.RegularExpressions.RegexOptions" />
        <related type="Article" href="https://msdn.microsoft.com/library/d1f52431-1c7d-4dc6-8792-6b988256892e">Sostituzioni</related>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
        <related type="Article" href="https://msdn.microsoft.com/library/34df1152-0b22-4a1c-a76c-3c28c47b70d8">Backtracking</related>
        <related type="Article" href="https://msdn.microsoft.com/library/618e5afb-3a97-440d-831a-70e4c526a51c">Procedure consigliate per le espressioni regolari in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool" Usage="System.Text.RegularExpressions.Regex.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ottiene un valore che indica se l'espressione regolare effettua la ricerca da destra a sinistra.</summary>
        <value>
          <see langword="true" /> se l'espressione regolare effettua la ricerca da destra a sinistra; in caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.RegularExpressions.Regex.RightToLeft%2A> viene `true` se il <xref:System.Text.RegularExpressions.Regex> istanza è stata creata con il <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft> opzione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="roptions">
      <MemberSignature Language="C#" Value="protected internal System.Text.RegularExpressions.RegexOptions roptions;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly valuetype System.Text.RegularExpressions.RegexOptions roptions" />
      <MemberSignature Language="DocId" Value="F:System.Text.RegularExpressions.Regex.roptions" />
      <MemberSignature Language="VB.NET" Value="Protected Friend roptions As RegexOptions " />
      <MemberSignature Language="C++ CLI" Value="protected public: System::Text::RegularExpressions::RegexOptions roptions;" />
      <MemberSignature Language="F#" Value="val mutable roptions : System.Text.RegularExpressions.RegexOptions" Usage="System.Text.RegularExpressions.Regex.roptions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.RegularExpressions.RegexOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Suddivide una stringa di input in una matrice di sottostringhe nelle posizioni definite dalla corrispondenza di un'espressione regolare.</summary>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input);" />
      <MemberSignature Language="F#" Value="member this.Split : string -&gt; string[]" Usage="regex.Split input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa da suddividere.</param>
        <summary>Suddivide una stringa di input in una matrice di sottostringhe in corrispondenza delle posizioni definite da un criterio di espressione regolare specificato nel costruttore <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Matrice di stringhe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodi sono simili al <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metodo, con la differenza che <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> suddivide la stringa delimitatore determinato da un'espressione regolare invece di un set di caratteri. La stringa è suddiviso come numero di volte possibile. Se non viene trovato alcun delimitatore, il valore restituito contiene un elemento il cui valore è la stringa di input originale.  
  
 Se più corrispondenze sono adiacenti tra loro, una stringa vuota viene inserita nella matrice. Ad esempio, suddivisione di una stringa con un trattino singolo, la matrice restituita da includere una stringa vuota nella posizione in cui vengono trovati due trattini adiacenti, come illustrato nel codice seguente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split1.vb#1)]  
  
 Se viene trovata una corrispondenza all'inizio o alla fine della stringa di input, una stringa vuota viene inclusa all'inizio o alla fine della matrice restituita. L'esempio seguente usa il modello di espressione regolare `\d+` per suddividere una stringa di input in caratteri numerici. Poiché la stringa inizia e finisce con i corrispondenti caratteri numerici, il valore dell'elemento e il cognome della matrice restituita è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split21.cs#21)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split21.vb#21)]  
  
 Se le parentesi di cattura vengono utilizzate un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> espressione, qualsiasi testo acquisito viene incluso nella matrice di stringhe risultante. Ad esempio, se si suddivide la stringa "viola-pera" su un segno meno inserito all'interno di parentesi di cattura, la matrice restituita include un elemento di stringa che contiene il segno meno.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split2.cs#2)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split2.vb#2)]  
  
 Tuttavia, quando il criterio di espressione regolare include più set di parentesi di cattura, il comportamento di questo metodo dipende dalla versione di .NET Framework. In .NET Framework 1.0 e 1.1, se non viene trovata una corrispondenza all'interno del primo set di parentesi di cattura, il testo acquisito dalla parentesi di cattura aggiuntive non è incluso nella matrice restituita. A partire da .NET Framework 2.0, tutto il testo acquisito viene anche aggiunto alla matrice restituita. Ad esempio, il codice seguente usa due set di parentesi di cattura per estrarre gli elementi di una data, tra cui i delimitatori di data, da una stringa di Data. Il primo set di parentesi di cattura acquisisce il trattino e il secondo set acquisisce la barra rovesciata. Se il codice di esempio viene compilato ed eseguito in .NET Framework 1.0 o 1.1, esclude i caratteri barra; Se viene compilato ed eseguito con il .NET Framework 2.0 o versioni successive, li include.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split3.cs#3)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split3.vb#3)]  
  
 Se l'espressione regolare può corrispondere a una stringa vuota, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%29> dividerà la stringa in una matrice di stringhe a caratteri singoli, perché il delimitatore di stringa vuota è reperibile in ogni posizione. Ad esempio:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split11.cs#11)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split11.vb#11)]  
  
 Si noti che la matrice restituita include anche una stringa vuota all'inizio e alla fine della matrice.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione split supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int -&gt; string[]" Usage="regex.Split (input, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa da suddividere.</param>
        <param name="count">Numero massimo di volte in cui la suddivisione può aver luogo.</param>
        <summary>Suddivide una stringa di input per un numero massimo di volte specificato in una matrice di sottostringhe in corrispondenza delle posizioni definite da un'espressione regolare specificata nel costruttore <see cref="T:System.Text.RegularExpressions.Regex" />.</summary>
        <returns>Matrice di stringhe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodi sono simili al <xref:System.String.Split%2A?displayProperty=nameWithType> metodo, con la differenza che <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> suddivide la stringa delimitatore determinato da un'espressione regolare invece di un set di caratteri. Il `count` parametro specifica il numero massimo di sottostringhe in cui il `input` stringa può essere suddivisa; l'ultima stringa contiene il resto della stringa non diviso. Oggetto `count` valore pari a zero fornisce il comportamento predefinito prevede la suddivisione come numero di volte possibile.  
  
 Se più corrispondenze sono adiacenti tra loro o se viene trovata una corrispondenza all'inizio o alla fine della `input`, e il numero di corrispondenze trovate è almeno due minore `count`, una stringa vuota viene inserita nella matrice. Vale a dire, stringhe vuote risultanti dalle corrispondenze adiacenti o dalle corrispondenze all'inizio o alla fine della stringa di input vengono conteggiate per determinare se il numero di sottostringhe corrispondente è uguale `count`. Nell'esempio seguente, l'espressione regolare `/d+` viene usato per suddividere una stringa di input che include uno o più cifre decimali in un massimo di tre sottostringhe. Poiché l'inizio della stringa di input corrisponde al criterio di espressione regolare, il primo elemento della matrice contiene <xref:System.String.Empty?displayProperty=nameWithType>, il secondo contiene il primo set di caratteri alfabetici nella stringa di input e il terzo contiene il resto della stringa che segue la corrispondenza di terza.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split25.cs#25)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split25.vb#25)]  
  
 Se le parentesi di cattura vengono utilizzate in un'espressione regolare, qualsiasi testo acquisito è incluso nella matrice di stringhe di divisione. Tuttavia, eventuali elementi di matrice che contengono il testo acquisito vengono conteggiati per determinare se ha raggiunto il numero di corrispondenze `count`. Ad esempio, dividere la stringa "mela-albicocca-viola-pera-banana" in un massimo di quattro risultati di sottostringhe in una matrice di sette elementi, come il codice seguente mostra.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split4.cs#4)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split4.vb#4)]  
  
 Tuttavia, quando il criterio di espressione regolare include più set di parentesi di cattura, il comportamento di questo metodo dipende dalla versione di .NET Framework. In .NET Framework 1.0 e 1.1, solo il testo acquisito dal primo set di parentesi di cattura è incluso nella matrice restituita. A partire da .NET Framework 2.0, tutto il testo acquisito viene aggiunto alla matrice restituita. Tuttavia, gli elementi nella matrice restituita che contengono il testo acquisito vengono conteggiati per determinare se il numero di sottostringhe corrispondente è uguale `count`. Nel codice seguente, ad esempio, due set di parentesi di cattura Usa un'espressione regolare per estrarre gli elementi di una data da una stringa di Data. Il primo set di parentesi di cattura acquisisce il trattino e il secondo set acquisisce la barra rovesciata. La chiamata al <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> metodo specifica quindi un massimo di due elementi nella matrice restituita. Se il codice di esempio viene compilato ed eseguito in .NET Framework 1.0 o 1.1, il metodo restituisce una matrice di stringhe di due elementi. Se viene compilato ed eseguito con il .NET Framework 2.0 o versioni successive, il metodo restituisce una matrice di stringhe di tre elementi.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split5.cs#5)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split5.vb#5)]  
  
 Se l'espressione regolare può corrispondere a una stringa vuota, <xref:System.Text.RegularExpressions.Regex.Split%28System.String%2CSystem.Int32%29> dividerà la stringa in una matrice di stringhe a caratteri singoli, perché il delimitatore di stringa vuota è reperibile in ogni posizione. Nell'esempio seguente suddivide la stringa "characters" in come numero di elementi presenti nella stringa di input. Poiché la stringa null corrisponde all'inizio della stringa di input, una stringa null viene inserita all'inizio della matrice restituita. In questo modo il decimo elemento costituita da due caratteri alla fine della stringa di input.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split12.vb#12)]  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione split supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern);" />
      <MemberSignature Language="F#" Value="static member Split : string * string -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Stringa da suddividere.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <summary>Suddivide una stringa di input in una matrice di sottostringhe in corrispondenza delle posizioni definite da un criterio di espressione regolare.</summary>
        <returns>Matrice di stringhe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodi sono simili al <xref:System.String.Split%2A?displayProperty=nameWithType> metodo, con la differenza che <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> suddivide la stringa delimitatore determinato da un'espressione regolare invece di un set di caratteri. Il `input` divisione della stringa come numero di volte possibile. Se `pattern` non viene trovato nel `input` stringa, il valore restituito contiene un elemento il cui valore è l'originale `input` stringa.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Espressioni regolari usate nelle chiamate a statica compilate <xref:System.Text.RegularExpressions.Regex.Split%2A> metodi vengono automaticamente memorizzate nella cache. Per gestire la durata delle espressioni regolari compilate, utilizzare l'istanza <xref:System.Text.RegularExpressions.Regex.Split%2A> metodi.  
  
 Se più corrispondenze sono adiacenti tra loro, una stringa vuota viene inserita nella matrice. Ad esempio, suddivisione di una stringa con un trattino singolo, la matrice restituita da includere una stringa vuota nella posizione in cui vengono trovati due trattini adiacenti, come illustrato nel codice seguente.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split8.cs#8)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split8.vb#8)]  
  
 Se viene trovata una corrispondenza all'inizio o alla fine della stringa di input, una stringa vuota viene inclusa all'inizio o alla fine della matrice restituita. L'esempio seguente usa il modello di espressione regolare `\d+` per suddividere una stringa di input in caratteri numerici. Poiché la stringa inizia e finisce con i corrispondenti caratteri numerici, il valore dell'elemento e il cognome della matrice restituita è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split22.cs#22)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split22.vb#22)]  
  
 Se le parentesi di cattura vengono utilizzate un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> espressione, qualsiasi testo acquisito viene incluso nella matrice di stringhe risultante. Ad esempio, se si suddivide la stringa "viola-pera" su un segno meno inserito all'interno di parentesi di cattura, la matrice restituita include un elemento di stringa che contiene il segno meno.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Tuttavia, quando il criterio di espressione regolare include più set di parentesi di cattura, il comportamento di questo metodo dipende dalla versione di .NET Framework. In .NET Framework 1.0 e 1.1, se non viene trovata una corrispondenza all'interno del primo set di parentesi di cattura, il testo acquisito dalla parentesi di cattura aggiuntive non è incluso nella matrice restituita. A partire da .NET Framework 2.0, tutto il testo acquisito viene anche aggiunto alla matrice restituita. Ad esempio, il codice seguente usa due set di parentesi di cattura per estrarre gli elementi di una data, tra cui i delimitatori di data, da una stringa di Data. Il primo set di parentesi di cattura acquisisce il trattino e il secondo set acquisisce la barra rovesciata. Se il codice di esempio viene compilato ed eseguito in .NET Framework 1.0 o 1.1, esclude i caratteri barra; Se viene compilato ed eseguito con il .NET Framework 2.0 o versioni successive, li include.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Se l'espressione regolare può corrispondere a una stringa vuota, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividerà la stringa in una matrice di stringhe a caratteri singoli, perché il delimitatore di stringa vuota è reperibile in ogni posizione. Ad esempio:  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split13.cs#13)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split13.vb#13)]  
  
 Si noti che la matrice restituita include anche una stringa vuota all'inizio e alla fine della matrice.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione split supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato il metodo. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per la divisione di testo in un criterio di ricerca è <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string input, int count, int startat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string input, int32 count, int32 startat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (input As String, count As Integer, startat As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, int count, int startat);" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * int -&gt; string[]" Usage="regex.Split (input, count, startat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="startat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="input">Stringa da suddividere.</param>
        <param name="count">Numero massimo di volte in cui la suddivisione può aver luogo.</param>
        <param name="startat">Posizione del carattere nella stringa di input da cui avrà inizio la ricerca.</param>
        <summary>Suddivide una stringa di input per un numero massimo di volte specificato in una matrice di sottostringhe in corrispondenza delle posizioni definite da un'espressione regolare specificata nel costruttore <see cref="T:System.Text.RegularExpressions.Regex" />. La ricerca del criterio di espressione regolare inizia da una posizione del carattere specificata nella stringa di input.</summary>
        <returns>Matrice di stringhe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodi sono simili al <xref:System.String.Split%2A?displayProperty=nameWithType> metodo, con la differenza che <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> suddivide la stringa delimitatore determinato da un'espressione regolare invece di un set di caratteri. Il `count` parametro specifica il numero massimo di sottostringhe in cui il `input` divisione della stringa; l'ultima stringa contiene il resto della stringa non diviso. Oggetto `count` valore pari a zero fornisce il comportamento predefinito prevede la suddivisione come numero di volte possibile. Il `startat` parametro definisce il punto in corrispondenza del quale inizia la ricerca per il primo delimitatore individuato (ciò può essere utilizzato per ignorare lo spazio vuoto iniziale).  
  
 Se viene trovata alcuna corrispondenza dal `count`+ 1 posizione nella stringa, il metodo restituisce una matrice a un elemento che contiene il `input` stringa. Se vengono trovate uno o più corrispondenze, il primo elemento della matrice restituita contiene la prima parte della stringa dal primo carattere fino a un carattere prima della corrispondenza.  
  
 Se più corrispondenze sono adiacenti tra loro e il numero di corrispondenze trovate è almeno due minore `count`, una stringa vuota viene inserita nella matrice. Analogamente, se viene individuata una corrispondenza a `startat`, ovvero il primo carattere nella stringa, il primo elemento della matrice restituita è una stringa vuota. Vale a dire, stringhe vuote risultanti dalle corrispondenze adiacenti vengono conteggiate per determinare se il numero di sottostringhe corrispondente è uguale `count`. Nell'esempio seguente, l'espressione regolare `\d+` viene usato per trovare la posizione iniziale della prima sottostringa di caratteri numerici in una stringa, quindi suddividere la stringa di un massimo di tre volte a partire da tale posizione. Poiché il modello di espressione regolare corrisponde all'inizio della stringa di input, la matrice di stringhe restituita costituito da una stringa vuota, una stringa alfabetica composto da cinque caratteri e il resto della stringa,  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split26.cs#26)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split26.vb#26)]  
  
 Se le parentesi di cattura vengono utilizzate in un'espressione regolare, qualsiasi testo acquisito è incluso nella matrice di stringhe di divisione. Tuttavia, eventuali elementi di matrice che contengono il testo acquisito vengono conteggiati per determinare se ha raggiunto il numero di corrispondenze `count`. Ad esempio, dividere la stringa ' "peach" in un massimo di quattro delle sottostringhe che inizia da carattere 15 nei risultati della stringa in una matrice di sette elementi, come illustrato nel codice seguente.  
  
 [!code-vb[System.Text.RegularExpressions.Regex.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split6.vb#6)]  
  
 Tuttavia, quando il criterio di espressione regolare include più set di parentesi di cattura, il comportamento di questo metodo dipende dalla versione di .NET Framework. In .NET Framework 1.0 e 1.1, se non viene trovata una corrispondenza all'interno del primo set di parentesi di cattura, il testo acquisito dalla parentesi di cattura aggiuntive non è incluso nella matrice restituita. A partire da .NET Framework 2.0, tutto il testo acquisito viene anche aggiunto alla matrice restituita. Ad esempio, il codice seguente usa due set di parentesi di cattura per estrarre le singole parole in una stringa. Il primo set di parentesi di cattura acquisisce il trattino e il secondo set acquisisce la barra verticale. Se il codice di esempio viene compilato ed eseguito in .NET Framework 1.0 o 1.1, esclude verticale della barra di caratteri. Se viene compilato ed eseguito con il .NET Framework 2.0 o versioni successive, li include.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split7.cs#7)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split7.vb#7)]  
  
 Se l'espressione regolare può corrispondere a una stringa vuota, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividerà la stringa in una matrice di stringhe a caratteri singoli, perché il delimitatore di stringa vuota è reperibile in ogni posizione. Nell'esempio seguente suddivide i caratteri"string" in tutti gli elementi perché contiene la stringa di input, a partire dal carattere "a". Poiché la stringa null corrisponde alla fine della stringa di input, una stringa null viene inserita alla fine della matrice restituita.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split14.cs#14)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split14.vb#14)]  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione split supera l'intervallo di timeout specificato da di <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> costruttore. Se non si imposta un intervallo di timeout quando si chiama il costruttore, l'eccezione viene generata se l'operazione supera un valore di timeout stabilito per il dominio applicazione in cui il <xref:System.Text.RegularExpressions.Regex> oggetto viene creato. Se è impostato alcun timeout non definito nel <xref:System.Text.RegularExpressions.Regex> chiamata al costruttore o nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startat" /> è minore di zero o maggiore della lunghezza di <paramref name="input" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
      </Parameters>
      <Docs>
        <param name="input">Stringa da suddividere.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <summary>Suddivide una stringa di input in una matrice di sottostringhe in corrispondenza delle posizioni definite da un criterio di espressione regolare specificato. Le opzioni specificate modificano l'operazione di corrispondenza.</summary>
        <returns>Matrice di stringhe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodi sono simili al <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metodo, con la differenza che <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> suddivide la stringa delimitatore determinato da un'espressione regolare invece di un set di caratteri. La stringa è suddiviso come numero di volte possibile. Se non viene trovato alcun delimitatore, il valore restituito contiene un elemento il cui valore è l'originale `input` stringa.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Espressioni regolari usate nelle chiamate a statica compilate <xref:System.Text.RegularExpressions.Regex.Split%2A> metodi vengono automaticamente memorizzate nella cache. Per gestire la durata delle espressioni regolari compilate, utilizzare l'istanza <xref:System.Text.RegularExpressions.Regex.Split%2A> metodi.  
  
 Se più corrispondenze sono adiacenti tra loro, una stringa vuota viene inserita nella matrice. Ad esempio, suddivisione di una stringa con un trattino singolo, la matrice restituita da includere una stringa vuota nella posizione in cui vengono trovati due trattini adiacenti.  
  
 Se viene trovata una corrispondenza all'inizio o alla fine della stringa di input, una stringa vuota viene inclusa all'inizio o alla fine della matrice restituita. L'esempio seguente usa il modello di espressione regolare `[a-z]+` per suddividere una stringa di input su qualsiasi carattere alfabetico maiuscolo o minuscolo. Poiché la stringa inizia e finisce con i corrispondenti caratteri alfabetici, il valore dell'elemento e il cognome della matrice restituita è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split24.cs#24)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split24.vb#24)]  
  
 Se le parentesi di cattura vengono utilizzate un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> espressione, qualsiasi testo acquisito viene incluso nella matrice di stringhe risultante. Ad esempio, se si suddivide la stringa "viola-pera" su un segno meno inserito all'interno di parentesi di cattura, la matrice restituita include un elemento di stringa che contiene il segno meno.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Tuttavia, quando il criterio di espressione regolare include più set di parentesi di cattura, il comportamento di questo metodo dipende dalla versione di .NET Framework. In .NET Framework 1.0 e 1.1, se non viene trovata una corrispondenza all'interno del primo set di parentesi di cattura, il testo acquisito dalla parentesi di cattura aggiuntive non è incluso nella matrice restituita. A partire da .NET Framework 2.0, tutto il testo acquisito viene anche aggiunto alla matrice restituita. Ad esempio, il codice seguente usa due set di parentesi di cattura per estrarre gli elementi di una data, tra cui i delimitatori di data, da una stringa di Data. Il primo set di parentesi di cattura acquisisce il trattino e il secondo set acquisisce la barra rovesciata. Se il codice di esempio viene compilato ed eseguito in .NET Framework 1.0 o 1.1, esclude i caratteri barra; Se viene compilato ed eseguito con il .NET Framework 2.0 o versioni successive, li include.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Se l'espressione regolare può corrispondere a una stringa vuota, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividerà la stringa in una matrice di stringhe a caratteri singoli, perché il delimitatore di stringa vuota è reperibile in ogni posizione.  
  
 Il <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione viene generata se il tempo di esecuzione dell'operazione split supera l'intervallo di timeout specificato per il dominio dell'applicazione in cui viene chiamato il metodo. Se è impostato alcun timeout non viene definito nelle proprietà del dominio dell'applicazione, o se il valore di timeout è <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>, viene generata alcuna eccezione.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>Questo metodo verifica il timeout dopo un intervallo uguale al valore di timeout predefinito del dominio dell'applicazione in cui viene chiamato il metodo. Se non è stato definito un valore di timeout per il dominio dell'applicazione, il valore <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, timeout, che impedisce il metodo viene utilizzato. Il metodo statico consigliato per la divisione di testo in un criterio di ricerca è <see cref="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />, che consente di impostare l'intervallo di timeout.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public static string[] Split (string input, string pattern, System.Text.RegularExpressions.RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Split(string input, string pattern, valuetype System.Text.RegularExpressions.RegexOptions options, valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split (input As String, pattern As String, options As RegexOptions, matchTimeout As TimeSpan) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Split(System::String ^ input, System::String ^ pattern, System::Text::RegularExpressions::RegexOptions options, TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member Split : string * string * System.Text.RegularExpressions.RegexOptions * TimeSpan -&gt; string[]" Usage="System.Text.RegularExpressions.Regex.Split (input, pattern, options, matchTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="options" Type="System.Text.RegularExpressions.RegexOptions" />
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="input">Stringa da suddividere.</param>
        <param name="pattern">Criterio di espressione regolare di cui trovare la corrispondenza.</param>
        <param name="options">Combinazione bit per bit dei valori di enumerazione che forniscono le opzioni per la corrispondenza.</param>
        <param name="matchTimeout">Intervallo di timeout o <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> per indicare che per il metodo non è previsto un timeout.</param>
        <summary>Suddivide una stringa di input in una matrice di sottostringhe in corrispondenza delle posizioni definite da un criterio di espressione regolare specificato. I parametri aggiuntivi specificano le opzioni che modificano l'operazione di corrispondenza e un intervallo di timeout se non viene trovata alcuna corrispondenza.</summary>
        <returns>Matrice di stringhe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> metodi sono simili al <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> metodo, con la differenza che <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> suddivide la stringa delimitatore determinato da un'espressione regolare invece di un set di caratteri. La stringa è suddiviso come numero di volte possibile. Se non viene trovato alcun delimitatore, il valore restituito contiene un elemento il cui valore è l'originale `input` stringa.  
  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
> [!IMPORTANT]
>  Espressioni regolari usate nelle chiamate a statica compilate <xref:System.Text.RegularExpressions.Regex.Split%2A> metodi vengono automaticamente memorizzate nella cache. Per gestire la durata delle espressioni regolari compilate, utilizzare l'istanza <xref:System.Text.RegularExpressions.Regex.Split%2A> metodi.  
  
 Se più corrispondenze sono adiacenti tra loro, una stringa vuota viene inserita nella matrice. Ad esempio, suddivisione di una stringa con un trattino singolo, la matrice restituita da includere una stringa vuota nella posizione in cui vengono trovati due trattini adiacenti.  
  
 Se viene trovata una corrispondenza all'inizio o alla fine della stringa di input, una stringa vuota viene inclusa all'inizio o alla fine della matrice restituita. L'esempio seguente usa il modello di espressione regolare `[a-z]+` per suddividere una stringa di input su qualsiasi carattere alfabetico maiuscolo o minuscolo. Poiché la stringa inizia e finisce con i corrispondenti caratteri alfabetici, il valore dell'elemento e il cognome della matrice restituita è <xref:System.String.Empty?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split23.cs#23)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split23.vb#23)]  
  
 Se le parentesi di cattura vengono utilizzate un <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> espressione, qualsiasi testo acquisito viene incluso nella matrice di stringhe risultante. Ad esempio, se si suddivide la stringa "viola-pera" su un segno meno inserito all'interno di parentesi di cattura, la matrice restituita include un elemento di stringa che contiene il segno meno.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split9.cs#9)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split9.vb#9)]  
  
 Tuttavia, quando il criterio di espressione regolare include più set di parentesi di cattura, il comportamento di questo metodo dipende dalla versione di .NET Framework. In .NET Framework 1.0 e 1.1, se non viene trovata una corrispondenza all'interno del primo set di parentesi di cattura, il testo acquisito dalla parentesi di cattura aggiuntive non è incluso nella matrice restituita. A partire da .NET Framework 2.0, tutto il testo acquisito viene anche aggiunto alla matrice restituita. Ad esempio, il codice seguente usa due set di parentesi di cattura per estrarre gli elementi di una data, tra cui i delimitatori di data, da una stringa di Data. Il primo set di parentesi di cattura acquisisce il trattino e il secondo set acquisisce la barra rovesciata. Se il codice di esempio viene compilato ed eseguito in .NET Framework 1.0 o 1.1, esclude i caratteri barra; Se viene compilato ed eseguito con il .NET Framework 2.0 o versioni successive, li include.  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/cs/split10.cs#10)]
 [!code-vb[System.Text.RegularExpressions.Regex.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.RegularExpressions.Regex.Split/vb/split10.vb#10)]  
  
 Se l'espressione regolare può corrispondere a una stringa vuota, <xref:System.Text.RegularExpressions.Regex.Split%2A> dividerà la stringa in una matrice di stringhe a caratteri singoli, perché il delimitatore di stringa vuota è reperibile in ogni posizione.  
  
 Il `matchTimeout` parametro specifica il modo in cui lungo un modello corrispondente metodo deve effettuare per trovare una corrispondenza prima del timeout. L'impostazione di un intervallo di timeout impedisce le espressioni regolari che si basano su un backtracking eccessivo che venga visualizzato il blocco quando elaborano un input che contiene corrispondenze. Per altre informazioni, vedere [procedure consigliate per le espressioni regolari](~/docs/standard/base-types/best-practices.md) e [Backtracking](~/docs/standard/base-types/backtracking-in-regular-expressions.md). Se viene trovata alcuna corrispondenza in tale intervallo di tempo, il metodo genera un <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> eccezione. `matchTimeout` esegue l'override di qualsiasi valore di timeout predefinito definito per il dominio applicazione in cui viene eseguito il metodo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si è verificato un errore di analisi dell'espressione regolare.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> o <paramref name="pattern" /> è <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="options" /> non è una combinazione bit per bit valida di valori di <see cref="T:System.Text.RegularExpressions.RegexOptions" />.  
  
oppure 
 <paramref name="matchTimeout" /> è negativo, zero o maggiore di circa 24 giorni.</exception>
        <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">Si è verificato un timeout. Per altre informazioni sui timeout, vedere la sezione Osservazioni.</exception>
        <block subset="none" type="usage">
          <para>È consigliabile impostare il <paramref name="matchTimeout" /> parametro su un valore appropriato, ad esempio due secondi. Se si disabilita i timeout specificando <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" />, il motore delle espressioni regolari offre prestazioni leggermente migliori. Tuttavia, è necessario disabilitare i timeout solo nelle condizioni seguenti: 
-Quando l'input elaborata da un'espressione regolare è derivato da un'origine conosciuta e attendibile o è costituito da testo statico. Esclude il testo che è stato in modo dinamico inseriti dagli utenti.  
  
-Quando il criterio di espressione regolare è stata accuratamente testato per verificare che gestisca in modo efficiente trova, mancate corrispondenze e a breve.  
  
-Quando il criterio di espressione regolare non contiene alcun elemento di linguaggio che potrebbero causare un backtracking eccessivo durante l'elaborazione di una corrispondenza più vicino.</para>
        </block>
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Elementi del linguaggio di espressioni regolari</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Oggetto da popolare con le informazioni sulla serializzazione.</param>
        <param name="context">Posizione di archiviazione e recupero dei dati serializzati. Tale parametro è riservato per utilizzi futuri.</param>
        <summary>Popola un oggetto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con i dati necessari per deserializzare l'oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> corrente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="regex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restituisce il criterio di espressione regolare passato al costruttore <see langword="Regex" />.</summary>
        <returns>Parametro <paramref name="pattern" /> passato al costruttore <see langword="Regex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il `pattern` parametro è costituito da elementi di linguaggio di espressioni regolari che descrivono in modo univoco la stringa da confrontare. Per altre informazioni sulle espressioni regolari, vedere [espressioni regolari di .NET Framework](~/docs/standard/base-types/regular-expressions.md) e [linguaggio di espressioni regolari - riferimento rapido](~/docs/standard/base-types/regular-expression-language-quick-reference.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Text.RegularExpressions.Regex" /> è la classe base delle espressioni regolari creata il <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> (metodo). Queste espressioni regolari compilate utilizzano il <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> implementazione della classe di base. Se viene chiamato da una classe derivata, il <see cref="M:System.Text.RegularExpressions.Regex.ToString" /> metodo restituisce la stringa passata per il <paramref name="pattern" /> parametro del <see cref="T:System.Text.RegularExpressions.RegexCompilationInfo" /> costruttore di classe usato per definire l'espressione regolare.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="public static string Unescape (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Unescape(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unescape (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Unescape(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Unescape : string -&gt; string" Usage="System.Text.RegularExpressions.Regex.Unescape str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Stringa di input contenente il testo da convertire.</param>
        <summary>Converte tutti i caratteri di escape presenti nella stringa di input.</summary>
        <returns>Stringa di caratteri con eventuali caratteri di escape convertiti nel relativo formato non di escape.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il <xref:System.Text.RegularExpressions.Regex.Unescape%2A> metodo esegue una delle due trasformazioni seguenti:  
  
-   Inverte la trasformazione eseguita per il <xref:System.Text.RegularExpressions.Regex.Escape%2A> metodo rimuovendo il carattere di escape ("\\") da ogni carattere di escape per il metodo. Sono inclusi i \\, *, +,?, &#124;, {, [, (,), ^, $,., # e gli spazi vuoti. Inoltre, il <xref:System.Text.RegularExpressions.Regex.Unescape%2A> metodo rimuove la parentesi di chiusura (]) e caratteri di parentesi graffa (}) di chiusura.  
  
> [!NOTE]
>  <xref:System.Text.RegularExpressions.Regex.Unescape%2A> non è possibile invertire una stringa con caratteri di escape perfettamente perché non può dedurre in modo preciso i caratteri di escape,  
  
-   Sostituisce i valori esadecimali nei valori letterali stringa verbatim con i caratteri stampabili effettivi. Ad esempio, che sostituisce @"\x07" con "\a", o @"\x0A" con "\n". Viene convertito in caratteri alfanumerici e caratteri di escape supportate, ad esempio \a \b, \e, \n, a capo \r, \f, \t, \v.
  
 Se il <xref:System.Text.RegularExpressions.Regex.Unescape%2A> metodo rileva altre sequenze di escape che non è possibile convertire, ad esempio \w o \s, genera un <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="str" /> include una sequenza di escape non riconosciuta.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> è <see langword="null" />.</exception>
        <altmember cref="M:System.Text.RegularExpressions.Regex.Escape(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/regular-expression-language-quick-reference.md">Linguaggio di espressioni regolari - Riferimento rapido</related>
      </Docs>
    </Member>
    <Member MemberName="UseOptionC">
      <MemberSignature Language="C#" Value="protected bool UseOptionC ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionC() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionC" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionC () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionC();" />
      <MemberSignature Language="F#" Value="member this.UseOptionC : unit -&gt; bool" Usage="regex.UseOptionC " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>
          <see langword="true" /> se la proprietà <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiene l'opzione <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseOptionR">
      <MemberSignature Language="C#" Value="protected bool UseOptionR ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool UseOptionR() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.UseOptionR" />
      <MemberSignature Language="VB.NET" Value="Protected Function UseOptionR () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool UseOptionR();" />
      <MemberSignature Language="F#" Value="member this.UseOptionR : unit -&gt; bool" Usage="regex.UseOptionR " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usato da un oggetto <see cref="T:System.Text.RegularExpressions.Regex" /> generato dal metodo <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" />.</summary>
        <returns>
          <see langword="true" /> se la proprietà <see cref="P:System.Text.RegularExpressions.Regex.Options" /> contiene l'opzione <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" />; in caso contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMatchTimeout">
      <MemberSignature Language="C#" Value="protected internal static void ValidateMatchTimeout (TimeSpan matchTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig void ValidateMatchTimeout(valuetype System.TimeSpan matchTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.RegularExpressions.Regex.ValidateMatchTimeout(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Sub ValidateMatchTimeout (matchTimeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static void ValidateMatchTimeout(TimeSpan matchTimeout);" />
      <MemberSignature Language="F#" Value="static member ValidateMatchTimeout : TimeSpan -&gt; unit" Usage="System.Text.RegularExpressions.Regex.ValidateMatchTimeout matchTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.RegularExpressions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matchTimeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="matchTimeout">Intervallo di timeout da verificare.</param>
        <summary>Verifica se un intervallo di timeout si trova all'interno di un intervallo di valori accettabili.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>